(function(scout, $, undefined) {
/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * JQuery plugin with scout extensions
 */

// === internal methods ===

/**
 * Returns false when the component display is 'none' or visibility is 'hidden', otherwise true.
 * Note: this gives other results than $.is(':visible'), since that method will also return false
 * when a component has absolute positioning and no width and height is defined (well, you cannot
 * see a component with a style like this, but technically it is not set to 'not visible').
 */
function elemVisible(elem) {
  // Check if element itself is hidden by its own style attribute
  if (isHidden(elem.style)) {
    return false;
  }
  // Must use correct window for element / computedStyle
  var myWindow = elem.ownerDocument.defaultView;
  // Check if element itself is hidden by external style-sheet
  if (isHidden(myWindow.getComputedStyle(elem))) {
    return false;
  }
  // Else visible
  return true;

  // ----- Helper functions -----

  function isHidden(style) {
    return style.display === 'none' || style.visibility === 'hidden';
  }
}

function explodeShorthandProperties(properties) {
  var newProperties = [];
  properties.forEach(function(prop) {
    // shorthand css properties may not be copied directly (at least not in firefox) -> copy the actual properties
    if (prop === 'margin' || prop === 'padding') {
      newProperties.push(prop + '-top');
      newProperties.push(prop + '-right');
      newProperties.push(prop + '-bottom');
      newProperties.push(prop + '-left');
    } else if (prop === 'border') {
      newProperties.push('border-top-style');
      newProperties.push('border-right-style');
      newProperties.push('border-bottom-style');
      newProperties.push('border-left-style');

      newProperties.push('border-top-color');
      newProperties.push('border-right-color');
      newProperties.push('border-bottom-color');
      newProperties.push('border-left-color');

      newProperties.push('border-top-width');
      newProperties.push('border-right-width');
      newProperties.push('border-bottom-width');
      newProperties.push('border-left-width');
    } else {
      newProperties.push(prop);
    }
  });
  return newProperties;
}

// === $ extensions ===

// used by some animate functions
$.removeThis = function() {
  $(this).remove();
};

/**
 * Convenience function that can be used as an jQuery event handler, when this
 * event should be "swallowed". Technically, this function calls preventDefault(),
 * stopPropagation() and stopImmediatePropagation() on the event.
 *
 * Note: "return false" is equal to preventDefault() and stopPropagation(), but
 * not stopImmediatePropagation().
 */
$.suppressEvent = function(event) {
  if (event) {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
  }
};

/**
 * If the event target is disabled (according to $.fn.isEnabled()), the event is suppressed
 * and the method returns true. Otherwise, false is returned.
 */
$.suppressEventIfDisabled = function(event, $target) {
  $target = $target || $(event.target);
  if (!$target.isEnabled()) {
    $.suppressEvent(event);
    return true;
  }
  return false;
};

/**
 * Implements the 'debounce' pattern. The given function fx is executed after a certain delay
 * (in milliseconds), but if the same function is called a second time within the waiting time,
 * the timer is reset. The default value for 'delay' is 250 ms.
 */
$.debounce = function(fx, delay) {
  delay = (delay !== undefined) ? delay : 250;
  var timeoutId = null;
  return function() {
    var that = this,
      args = arguments;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(function() {
      fx.apply(that, args);
    }, delay);
  };
};

/**
 * Executes the given function. Further calls to the same function are delayed by the given delay
 * (default 250ms). This is similar to $.debounce() but ensures that function is called at least
 * every 'delay' milliseconds. Can be useful to prevent too many function calls, e.g. from UI events.
 */
$.throttle = function(fx, delay) {
  delay = (delay !== undefined) ? delay : 250;
  var timeoutId = null;
  var lastExecution;
  return function() {
    var that = this,
      args = arguments,
      now = new Date().getTime(),
      callFx = function() {
        lastExecution = now;
        fx.apply(that, args);
      };
    if (lastExecution && lastExecution + delay > now) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(function() {
        callFx();
      }, delay);
    } else {
      callFx();
    }
  };
};

/**
 * Returns a function which negates the return value of the given function when called.
 */
$.negate = function(fx) {
  return function() {
    return !fx.apply(this, arguments);
  };
};

/**
 * color calculation
 */
$.colorOpacity = function(hex, opacity) {
  // validate hex string
  hex = String(hex).replace(/[^0-9a-f]/gi, '');
  if (hex.length < 6) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  opacity = opacity || 0;

  // convert to decimal and change luminosity
  var rgb = '#';
  for (var i = 0; i < 3; i++) {
    var c = parseInt(hex.substr(i * 2, 2), 16);
    c = Math.round(Math.min(Math.max(0, 255 - (255 - c) * opacity), 255)).toString(16);
    rgb += ('00' + c).substr(c.length);
  }

  return rgb;
};

/**
 * CSP-safe method to dynamically load a script from the server. A new <script>
 * tag is added to the head element to prevent problematic "eval()" calls. A
 * jQuery deferred object is returned which can be used to execute code after
 * the loading has been complete:
 *
 *   $injectScript('http://www....').done(function() { ... });
 *
 * Options (optional):
 *
 * NAME              DEFAULT             DESCRIPTION
 * --------------------------------------------------------------------------------------------
 * document          window.document     Which document to inject the script to.
 *
 * removeTag         false               Whether to remove the script tag again from the DOM
 *                                       after the script has been loaded.
 */
$.injectScript = function(url, options) {
  options = options || {};
  var deferred = $.Deferred();

  var myDocument = options.document || window.document;
  var scriptTag = myDocument.createElement('script');
  $(scriptTag)
    .attr('src', url)
    .attr('async', true)
    .on('load error', function(event) {
      if (options.removeTag) {
        myDocument.head.removeChild(scriptTag);
      }
      if (event.type === 'error') {
        deferred.reject();
      } else {
        deferred.resolve();
      }
    });
  // Use raw JS function to append the <script> tag, because jQuery handles
  // script tags specially (see "domManip" function) and uses eval() which
  // is not CSP-safe.
  myDocument.head.appendChild(scriptTag);

  return deferred.promise();
};

/**
 * Dynamically add a style sheet to the document. A new <style> tag is added to the head element.
 * A jQuery object referring to the new style tag is returned.
 *
 *   $injectStyle('p { text-color: orange; }').done(function() { ... });
 *
 * Options (optional):
 *
 * NAME              DEFAULT             DESCRIPTION
 * --------------------------------------------------------------------------------------------
 * document          window.document     Which document to inject the style to.
 */
$.injectStyle = function(data, options) {
  options = options || {};
  var deferred = $.Deferred();

  var myDocument = options.document || window.document;
  var styleTag = myDocument.createElement('style');
  var $styleTag = $(styleTag);
  $styleTag
    .attr('type', 'text/css')
    .html(data);
  myDocument.head.appendChild(styleTag);

  return $styleTag;
};

$.pxToNumber = function(pixel) {
  if (!pixel) {
    // parseFloat would return NaN if pixel is '' or undefined
    return 0;
  }
  // parseFloat ignores 'px' and just extracts the number
  return parseFloat(pixel, 10);
};

/**
 * Use this function as shorthand of this:
 * <code>$.Deferred().resolve([arguments]);</code>
 *
 * @param all arguments of this function are passed to the resolve function of the deferred
 * @returns {$.Deferred} a deferred for an already resolved jQuery.Deferred object.
 */
$.resolvedDeferred = function() {
  var deferred = $.Deferred();
  deferred.resolve.apply(deferred, arguments);
  return deferred;
};

/**
 * Use this function as shorthand of this:
 * <code>$.Deferred().resolve([arguments]).promise();</code>
 *
 * @param all arguments of this function are passed to the resolve function of the deferred
 * @returns {$.Deferred} a promise for an already resolved jQuery.Deferred object.
 */
$.resolvedPromise = function() {
  var deferred = $.Deferred();
  deferred.resolve.apply(deferred, arguments);
  return deferred.promise();
};

/**
 * Creates a new promise which resolves when all promises resolve and fails when the first promise fails.
 *
 * @param asArray (optional) when set to true, the resolve and reject functions will transform the
 *    flat arguments list containing the results into an array. Default is false.
 */
$.promiseAll = function(promises, asArray) {
  asArray = scout.nvl(asArray, false);
  promises = scout.arrays.ensure(promises);
  var deferred = $.Deferred();
  $.when.apply($, promises).done(function() {
    if (asArray) {
      deferred.resolve(scout.objects.argumentsToArray(arguments));
    } else {
      deferred.resolve.apply(this, arguments);
    }
  }).fail(function() {
    if (asArray) {
      deferred.reject(scout.objects.argumentsToArray(arguments));
    } else {
      deferred.reject.apply(this, arguments);
    }
  });
  return deferred.promise();
};

/**
 * Shorthand for an AJAX request for a JSON file with UTF8 encoding
 * and a default fail handler which simply throws an Error.
 *
 * @returns a promise form JQuery function $.ajax
 */
$.ajaxJson = function(url) {
  return $.ajax({
    url: url,
    dataType: 'json',
    contentType: 'application/json; charset=UTF-8'
  }).fail(function(jqXHR, textStatus, errorThrown) {
    throw new Error('Error while loading URL \'' + url + '\'. Error=' + errorThrown);
  });
};

// === $.prototype extensions ===

$.fn.nvl = function($element) {
  if (this.length || !($element instanceof $)) {
    return this;
  }
  return $element;
};

/**
 * @param element string. Example = &lt;input&gt;
 * @param cssClass (optional) class attribute
 * @param text (optional) adds a child text-node with given text (no HTML content)
 */
$.fn.makeElement = function(element, cssClass, text) {
  var myDocument = this.document(true);
  if (myDocument === undefined || element === undefined) {
    return new Error('missing arguments: document, element');
  }
  var $element = $(element, myDocument);
  if (cssClass) {
    $element.addClass(cssClass);
  }
  if (text) {
    $element.text(text);
  }
  return $element;
};

/**
 * Creates a DIV element in the current document. The function adds an unselectable attribute,
 * if this is required by the current device (@see Device.js). When you don't want the (un-)
 * selectable behavior use <code>makeElement('&lt;div&gt;')</code>.
 *
 * @param cssClass (optional) string added to the 'class' attribute
 * @param text (optional) string used as inner text
 */
$.fn.makeDiv = function(cssClass, text) {
  var unselectable = scout.device.unselectableAttribute,
    $div = this.makeElement('<div>', cssClass, text);

  if (unselectable.key) {
    $div.attr(unselectable.key, unselectable.value);
  }
  return $div;
};

$.fn.makeSpan = function(cssClass, text) {
  return this.makeElement('<span>', cssClass, text);
};

/**
 * @return HTML document reference (ownerDocument) of the HTML element.
 * @param domElement (optional) if true this function returns a JQuery object, otherwise only the DOM element is returned
 */
$.fn.document = function(domElement) {
  var myDocument = this.length ? this[0].ownerDocument : null;
  return domElement ? myDocument : $(myDocument);
};

/**
 * @return HTML window reference (defaultView) of the HTML element
 * @param domElement (optional) if true this function returns a JQuery object, otherwise only the DOM element is returned
 */
$.fn.window = function(domElement) {
  var myDocument = this.document(true),
    myWindow = myDocument ? myDocument.defaultView : null;
  return domElement ? myWindow : $(myWindow);
};

/**
 * @return HTML document reference (ownerDocument) of the HTML element.
 * @param domElement (optional) if true this function returns a JQuery object, otherwise only the DOM element is returned
 */
$.fn.activeElement = function(domElement) {
  var myDocument = this.document(true),
    activeElement = myDocument ? myDocument.activeElement : null;
  return domElement ? activeElement : $(activeElement);
};

/**
 * @return the BODY element of the HTML document in which the current HTML element is placed.
 */
$.fn.body = function() {
  return $('body', this.document(true));
};

/**
 * @return the closest DOM element that has the 'scout' class.
 * @param domElement (optional) if true this function returns a JQuery object, otherwise only the DOM element is returned
 */
$.fn.entryPoint = function(domElement) {
  var $element = this.closest('.scout');
  return domElement ? $element[0] : $element;
};

// prepend - and return new div for chaining
$.fn.prependDiv = function(cssClass, text) {
  return this.makeDiv(cssClass, text).prependTo(this);
};

// append - and return new div for chaining
$.fn.appendDiv = function(cssClass, text) {
  return this.makeDiv(cssClass, text).appendTo(this);
};

$.fn.prependElement = function(element, cssClass, text) {
  return this.makeElement(element, cssClass, text).prependTo(this);
};

$.fn.appendElement = function(element, cssClass, text) {
  return this.makeElement(element, cssClass, text).appendTo(this);
};

// insert after - and return new div for chaining
$.fn.afterDiv = function(cssClass, text) {
  return this.makeDiv(cssClass, text).insertAfter(this);
};

// insert before - and return new div for chaining
$.fn.beforeDiv = function(cssClass, text) {
  return this.makeDiv(cssClass, text).insertBefore(this);
};

$.fn.appendSpan = function(cssClass, text) {
  return this.makeSpan(cssClass, text).appendTo(this);
};

$.fn.appendBr = function(cssClass) {
  return this.makeElement('<br>', cssClass).appendTo(this);
};

$.fn.appendTextNode = function(text) {
  return $(this.document(true).createTextNode(text)).appendTo(this);
};

$.fn.makeSVG = function(type, cssClass, text, id) {
  var myDocument = this.document(true);
  if (myDocument === undefined || type === undefined) {
    return new Error('missing arguments: document, type');
  }
  var $svg = $(myDocument.createElementNS('http://www.w3.org/2000/svg', type));
  if (cssClass) {
    $svg.attrSVG('class', cssClass);
  }
  if (text) {
    $svg.text(text);
  }
  if (id !== undefined) {
    $svg.attrSVG('id', id);
  }
  return $svg;
};

// append SVG
$.fn.appendSVG = function(type, cssClass, text, id) {
  return this.makeSVG(type, cssClass, text, id).appendTo(this);
};

// attr and class handling for svg
$.fn.attrSVG = function(attributeName, value) {
  if (this.length === 0) { // shortcut for empty collections
    return this;
  }
  if (this.length === 1) { // shortcut for single element collections
    this[0].setAttribute(attributeName, value);
    return this;
  }
  return this.each(function() {
    this.setAttribute(attributeName, value);
  });
};

$.fn.removeAttrSVG = function(attributeName) {
  if (this.length === 0) { // shortcut for empty collections
    return this;
  }
  if (this.length === 1) { // shortcut for single element collections
    this[0].removeAttribute(attributeName);
    return this;
  }
  return this.each(function() {
    this.removeAttribute(attributeName);
  });
};

$.fn.attrXLINK = function(attributeName, value) {
  if (this.length === 0) { // shortcut for empty collections
    return this;
  }
  if (this.length === 1) { // shortcut for single element collections
    this[0].setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:' + attributeName, value);
    return this;
  }
  return this.each(function() {
    this.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:' + attributeName, value);
  });
};

$.fn.addClassSVG = function(cssClass) {
  var old;
  if (this.length === 0) { // shortcut for empty collections
    return this;
  }
  if (this.length === 1) { // shortcut for single element collections
    if (!this.hasClassSVG(cssClass)) {
      old = this[0].getAttribute('class');
      this[0].setAttribute('class', scout.strings.join(' ', old, cssClass).trim());
    }
    return this;
  }
  return this.each(function() {
    if (!$(this).hasClassSVG(cssClass)) {
      old = this.getAttribute('class');
      this.setAttribute('class', scout.strings.join(' ', old, cssClass).trim());
    }
  });
};

$.fn.removeClassSVG = function(cssClass) {
  var old;
  if (this.length === 0) { // shortcut for empty collections
    return this;
  }
  if (this.length === 1) { // shortcut for single element collections
    old = ' ' + this[0].getAttribute('class') + ' ';
    this[0].setAttribute('class', old.replace(' ' + cssClass + ' ', ' ').trim());
    return this;
  }
  return this.each(function() {
    var old = ' ' + this.getAttribute('class') + ' ';
    this.setAttribute('class', old.replace(' ' + cssClass + ' ', ' ').trim());
  });
};

$.fn.hasClassSVG = function(cssClass) {
  var old = ' ' + this[0].getAttribute('class') + ' ';
  return old.indexOf(' ' + cssClass + ' ') !== -1;
};

// select one and deselect siblings
$.fn.selectOne = function() {
  this.siblings().removeClass('selected');
  this.addClass('selected');
  return this;
};

$.fn.select = function(selected) {
  return this.toggleClass('selected', !!selected);
};

$.fn.isSelected = function() {
  return this.hasClass('selected');
};

$.fn.setEnabled = function(enabled) {
  enabled = !!enabled;
  this.toggleClass('disabled', !enabled);
  // Toggle disabled attribute for elements that support it (see http://www.w3.org/TR/html5/disabled-elements.html)
  if (this.is('button, input, select, textarea, optgroup, option, fieldset')) {
    this.toggleAttr('disabled', !enabled);
  }
  return this;
};

$.fn.isEnabled = function() {
  return !this.hasClass('disabled');
};

$.fn.setVisible = function(visible) {
  var i, elem;
  for (i = 0; i < this.length; i++) {
    elem = this[i];
    if (elemVisible(elem) !== visible) {
      if (visible) {
        this.show();
      } else {
        this.hide();
      }
    }
  }
  return this;
};

$.fn.isDisplayNone = function() {
  return this.css('display') === 'none';
};

$.fn.setTabbable = function(tabbable) {
  return this.attr('tabIndex', tabbable ? 0 : null);
};

$.fn.icon = function(iconId) {
  var icon, $icon = this.data('$icon');
  if (iconId) {
    icon = scout.icons.parseIconId(iconId);
    if (icon.isFontIcon()) {
      getOrCreateIconElement.call(this, $icon, '<span>')
        .addClass(icon.appendCssClass('font-icon'))
        .addClass('icon')
        .text(icon.iconCharacter);
    } else {
      getOrCreateIconElement.call(this, $icon, '<img>')
        .attr('src', icon.iconUrl)
        .addClass('icon');
    }
  } else {
    removeIconElement.call(this, $icon);
  }
  return this;

  // ----- Helper functions -----

  function getOrCreateIconElement($icon, newElement) {
    // If element type does not match existing element, remove the existing element (e.g. when changing from font-icon to picture icon)
    if ($icon && !$icon.is(newElement.replace(/[<>]/g, ''))) {
      removeIconElement.call(this, $icon);
      $icon = null;
    }
    // Create new element if necessary
    if (!$icon) {
      $icon = $(newElement);
      this.data('$icon', $icon);
      this.prepend($icon);
    }
    return $icon;
  }

  function removeIconElement($icon) {
    if ($icon) {
      $icon.remove();
    }
    this.removeData('$icon');
  }
};

$.fn.placeholder = function(placeholder) {
  return this.toggleAttr('placeholder', !!placeholder, placeholder);
};

$.fn.isVisible = function() {
  return elemVisible(this[0]);
};

$.fn.isEveryParentVisible = function() {
  var everyParentVisible = true;
  this.parents().each(function() {
    if (!$(this).isVisible()) {
      everyParentVisible = false;
      return false;
    }
  });
  return everyParentVisible;
};

/**
 * @return true if the element is attached (= is in the dom tree), false if not
 */
$.fn.isAttached = function() {
  return $.contains(this.document(true).documentElement, this[0]);
};

/**
 * Returns the first parent which is scrollable
 */
$.fn.scrollParent = function() {
  var $elem = this;
  while ($elem.length > 0) {
    if ($elem.data('scrollable')) {
      return $elem;
    }
    $elem = $elem.parent();
  }
  return $();
};

/**
 * Returns every parent which is scrollable
 */
$.fn.scrollParents = function() {
  var $scrollParents = $(),
    $elem = this;

  while ($elem.length > 0) {
    if ($elem.data('scrollable')) {
      $scrollParents.push($elem);
    }
    $elem = $elem.parent();
  }
  return $scrollParents;
};

// most used animate
$.fn.animateAVCSD = function(attr, value, complete, step, duration) {
  var properties = {};
  var options = {};

  properties[attr] = value;
  if (complete) {
    options.complete = complete;
  }
  if (step) {
    options.step = step;
  }
  if (duration) {
    options.duration = duration;
  }
  options.queue = false;

  this.animate(properties, options);
  return this;
};

// SVG animate, array contains attr, endValue + startValue
$.fn.animateSVG = function(attr, endValue, duration, complete, withoutTabIndex) {
  return this.each(function() {
    var startValue = parseFloat($(this).attr(attr));
    if (withoutTabIndex) {
      var oldComplete = complete;
      complete = function() {
        if (oldComplete) {
          oldComplete.call(this);
        }
        $(this).removeAttr('tabindex');
      };
    }
    $(this).animate({
      tabIndex: 0
    }, {
      step: function(now, fx) {
        this.setAttribute(attr, startValue + (endValue - startValue) * fx.pos);
      },
      duration: duration,
      complete: complete,
      queue: false
    });
  });
};

$.fn.addClassForAnimation = function(className, options) {
  var defaultOptions = {
    classesToRemove: className
  };
  options = $.extend({}, defaultOptions, options);
  this.addClass(className);
  this.oneAnimationEnd(function() {
    // remove class, otherwise animation will be executed each time the element changes it's visibility (attach/rerender),
    // and even each time when the css classes change
    this.removeClass(options.classesToRemove);
    // delay must be greater than css animation duration
  }.bind(this));
};

$.fn.oneAnimationEnd = function(selector, data, handler) {
  this.one('animationend webkitAnimationEnd', selector, data, handler);
};

/**
 * Animates from old to new width
 */
$.fn.cssWidthAnimated = function(oldWidth, newWidth, opts) {
  opts = opts || {};
  opts.duration = scout.nvl(opts.duration, 300);

  // Reset to old width first
  this.cssWidth(oldWidth);

  // Then animate to new width
  this.animate({
    width: newWidth
  }, opts);

  return this;
};

$.fn.cssHeightAnimated = function(oldHeight, newHeight, opts) {
  opts = opts || {};
  opts.duration = scout.nvl(opts.duration, 300);

  // Reset to old height first
  this.cssHeight(oldHeight);

  // Then animate to new height
  this.animate({
    height: newHeight
  }, opts);

  return this;
};

$.fn.cssLeftAnimated = function(from, to, opts) {
  opts = opts || {};
  opts.duration = scout.nvl(opts.duration, 300);

  // Reset to from first
  this.cssLeft(from);

  // Then animate to new width
  this.animate({
    left: to
  }, opts);

  return this;
};

$.fn.cssTopAnimated = function(from, to, opts) {
  opts = opts || {};
  opts.duration = scout.nvl(opts.duration, 300);

  // Reset to from first
  this.cssTop(from);

  // Then animate to new pos
  this.animate({
    top: to
  }, opts);

  return this;
};

$.fn.cssAnimated = function(fromVals, toVals, opts) {
  opts = opts || {};
  opts.duration = scout.nvl(opts.duration, 300);

  // Reset to from first
  this.css(fromVals);

  // Then animate to new pos
  this.animate(toVals, opts);
  return this;
};

// over engineered animate
$.fn.widthToContent = function(opts) {
  var oldW = this.outerWidth(),
    newW = this.css('width', 'auto').outerWidth();

  this.cssWidthAnimated(oldW, newW, opts);
  return this;
};

/**
 * Offset to a specific ancestor and not to the document as offset() would do.
 * Not the same as position() which returns the position relative to the offset parent.
 */
$.fn.offsetTo = function($to) {
  var toOffset = $to.offset(),
    offset = this.offset();

  return {
    top: offset.top - toOffset.top,
    left: offset.left - toOffset.left
  };
};

$.fn.cssLeft = function(position) {
  return this.cssPxValue('left', position);
};

$.fn.cssTop = function(position) {
  return this.cssPxValue('top', position);
};

$.fn.cssBottom = function(position) {
  return this.cssPxValue('bottom', position);
};

$.fn.cssRight = function(position) {
  return this.cssPxValue('right', position);
};

$.fn.cssWidth = function(width) {
  return this.cssPxValue('width', width);
};

$.fn.cssHeight = function(height) {
  return this.cssPxValue('height', height);
};

$.fn.cssLineHeight = function(height) {
  return this.cssPxValue('line-height', height);
};

$.fn.cssPxValue = function(prop, value) {
  if (value === undefined) {
    return $.pxToNumber(this.css(prop));
  }
  return this.css(prop, value + 'px');
};

$.fn.cssMarginLeft = function(value) {
  return this.cssPxValue('margin-left', value);
};

$.fn.cssMarginBottom = function(value) {
  return this.cssPxValue('margin-bottom', value);
};

$.fn.cssMarginRight = function(value) {
  return this.cssPxValue('margin-right', value);
};

$.fn.cssMarginTop = function(value) {
  return this.cssPxValue('margin-top', value);
};

$.fn.cssMarginX = function(value) {
  if (value === undefined) {
    return this.cssMarginLeft() + this.cssMarginRight();
  }
  this.cssMarginLeft(value);
  this.cssMarginRight(value);
};

$.fn.cssMarginY = function(value) {
  if (value === undefined) {
    return this.cssMarginTop() + this.cssMarginBottom();
  }
  this.cssMarginTop(value);
  this.cssMarginBottom(value);
};

$.fn.cssPaddingTop = function(value) {
  return this.cssPxValue('padding-top', value);
};

$.fn.cssBorderBottomWidth = function(value) {
  return this.cssPxValue('border-bottom-width', value);
};

$.fn.cssBorderLeftWidth = function(value) {
  return this.cssPxValue('border-left-width', value);
};

$.fn.cssBorderRightWidth = function(value) {
  return this.cssPxValue('border-right-width', value);
};

$.fn.cssBorderTopWidth = function(value) {
  return this.cssPxValue('border-top-width', value);
};

$.fn.cssBorderWidthY = function(value) {
  if (value === undefined) {
    return this.cssBorderTopWidth() + this.cssBorderBottomWidth();
  }
  this.cssBorderTopWidth(value);
  this.cssBorderBottomWidth(value);
};

$.fn.cssBorderWidthX = function(value) {
  if (value === undefined) {
    return this.cssBorderLeftWidth() + this.cssBorderRightWidth();
  }
  this.cssBorderLeftWidth(value);
  this.cssBorderRightWidth(value);
};

/**
 * Bottom of a html element without margin and border relative to offset parent. Expects border-box model.
 */
$.fn.innerBottom = function() {
  return this.position().top + this.outerHeight(true) - this.cssMarginBottom() - this.cssBorderBottomWidth();
};

/**
 * Right of a html element without margin and border relative to offset parent. Expects border-box model.
 */
$.fn.innerRight = function() {
  return this.position().left + this.outerWidth(true) - this.cssMarginRight() - this.cssBorderRightWidth();
};

$.fn.copyCss = function($origin, props) {
  var properties = props.split(' ');
  var $this = this;
  properties = explodeShorthandProperties(properties);
  properties.forEach(function(prop) {
    $this.css(prop, $origin.css(prop));
  });
  return $this;
};

$.fn.copyCssIfGreater = function($origin, props) {
  var properties = props.split(' ');
  var $this = this;
  properties = explodeShorthandProperties(properties);
  properties.forEach(function(prop) {
    var originValue = $.pxToNumber($origin.css(prop));
    var thisValue = $.pxToNumber($this.css(prop));
    if (originValue > thisValue) {
      $this.css(prop, originValue + 'px');
    }
  });
  return $this;
};

$.fn.copyCssClasses = function($other, classString) {
  var classes = classString.split(' ');
  var $this = this;
  classes.forEach(function(cssClass) {
    if ($other.hasClass(cssClass)) {
      $this.addClass(cssClass);
    }
  });
  return $this;
};

$.fn.disableSpellcheck = function() {
  return this.attr('spellcheck', false);
};

/**
 * Returns whether the current element is the given element or has a child which is the given element.
 */
$.fn.isOrHas = function(elem) {
  return this[0] === elem || this.has(elem).length > 0;
};

/**
 * Makes any element movable with the mouse. If the argument '$handle' is missing, the entire
 * element can be used as a handle.
 *
 * A callback function can be passed as second argument (optional). The function is called for
 * every change of the draggable's position with an object as argument:
 * { top: (top pixels), left: (left pixels) }
 */
$.fn.makeDraggable = function($handle, callback) {
  var $draggable = this;
  $handle = $handle || $draggable;
  return $handle.on('mousedown.draggable', function(event) {
    var orig_offset = $draggable.offset();
    var orig_event = event;
    var handleWidth = $handle.width();
    var windowWidth = $handle.window().width();
    var windowHeight = $handle.window().height();
    $handle.parents()
      .on('mousemove.dragging', function(event) {
        var top = orig_offset.top + (event.pageY - orig_event.pageY);
        var left = orig_offset.left + (event.pageX - orig_event.pageX);
        // do not drop outside of viewport (and leave a margin of 100 pixels)
        left = Math.max(100 - handleWidth, left);
        left = Math.min(windowWidth - 100, left);
        top = Math.max(0, top); // must not be dragged outside of top, otherwise dragging back is impossible
        top = Math.min(windowHeight - 100, top);
        var newOffset = {
          top: top,
          left: left
        };
        $draggable.offset(newOffset);
        callback && callback(newOffset);
      })
      .on('mouseup.dragging', function(e) {
        $handle.parents().off('.dragging');
      });
    event.preventDefault();
  });
};

/**
 * Calls jQuery.fadeOut() and then removes the element from the DOM.
 * Default fade-out duration is 150 ms.
 */
$.fn.fadeOutAndRemove = function(duration, callback) {
  if (callback === undefined && typeof duration === 'function') {
    callback = duration;
    duration = undefined;
  }
  duration = scout.nvl(duration, 150);
  this.stop(true).fadeOut(duration, function() {
    $(this).remove();
    if (callback) {
      callback.call(this);
    }
  });
};

var _oldhide = $.fn.hide;
$.fn.hide = function() {
  this.trigger('hide');
  var returnValue = _oldhide.apply(this, arguments);
  return returnValue;
};
//TODO [6.1] cgu: provide alternative methods for show and hide which just change the css class (this.addClass('hidden');). Should be a lot faster because it is not necessary to remember any state.

/**
 * Sets the given 'text' as text to the jQuery element, using the text() function (i.e. HTML is encoded automatically).
 * If the text does not contain any non-space characters, the text '&nbsp;' is set instead (using the html() function).
 * If an 'emptyCssClass' is provided, this CSS class is removed in the former and added in the later case.
 */
$.fn.textOrNbsp = function(text, emptyCssClass) {
  if (scout.strings.hasText(text)) {
    this.text(text);
    if (emptyCssClass) {
      this.removeClass(emptyCssClass);
    }
  } else {
    this.html('&nbsp;');
    if (emptyCssClass) {
      this.addClass(emptyCssClass);
    }
  }
  return this;
};

/**
 * Same as "textOrNbsp", but with html (caller is responsible for encoding).
 */
$.fn.htmlOrNbsp = function(html, emptyCssClass) {
  if (scout.strings.hasText(html)) {
    this.html(html);
    if (emptyCssClass) {
      this.removeClass(emptyCssClass);
    }
  } else {
    this.html('&nbsp;');
    if (emptyCssClass) {
      this.addClass(emptyCssClass);
    }
  }
  return this;
};

/**
 * Like toggleClass(), this toggles a HTML attribute on a set of jquery elements.
 *
 * @param attr
 *          Name of the attribute to toggle.
 * @param state
 *          Specifies if the attribute should be added or removed (based on whether the argument is truthy or falsy).
 *          If this argument is not defined, the attribute is added when it exists, and vice-versa. If this behavior
 *          is not desired, explicitly cast the argument to a boolean using "!!".
 * @param value
 *          Value to use when adding the attribute.
 *          If this argument is not specified, 'attr' is used as value.
 */
$.fn.toggleAttr = function(attr, state, value) {
  if (!attr) {
    return this;
  }
  if (value === undefined) {
    value = attr;
  }
  return this.each(function() {
    var $element = $(this);
    if (state === undefined) {
      // set state according to the current value
      state = ($element.attr(attr) === undefined);
    }
    if (state) {
      // set attr
      $element.attr(attr, value);
    } else {
      // remove attr
      $element.removeAttr(attr);
    }
  });
};

$.fn.backupSelection = function() {
  var field = this[0];
  if (field && field === this.activeElement(true)) {
    return {
      selectionStart: field.selectionStart,
      selectionEnd: field.selectionEnd,
      selectionDirection: field.selectionDirection
    };
  }
  return null;
};

$.fn.restoreSelection = function(selection) {
  var field = this[0];
  if (field && field === this.activeElement(true) && selection) {
    field.setSelectionRange(selection.selectionStart, selection.selectionEnd, selection.selectionDirection);
  }
};

/**
 * If the given value is "truthy", it is set as attribute on the target. Otherwise, the attribute is removed.
 */
$.fn.attrOrRemove = function(attributeName, value) {
  if (value) {
    $(this).attr(attributeName, value);
  } else {
    $(this).removeAttr(attributeName);
  }
};

$.fn.appendAppLink = function(appLinkBean, func) {
  return this.appendSpan().appLink(appLinkBean, func);
};

/**
 * @param appLinkBean
 *          Either
 *           - an AppLinkBean with both (1) a ref attribute which will be mapped to the
 *             data-ref attribute of the element and (2) a text attribute which will be
 *             set as the text of the element.
 *           - or just a ref, which will be mapped to the data-ref attribute of the
 *             element.
 * @param func
 *          Optional. Either
 *           - a function to be called when the app link has been clicked
 *           - or an object with a method named _onAppLinkAction (e.g. an instance of
 *             BeanField)
 *          If func is not set, the _onAppLinkAction of the inner most widget relative to
 *          this element (if any) will be called when the app link has been clicked.
 */
$.fn.appLink = function(appLinkBean, func) {
  if (!func) {
    func = function(event) {
      var widget = scout.Widget.getWidgetFor(this);
      if (widget && widget._onAppLinkAction) {
        widget._onAppLinkAction(event);
      }
    }.bind(this);
  } else if (typeof func === 'object' && func._onAppLinkAction) {
    func = func._onAppLinkAction.bind(func);
  }

  this.addClass('app-link')
    .attr('tabindex', '0')
    .unfocusable()
    .on('click', func);

  if (typeof appLinkBean === 'string') {
    this.attr('data-ref', appLinkBean);
  } else {
    this
      .text(appLinkBean.name)
      .attr('data-ref', appLinkBean.ref);
  }
  return this;
};

/**
 * Adds the class 'unfocusable' to current result set. The class is not used for styling purposes
 * but has a meaning to the FocusManager.
 */
$.fn.unfocusable = function() {
  return this.addClass('unfocusable');
};

/**
 * Select all text within an element, e.g. within a content editable div element.
 */
$.fn.selectAllText = function() {
  var range,
    myDocument = this.document(true),
    myWindow = this.window(true),
    element = this[0];

  if (myDocument.body.createTextRange) {
    range = myDocument.body.createTextRange();
    range.moveToElementText(element);
    range.select();
    return;
  }

  if (myWindow.getSelection) {
    range = myDocument.createRange();
    range.selectNodeContents(element);
    myWindow.getSelection().removeAllRanges();
    myWindow.getSelection().addRange(range);
  }
};

/**
 * Checks if content is truncated.
 */
$.fn.isContentTruncated = function() {
  var clientWidth = this[0].clientWidth;
  var scrollWidth = this[0].scrollWidth;

  // 1. Fast return if scrollWidth is larger than width
  if (scrollWidth > clientWidth) {
    return true;
  }

  // 2. In some cases the browser returns the same values for clientWidth and scrollWidth,
  // but will cut off the text nevertheless. At least in FF this seems to be a bug related
  // to sub-pixel rendering. The text is "slightly" (0.2 pixels) larger than the clientWidth,
  // but scrollWidth returns the same value.
  // As a workaround, we do a second measurement of the uncut width before returning false.
  var oldStyle = this.attr('style');
  this.css('width', 'auto');
  scrollWidth = this[0].scrollWidth;
  this.attrOrRemove('style', oldStyle);

  return scrollWidth > clientWidth;
};

// TODO awe: (graph) consider moving this function to DoubleClickHandler.js
/**
 * This function is used to distinct between single and double clicks.
 * Instead of executing a handler immediately when the first click occurs,
 * we wait for a given timeout (or by default 300 ms) to check if it is followed by a second click.
 * This will delay the execution of a single click a bit, so you should use this function wisely.
 */
$.fn.onSingleOrDoubleClick = function(singleClickFunc, doubleClickFunc, timeout) {
  return this.each(function() {
    var that = this,
      numClicks = 0,
      timeout = scout.nvl(timeout, 300);
    $(this).on('click', function(event) {
      numClicks++;
      if (numClicks === 1) {
        setTimeout(function() {
          if (numClicks === 1) {
            singleClickFunc.call(that, event);
          } else {
            doubleClickFunc.call(that, event);
          }
          numClicks = 0;
        }, timeout);
      }
    });
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
// TODO [5.2] awe, CGU: think about refactoring this code to a Scout.js class and use an
// instance of that new class in scout-module.js for the last line of code:
// }(window.scout = window.scout || {}, jQuery));

scout.sessions = [];

/**
    session.start();
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model
 */
scout.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
  childCtor.parent = parentCtor;
};

/**
 * Returns the first of the given arguments that is not null or undefined. If no such element
 * is present, the last argument is returned. If no arguments are given, undefined is returned.
 */
scout.nvl = function() {
  var result;
  for (var i = 0; i < arguments.length; i++) {
    result = arguments[i];
    if (result !== undefined && result !== null) {
      break;
    }
  }
  return result;
};

/**
 * Use this method in your functions to assert that a mandatory parameter is passed
 * to the function. Throws an Error when value is not set.
 *
 * @param type (optional) if this parameter is set, the given value must be of this type (instanceof check)
 */
scout.assertParameter = function(parameterName, value, type) {
  if (!value) {
    throw new Error('Missing required parameter \'' + parameterName + '\'');
  }
  if (type && !(value instanceof type)) {
    throw new Error('Parameter \'' + parameterName + '\' has wrong type');
  }
};

scout.isOneOf = function() {
  if (arguments.length >= 2) {
    var value = arguments[0];
    var argsToCheck;
    if (arguments.length === 2 && Array.isArray(arguments[1])) {
      argsToCheck = arguments[1];
    } else {
      argsToCheck = Array.prototype.slice.call(arguments, 1);
    }
    return argsToCheck.indexOf(value) !== -1;
  }
  return false;
};

/**
 * Creates a new object instance.<p> Delegates the create call to scout.ObjectFactory#create.
 */
scout.create = function(objectType, model, options) {
  return scout.objectFactory.create(objectType, model, options);
};

/**
 * Prepares the DOM for scout in the given document. This should be called once while initializing scout.
 * If the target document is not specified, the global "document" variable is used instead.
 *
 * This is used by main.js, login.js and logout.js.
 *
 * Currently it does the following:
 * - Remove the <noscript> tag (obviously there is no need for it).
 * - Remove <scout-text> tags (they must have been processed before, see scout.texts.readFromDOM())
 * - If the browser is Google Chrome, add a special meta header to prevent automatic translation.
 */
scout.prepareDOM = function(targetDocument) {
  targetDocument = targetDocument || document;
  // Cleanup DOM
  $('noscript', targetDocument).remove();
  $('scout-text', targetDocument).remove();

  // Prevent "Do you want to translate this page?" in Google Chrome
  if (scout.device.browser === scout.Device.Browser.CHROME) {
    var metaNoTranslate = '<meta name="google" content="notranslate" />';
    var $title = $('head > title', targetDocument);
    if ($title.length === 0) {
      // Add to end of head
      $('head', targetDocument).append(metaNoTranslate);
    } else {
      $title.after(metaNoTranslate);
    }
  }
};

scout._checkBrowserCompability = function(options) {
  var device = scout.device;
  $.log.info('Detected browser ' + device.browser + ' version ' + device.browserVersion);
  if (!scout.nvl(options.checkBrowserCompatibility, true) || device.isSupportedBrowser()) {
    // No check requested or browser is supported
    return true;
  }

  $('.scout').each(function() {
    var $entryPoint = $(this),
      $box = $entryPoint.appendDiv(),
      newOptions = scout.objects.valueCopy(options);

    newOptions.checkBrowserCompatibility = false;
    $box.load('unsupported-browser.html', function() {
      $box.find('button').on('click', function() {
        $box.remove();
        scout._init(newOptions);
      });
    });
  });
  return false;
};

/**
 * Note: we do not install an error handler on popup-windows because everything is controlled by the main-window
 * so exceptions will also occur in that window. This also means, the fatal message-box will be displayed in the
 * main-window, even when a popup-window is opened and active.
 *
 * Caution: The error.stack doesn't look the same in different browsers. Chrome for instance puts the error message
 * on the first line of the stack. Firefox does only contain the stack lines, without the message, but in return
 * the stack trace is much longer :)
 */
scout._installGlobalJavascriptErrorHandler = function() {
  window.onerror = function(errorMessage, fileName, lineNumber, columnNumber, error) {
    try {
      var errorCode = getJsErrorCode(error),
        logStr = errorMessage + ' at ' + fileName + ':' + lineNumber;
      if (error && error.stack) {
        logStr += '\n' + error.stack;
      }
      logStr += '\n(' + 'Code ' + errorCode + ')';
      $.log.error(logStr);
      if (window.console) {
        window.console.log(logStr);
      }
      // FIXME bsh: Improve this! Accessing session at index 0 is not a good idea when a window has multiple scout instances (portlet use-case)
      if (scout.sessions.length > 0) {
        var session = scout.sessions[0],
          boxOptions = {
            header: session.optText('ui.UnexpectedProblem', 'Internal UI Error'),
            body: scout.strings.join('\n\n',
              session.optText('ui.InternalUiErrorMsg', errorMessage, ' (' + session.optText('ui.ErrorCodeX', 'Code ' + errorCode, errorCode) + ')'),
              session.optText('ui.UiInconsistentMsg', '')),
            yesButtonText: session.optText('ui.Reload', 'Reload'),
            yesButtonAction: scout.reloadPage,
            noButtonText: session.optText('ui.Ignore', 'Ignore'),
            hiddenText: logStr
          };

        session.showFatalMessage(boxOptions, errorCode);
        session.sendLogRequest(logStr);
      }
    } catch (err) {
      throw new Error('Error in global JavaScript error handler: ' + err.message + ' (original error: ' + errorMessage + ' at ' + fileName + ':' + lineNumber + ')');
    }

    // ----- Helper functions -----

    /**
     * Generate a "cool looking" error code from the JS error object, that
     * does not reveal too much technical information, but at least indicates
     * that a JS runtime error has occurred. (In contrast, fatal errors from
     * the server have numeric error codes.)
     */
    function getJsErrorCode(error) {
      if (error) {
        if (error.name === 'EvalError') {
          return 'E1';
        }
        if (error.name === 'InternalError') {
          return 'I2';
        }
        if (error.name === 'RangeError') {
          return 'A3';
        }
        if (error.name === 'ReferenceError') {
          return 'R4';
        }
        if (error.name === 'SyntaxError') {
          return 'S5';
        }
        if (error.name === 'TypeError') {
          return 'T6';
        }
        if (error.name === 'URIError') {
          return 'U7';
        }
      }
      return 'J0';
    }
  };
};

/**
 * Installs a global 'mousedown' interceptor to invoke 'aboutToBlurByMouseDown' on value field before anything else gets executed.
 */
scout._installGlobalMouseDownInterceptor = function(myDocument) {
  myDocument.addEventListener('mousedown', function(event) {
    scout.ValueField.invokeValueFieldAboutToBlurByMouseDown(event.target || event.srcElement);
  }, true); // true=the event handler is executed in the capturing phase
};

scout._globalAjaxSetup = function() {
  $.ajaxSetup({
    beforeSend: function(request) {
      request.setRequestHeader('X-Scout-Correlation-Id', scout.numbers.correlationId());
    }
  });
};

/**
 * Helper function to get the model adapter for a given adapterId. If there is more than one
 * session, e.g. in case of portlets, the second argument specifies the session to be queried
 * (can be either the zero-based index or the partId). If the session or the adapter could
 * not be found, nothing is returned.
 */
scout.adapter = function(adapterId, sessionIndex) {
  var session = scout.getSession(sessionIndex);
  if (session && session.modelAdapterRegistry) {
    return session.modelAdapterRegistry[adapterId];
  }
};

scout.getSession = function(sessionIndex) {
  if (!scout.sessions) {
    return null;
  }
  var session;
  if (scout.sessions.length === 1) {
    session = scout.sessions[0];
  } else {
    sessionIndex = sessionIndex || 0;
    for (var i = 0; i < scout.sessions.length; i++) {
      if (scout.sessions[i].partId == sessionIndex) { // <-- compare with '==' is intentional! (NOSONAR)
        sessionIndex = i;
        break;
      }
    }
    session = scout.sessions[sessionIndex];
  }
  return session;
};

/**
 * This method exports the adapter with the given ID as JSON, it returns an plain object containing the
 * configuration of the adapter. You can transform that object into JSON by calling <code>JSON.stringify</code>.
 * This method can only be called through the browser JavaScript console.
 * Here's an example of how to call the method:
 *
 * JSON.stringify(scout.exportAdapter(4))
 *
 * @param adapterId
 */
scout.exportAdapter = function(adapterId, sessionIndex) {
  var session = scout.getSession(sessionIndex);
  if (session && session.modelAdapterRegistry) {
    var adapter = session.getModelAdapter(adapterId);
    var adapterData = cloneAdapterData(adapterId);
    resolveAdapterReferences(adapter, adapterData);
    adapterData.type = 'model'; // property 'type' is required for models.js
    return adapterData;
  }

  function cloneAdapterData(adapterId) {
    var adapterData = session.getAdapterData(adapterId);
    adapterData = $.extend(true, {}, adapterData);
    return adapterData;
  }

  function resolveAdapterReferences(adapter, adapterData) {
    var tmpAdapter, tmpAdapterData;
    adapter._adapterProperties.forEach(function(adapterPropertyName) {
      var adapterPropertyValue = adapterData[adapterPropertyName];
      if (!adapterPropertyValue) {
        return; // nothing to do when property is null
      }
      if (Array.isArray(adapterPropertyValue)) {
        // value is an array of adapter IDs
        var adapterDataArray = [];
        adapterPropertyValue.forEach(function(adapterId) {
          tmpAdapter = session.getModelAdapter(adapterId);
          tmpAdapterData = cloneAdapterData(adapterId);
          resolveAdapterReferences(tmpAdapter, tmpAdapterData);
          adapterDataArray.push(tmpAdapterData);
        });
        adapterData[adapterPropertyName] = adapterDataArray;
      } else {
        // value is an adapter ID
        tmpAdapter = session.getModelAdapter(adapterPropertyValue);
        tmpAdapterData = cloneAdapterData(adapterPropertyValue);
        resolveAdapterReferences(tmpAdapter, tmpAdapterData);
        adapterData[adapterPropertyName] = tmpAdapterData;
      }
    });
    adapterData = adapter.exportAdapterData(adapterData);
  }
};

/**
 * Reloads the entire browser window.
 *
 * Options:
 *   [schedule]
 *     If true, the page reload is not executed in the current thread but scheduled using setTimeout().
 *     This is useful if the caller wants to execute some other code before the reload. The default is false.
 *   [clearBody]
 *     If true, the body is cleared first before the reload is performed. This is useful to prevent
 *     showing "old" content in the browser until the new content arrives. The default is true.
 *   [redirectUrl]
 *      The new URL to load. If not specified, the current location is used (window.location).
 */
scout.reloadPage = function(options) {
  options = options || {};
  if (options.schedule) {
    setTimeout(reloadPageImpl);
  } else {
    reloadPageImpl();
  }

  // ----- Helper functions -----

  function reloadPageImpl() {
    // Hide everything (on entire page, not only $entryPoint)
    if (scout.nvl(options.clearBody, true)) {
      $('body').html('');
    }

    // Reload window (using setTimeout, to overcome drawing issues in IE)
    setTimeout(function() {
      if (options.redirectUrl) {
        window.location.href = options.redirectUrl;
      } else {
        window.location.reload();
      }
    });
  }
};

scout.App = function() { //
};

/**
 * Main initialization function.<p>
 *
 * Calls this._bootstrap and this._init.<p>
 * During the bootstrap phase additional scripts may get loaded required for a successful session startup.
 * The actual initialization does not get started before these bootstrap scripts are loaded.
 */
scout.App.prototype.init = function(options) {
  var promises = this._bootstrap(options.bootstrap);
  return $.promiseAll(promises).then(function() {
    this._init(options);
  }.bind(this));
};

/**
 * Executes the default bootstrap functions and returns an array of promises.<p>
 * The actual session startup begins only when every of these promises are completed.
 * This gives the possibility to dynamically load additional scripts or files which are mandatory for a successful session startup.
 * The individual bootstrap functions may return null or undefined, a single promise or multiple promises as an array.
 */
scout.App.prototype._bootstrap = function(options) {
  options = options || {};
  var promiseValues = this._doBootstrap(options);

  var promises = [];
  promiseValues.forEach(function(value) {
    if (Array.isArray(value)) {
      promises.concat(value);
    } else if (value) {
      promises.push(value);
    }
  });
  return promises;
};

scout.App.prototype._doBootstrap = function(options) {
  return [
    scout.logging.bootstrap(),
    scout.device.bootstrap(),
    scout.fonts.bootstrap(options.fonts),
    scout.models.bootstrap(options.modelsUrl),
    scout.locales.bootstrap(options.localesUrl),
    scout.texts.bootstrap(options.textsUrl),
    scout.codes.bootstrap(options.codesUrl)
  ];
};

/**
 * Initializes a session for each html element with class '.scout' and stores them in scout.sessions.
 */
scout.App.prototype._init = function(options) {
  options = options || {};
  if (!scout._checkBrowserCompability(options)) {
    return;
  }

  scout.polyfills.install(window);
  scout.prepareDOM();
  scout.objectFactory.init();
  scout._installGlobalJavascriptErrorHandler();
  scout._installGlobalMouseDownInterceptor(document);
  scout._globalAjaxSetup();

  this.installExtensions();

  $('.scout').each(function(i, elem) {
    var $entryPoint = $(elem);
    options.portletPartId = options.portletPartId || $entryPoint.data('partid') || '0';
    var session = this._createSession($entryPoint, options);
    scout.sessions.push(session);
  }.bind(this));
};

scout.App.prototype._createSession = function($entryPoint, options) {
  options.locale = options.locale || new scout.Locale(scout.locales.get('de-CH')); //FIXME CGU wo soll die locale definiert werden? Initial vom browser auslesen?
  options.$entryPoint = $entryPoint;
  var session = scout.create('Session', options, {
    ensureUniqueId: false
  });

  // FIXME improve this, start must not be executed because it currently does a server request
  var parent = new scout.NullWidget();
  parent.session = session;
  session.desktop = this._createDesktop(parent);
  session.render(function() {
    this.onSessionReady(session);
    session._renderDesktop();

    // Ensure layout is valid (explicitly layout immediately and don't wait for setTimeout to run to make layouting invisible to the user)
    session.layoutValidator.validate();
    session.focusManager.validateFocus();

    session.ready = true;
    $.log.info('Session initialized. Detected ' + scout.device);
  }.bind(this));
  return session;
};

scout.App.prototype._createDesktop = function(parent) {
  return scout.create('Desktop', {
    parent: parent
  });
};

scout.App.prototype.onSessionReady = function(session) {
  // NOP
};

scout.App.prototype.onDesktopReady = function(desktop) {
  // NOP
};

/**
 * Override this method to install extensions to Scout objects. Since the extension feature replaces functions
 * on the prototype of the Scout objects you must apply 'function patches' to Scout framework or other code before
 * the extensions are installed.
 *
 * The default implementation does nothing.
 */
scout.App.prototype.installExtensions = function() {
  // NOP
};

scout.RemoteApp = function() { //
};
scout.inherits(scout.RemoteApp, scout.App);

scout.RemoteApp.prototype._doBootstrap = function(options) {
  return [
    scout.logging.bootstrap(),
    scout.device.bootstrap(),
    scout.defaultValues.bootstrap(),
    scout.fonts.bootstrap(options.fonts)
  ];
};

/**
 * @override
 */
scout.RemoteApp.prototype._createSession = function($entryPoint, options) {
  options = options || {};
  options.remote = true;
  options.$entryPoint = $entryPoint;
  var session = scout.create('Session', options, {
    ensureUniqueId: false
  });
  session.start();
  return session;
};

/**
 * @override
 */
scout.RemoteApp.prototype._init = function(options) {
  scout.RemoteApp.modifyWidgetPrototype();
  scout.RemoteApp.modifyTablePrototype();
  scout.RemoteApp.modifyBooleanColumnPrototype();
  scout.RemoteApp.parent.prototype._init.call(this, options);
};

/**
 * Static method to modify the prototype of scout.Widget.
 */
scout.RemoteApp.modifyWidgetPrototype = function() {
  // _createChild
  scout.objects.replacePrototypeFunction(scout.Widget, '_createChild', function(model) {
    if (model instanceof scout.Widget) {
      return model;
    }

    // Remote case
    var modelAdapter = findModelAdapter(this);
    if (modelAdapter) { // If the widget (or one of its parents) has a remote-adapter, all its properties must be remotable
      return this.session.getOrCreateWidget(model, this); // model is a String, contains (remote) object ID
    }

    // Local case (default)
    model.parent = this;
    return scout.create(model);

    function findModelAdapter(widget) {
      while (widget) {
        if (widget.modelAdapter) {
          return widget.modelAdapter;
        }
        widget = widget.parent;
      }
      return null;
    }
  });
};

/**
 * Static method to modify the prototype of scout.Table.
 */
scout.RemoteApp.modifyTablePrototype = function() {
  // prepareCellEdit
  scout.objects.replacePrototypeFunction(scout.Table, 'prepareCellEdit', function(column, row, openFieldPopupOnCellEdit) {
    this.openFieldPopupOnCellEdit = scout.nvl(openFieldPopupOnCellEdit, false);
    this.trigger('prepareCellEdit', {
      column: column,
      row: row
    });
  });

  // completeCellEdit
  scout.objects.replacePrototypeFunction(scout.Table, 'completeCellEdit', function(field) {
    this.trigger('completeCellEdit', {
      field: field
    });
  });

  // cancelCellEdit
  scout.objects.replacePrototypeFunction(scout.Table, 'cancelCellEdit', function(field) {
    this.trigger('cancelCellEdit', {
      field: field
    });
  });
};

scout.RemoteApp.modifyBooleanColumnPrototype = function() {
  // _toggleCellValue
  scout.objects.replacePrototypeFunction(scout.BooleanColumn, '_toggleCellValue', function(row, cell) {
    // NOP - do nothing, since server will handle the click, see Java AbstractTable#interceptRowClickSingleObserver
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * This class is used to extend an existing Scout object. In order to use the extension feature
 * you must subclass scout.Extension an implement an init method where you register the methods
 * you want to extend. Example:
 *
 * scout.MyExtension.prototype.init = function() {
 *   this.extend(scout.MyStringField.prototype, '_init');
 *   this.extend(scout.MyStringField.prototype, '_renderProperties');
 * };
 *
 * Then you implement methods with the same name and signature on the extension class. Example:
 *
 * scout.MyExtension.prototype._init = function(model) {
 *   this.next(model);
 *   this.extended.setProperty('bar', 'foo');
 * };
 *
 * The extension feature sets two properties on the extension instance before the extended method
 * is called. Note: the function scope (this) is set to the extension instance when the extended
 * function is called:
 *
 *   next: is a reference to the next extended function or the original function of the extended
 *         object, in case the current extension is the last extension in the extension chain.
 *
 *   extended: is the extended or original object.
 */
scout.Extension = function() {
};

scout.Extension.prototype.extend = function(extended, funcName) {
  var origFunc = extended[funcName];
  var extension = this;
  var wrapper = function() {
    extension.extended = this;
    extension.next = origFunc.bind(this);
    extension[funcName].apply(extension, arguments);
  };
  extended[funcName] = wrapper;
};

/**
 * Calls scout.create for each extension class in the given extensions array.
 *
 * @param extensions an Array of strings containing extension class names
 * @static
 */
scout.Extension.install = function(extensions) {
  extensions.forEach(function(ext) {
    scout.create(ext);
  });
};


/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * @param initialRegistry (optional) map object containing the initial values used as object registry.
 *   All entries of the given initialRegistry will be cloned. Key = objectType, value = createFunc which
 *   returns a new Scout object instance.
 * @singleton
 */
scout.ObjectFactory = function() {
  // use createUniqueId() to generate a new ID
  this.uniqueIdSeqNo = 0;
  this._registry = {};
};

scout.ObjectFactory.NAMESPACE_SEPARATOR = ".";
scout.ObjectFactory.MODEL_VARIANT_SEPARATOR = ":";

/**
 * Creates an object from the given objectType. Only the constructor is called.
 *
 * OBJECT TYPE:
 *
 * An object type may consist of three parts: [name.space.]Class[:Variant]
 * 1. Name spaces (optional)
 *    All name space parts have to end with a dot ('.') character. If this part is omitted, the default
 *    name space "scout." is assumed.
 *    Examples: "scout.", "my.custom.namespace."
 * 2. Scout class name (mandatory)
 *    Examples: "Desktop", "Session", "StringField"
 * 3. Model variant (optional)
 *    Custom variants of a class can be created by adding the custom class prefix after
 *    the Scout class name and a colon character (':'). This prefix is then combined with
 *    the class name.
 *    Examples: ":Offline", ":Horizontal"
 *
 * Full examples:
 *   Object type: Outline                        -> Constructor: scout.Outline
 *   Object type: myNamespace.Outline            -> Constructor: myNamespace.Outline
 *   Object type: Outline:MyVariant              -> Constructor: scout.MyVariantOutline
 *   Object type: myNamespace.Outline:MyVariant  -> Constructor: myNamespace.MyVariantOutline
 *
 * RESOLVING THE CONSTRUCTOR:
 *
 * When scout.objectFactories contains a create function for the given objectType, this function is called.
 *
 * Otherwise it tries to find the constructor function by the following logic:
 * If the objectType provides a name space, it is used. Otherwise it takes the default "scout" name space.
 * If the object type provides a variant ("Type:Variant"), the final object type is built by prepending
 * the variant to the type ("VariantType"). If no such type can be found and the option "variantLenient"
 * is set to true, a second attempt is made without the variant.
 *
 * @param objectType (mandatory) String describing the type of the object to be created.
 * @param options    (optional)  Options object, currently supporting the following two options:
 *                               - model = Model object to be passed to the constructor or create function
 *                               - variantLenient = Flag to allow a second attempt to resolve the class
 *                                 without variant (see description above).
 */
scout.ObjectFactory.prototype._createObjectByType = function(objectType, options) {
  if (typeof objectType !== 'string') {
    throw new Error('missing or invalid object type');
  }
  options = options || {};

  var scoutObject,
    failMsgPrefix = 'Failed to create object for objectType "' + objectType + '": ';

  var createFunc = this._registry[objectType];
  if (createFunc) {
    // 1.
    // Use factory function registered for the given objectType
    scoutObject = createFunc(options.model);
    if (!scoutObject) {
      throw new Error(failMsgPrefix + 'Factory function did not return a valid object');
    }
  } else {
    // 2.
    // Resolve class by name
    var namespaceParts = objectType.split(scout.ObjectFactory.NAMESPACE_SEPARATOR);
    var namespaces = namespaceParts.slice(0, namespaceParts.length - 1);
    var objectTypeParts = namespaceParts[namespaceParts.length - 1]
      .split(scout.ObjectFactory.MODEL_VARIANT_SEPARATOR)
      // Ensure max. two objectType parts (ignore multiple separators)
      .slice(0, 2);
    // Change "Type:Custom" to "CustomType"
    var scoutClass = objectTypeParts.slice().reverse().join('');

    // Find name space
    var namespace = scout; // <-- default
    if (namespaces.length) {
      namespace = window;
      for (var i = 0; i < namespaces.length; i++) {
        namespace = namespace[namespaces[i]];
        if (!namespace) {
          throw new Error(failMsgPrefix + 'Could not resolve namespace "' + namespaces[i] + '"');
        }
      }
    }
    if (!namespace[scoutClass]) {
      if (options.variantLenient && objectTypeParts.length === 2) {
        // Try without variant if variantLenient is true
        return this._createObjectByType(namespaces.concat(objectTypeParts[0]).join(scout.ObjectFactory.NAMESPACE_SEPARATOR), options);
      }
      throw new Error(failMsgPrefix + 'Could not find "' + scoutClass + '" in namespace "' + namespaces.join('.') + '"');
    }
    scoutObject = new namespace[scoutClass](options.model);
  }

  return scoutObject;
};

/**
 * Creates and initializes a new Scout object.
 *
 * @param objectType A string with the requested objectType. This argument is optional, but if it
 *                   is omitted, the argument "model" becomes mandatory and MUST contain a
 *                   property named "objectType".
 * @param model      The model object passed to the constructor function and to the init() method.
 *                   This argument is mandatory if it is the first argument, otherwise it is
 *                   optional (see above).
 * @param options    Options object, see table below. This argument is optional.
 *
 * An error is thrown if the argument list does not match this definition.
 *
 * List of options:
 *
 * OPTION                   DEFAULT VALUE   DESCRIPTION
 * ------------------------------------------------------------------------------------------------------
 * variantLenient           false           Controls if the object factory may try to resolve the
 *                                          scoutClass without the model variant part if the initial
 *                                          objectType could not be resolved.
 *
 * initObject               true            If true, the init() method is called on the newly created
 *                                          scoutObject (with the model as argument).
 *
 * ensureUniqueId           true            Controls if the resulting object should be assigned the
 *                                          attribute "id" if it is not defined. If "initObject" is
 *                                          true, this also happens on the given model object, to
 *                                          allow the init() method to copy the attribute from the
 *                                          model to the scoutObject.
 *
 * ensureObjectType         true            Controls if the resulting object should be assigned the
 *                                          attribute "objectType" if it is not defined. If "initObject"
 *                                          is true, this also happens on the given model object, to
 *                                          allow the init() method to copy the attribute from the
 *                                          model to the scoutObject.
 */
scout.ObjectFactory.prototype.create = function(objectType, model, options) {
  // Normalize arguments
  if (typeof objectType === 'string') {
    options = options || {};
  } else if (scout.objects.isPlainObject(objectType)) {
    options = model || {};
    model = objectType;
    if (!model.objectType) {
      throw new Error('Missing mandatory property "objectType" on model');
    }
    objectType = model.objectType;
  } else {
    throw new Error('Invalid arguments');
  }
  options.model = model;

  // Create object
  var scoutObject = this._createObjectByType(objectType, options);

  if (scout.nvl(options.initObject, true)) {
    if (model) {
      if (model.id === undefined && scout.nvl(options.ensureUniqueId, true)) {
        model.id = this.createUniqueId();
      }
      if (model.objectType === undefined && scout.nvl(options.ensureObjectType, true)) {
        model.objectType = objectType;
      }
    }
    // Initialize object
    scoutObject.init(model);
  }

  if (scoutObject.id === undefined && scout.nvl(options.ensureUniqueId, true)) {
    scoutObject.id = this.createUniqueId();
  }
  if (scoutObject.objectType === undefined && scout.nvl(options.ensureObjectType, true)) {
    scoutObject.objectType = objectType;
  }

  return scoutObject;
};

/**
 * Returns a new unique ID to be used for Widgets/Adapters created by the UI
 * without a model delivered by the server-side client.
 * @return string ID with prefix 'ui'
 */
scout.ObjectFactory.prototype.createUniqueId = function() {
  return 'ui' + (++this.uniqueIdSeqNo).toString();
};

scout.ObjectFactory.prototype.register = function(objectType, createFunc) {
  $.log.debug('(ObjectFactory) registered create-function for objectType ' + objectType);
  this._registry[objectType] = createFunc;
};

scout.ObjectFactory.prototype.unregister = function(objectType) {
  $.log.debug('(ObjectFactory) unregistered objectType ' + objectType);
  delete this._registry[objectType];
};

scout.ObjectFactory.prototype.get = function(objectType) {
  return this._registry[objectType];
};

/**
 * Cannot init ObjectFactory until Log4Javascript is initialized.
 * That's why we call this method in the scout._init method.
 */
scout.ObjectFactory.prototype.init = function() {
  for (var objectType in scout.objectFactories) {
    if (scout.objectFactories.hasOwnProperty(objectType)) {
      this.register(objectType, scout.objectFactories[objectType]);
    }
  }
};

scout.objectFactory = new scout.ObjectFactory(scout.objectFactories);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.objectFactories = {
  'KeyStroke': function() {
    // A model keystroke is represented as an Action
    return new scout.Action();
  },
  'KeyStrokeAdapter': function() {
    return new scout.ActionAdapter();
  },
  'ComposerField': function() {
    // Composer is just a tree field, there is currently no need to duplicate the JS/CSS code
    return new scout.TreeField();
  },
  'ComposerFieldAdapter': function() {
    return new scout.TreeFieldAdapter();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * @param options The following properties are supported:
 *  [options] mandatory
 *  [containerProperty] optional, if not set: '$container' is used. This property points to the JQuery element that
 *      should be hidden when the field is in loading state. We cannot reference the property in the Ctor of this
 *      class, because the property is not set until the render() method runs.
 *  [loadingIndicatorDelay] optional, if not set: 250 ms
 */
scout.LoadingSupport = function(options) {
  if (!options.widget) {
    throw new Error('Option \'widget\' not set');
  }
  this.widget = options.widget;
  this.$container = options.$container || function() {
    return this.widget.$container;
  }.bind(this);
  this.loadingIndicatorDelay = scout.nvl(options.loadingIndicatorDelay, 250); // ms

  this._loadingIndicatorTimeoutId;
};

scout.LoadingSupport.prototype.setLoadingIndicatorDelay = function(loadingIndicatorDelay) {
  this.loadingIndicatorDelay = loadingIndicatorDelay;
};

scout.LoadingSupport.prototype.renderLoading = function() {
  // Clear any pending loading function
  clearTimeout(this._loadingIndicatorTimeoutId);

  if (!this.widget) {
    return;
  }

  if (this.widget.loading && !this._$loadingIndicator) {
    // --- 1. not loading -> loading ---

    var renderLoading = function() {
      if (this.widget.rendered) {
        // Hide widget content
        this.$container().addClass('loading');
        // Create loading indicator
        this._$loadingIndicator = this.$container().appendDiv('loading-indicator');
      }
    }.bind(this);

    if (this.loadingIndicatorDelay) {
      this._loadingIndicatorTimeoutId = setTimeout(renderLoading, this.loadingIndicatorDelay);
    } else {
      renderLoading();
    }

  } else if (!this.widget.loading && this._$loadingIndicator) {
    // --- 2. loading -> not loading ---

    // Remove loading indicator
    this._$loadingIndicator.fadeOutAndRemove(function() {
      this._$loadingIndicator = null;
      if (this.widget.rendered) {
        // Show widget's content (layout if necessary)
        this.$container().removeClass('loading');
        this.widget.invalidateLayoutTree();
      }
    }.bind(this));
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * A ModelAdapter has a these naming-based contracts. Each property the model (=JSON data) has, is automatically
 * synchronized with the property with the same name in the ModelAdapter. When a property is synchronized it
 * happens in this defined order:
 *
 * <ol>
 * <li><b>_sync[propertyName](newValue, oldValue) method</b> [optional] if this method is present, it is called with the new- and the old value.
 *   Use this method to perform required conversions on the values provided by the model (for instance, convert a date-string into a date object),
 *   or use it when you have to do something based on the old-value.</li>
 * <li><b>Set property [propertyName]</b> if a _sync method is not present, the property is simply set. If the property is an adapter, as specified
 *   by the <code>_adapterProperties</code> list, the property is automatically transformed to an adapter instance.</li>
 * <li><b>_render[propertyName] method</b> at the point the _render method is called, the property is already set, so you can access its value
 *   by using this.[propertyName]. The _render method is required to update the UI based on the new property-value.</li>
 * </ol>
 */
scout.ModelAdapter = function() {
  this._adapterProperties = []; // FIXME [awe, cgu] 6.1 - hier lschen (nur noch auf Widget.js)
  this.initialized = false;
  this.attached = false;
  this.destroyed = false;
  this.widget;

  /**
   * Widget properties which should be sent to server on property change.
   */
  this._remoteProperties = [];
  this._widgetListener;

  this._propertyChangeEventFilter = new scout.PropertyChangeEventFilter();
  this._widgetEventTypeFilter = new scout.WidgetEventTypeFilter();
  this.events = new scout.EventSupport();
};

scout.ModelAdapter.prototype.init = function(model) {
  this._init(model);
  this.initialized = true;
};

/**
 * @param model expects a plain-object with properties: id, session
 */
scout.ModelAdapter.prototype._init = function(model) {
  scout.assertParameter('id', model.id);
  scout.assertParameter('session', model.session);
  $.extend(this, model);
  this.session.registerModelAdapter(this);
};

scout.ModelAdapter.prototype.destroy = function() {
  this._detachWidget();
  this.widget.destroy();
  this.widget = null;
  this.session.unregisterModelAdapter(this);
  this.destroyed = true;
};

scout.ModelAdapter.prototype.createWidget = function(adapterData, parent) {
  var model = this._initModel(adapterData, parent);
  this.widget = this._createWidget(model);
  this._attachWidget();
  this._postCreateWidget();
  return this.widget;
};

/**
 * Override this method to do something right after the widget has been created and has been
 * attached to the remote adapter. The default impl. does nothing.
 */
scout.ModelAdapter.prototype._postCreateWidget = function() {
  // NOP
};

scout.ModelAdapter.prototype._initModel = function(model, parent) {
  // Make a copy to prevent a modification of the given model
  var deepCopy = this.session.adapterExportEnabled;
  model = $.extend(deepCopy, {}, model);

  // Fill in the missing default values
  scout.defaultValues.applyTo(model);

  model.parent = parent;
  model.modelAdapter = this;

  if (model.owner !== undefined) {
    // Prefer the owner sent by the server
    model.owner = this.session.getModelAdapter(model.owner).widget;
    if (!model.owner) {
      throw new Error('owner not found.');
    }
  }

  this._initProperties(model);

  return model;
};

/**
 * Override this method to call _sync* methods of the ModelAdapter _before_ the widget is created.
 */
scout.ModelAdapter.prototype._initProperties = function() {
  // NOP
};

/**
 * @returns A new widget instance. The default impl. uses calls scout.create() with property objectType from given model.
 */
scout.ModelAdapter.prototype._createWidget = function(model) {
  var widget = scout.create(model.objectType, model);
  widget._addCloneProperties(['modelClass', 'classId']);
  return widget;
};

scout.ModelAdapter.prototype._attachWidget = function() {
  if (this._widgetListener) {
    return;
  }
  this._widgetListener = {
    func: this._onWidgetEventInternal.bind(this)
  };
  this.widget.addListener(this._widgetListener);
  this.attached = true;
  this.events.trigger('attach');
};

scout.ModelAdapter.prototype._detachWidget = function() {
  if (!this._widgetListener) {
    return;
  }
  this.widget.removeListener(this._widgetListener);
  this._widgetListener = null;
  this.attached = false;
  this.events.trigger('detach');
};

scout.ModelAdapter.prototype.goOffline = function() {
  this.widget.children.forEach(function(child) {
    if (!child.rendered) {
      // going offline must not modify model state -> only necessary to inform rendered objects
      return;
    }
    if (!child.modelAdapter) {
      return;
    }
    child.modelAdapter.goOffline();
  }, this);
  this._goOffline();
};

scout.ModelAdapter.prototype._goOffline = function() {
  // NOP may be implemented by subclasses
};

scout.ModelAdapter.prototype.goOnline = function() {
  this.widget.children.forEach(function(child) {
    if (!child.rendered) {
      // going online must not modify model state -> only necessary to inform rendered objects
      return;
    }
    if (!child.modelAdapter) {
      return;
    }
    child.modelAdapter.goOnline();
  }, this);
  this._goOnline();
};

scout.ModelAdapter.prototype._goOnline = function() {
  // NOP may be implemented by subclasses
};

scout.ModelAdapter.prototype._isAdapterProperty = function(propertyName) {
  return this._adapterProperties.indexOf(propertyName) > -1;
};

scout.ModelAdapter.prototype._isRemoteProperty = function(propertyName) {
  return this._remoteProperties.indexOf(propertyName) > -1;
};

/**
 * Adds property name(s) of model properties which must be converted automatically to a model adapter.
 *
 * @param properties String or String-array with property names.
 */
scout.ModelAdapter.prototype._addAdapterProperties = function(properties) {
  this._addProperties('_adapterProperties', properties);
};

scout.ModelAdapter.prototype._addRemoteProperties = function(properties) {
  this._addProperties('_remoteProperties', properties);
};

scout.ModelAdapter.prototype._addProperties = function(propertyName, properties) {
  if (Array.isArray(properties)) {
    this[propertyName] = this[propertyName].concat(properties);
  } else {
    this[propertyName].push(properties);
  }
};

/**
 * Removes  property name(s) of model properties which must be converted automatically to a model adapter.
 *
 * Only used for special cases (e.g. when a model adapter wraps another adapter).
 */
scout.ModelAdapter.prototype._removeAdapterProperties = function(properties) {
  if (Array.isArray(properties)) {
    scout.arrays.removeAll(this._adapterProperties, properties);
  } else {
    scout.arrays.remove(this._adapterProperties, properties);
  }
};

/**
 * @returns Creates a scout.Event object from the current adapter instance and
 *   sends the event by using the Session#sendEvent() method. Local objects may
 *   set a different remoteHandler to call custom code instead of the Session#sendEvent()
 *   method.
 *
 * @param type of event
 * @param data of event
 * @param options (optional) options according to the following table:
 *
 * Option name         Default value   Description
 * -----------------------------------------------------------------------------------------
 * delay               0               Delay in milliseconds before the event is sent.
 *
 * coalesce            undefined       Coalesce function added to event-object.
 *
 * showBusyIndicator   undefined       Whether sending the event should block the UI
 *                     (true*)         after a certain delay.
 *                                     * The default value 'undefined' means that the
 *                                       default value ('true') is determined in Session.js.
 *                                       We don't write it explicitly to the event here
 *                                       because that would break many Jasmine tests.
 */
scout.ModelAdapter.prototype._send = function(type, data, options) {
  // Legacy fallback with all options as arguments
  var opts = {};
  if (arguments.length > 2) {
    if (options !== null && typeof options === 'object') {
      opts = options;
    } else {
      opts.delay = arguments[2];
      opts.coalesce = arguments[3];
      opts.showBusyIndicator = arguments[4];
    }
  }
  options = opts;
  // (End legacy fallback)

  var event = new scout.Event(this.id, type, data);
  // The following properties will not be sent to the server, see Session._requestToJson().
  if (options.coalesce !== undefined) {
    event.coalesce = options.coalesce;
  }
  if (options.showBusyIndicator !== undefined) {
    event.showBusyIndicator = options.showBusyIndicator;
  }
  this.session.sendEvent(event, options.delay);
};

/**
 * Sends the given value as property event to the server.
 */
scout.ModelAdapter.prototype._sendProperty = function(propertyName, value) {
  var data = {};
  data[propertyName] = value;
  this._send('property', data);
};

scout.ModelAdapter.prototype.addFilterForWidgetEvent = function(filter) {
  this._widgetEventTypeFilter.addFilter(filter);
};

scout.ModelAdapter.prototype.addFilterForWidgetEventType = function(eventType) {
  this._widgetEventTypeFilter.addFilterForEventType(eventType);
};

scout.ModelAdapter.prototype.addFilterForProperties = function(properties) {
  this._propertyChangeEventFilter.addFilterForProperties(properties);
};

scout.ModelAdapter.prototype._isPropertyChangeEventFiltered = function(propertyName, value) {
  return this._propertyChangeEventFilter.filter(propertyName, value);
};

scout.ModelAdapter.prototype._isWidgetEventFiltered = function(event) {
  return this._widgetEventTypeFilter.filter(event);
};

scout.ModelAdapter.prototype.resetEventFilters = function() {
  this._propertyChangeEventFilter.reset();
  this._widgetEventTypeFilter.reset();
};

scout.ModelAdapter.prototype._onWidgetPropertyChange = function(event) {
  event.changedProperties.forEach(function(propertyName) {
    var value = event.newProperties[propertyName];

    // FIXME CGU [6.1] This does not work if value will be converted into another object (e.g scout.DateRange.ensure(selectionRange) in Planner.js)
    // -> either do the check in this._send() or extract ensure into separate method and move the call of addFilterForProperties.
    // The advantage of the first one would be simpler filter functions (e.g. this.widget._nodesToIds(this.widget.selectedNodes) in Tree.js)
    if (this._isPropertyChangeEventFiltered(propertyName, value)) {
      return;
    }

    if (this._isRemoteProperty(propertyName)) {
      if (value && this._isAdapterProperty(propertyName)) {
        value = value.modelAdapter.id;
      }
      this._callSendProperty(propertyName, value);
    }
  }, this);
};

scout.ModelAdapter.prototype._callSendProperty = function(propertyName, value) {
  var sendFuncName = '_send' + scout.strings.toUpperCaseFirstLetter(propertyName);
  if (this[sendFuncName]) {
    this[sendFuncName](value);
  } else {
    this._sendProperty(propertyName, value);
  }
};

scout.ModelAdapter.prototype._onWidgetDestroy = function() {
  this.destroy();
};

/**
 * Do not override this method. Widget event filtering is done here, before _onWidgetEvent is called.
 * @param event
 */
scout.ModelAdapter.prototype._onWidgetEventInternal = function(event) {
  if (!this._isWidgetEventFiltered(event)) {
    this._onWidgetEvent(event);
  }
};

scout.ModelAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'destroy') {
    this._onWidgetDestroy(event);
  } else if (event.type === 'propertyChange') {
    this._onWidgetPropertyChange(event);
  } else {
    // FIXME CGU [6.1] temporary, until model adapter separation
    if (event.sendToServer) {
      event = $.extend({}, event); // copy
      delete event.source;
      delete event.sendToServer;
      this._send(event.type, event);
    }
  }
};

scout.ModelAdapter.prototype._syncPropertiesOnPropertyChange = function(newProperties) {
  Object.keys(newProperties).forEach(function(propertyName) {
    var value = newProperties[propertyName];
    var syncFuncName = '_sync' + scout.strings.toUpperCaseFirstLetter(propertyName);
    if (this[syncFuncName]) {
      this[syncFuncName](value);
    } else {
      this.widget.callSetter(propertyName, value);
    }
  }, this);
};

/**
 * Called by Session.js for every event from the model
 */
scout.ModelAdapter.prototype.onModelEvent = function(event) {
  if (!event) {
    return;
  }
  if (event.type === 'property') { // Special handling for 'property' type
    this.onModelPropertyChange(event);
  } else {
    this.onModelAction(event);
  }
};

/**
 * Processes the JSON event from the server and calls the corresponding setter of the widget for each property.
 */
scout.ModelAdapter.prototype.onModelPropertyChange = function(event) {
  this.addFilterForProperties(event.properties);
  this._syncPropertiesOnPropertyChange(event.properties);
};

/**
 * The default impl. only logs a warning that the event is not supported.
 */
scout.ModelAdapter.prototype.onModelAction = function(event) {
  $.log.warn('Model action "' + event.type + '" is not supported by model-adapter ' + this.objectType);
};

scout.ModelAdapter.prototype.toString = function() {
  return 'ModelAdapter[objectType=' + this.objectType + ' id=' + this.id + ']';
};

/**
 * This method is used to modify adapterData before the data is exported (as used for JSON export).
 */
scout.ModelAdapter.prototype.exportAdapterData = function(adapterData) {
  // use last part of class-name as ID (because that's better than having only a number as ID)
  var modelClass = adapterData.modelClass;
  if (modelClass) {
    var pos = Math.max(0,
        modelClass.lastIndexOf('$') + 1,
        modelClass.lastIndexOf('.') + 1);
    adapterData.id = modelClass.substring(pos);
  }
  delete adapterData.owner;
  delete adapterData.classId;
  delete adapterData.modelClass;
  return adapterData;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Widget = function() {
  this.session;

  /**
   * The owner is responsible that its children are destroyed when the owner is being destroyed.
   */
  this.owner;
  this.parent;
  this.children = [];
  this.initialized = false;

  /**
   * The 'rendering' flag is set the true while the _inital_ rendering is performed.
   * It is used to to something different in a _render* method when the method is
   * called for the first time.
   */
  this.rendering = false;

  /**
   * The 'rendered' flag is set the true when initial rendering of the widget is completed.
   */
  this.rendered = false;
  this.attached = false;
  this.destroyed = false;

  this.enabled = true;
  this.disabledStyle = scout.Widget.DisabledStyle.DEFAULT;
  this.visible = true;
  this.loading = false;

  this.$container;
  // If set to true, remove won't remove the element immediately but after the animation has been finished
  // This expects a css animation which may be triggered by the class 'removed'
  // If browser does not support css animation, remove will be executed immediately
  this.animateRemoval;

  // FIXME [6.1] CGU, AWE durch propertyConfig ersetzen oder renamen auf widgetProperties
  // ev. dafr sorgen dass die config nur noch pro Klasse und nicht pro Instanz gemacht wird (memory)
  this._adapterProperties = [];
  this._cloneProperties = ['visible', 'enabled', 'cssClass'];
  this._preserveOnPropertyChangeProperties = []; // FIXME [awe, cgu] 6.1 - migrieren zu propertyConfig und
  this._postRenderActions = [];
  this._parentDestroyHandler = this._onParentDestroy.bind(this);
  this.events = this._createEventSupport();
  this.loadingSupport = this._createLoadingSupport();
  this.keyStrokeContext = this._createKeyStrokeContext();
};

/**
 * Enum used to define different styles used when the field is disabled.
 */
scout.Widget.DisabledStyle = {
  DEFAULT: 0,
  READ_ONLY: 1
};

scout.Widget.prototype.init = function(model) {
  var staticModel = this._jsonModel();
  $.extend(model, staticModel);
  this._init(model);
  this._initKeyStrokeContext();
  this.initialized = true;
  this.trigger('init');
};

/**
 * @param options
 * - parent (required): The parent widget
 * - session (optional): If not specified the session of the parent is used
 */
scout.Widget.prototype._init = function(model) {
  model = model || {};
  if (!model.parent) {
    throw new Error('Parent expected: ' + this);
  }
  this.setOwner(model.owner || model.parent);
  this.setParent(model.parent);

  this.session = model.session || this.parent.session;
  if (!this.session) {
    throw new Error('Session expected: ' + this);
  }
  this.animateRemoval = scout.nvl(model.animateRemoval, false);

  this._eachProperty(model, function(propertyName, value, isAdapterProperty) {
    if (value === undefined) {
      // Don't set the value if it is undefined, compared to null which is allowed explicitly ($.extend works in the same way)
      return;
    }
    if (isAdapterProperty) {
      value = this._prepareWidgetProperty(propertyName, value);
    }
    this[propertyName] = value;
  }.bind(this));
};

/**
 * Default implementation simply returns undefined. A Subclass
 * may override this method to load or extend a JSON model with scout.models.getModel or scout.models.extend.
 */
scout.Widget.prototype._jsonModel = function() {};

/**
 * Creates the widgets using the given models, or returns the widgets if the given models already are widgets.
 * @returns an array of created widgets if models was an array. Or the created widget if models is not an array.
 */
scout.Widget.prototype._createChildren = function(models) {
  if (!models) {
    return null;
  }

  if (!Array.isArray(models)) {
    return this._createChild(models);
  }

  var widgets = [];
  models.forEach(function(model, i) {
    widgets[i] = this._createChildren(model);
  }, this);
  return widgets;
};

/**
 * Calls {@link scout.create} for the given model, or if model is already a scout.Widget simply returns the widget.
 *
 * @param model {Object|scout.Widget}
 * @returns {scout.Widget}
 */
scout.Widget.prototype._createChild = function(model) {
  if (model instanceof scout.Widget) {
    return model;
  }
  model.parent = this;
  return scout.create(model);
};

scout.Widget.prototype._initKeyStrokeContext = function() {
  if (!this.keyStrokeContext) {
    return;
  }
  this.keyStrokeContext.$scopeTarget = function() {
    return this.$container;
  }.bind(this);
  this.keyStrokeContext.$bindTarget = function() {
    return this.$container;
  }.bind(this);
};

scout.Widget.prototype.destroy = function() {
  if (this.destroyed) {
    // Already destroyed, do nothing
    return;
  }

  if (this.animateRemoval && this.rendered) {
    this.one('remove', function() {
      this.destroy();
    }.bind(this));
    this.remove();
    return;
  }

  // Destroy children in reverse order
  this._destroyChildren(this.children.slice().reverse());

  this.remove();

  // Disconnect from owner and parent
  this.owner.removeChild(this);
  this.owner = null;
  this.parent.removeChild(this);
  this.parent.off('destroy', this._parentDestroyHandler);
  this.parent = null;

  this.destroyed = true;
  this.trigger('destroy');
};

/**
 * @param widgets may be an object or array of objects
 */
scout.Widget.prototype._destroyChildren = function(widgets) {
  if (!widgets) {
    return;
  }

  widgets = scout.arrays.ensure(widgets);
  widgets.forEach(function(widget, i) {
    this._destroyChild(widget);
  }, this);
};

scout.Widget.prototype._destroyChild = function(child) {
  if (child.owner !== this) {
    return;
  }
  child.destroy();
};

scout.Widget.prototype.render = function($parent) {
  $.log.trace('Rendering widget: ' + this);
  if (!this.initialized) {
    throw new Error('Not initialized: ' + this);
  }
  if (this.rendered) {
    throw new Error('Already rendered: ' + this);
  }
  if (this.destroyed) {
    throw new Error('Widget is destroyed: ' + this);
  }
  this.rendering = true;
  this.$parent = $parent;
  this._render($parent);
  this._renderProperties();
  this._renderInspectorInfo();
  this._linkWithDOM();
  this.session.keyStrokeManager.installKeyStrokeContext(this.keyStrokeContext);
  this.rendering = false;
  this.rendered = true;
  this.attached = true;
  this.trigger('render');
  this._postRender();
};

/**
 * This method creates the UI through DOM manipulation. At this point we should not apply model
 * properties on the UI, since sub-classes may need to contribute to the DOM first. You must not
 * apply model values to the UI here, since this is done in the _renderProperties method later.
 * The default impl. does nothing.
 */
scout.Widget.prototype._render = function($parent) {
  // NOP
};

/**
 * This method calls the UI setter methods after the _render method has been executed.
 * Here values of the model are applied to the DOM / UI.
 */
scout.Widget.prototype._renderProperties = function() {
  this._renderEnabled();
  this._renderVisible();
  this._renderCssClass();
  this._renderLoading();
};

/**
 * Method invoked once rendering completed and 'rendered' flag is set to 'true'.<p>
 * By default executes every action of this._postRenderActions
 */
scout.Widget.prototype._postRender = function() {
  var actions = this._postRenderActions;
  this._postRenderActions = [];
  actions.forEach(function(action) {
    action();
  });
};

scout.Widget.prototype.remove = function() {
  if (!this.rendered || this._isRemovalPending()) {
    return;
  }
  if (this.animateRemoval) {
    this._removeAnimated();
  } else {
    this._removeInternal();
  }
};

/**
 * Returns true if the removal of this or an ancestor widget is pending. Checking the ancestor is omitted if the parent is being removed.
 * This may be used to prevent a removal if an ancestor will be removed (e.g by an animation)
 */
scout.Widget.prototype._isRemovalPending = function() {
  if (this.removalPending) {
    return true;
  }
  var parent = this.parent;
  if (!parent || parent.removing) {
    // If parent is being removed, no need to check the ancestors because removing is already in progress
    return false;
  }
  while (parent) {
    if (parent.removalPending) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
};

scout.Widget.prototype._removeInternal = function() {
  if (!this.rendered) {
    return;
  }

  $.log.trace('Removing widget: ' + this);
  this.removing = true;

  // remove children in reverse order.
  this.children.slice().reverse().forEach(function(child) {
    // Only remove the child if this widget is the current parent (if that is not the case this widget is the owner)
    if (child.parent === this) {
      child.remove();
    }
  }, this);
  this.session.keyStrokeManager.uninstallKeyStrokeContext(this.keyStrokeContext);
  this._cleanup();
  this._remove();
  this.$parent = null;
  this.rendered = false;
  this.attached = false;
  this.removing = false;
  this.trigger('remove');
};

/**
 * Adds class 'removed' to container which can be used to trigger the animation.
 * After the animation is executed, the element gets removed using this._removeInternal.
 */
scout.Widget.prototype._removeAnimated = function() {
  if (!scout.device.supportsCssAnimation() || !this.$container) {
    // Cannot remove animated, remove regularly
    this._removeInternal();
    return;
  }

  // Destroy open popups first, they are not animated
  this.session.desktop.destroyPopupsFor(this);

  this.removalPending = true;
  // Don't execute immediately to make sure nothing interferes with the animation (e.g. layouting) which could make it laggy
  setTimeout(function() {
    this.$container.addClass('removed');
    this.$container.oneAnimationEnd(function() {
      this.removalPending = false;
      this._removeInternal();
    }.bind(this));
  }.bind(this));
};

scout.Widget.prototype._renderInspectorInfo = function() {
  if (!this.session.inspector) {
    return;
  }
  scout.inspector.applyInfo(this);
};

/**
 * Links $container with the widget.
 */
scout.Widget.prototype._linkWithDOM = function() {
  if (this.$container) {
    this.$container.data('widget', this);
  }
};

/**
 * Called right before _remove is called.
 * Default calls LayoutValidator.cleanupInvalidComponents to make sure that child components are removed from the invalid components list.
 */
scout.Widget.prototype._cleanup = function() {
  if (this.$container) {
    this.session.layoutValidator.cleanupInvalidComponents(this.$container);
  }
};

scout.Widget.prototype._remove = function() {
  if (this.$container) {
    this.$container.remove();
    this.$container = null;
  }
};

scout.Widget.prototype.setOwner = function(owner) {
  scout.assertParameter('owner', owner);
  if (owner === this.owner) {
    return;
  }

  if (this.owner) {
    // Remove from old owner
    this.owner.removeChild(this);
  }
  this.owner = owner;
  this.owner.addChild(this);
};

scout.Widget.prototype.setParent = function(parent) {
  scout.assertParameter('parent', parent);
  if (parent === this.parent) {
    return;
  }

  if (this.parent) {
    // Don't link to new parent yet if removal is still pending.
    // After the animation the parent will remove its children.
    // If they are already linked to a new parent, removing the children is not possible anymore.
    // This may lead to an "Already rendered" exception if the new parent wants to render its children.
    if (this.parent._isRemovalPending()) {
      this.parent.one('remove', function() {
        this.setParent(parent);
      }.bind(this));
      return;
    }

    this.parent.off('destroy', this._parentDestroyHandler);

    if (this.parent !== this.owner) {
      // Remove from old parent if getting relinked
      // If the old parent is still the owner, don't remove it because owner stays responsible for destryoing it
      this.parent.removeChild(this);
    }
  }
  this.parent = parent;
  this.parent.addChild(this);
  this.parent.one('destroy', this._parentDestroyHandler);
};

scout.Widget.prototype.addChild = function(child) {
  $.log.trace('addChild(' + child + ') to ' + this);
  if (this.children.indexOf(child) === -1) {
    this.children.push(child);
  }
};

scout.Widget.prototype.removeChild = function(child) {
  $.log.trace('removeChild(' + child + ') from ' + this);
  scout.arrays.remove(this.children, child);
};

/**
 * @returns true if the given widget is the same as this or a descendant
 */
scout.Widget.prototype.isOrHas = function(widget) {
  if (widget === this) {
    return true;
  }
  return this.has(widget);
};

/**
 * @returns true if the given widget is a descendant
 */
scout.Widget.prototype.has = function(widget) {
  while (widget) {
    if (widget.parent === this) {
      return true;
    }
    widget = widget.parent;
  }

  return false;
};

scout.Widget.prototype.setEnabled = function(enabled) {
  this.setProperty('enabled', enabled);
};

scout.Widget.prototype._renderEnabled = function() {
  if (!this.$container) {
    return;
  }
  this.$container.setEnabled(this.enabled);
  this._renderDisabledStyle();
};

scout.Widget.prototype.setDisabledStyle = function(disabledStyle) {
  this.setProperty('disabledStyle', disabledStyle);
};

scout.Widget.prototype._renderDisabledStyle = function() {
  this._renderDisabledStyleInternal(this.$container);
};

/**
 * This function is used by subclasses to render the read-only class for a given $field.
 * Some fields like DateField have two input fields and thus cannot use the this.$field property.
 */
scout.Widget.prototype._renderDisabledStyleInternal = function($element) {
  if (!$element) {
    return;
  }
  var enabled = this.enabled;
  // For FormFields, the parents' "enabledness" must be considered as well (e.g. when a field is enabled,
  // but the parent group box is not, the field has enabled=true but is rendered as disabled). This
  // instance check may probably be removed in the future, when enabledComputed is move to Widget.js
  if (this instanceof scout.FormField) {
    enabled = this.enabledComputed;
  }
  if (enabled) {
    $element.removeClass('read-only');
  } else {
    $element.toggleClass('read-only', this.disabledStyle === scout.Widget.DisabledStyle.READ_ONLY);
  }
};

scout.Widget.prototype.setVisible = function(visible) {
  this.setProperty('visible', visible);
};

scout.Widget.prototype._renderVisible = function() {
  if (!this.$container) {
    return;
  }
  this.$container.setVisible(this.visible);
};

scout.Widget.prototype._syncCssClass = function(cssClass) {
  if (this.rendered) {
    this._removeCssClass();
  }
  this._setProperty('cssClass', cssClass);
};

scout.Widget.prototype._removeCssClass = function() {
  if (!this.$container) {
    return;
  }
  this.$container.removeClass(this.cssClass);
};

scout.Widget.prototype._renderCssClass = function() {
  if (!this.$container) {
    return;
  }
  this.$container.addClass(this.cssClass);
};

scout.Widget.prototype.setCssClass = function(cssClass) {
  this.setProperty('cssClass', cssClass);
};

/**
 * Creates nothing by default. If a widget needs loading support, override this method and return a loading support.
 */
scout.Widget.prototype._createLoadingSupport = function() {
  return null;
};

scout.Widget.prototype.setLoading = function(loading) {
  this.setProperty('loading', loading);
};

scout.Widget.prototype._renderLoading = function() {
  if (!this.loadingSupport) {
    return;
  }
  this.loadingSupport.renderLoading();
};

//--- Layouting / HtmlComponent methods ---

scout.Widget.prototype.pack = function() {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.pack();
};

scout.Widget.prototype.invalidateLayout = function() {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.invalidateLayout();
};

scout.Widget.prototype.validateLayout = function() {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.validateLayout();
};

scout.Widget.prototype.revalidateLayout = function() {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.revalidateLayout();
};

scout.Widget.prototype.invalidateLayoutTree = function(invalidateParents) {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.invalidateLayoutTree(invalidateParents);
};

scout.Widget.prototype.validateLayoutTree = function() {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.validateLayoutTree();
};

scout.Widget.prototype.revalidateLayoutTree = function() {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.revalidateLayoutTree();
};

scout.Widget.prototype.setLayoutData = function(layoutData) {
  if (!this.rendered) {
    return;
  }
  if (!this.htmlComp) {
    throw new Error('Function expects a htmlComp property');
  }
  this.htmlComp.layoutData = layoutData;
};

//--- Event handling methods ---
scout.Widget.prototype._createEventSupport = function() {
  return new scout.EventSupport();
};

scout.Widget.prototype.trigger = function(type, event) {
  event = event || {};
  event.source = this;
  this.events.trigger(type, event);
};

scout.Widget.prototype.one = function(type, func) {
  this.events.one(type, func);
};

scout.Widget.prototype.on = function(type, func) {
  return this.events.on(type, func);
};

scout.Widget.prototype.off = function(type, func) {
  this.events.off(type, func);
};

scout.Widget.prototype.addListener = function(listener) {
  this.events.addListener(listener);
};

scout.Widget.prototype.removeListener = function(listener) {
  this.events.removeListener(listener);
};

/**
 * @param $element (optional) element from which the entryPoint will be resolved. If not set this.$container is used.
 * @returns the entry-point for this Widget. If the widget is part of the main-window it returns this.session.$entryPoint,
 * for popup-window this function will return the body of the document in the popup window.
 */
scout.Widget.prototype.entryPoint = function($element) {
  $element = scout.nvl($element, this.$container);
  if (!$element.length) {
    throw new Error('Cannot resolve entryPoint, $element.length is 0 or undefined');
  }
  return $element.entryPoint();
};

/**
 * This method attaches the detached $container to the DOM.
 */
scout.Widget.prototype.attach = function() {
  if (this.attached || !this.rendered) {
    return;
  }
  this._attach();
  this._triggerChildrenAfterAttach(this);
};

scout.Widget.prototype._triggerChildrenAfterAttach = function(parent) {
  this.children.forEach(function(child) {
    child._afterAttach(parent);
    child._triggerChildrenAfterAttach(parent);
  });
};

scout.Widget.prototype._afterAttach = function(parent) {
  // NOP
};

/**
 * Override this method to do something when Widget is attached again. Typically
 * you will append this.$container to this.$parent. The default implementation
 * sets this.attached to true.
 *
 * @param the event.target property is used to decide if a Widget must attach
 *   its $container. When the parent of the Widget already attaches, the Widget
 *   itself must _not_ attach its own $container. That's why we should only
 *   attach when event.target is === this.
 */
scout.Widget.prototype._attach = function(event) {
  this.attached = true;
};

/**
 * This method calls detach() on all child-widgets. It is used to store some data
 * before a DOM element is detached and propagate the detach "event" to all child-
 * widgets, because when a DOM element is detached - child elements are not notified
 */
scout.Widget.prototype.detach = function() {
  if (this.rendering) {
    // Defer the execution of detach. If it was detached while rendering the attached flag would be wrong.
    this._postRenderActions.push(this.detach.bind(this));
  }
  if (!this.attached || !this.rendered || this._isRemovalPending()) {
    return;
  }

  this._triggerChildrenBeforeDetach(this);
  this._detach();
};

/**
 * Override this method to do something when Widget is detached. Typically you
 * will call this.$container.detach() here and use the DetachHelper to store
 * additional state (focus, scrollbars) for the detached element. The default
 * implementation sets this.attached to false.
 *
 * @param the event.target property is used to decide if a Widget must detach
 *   its $container. When the parent of the Widget already detaches, the Widget
 *   itself must _not_ detach its own $container. That's why we should only
 *   detach when event.target is === this.
 */
scout.Widget.prototype._detach = function() {
  this.attached = false;
};

scout.Widget.prototype._triggerChildrenBeforeDetach = function(parent) {
  this.children.forEach(function(child) {
    child._beforeDetach(parent);
    child._triggerChildrenBeforeDetach(parent);
  });
};

scout.Widget.prototype._beforeDetach = function(parent) {
  // NOP
};

/**
 * Does nothing by default. If a widget needs keystroke support override this method and return a keystroke context, e.g. the default scout.KeyStrokeContext.
 */
scout.Widget.prototype._createKeyStrokeContext = function() {
  return null;
};

scout.Widget.prototype.updateKeyStrokes = function(newKeyStrokes, oldKeyStrokes) {
  this.unregisterKeyStrokes(oldKeyStrokes);
  this.registerKeyStrokes(newKeyStrokes);
};

scout.Widget.prototype.registerKeyStrokes = function(keyStrokes) {
  keyStrokes = scout.arrays.ensure(keyStrokes);
  keyStrokes.forEach(function(keyStroke) {
    this.keyStrokeContext.registerKeyStroke(keyStroke);
  }, this);
};

scout.Widget.prototype.unregisterKeyStrokes = function(keyStrokes) {
  keyStrokes = scout.arrays.ensure(keyStrokes);
  keyStrokes.forEach(function(keyStroke) {
    this.keyStrokeContext.unregisterKeyStroke(keyStroke);
  }, this);
};

scout.Widget.prototype.triggerBulkPropertyChange = function(oldProperties, newProperties) {
  var propertyChangeEvent = {
    newProperties: newProperties,
    oldProperties: oldProperties,
    changedProperties: []
  };
  // To allow a listener to react only to properties that have really changed their value, we
  // calculate the list of "changedProperties". This may be relevant, when the value on the model
  // changes from A to B and back to A, which emits a property change event when in fact, the
  // property has not really changed for the UI.
  for (var prop in newProperties) {
    if (newProperties[prop] !== oldProperties[prop]) {
      propertyChangeEvent.changedProperties.push(prop);
    }
  }
  this.trigger('propertyChange', propertyChangeEvent);
};

/**
 * Fires a property change for a single property.
 */
scout.Widget.prototype.triggerPropertyChange = function(propertyName, oldValue, newValue) {
  if (!propertyName) {
    return;
  }
  var oldProperties = {},
    newProperties = {};
  oldProperties[propertyName] = oldValue;
  newProperties[propertyName] = newValue;
  this.triggerBulkPropertyChange(oldProperties, newProperties);
};

/**
 * Sets the value of the property 'propertyName' to 'newValue' and then fires a propertyChange event for that property.
 */
scout.Widget.prototype._setProperty = function(propertyName, newValue) {
  if (!propertyName) {
    return;
  }
  var oldValue = this[propertyName];
  this[propertyName] = newValue;
  this.triggerPropertyChange(propertyName, oldValue, newValue);
};

/**
 * Sets a new value for a specific property. If the new value is the same value as the old one, nothing is performed.
 * Otherwise the following phases are executed:
 * <p>
 * 1. Preparation: If the property is a widget property, several actions are performed in _prepareWidgetProperty().
 * 2. DOM removal: If the property is a widget property and the widget is rendered, the changed widget(s) are removed unless the property should not be preserved (see _preserveOnPropertyChangeProperties).
 *    If there is a custom remove function (e.g. _removeXY where XY is the property name), it will be called instead of removing the widgets directly.
 * 3. Model update: If there is a custom sync function (e.g. _syncXY where XY is the property name), it will be called. Otherwise the default sync function _setProperty is called.
 * 4. DOM rendering: If the widget is rendered and there is a custom render function (e.g. _renderXY where XY is the property name), it will be called. Otherwise nothing happens.
 */
scout.Widget.prototype.setProperty = function(propertyName, value) {
  if (scout.objects.equals(this[propertyName], value)) {
    return;
  }

  value = this._prepareProperty(propertyName, value);
  if (this.rendered) {
    this._callRemoveProperty(propertyName);
  }
  this._callSetProperty(propertyName, value);
  if (this.rendered) {
    this._callRenderProperty(propertyName);
  }
};

scout.Widget.prototype._prepareProperty = function(propertyName, value) {
  if (!this._isAdapterProperty(propertyName)) {
    return value;
  }
  return this._prepareWidgetProperty(propertyName, value);
};

scout.Widget.prototype._prepareWidgetProperty = function(propertyName, widgets) {
  // Create new child widget(s)
  widgets = this._createChildren(widgets);

  var oldWidgets = this[propertyName];
  if (oldWidgets && Array.isArray(widgets)) {
    // if new value is an array, old value has to be one as well
    // copy to prevent modification of original
    oldWidgets = oldWidgets.slice();

    // only destroy those which are not in the new array
    scout.arrays.removeAll(oldWidgets, widgets);
  }

  // Destroy old child widget(s)
  if (!this._isPreserveOnPropertyChangeProperty(propertyName)) {
    this._destroyChildren(oldWidgets);
  }

  // Link to new parent
  this.link(widgets);

  return widgets;
};

/**
 * Does nothing if the property is not a widget property.<p>
 * If it is a widget property, it removes the existing widgets. Render has to be implemented by the widget itself.
 */
scout.Widget.prototype._callRemoveProperty = function(propertyName) {
  if (!this._isAdapterProperty(propertyName)) {
    return;
  }
  if (this._isPreserveOnPropertyChangeProperty(propertyName)) {
    return;
  }
  var widgets = this[propertyName];
  if (!widgets) {
    return;
  }
  var removeFuncName = '_remove' + scout.strings.toUpperCaseFirstLetter(propertyName);
  if (this[removeFuncName]) {
    this[removeFuncName]();
  } else {
    this._internalRemoveWidgets(widgets);
  }
};

/**
 * Removes the given widgets
 */
scout.Widget.prototype._internalRemoveWidgets = function(widgets) {
  widgets = scout.arrays.ensure(widgets);
  widgets.forEach(function(widget) {
    widget.remove();
  });
};

scout.Widget.prototype._callSetProperty = function(propertyName, value) {
  var syncFuncName = '_sync' + scout.strings.toUpperCaseFirstLetter(propertyName);
  if (this[syncFuncName]) {
    this[syncFuncName](value); // FIXME [6.1] CGU rename to _setFuncName
  } else {
    this._setProperty(propertyName, value);
  }
};

scout.Widget.prototype._callRenderProperty = function(propertyName) {
  var renderFuncName = '_render' + scout.strings.toUpperCaseFirstLetter(propertyName);
  if (!this[renderFuncName]) {
    return;
  }
  this[renderFuncName]();
};

/**
 * Sets this widget as parent of the given widget(s).
 *
 * @param widgets may be a widget or array of widgets
 */
scout.Widget.prototype.link = function(widgets) {
  if (!widgets) {
    return;
  }

  widgets = scout.arrays.ensure(widgets);
  widgets.forEach(function(child, i) {
    child.setParent(this);
  }, this);
};

/**
 * Method required for widgets which are supposed to be directly covered by a glasspane.<p>
 *
 * Returns the DOM elements to paint a glassPanes over, once a modal Form, message-box or file-chooser is shown with this widget as its 'displayParent'.<br>
 * If the widget is not rendered yet, a scout.DerredGlassPaneTarget is returned.<br>
 * In both cases the method _glassPaneTargets is called which may be overridden by the actual widget.
 */
scout.Widget.prototype.glassPaneTargets = function() {
  if (this.rendered) {
    return this._glassPaneTargets();
  }

  return scout.DeferredGlassPaneTarget.createFor(this, this._glassPaneTargets.bind(this));
};

scout.Widget.prototype._glassPaneTargets = function() {
  return [this.$container];
};

scout.Widget.prototype.toString = function() {
  return 'Widget[rendered=' + this.rendered +
    (this.$container ? ' $container=' + scout.graphics.debugOutput(this.$container) : '') + ']';
};

scout.Widget.prototype.resolveTextKeys = function(properties) {
  properties.forEach(function(property) {
    scout.texts.resolveTextProperty(this, property);
  }, this);
};

scout.Widget.prototype.resolveIconIds = function(properties) {
  properties.forEach(function(property) {
    this[property] = scout.icons.resolveIconId(this[property]);
  }, this);
};

// FIXME CGU [6.1] temporary, rename
scout.Widget.prototype._addAdapterProperties = function(properties) {
  this._addProperties('_adapterProperties', properties);
};

scout.Widget.prototype._isAdapterProperty = function(propertyName) {
  return this._adapterProperties.indexOf(propertyName) > -1;
};

scout.Widget.prototype._addCloneProperties = function(properties) {
  this._addProperties('_cloneProperties', properties);
};

scout.Widget.prototype._isCloneProperty = function(propertyName) {
  return this._cloneProperties.indexOf(propertyName) > -1;
};

scout.Widget.prototype._addPreserveOnPropertyChangeProperties = function(properties) {
  this._addProperties('_preserveOnPropertyChangeProperties', properties);
};

scout.Widget.prototype._isPreserveOnPropertyChangeProperty = function(propertyName) {
  return this._preserveOnPropertyChangeProperties.indexOf(propertyName) > -1;
};

scout.Widget.prototype._addProperties = function(propertyName, properties) {
  if (Array.isArray(properties)) {
    this[propertyName] = this[propertyName].concat(properties);
  } else {
    this[propertyName].push(properties);
  }
};

scout.Widget.prototype._eachProperty = function(model, func) {
  var propertyName, value, i;

  // Loop through primitive properties
  for (propertyName in model) {
    if (this._adapterProperties.indexOf(propertyName) > -1) {
      continue; // will be handled below
    }
    value = model[propertyName];
    func(propertyName, value);
  }

  //Loop through adapter properties (any order will do).
  for (i = 0; i < this._adapterProperties.length; i++) {
    propertyName = this._adapterProperties[i];
    value = model[propertyName];
    if (value === undefined) {
      continue;
    }

    func(propertyName, value, true);
  }
};

scout.Widget.prototype._removeAdapterProperties = function(properties) {
  if (Array.isArray(properties)) {
    scout.arrays.removeAll(this._adapterProperties, properties);
  } else {
    scout.arrays.remove(this._adapterProperties, properties);
  }
};

// FIXME CGU [6.1] temporary, remove after model adapter separation
scout.Widget.prototype._send = function(type, data) {
  data = $.extend({}, data); // create a copy, so we don't change the original data unintentionally
  data.sendToServer = true;
  this.trigger(type, data);
};

/**
 * Clones the widget and mirrors the events, see this.clone() and this.mirror() for details.
 */
scout.Widget.prototype.cloneAndMirror = function(model) {
  var clone = this.clone(model);
  clone.mirror();
  return clone;
};

/**
 * @returns the original widget from which this one was cloned. If it is not a clone, itself is returned.
 */
scout.Widget.prototype.original = function() {
  var original = this;
  while (original.cloneOf) {
    original = original.cloneOf;
  }
  return original;
};

/**
 * Clones the widget and returns the clone. Only the properties defined in this._cloneProperties are copied to the clone.
 * The parameter model has to contain at least the property 'parent'.
 * @param model The model used to create the clone is a combination of the clone properties and this model.
 * Therefore this model may be used to override the cloned properties or to add additional properties.
 */
scout.Widget.prototype.clone = function(model) {
  var clone, cloneModel;
  model = model || {};

  cloneModel = scout.objects.extractProperties(this, model, this._cloneProperties);
  clone = scout.create(this.objectType, cloneModel);
  clone.cloneOf = this;

  return clone;
};

/**
 * Delegates every property change event from the original widget to this cloned widget by calling the appropriate setter.
 * Works only if this widget is a clone.
 */
scout.Widget.prototype.mirror = function() {
  if (!this.cloneOf) {
    throw new Error('Widget is not a clone.');
  }
  this._mirror(this.cloneOf);
  this.children.forEach(function(childClone) {
    if (childClone.cloneOf) {
      childClone.mirror(childClone.cloneOf);
    }
  });
};

scout.Widget.prototype._mirror = function(source) {
  if (this._mirrorListener) {
    return;
  }
  this._mirrorListener = {
    func: this._onMirrorEvent.bind(this)
  };
  source.events.addListener(this._mirrorListener);
  this.one('destroy', function() {
    this.unmirror(source);
  }.bind(this));
};

scout.Widget.prototype.unmirror = function() {
  this.children.forEach(function(childClone) {
    if (childClone.cloneOf) {
      childClone.unmirror(childClone.cloneOf);
    }
  });
  this._unmirror(this.cloneOf);
};

scout.Widget.prototype._unmirror = function(source) {
  if (!this._mirrorListener) {
    return;
  }
  source.events.removeListener(this._mirrorListener);
  this._mirrorListener = null;
};

scout.Widget.prototype._onMirrorEvent = function(event) {
  if (event.type === 'propertyChange') {
    this._onMirrorPropertyChange(event);
  }
};

scout.Widget.prototype._onMirrorPropertyChange = function(event) {
  event.changedProperties.forEach(function(property) {
    this.callSetter(property, event.newProperties[property]);
  }, this);
};

scout.Widget.prototype._onParentDestroy = function(event) {
  if (this.destroyed) {
    return;
  }
  // If the parent is destroyed but the widget not make sure it gets a new parent
  // This ensures the old one may be properly garbage collected
  this.setParent(this.owner);
};

scout.Widget.prototype.callSetter = function(propertyName, value) {
  var setterFuncName = 'set' + scout.strings.toUpperCaseFirstLetter(propertyName);
  if (this[setterFuncName]) {
    this[setterFuncName](value);
  } else {
    this.setProperty(propertyName, value);
  }
};

/**
 * Traverses the object-tree (children) of this widget and searches for a widget with the given ID.
 * Returns the widget with the requested ID or null if no widget has been found.
 * @param widgetId
 */
scout.Widget.prototype.widget = function(widgetId) {
  return _recWidget(this, widgetId);

  function _recWidget(widget, widgetId) {
    if (widget.id === widgetId) {
      return widget;
    }
    var i, child;
    if (widget.children && widget.children.length > 0) {
      for (i = 0; i < widget.children.length; i++) {
        child = widget.children[i];
        if (child.id === widgetId) {
          return child;
        } else {
          child = _recWidget(child, widgetId);
          if (child) {
            return child;
          }
        }
      }
    } else {
      return null;
    }
  }
};

/**
 * @deprecated Use this.widget() instead
 */
scout.Widget.prototype.getWidgetById = function(widgetId) {
  return this.widget(widgetId);
};

scout.Widget.prototype.requestFocus = function() {
  if (!this.rendered) {
    this._postRenderActions.push(this.requestFocus.bind(this));
    return;
  }

  this.session.focusManager.requestFocus(this.$container);
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

scout.Widget.getWidgetFor = function($elem) {
  while ($elem && $elem.length > 0) {
    var widget = $elem.data('widget');
    if (widget) {
      return widget;
    }
    $elem = $elem.parent();
  }
  return null;
};

scout.Composite = function() {
  scout.Composite.parent.call(this);

  this.widgets = [];
  this._addAdapterProperties(['widgets']);
};
scout.inherits(scout.Composite, scout.Widget);

scout.Composite.prototype._render = function($parent) {
  this.$container = $parent.appendDiv();
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
};

scout.Composite.prototype._renderProperties = function() {
  scout.Composite.parent.prototype._renderProperties.call(this);
  this._renderWidgets();
};

scout.Composite.prototype.setWidgets = function(widgets) {
  this.setProperty('widgets', widgets);
};

scout.Composite.prototype._renderWidgets = function($parent) {
  this.widgets.forEach(function(widget) {
    widget.render(this.$container);
  }, this);
  this.invalidateLayoutTree();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.NullWidget = function() {
  scout.NullWidget.parent.call(this);

  this._addAdapterProperties(['childWidget']);
};
scout.inherits(scout.NullWidget, scout.Widget);

scout.NullWidget.prototype.setChildWidget = function(childWidget) {
  this.setProperty('childWidget', childWidget);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.NullWidgetAdapter = function() {
  scout.NullWidgetAdapter.parent.call(this);

  this._addAdapterProperties(['childWidget']);
};
scout.inherits(scout.NullWidgetAdapter, scout.ModelAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.arrays = {

  /**
   * Ensures the given parameter is an array
   * @memberOf scout.arrays
   */
  ensure: function(array) {
    if (array === undefined || array === null) {
      return [];
    }
    if (!Array.isArray(array)) {
      return [array];
    }
    return array;
  },

  /**
   * Creates an array with the given length and initializes each value with the given initValue.
   */
  init: function(length, initValue) {
    var array = [];
    for (var i = 0; i < length; i++) {
      array[i] = initValue;
    }
    return array;
  },

  /**
   * Removes the first occurrence of the specified element from the array,
   * if it is present (optional operation).  If the array does not contain
   * the element, it is unchanged.
   *
   * @return true if the array contained the specified element
   */
  remove: function(arr, element) {
    if (arr) {
      var index = arr.indexOf(element);
      if (index !== -1) {
        arr.splice(index, 1);
        return true;
      }
    }
    return false;
  },

  /**
   * Removes every given element from the array
   *
   * @return true if the array contained at least one of the specified elements
   */
  removeAll: function(arr, elements) {
    var modified = false;
    if (!elements || elements.length === 0) {
      return false;
    }
    for (var i = arr.length - 1; i >= 0; i--) {
      if (elements.indexOf(arr[i]) > -1) {
        arr.splice(i, 1);
        modified = true;
      }
    }
    return modified;
  },

  /**
   * return index of replaced element
   */
  replace: function(arr, element, replacement) {
    var index = arr.indexOf(element);
    if (index !== -1) {
      arr[index] = replacement;
    }
    return index;
  },

  insert: function(arr, element, index) {
    scout.arrays.insertArray(arr, element, index);
  },

  insertArray: function(arr, elements, index) {
    elements = scout.arrays.ensure(elements);
    Array.prototype.splice.apply(arr, [index, 0].concat(elements));
  },

  move: function(arr, fromIndex, toIndex) {
    arr.splice(toIndex, 0, arr.splice(fromIndex, 1)[0]);
  },

  containsAny: function(haystack, needles) {
    haystack = this.ensure(haystack);
    needles = this.ensure(needles);
    return needles.some(function contains(element) {
      return haystack.indexOf(element) >= 0;
    });
  },

  containsAll: function(haystack, needles) {
    haystack = this.ensure(haystack);
    needles = this.ensure(needles);
    return needles.every(function contains(element) {
      return haystack.indexOf(element) >= 0;
    });
  },

  first: function(arr) {
    if (Array.isArray(arr)) {
      return arr[0];
    }
    return arr;
  },

  last: function(arr) {
    if (Array.isArray(arr)) {
      return arr[arr.length - 1];
    }
    return arr;
  },

  pushAll: function(arr, arr2) {
    arr.push.apply(arr, arr2);
  },

  /**
   * Merges the two given arrays and removes duplicate entries in O(n).
   * If the arrays contain objects instead of primitives, it uses their id to check for equality.
   */
  union: function(array1, array2) {
    var result = [],
      map = {};

    array1 = this.ensure(array1);
    array2 = this.ensure(array2);

    array1.forEach(function(entry) {
      var key = entry;
      if (typeof entry === 'object') {
        key = entry.id;
      }
      map[key] = entry;
      result.push(entry);
    });

    array2.forEach(function(entry) {
      var key = entry;
      if (typeof entry === 'object') {
        key = entry.id;
      }
      if (!(key in map)) {
        result.push(entry);
      }
    });

    return result;
  },

  equalsIgnoreOrder: function(arr, arr2) {
    if (arr === arr2) {
      return true;
    }
    if ((!arr || arr.length === 0) && (!arr2 || arr2.length === 0)) {
      return true;
    }
    if (!arr || !arr2) {
      return false;
    }
    if (arr.length !== arr2.length) {
      return false;
    }
    return scout.arrays.containsAll(arr, arr2);
  },

  equals: function(arr, arr2) {
    if (arr === arr2) {
      return true;
    }
    if ((!arr || arr.length === 0) && (!arr2 || arr2.length === 0)) {
      return true;
    }
    if (!arr || !arr2) {
      return false;
    }
    if (arr.length !== arr2.length) {
      return false;
    }

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  },

  greater: function(arr, arr2) {
    var arrLength = 0,
      arr2Length = 0;
    if (arr) {
      arrLength = arr.length;
    }
    if (arr2) {
      arr2Length = arr2.length;
    }
    return arrLength > arr2Length;
  },

  eachSibling: function(arr, element, func) {
    if (!arr || !func) {
      return;
    }
    for (var i = 0; i < arr.length; i++) {
      var elementAtI = arr[i];
      if (elementAtI !== element) {
        func(elementAtI, i);
      }
    }
  },

  /**
   * Alternative implementation of Array.findIndex(callback [, thisArg]), which is supported by most browsers.
   * See Array.findIndex for a detailed description.
   */
  findIndex: function(arr, predicate, thisArg){
    if (!arr || !predicate) {
      return -1;
    }
    for (var i = 0; i < arr.length; i++) {
      if (predicate.call(thisArg, arr[i], i, arr)) {
        return i;
      }
    }
    return -1;
  },

  find: function(arr, predicate) {
    if (!arr || !predicate) {
      return null;
    }
    for (var i = 0; i < arr.length; i++) {
      var element = arr[i];
      if (predicate(element, i)) {
        return element;
      }
    }
  },

  findFrom: function(arr, startIndex, predicate, backwards) {
    if (backwards) {
      return scout.arrays.findFromPrev(arr, startIndex, predicate);
    } else {
      return scout.arrays.findFromNext(arr, startIndex, predicate);
    }
  },

  findFromNext: function(arr, startIndex, predicate) {
    if (!arr || !predicate) {
      return null;
    }
    for (var i = startIndex; i < arr.length; i++) {
      var element = arr[i];
      if (predicate(element, i)) {
        return element;
      }
    }
  },

  findFromPrev: function(arr, startIndex, predicate) {
    if (!arr || !predicate) {
      return null;
    }
    for (var i = startIndex; i >= 0; i--) {
      var element = arr[i];
      if (predicate(element, i)) {
        return element;
      }
    }
  },

  /**
   * @param encoded defaults to false
   */
  format: function(arr, delimiter, encodeHtml) {
    if (!arr || arr.length === 0) {
      return '';
    }

    var output = '';
    for (var i = 0; i < arr.length; i++) {
      var element = arr[i];
      if (delimiter && i > 0 && i < arr.length) {
        output += delimiter;
      }
      if (encodeHtml) {
        element = scout.strings.encode(element);
      }
      output += element;
    }
    return output;
  },

  formatEncoded: function(arr, delimiter) {
    return scout.arrays.format(arr, delimiter, true);
  },

  max: function(arr) {
    return Math.max.apply(Math, arr);
  },

  min: function(arr) {
    return Math.min.apply(Math, arr);
  },

  //
  // Use these methods if you have an array of jquery objects.
  // Reason $elem1 === $elem2 does often not work because new jquery objects are created for the same html node.
  // -> Html nodes need to be compared.
  //

  $indexOf: function(arr, $element) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i][0] === $element[0]) {
        return i;
      }
    }
  },

  $remove: function(arr, $element) {
    var index = scout.arrays.$indexOf(arr, $element);
    if (index >= 0) {
      arr.splice(index, 1);
    }
  },

  /**
   * Converts an JS array of jQuery elements to a jQuery collection.
   */
  $: function(arrayOfJQueryElements) {
    return $(arrayOfJQueryElements).map(function() {
      return this[0];
    });
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Code = function() {
  this.active;
  this.id;
  this.parent;
  this.children = [];
};

scout.Code.prototype.init = function(model) {
  scout.assertParameter('id', model.id);

  this.active = model.active;
  this.id = model.id;
  this._text = model.text;
  this.modelClass = model.modelClass;

  // If model contains a text map, generate a text key and add the texts to the text maps of the session
  if (model.texts) {
    if (this._text) {
      throw new Error('Either set texts or text property, not both.');
    }
    var key = scout.codes.registerTexts(this, model.texts);
    // Convert to ${textKey:key} so that text() may resolve it
    this._text = scout.texts.buildKey(key);
  }
};

/**
 * @param vararg the language tag or the locale (object with a property languageTag) to load the text for.
 */
scout.Code.prototype.text = function(vararg) {
  var languageTag = vararg;
  if (typeof vararg === 'object') {
    languageTag = vararg.languageTag;
  }
  return scout.texts.resolveText(this._text, languageTag);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CodeType = function() {
  this.id;
  this.codes = [];
  this.codeMap = {};
};

scout.CodeType.prototype.init = function(model) {
  scout.assertParameter('id', model.id);
  this.id = model.id;
  this.modelClass = model.modelClass;

  var i, code;
  if (model.codes) {
    for (i = 0; i < model.codes.length; i++) {
      this._initCode(model.codes[i]);
    }
  }
};

scout.CodeType.prototype._initCode = function(modelCode, parent) {
  var i;
  var code;
  code = scout.create(modelCode);
  this.add(code, parent);
  if (modelCode.children) {
    for (i = 0; i < modelCode.children.length; i++) {
      this._initCode(modelCode.children[i], code);
    }
  }
};

scout.CodeType.prototype.add = function(code, parent) {
  this.codes.push(code);
  this.codeMap[code.id] = code;
  if (parent) {
    parent.children.push(code);
    code.parent = parent;
  }
};

scout.CodeType.prototype.get = function(codeId) {
  var code = this.codeMap[codeId];
  if (!code) {
    throw new Error('No code found for id=' + codeId);
  }
  return code;
};

scout.CodeType.prototype.getCodes = function(rootOnly) {
  if (rootOnly) {
    var rootCodes = [];
    for (var i = 0; i < this.codes.length; i++) {
      if (!this.codes[i].parent) {
        rootCodes.push(this.codes[i]);
      }
    }
    return rootCodes;
  } else {
    return this.codes;
  }
};

scout.CodeType.ensure = function(codeType) {
  if (!codeType) {
    return codeType;
  }
  if (codeType instanceof scout.CodeType) {
    return codeType;
  }
  return scout.create('CodeType', codeType);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.codes = {

  /**
   * This default language is used whenever a code registers its texts in scout.texts.
   */
  defaultLanguage: 'en',

  registry: {},

  bootstrap: function(url) {
    url = scout.nvl(url, 'res/codes.json');
    return $.ajaxJson(url)
      .done(this.init.bind(this));
  },

  init: function(data) {
    data = data || {};
    Object.keys(data).forEach(function(codeTypeId) {
      this.add(data[codeTypeId]);
    }, this);
  },

  /**
   * @param codes one or more codeTypes, maybe an object or an array
   */
  add: function(codeTypes) {
    codeTypes = scout.arrays.ensure(codeTypes);
    codeTypes.forEach(function(codeType) {
      codeType = scout.CodeType.ensure(codeType);
      this.registry[codeType.id] = codeType;
    }, this);
  },

  /**
   * Returns a code for the given codeId. The codeId is a string in the following format:
   *
   * "[CodeType.id] [Code.id]"
   *
   * Examples:
   * "71074 104860"
   * "MessageChannel Phone"
   *
   * CodeType.id and Code.id are separated by a space.
   * The Code.id alone is not unique, that's why the CodeType.id must be always provided.
   *
   * You can also call this function with two arguments. In that case the first argument
   * is the codeTypeId and the second is the codeId.
   */
  get: function(vararg, codeId) {
    var codeTypeId;
    if (arguments.length === 2) {
      codeTypeId = vararg;
    } else {
      var tmp = vararg.split(' ');
      if (tmp.length !== 2) {
        throw new Error('Invalid string. Must have format "[CodeType.id] [Code.id]"');
      }
      codeTypeId = tmp[0];
      codeId = tmp[1];
    }
    scout.assertParameter('codeTypeId', codeTypeId);
    scout.assertParameter('codeId', codeId);
    return this.codeType(codeTypeId).get(codeId);
  },

  codeType: function(codeTypeId, optional) {
    var codeType = this.registry[codeTypeId];
    if (!optional && !codeType) {
      throw new Error('No CodeType found for id=' + codeTypeId);
    }
    return codeType;
  },

  generateTextKey: function(code) {
    // Use __ as prefix to reduce the possibility of overriding 'real' keys
    return '__code.' + code.id;
  },

  /**
   * Registers texts for a code. It uses the method generateTextKey to generate the text key.
   * The texts for the default locale specified by scout.codes.defaultLanguage are used as default texts.
   *
   * @param code the code to register the text for
   * @param texts an object with the languageTag as key and the translated text as value
   * @return the generated text key
   */
  registerTexts: function(code, texts) {
    var key = scout.codes.generateTextKey(code);
    for (var languageTag in texts) { // NOSONAR
      var text = texts[languageTag];
      // Use defaultLanguage as default, if specified (may be changed or set to null by the app).
      if (languageTag && languageTag === this.defaultLanguage) {
        languageTag = 'default';
      }
      scout.texts.get(languageTag).add(key, text);
    }
    return key;
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.dates = {

  /**
   * @memberOf scout.dates
   */
  shift: function(date, years, months, days) {
    var newDate = new Date(date.getTime());
    if (years) {
      newDate.setFullYear(date.getFullYear() + years);
      if (scout.dates.compareMonths(newDate, date) !== years * 12) {
        // Set to last day of the previous month
        // The reason: 2016-02-29 + 1 year -> 2017-03-01 instead of 2017-02-28
        newDate.setDate(0);
      }
    }
    if (months) {
      newDate.setMonth(date.getMonth() + months);
      if (scout.dates.compareMonths(newDate, date) !== months + years * 12) {
        // Set to last day of the previous month
        // The reason: 2010-10-31 + 1 month -> 2010-12-01 instead of 2010-11-30
        newDate.setDate(0);
      }
    }
    if (days) {
      newDate.setDate(date.getDate() + days);
    }
    return newDate;
  },

  shiftTime: function(date, hours, minutes, seconds, milliseconds) {
    var newDate = new Date(date.getTime());
    if (hours) {
      newDate.setHours(date.getHours() + hours);
    }
    if (minutes) {
      newDate.setMinutes(date.getMinutes() + minutes);
    }
    if (seconds) {
      newDate.setSeconds(date.getSeconds() + seconds);
    }
    if (milliseconds) {
      newDate.setMilliseconds(date.getMilliseconds() + milliseconds);
    }
    return newDate;
  },

  shiftToNextDayOfType: function(date, day) {
    var diff = day - date.getDay();

    if (diff <= 0) {
      diff += 7;
    }
    return scout.dates.shift(date, 0, 0, diff);
  },

  shiftToPreviousDayOfType: function(date, day) {
    var diff = day - date.getDay();

    if (diff >= 0) {
      diff -= 7;
    }
    return scout.dates.shift(date, 0, 0, diff);
  },

  shiftToNextOrPrevDayOfType: function(date, day, direction) {
    if (direction > 0) {
      return scout.dates.shiftToNextDayOfType(date, day);
    } else {
      return scout.dates.shiftToPreviousDayOfType(date, day);
    }
  },

  shiftToNextOrPrevMonday: function(date, direction) {
    return scout.dates.shiftToNextOrPrevDayOfType(date, 1, direction);
  },

  /**
   * Ensures that the given date is really a date.
   * <p>
   * If it already is a date, the date will be returned.
   * Otherwise parseJsonDate is used to create a Date.
   *
   * @param date may be of type date or string.
   */
  ensure: function(date) {
    if (!date) {
      return date;
    }
    if (date instanceof Date) {
      return date;
    }
    return scout.dates.parseJsonDate(date);
  },

  ensureMonday: function(date, direction) {
    if (date.getDay() === 1) {
      return date;
    }
    return scout.dates.shiftToNextOrPrevMonday(date, direction);
  },

  isSameDay: function(date, date2) {
    if (!date || !date2) {
      return false;
    }
    return date.getFullYear() === date2.getFullYear() &&
      date.getMonth() === date2.getMonth() &&
      date.getDate() === date2.getDate();
  },

  /**
   * @return the difference of the two dates in number of months.
   */
  compareMonths: function(date1, date2) {
    var d1Month = date1.getMonth(),
      d2Month = date2.getMonth(),
      d1Year = date1.getFullYear(),
      d2Year = date2.getFullYear(),
      monthDiff = d1Month - d2Month;
    if (d1Year === d2Year) {
      return monthDiff;
    }
    return (d1Year - d2Year) * 12 + monthDiff;
  },

  /**
   * @return the difference of the two dates in number of days.
   */
  compareDays: function(date1, date2) {
    return ((scout.dates.trunc(date1) - scout.dates.trunc(date2)) - (date1.getTimezoneOffset() - date2.getTimezoneOffset()) * 60000) / (3600000 * 24);
  },

  /**
   * Returns the time (with milliseconds) for the given date as a string in the format
   * [year#4][month#2][day#2][hour#2][minute#2][second#2][#millisecond#3]. All characters
   * are guaranteed to be digits. If the date argument is omitted, the current date is
   * used. The returned string in in UTC if the argument 'utc' is true, otherwise the
   * result is in local time (default).
   */
  timestamp: function(date, utc) {
    // (note: month is 0-indexed)
    var d = date || new Date();
    if (utc) {
      return scout.strings.padZeroLeft(d.getUTCFullYear(), 4) +
        scout.strings.padZeroLeft((d.getUTCMonth() + 1), 2) +
        scout.strings.padZeroLeft(d.getUTCDate(), 2) +
        scout.strings.padZeroLeft(d.getUTCHours(), 2) +
        scout.strings.padZeroLeft(d.getUTCMinutes(), 2) +
        scout.strings.padZeroLeft(d.getUTCSeconds(), 2) +
        scout.strings.padZeroLeft(d.getUTCMilliseconds(), 3);
    }
    return scout.strings.padZeroLeft(d.getFullYear(), 4) +
      scout.strings.padZeroLeft((d.getMonth() + 1), 2) +
      scout.strings.padZeroLeft(d.getDate(), 2) +
      scout.strings.padZeroLeft(d.getHours(), 2) +
      scout.strings.padZeroLeft(d.getMinutes(), 2) +
      scout.strings.padZeroLeft(d.getSeconds(), 2) +
      scout.strings.padZeroLeft(d.getMilliseconds(), 3);
  },

  orderWeekdays: function(weekdays, firstDayOfWeek) {
    var weekdaysOrdered = [];
    for (var i = 0; i < 7; i++) {
      weekdaysOrdered[i] = weekdays[(i + firstDayOfWeek) % 7];
    }
    return weekdaysOrdered;
  },

  /**
   * Returns the week number according to ISO 8601 definition:
   * - All years have 52 or 53 weeks.
   * - The first week is the week with January 4th in it.
   * - The first day of a week is Monday, the last day is Sunday
   *
   * This is the default behavior. By setting the optional second argument 'option',
   * the first day in a week can be changed (e.g. 0 = Sunday). The returned numbers weeks are
   * not ISO 8601 compliant anymore, but can be more appropriate for display in a calendar. The
   * argument can be a number, a 'scout.Locale' or a 'scout.DateFormat' object.
   */
  weekInYear: function(date, option) {
    if (!date) {
      return undefined;
    }
    var firstDayOfWeek = 1;
    if (typeof option === 'object') {
      // scout.DateFormat
      if (option.symbols !== undefined && option.symbols.firstDayOfWeek !== undefined) {
        firstDayOfWeek = option.symbols.firstDayOfWeek;
      }
      // scout.Locale
      else if (option.decimalFormatSymbols !== undefined && option.decimalFormatSymbols.firstDayOfWeek !== undefined) {
        firstDayOfWeek = option.decimalFormatSymbols.firstDayOfWeek;
      }
    } else if (typeof option === 'number') {
      firstDayOfWeek = option;
    }

    // Thursday of current week decides the year
    var thursday = this._thursdayOfWeek(date, firstDayOfWeek);

    // In ISO format, the week with January 4th is the first week
    var jan4 = new Date(thursday.getFullYear(), 0, 4);

    // If the date is before the beginning of the year, it belongs to the year before
    var startJan4 = this._firstDayOfWeek(jan4, firstDayOfWeek);
    if (date.getTime() < startJan4.getTime()) {
      jan4 = new Date(thursday.getFullYear() - 1, 0, 4);
    }

    // Get the Thursday of the first week, to be able to compare it to 'thursday'
    var thursdayFirstWeek = this._thursdayOfWeek(jan4, firstDayOfWeek);

    var diffInDays = (thursday.getTime() - thursdayFirstWeek.getTime()) / 86400000;

    return 1 + Math.round(diffInDays / 7);
  },

  _thursdayOfWeek: function(date, firstDayOfWeek) {
    if (!date || typeof firstDayOfWeek !== 'number') {
      return undefined;
    }

    var thursday = new Date(date.valueOf());
    if (thursday.getDay() !== 4) { // 0 = Sun, 1 = Mon, 2 = Thu, 3 = Wed, 4 = Thu, 5 = Fri, 6 = Sat
      if (thursday.getDay() < firstDayOfWeek) {
        // go 1 week backward
        thursday.setDate(thursday.getDate() - 7);
      }
      thursday.setDate(thursday.getDate() - thursday.getDay() + 4); // go to start of week, then add 4 to go to Thursday
    }
    return thursday;
  },

  _firstDayOfWeek: function(date, firstDayOfWeek) {
    if (!date || typeof firstDayOfWeek !== 'number') {
      return undefined;
    }
    var firstDay = new Date(date.valueOf());
    if (firstDay.getDay() !== firstDayOfWeek) {
      firstDay.setDate(firstDay.getDate() - ((firstDay.getDay() + 7 - firstDayOfWeek) % 7));
    }
    return firstDay;
  },

  /**
   * Parses a string that corresponds to one of the canonical JSON transfer formats
   * and returns it as a JavaScript 'Date' object.
   *
   * @see JsonDate.java
   */
  parseJsonDate: function(jsonDate) {
    if (!jsonDate) {
      return null;
    }

    var year = '1970',
      month = '01',
      day = '01',
      hours = '00',
      minutes = '00',
      seconds = '00',
      milliseconds = '000',
      utc = false;

    // Date + Time
    var matches = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})\.(\d{3})(Z?)$/.exec(jsonDate);
    if (matches !== null) {
      year = matches[1];
      month = matches[2];
      day = matches[3];
      hours = matches[4];
      minutes = matches[5];
      seconds = matches[6];
      milliseconds = matches[7];
      utc = (matches[8] === 'Z');
    } else {
      // Date only
      matches = /^(\d{4})-(\d{2})-(\d{2})(Z?)$/.exec(jsonDate);
      if (matches !== null) {
        year = matches[1];
        month = matches[2];
        day = matches[3];
        utc = (matches[4] === 'Z');
      } else {
        // Time only
        matches = /^(\d{2}):(\d{2}):(\d{2})\.(\d{3})(Z?)$/.exec(jsonDate);
        if (matches !== null) {
          hours = matches[1];
          minutes = matches[2];
          seconds = matches[3];
          milliseconds = matches[4];
          utc = (matches[5] === 'Z');
        } else {
          throw new Error('Unparsable date: ' + jsonDate);
        }
      }
    }

    var result;
    if (utc) {
      // UTC date
      result = new Date(Date.UTC(year, (month - 1), day, hours, minutes, seconds, milliseconds));
      if (year < 100) { // fix "two-digit years between 1900 and 1999" logic
        result.setUTCFullYear(year);
      }
    } else {
      // local date
      result = new Date(year, (month - 1), day, hours, minutes, seconds, milliseconds);
      if (year < 100) { // fix "two-digit years between 1900 and 1999" logic
        result.setFullYear(year);
      }
    }
    return result;
  },

  /**
   * Converts the given date object to a JSON string. By default, the local time zone
   * is used to built the result, time zone information itself is not part of the
   * result. If the argument 'utc' is set to true, the result is built using the
   * UTC values of the date. Such a result string is marked with a trailing 'Z' character.
   *
   * @see JsonDate.java
   */
  toJsonDate: function(date, utc, includeDate, includeTime) {
    if (!date) {
      return null;
    }
    if (includeDate === undefined) {
      includeDate = true;
    }
    if (includeTime === undefined) {
      includeTime = true;
    }
    var datePart, timePart, utcPart;
    if (utc) {
      // (note: month is 0-indexed)
      datePart = scout.strings.padZeroLeft(date.getUTCFullYear(), 4) + '-' +
        scout.strings.padZeroLeft((date.getUTCMonth() + 1), 2) + '-' +
        scout.strings.padZeroLeft(date.getUTCDate(), 2);
      timePart = scout.strings.padZeroLeft(date.getUTCHours(), 2) + ':' +
        scout.strings.padZeroLeft(date.getUTCMinutes(), 2) + ':' +
        scout.strings.padZeroLeft(date.getUTCSeconds(), 2) + '.' +
        scout.strings.padZeroLeft(date.getUTCMilliseconds(), 3);
      utcPart = 'Z';
    } else {
      // (note: month is 0-indexed)
      datePart = scout.strings.padZeroLeft(date.getFullYear(), 4) + '-' +
        scout.strings.padZeroLeft((date.getMonth() + 1), 2) + '-' +
        scout.strings.padZeroLeft(date.getDate(), 2);
      timePart = scout.strings.padZeroLeft(date.getHours(), 2) + ':' +
        scout.strings.padZeroLeft(date.getMinutes(), 2) + ':' +
        scout.strings.padZeroLeft(date.getSeconds(), 2) + '.' +
        scout.strings.padZeroLeft(date.getMilliseconds(), 3);
      utcPart = '';
    }
    var result = '';
    if (includeDate) {
      result += datePart;
      if (includeTime) {
        result += ' ';
      }
    }
    if (includeTime) {
      result += timePart;
    }
    result += utcPart;
    return result;
  },

  toJsonDateRange: function(range) {
    return {
      from: scout.dates.toJsonDate(range.from),
      to: scout.dates.toJsonDate(range.to)
    };
  },

  /**
   * Creates a new JavaScript Date object by parsing the given string. This method is not intended to be
   * used in application code, but provides a quick way to create dates in unit tests.
   *
   * The format is as follows:
   *
   * [Year#4]-[Month#2]-[Day#2] [Hours#2]:[Minutes#2]:[Seconds#2].[Milliseconds#3][Z]
   *
   * The year component is mandatory, but all others are optional (starting from the beginning).
   * The date is constructed using the local time zone. If the last character is 'Z', then
   * the values are interpreted as UTC date.
   */
  create: function(dateString) {
    if (dateString) {
      var matches = /^(\d{4})(?:-(\d{2})(?:-(\d{2})(?: (\d{2})(?::(\d{2})(?::(\d{2})(?:\.(\d{3}))?(Z?))?)?)?)?)?/.exec(dateString);
      if (matches === null) {
        throw new Error('Unparsable date: ' + dateString);
      }
      var date;
      if (matches[8] === 'Z') {
        date = new Date(Date.UTC(
          matches[1], // fullYear
          ((matches[2] || 1) - 1), // month (0-indexed)
          (matches[3] || 1), // day of month
          (matches[4] || 0), // hours
          (matches[5] || 0), // minutes
          (matches[6] || 0), // seconds
          (matches[7] || 0) // milliseconds
        ));
      } else {
        date = new Date(
          matches[1], // fullYear
          ((matches[2] || 1) - 1), // month (0-indexed)
          (matches[3] || 1), // day of month
          (matches[4] || 0), // hours
          (matches[5] || 0), // minutes
          (matches[6] || 0), // seconds
          (matches[7] || 0) // milliseconds
        );
      }
      return date;
    }
    return undefined;
  },

  format: function(date, locale, pattern) {
    var dateFormat = new scout.DateFormat(locale, pattern);
    return dateFormat.format(date);
  },

  compare: function(a, b) {
    if (!a && !b) {
      return 0;
    }
    if (!a) {
      return -1;
    }
    if (!b) {
      return 1;
    }
    var diff = a.getTime() - b.getTime();
    if (diff < -1) {
      return -1;
    }
    if (diff > 1) {
      return 1;
    }
    return diff;
  },

  equals: function(a, b) {
    return this.compare(a, b) === 0;
  },

  /**
   * TODO [5.2] nbu: Add jasmine test
   * This combines a date and time, passed as date objects to one object with the date part of param date and the time part of param time.
   */
  combineDateTime: function(date, time) {
    var newDate = new Date(0);
    if (date) {
      newDate.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    }
    if (time) {
      newDate.setHours(scout.nvl(time.getHours(), 0));
      newDate.setMinutes(scout.nvl(time.getMinutes(), 0));
      newDate.setSeconds(scout.nvl(time.getSeconds(), 0));
      newDate.setMilliseconds(scout.nvl(time.getMilliseconds(), 0));
    }
    return newDate;
  },

  /**
   * Returns <code>true</code> if the given year is a leap year, i.e if february 29 exists in that year.
   */
  isLeapYear: function(year) {
    if (year === undefined || year === null) {
      return false;
    }
    var date = new Date(year, 1, 29);
    return (date.getDate() === 29);
  },

  /**
   * Returns the given date with time set to midnight (hours, minutes, seconds, milliseconds = 0).
   *
   * @param date (required)
   *          The date to truncate.
   * @param createCopy (optional)
   *          If this flag is true, a copy of the given date is returned (the input date is not
   *          altered). If the flag is false, the given object is changed and then returned.
   *          The default value for this flag is "true".
   */
  trunc: function(date, createCopy) {
    if (date) {
      if (scout.nvl(createCopy, true)) {
        date = new Date(date.getTime());
      }
      date.setHours(0, 0, 0, 0); // clear time
    }
    return date;
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.defaultValues = {

  /**
   * map of "objectType" -> { defaultValuesObject }
   */
  _defaults: {},

  /**
   * map of "objectType" -> [ "objectType", "parentObjectType", ..., "topLevelObjectType" ]
   */
  _objectTypeHierarchyFlat: {},

  bootstrap: function(options) {
    options = options || {};
    var defaultOptions = {
      url: 'defaultValues'
    };
    options = $.extend({}, defaultOptions, options);
    // Load default value configuration from server (and cache it)
    return $.ajaxJson(options.url)
      .done(this.init.bind(this));
  },

  init: function(data) {
    // Store defaults
    this._objectTypeHierarchyFlat = {};
    this._defaults = data.defaults || {};

    // Generate object type hierarchy
    var objectTypeHierarchy = data.objectTypeHierarchy || {};
    this._generateObjectTypeHierarchyRec(objectTypeHierarchy, undefined, this._objectTypeHierarchyFlat);

    // For all object types in the defaults that don't have a hierarchy yet, add a dummy hierarchy with one element
    Object.keys(this._defaults).forEach(function(objectType) {
      if (!this._objectTypeHierarchyFlat[objectType]) {
        this._objectTypeHierarchyFlat[objectType] = [objectType];
      }
    }, this);
  },

  _generateObjectTypeHierarchyRec: function(json, currentParentObjectTypes, targetMap) {
    if (!json) {
      return;
    }
    if (!targetMap) {
      throw new Error('Argument \'targetMap\' must not be null');
    }
    Object.keys(json).forEach(function(objectType) {
      var newCurrentParentObjectTypes = [objectType];
      if (currentParentObjectTypes) {
        newCurrentParentObjectTypes = newCurrentParentObjectTypes.concat(currentParentObjectTypes);
      }

      if (typeof json[objectType] === 'object') {
        this._generateObjectTypeHierarchyRec(json[objectType], newCurrentParentObjectTypes, targetMap);
      }

      // Store current result
      if (targetMap[objectType]) {
        throw new Error('Object type \'' + objectType + '\' has ambiguous parent object types.');
      }
      targetMap[objectType] = newCurrentParentObjectTypes;
    }, this);
  },

  /**
   * Applies the defaults for the given object type to the given object. Properties
   * are only set if they don't exist yet. The argument 'objectType' is optional
   * if the object has a property of the same name. If the object is an array,
   * the defaults are applied to each of the elements.
   */
  applyTo: function(object, objectType) {
    if (Array.isArray(object)) {
      for (var i = 0; i < object.length; i++) {
        this.applyTo(object[i], objectType);
      }
    } else if (typeof object === 'object') {
      objectType = objectType || object.objectType;
      if (objectType) {
        this._applyToInternal(object, objectType);
      }
    }
  },

  _applyToInternal: function(object, objectType) {
    var objectTypeHierarchy = this._objectTypeHierarchyFlat[objectType];
    if (!objectTypeHierarchy) {
      // Remove model variant and try again
      objectType = objectType.replace(new RegExp(scout.strings.quote(scout.ObjectFactory.MODEL_VARIANT_SEPARATOR) + '.*'), '');
      objectTypeHierarchy = this._objectTypeHierarchyFlat[objectType];
    }
    if (!objectTypeHierarchy) {
      // Unknown type, nothing to apply
      return;
    }
    for (var i = 0; i < objectTypeHierarchy.length; i++) {
      var t = objectTypeHierarchy[i];
      var defaults = this._defaults[t];
      this._extendWithDefaults(object, defaults);
    }
  },

  _extendWithDefaults: function(object, defaults) {
    if (object === undefined || defaults === undefined) {
      return;
    }
    Object.keys(defaults).forEach(function(prop) {
      // Support for "pseudo" default values: If a property name in the default values definition
      // starts with a "~" character, the defined object will _not_ be applied as a default value
      // for a non-existing property, but inner properties of that object will be applied to an
      // existing object.
      var realProp = prop;
      if (scout.strings.startsWith(prop, '~')) {
        realProp = prop.substring(1);
      }
      // If property does not exist, set the default value and return.
      if (object[realProp] === undefined) {
        object[realProp] = scout.objects.valueCopy(defaults[realProp]);
      }
      // Special case: "default objects". If the property value is an object and default
      // value is also an object, extend the property value instead of replacing it.
      else if (scout.objects.isPlainObject(object[realProp]) && scout.objects.isPlainObject(defaults[prop])) {
        this._extendWithDefaults(object[realProp], defaults[prop]);
      }
      // Special case: "array of default objects": If the property value is an array of objects and
      // the default value is an object, extend each object in the array with the default value.
      else if (Array.isArray(object[realProp]) && scout.objects.isPlainObject(defaults[prop])) {
        var objectArray = object[realProp];
        for (var i = 0; i < objectArray.length; i++) {
          if (scout.objects.isPlainObject(objectArray[i])) {
            this._extendWithDefaults(objectArray[i], defaults[prop]);
          }
        }
      }
    }, this);
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * When jquery's detach is used, not everything is restored when attaching the element again (using append or similar methods).
 * ScrollTop and ScrollLeft are such examples.
 * This detach helper provides methods to store and restore such data.
 */
scout.DetachHelper = function(session) {
  this.session = session;
  this._defaultOptions = {
    storeScrollPositions: true,
    storeTooltips: true,
    storeFocus: true
  };
};

scout.DetachHelper.prototype.beforeDetach = function($container, options) {
  options = $.extend(this._defaultOptions, options || {});
  if (options.storeScrollPositions) {
    this._storeScrollPositions($container);
  }
  if (options.storeTooltips) {
    this._storeTooltips($container);
  }

  this._storeFocusAndFocusContext($container, options);
};

scout.DetachHelper.prototype.afterAttach = function($container) {
  this._restoreScrollPositions($container);
  this._restoreTooltips($container);
  this._restoreFocusAndFocusContext($container);
};

/**
 * Stores the position of all scrollables that belong to this session.
 */
scout.DetachHelper.prototype._storeScrollPositions = function($container) {
  scout.scrollbars.storeScrollPositions($container, this.session);
};

/**
 * Restores the position of all scrollables that belong to this session.
 */
scout.DetachHelper.prototype._restoreScrollPositions = function($container) {
  scout.scrollbars.restoreScrollPositions($container, this.session);
};

scout.DetachHelper.prototype._storeTooltips = function($container) {
  var tooltips = scout.tooltips.find($container),
    tooltipDestroyHandler, tooltipRenderHandler;
  tooltipDestroyHandler = function(event) {
    // If tooltip will be destroyed, remove it from the list so that restore won't try to render it
    scout.arrays.remove(tooltips, event.source);
    event.source.off('render', tooltipRenderHandler);
  };
  tooltipRenderHandler = function(event) {
    // If tooltip will be rendered, destroy listener is obsolete
    event.source.off('destroy', tooltipDestroyHandler);
  };
  tooltips.forEach(function(tooltip) {
    if (!tooltip.rendered) {
      return;
    }
    tooltip.remove();
    tooltip.one('render', tooltipRenderHandler);
    tooltip.one('destroy', tooltipDestroyHandler);
  });
  $container.data('tooltips', tooltips);
};

scout.DetachHelper.prototype._restoreTooltips = function($container) {
  var tooltips = $container.data('tooltips');
  if (!tooltips) {
    return;
  }
  tooltips.forEach(function(tooltip) {
    tooltip.render(tooltip.$parent);
  });
  $container.data('tooltips', null);
};

scout.DetachHelper.prototype._storeFocusAndFocusContext = function($container, options) {
  // Get the currently focused element, which is either the given $container, or one of its children. (debugging hint: ':focus' does not work if debugging with breakpoints).
  var focusedElement = ($container.is(':focus') ? $container : $container.find(':focus'))[0];

  if (options.storeFocus) {
    if (focusedElement) {
      $container.data('focus', focusedElement);
    } else {
      $container.removeData('focus');
    }
  }

  if (this.session.focusManager.isFocusContextInstalled($container)) {
    this.session.focusManager.uninstallFocusContext($container);
    $container.data('focusContext', true);
  } else {
    $container.removeData('focusContext');

    if (focusedElement) {
      // Currently, the focus is on an element which is about to be detached. Hence, it must be set onto another control, which will not removed. Otherwise, the HTML body would be focused, because the currently focused element is removed from the DOM.
      // JQuery implementation detail: the detach operation does not trigger a 'remove' event.
      this.session.focusManager.validateFocus(scout.filters.outsideFilter($container)); // exclude the container or any of its child elements to gain focus.
    }
  }
};

scout.DetachHelper.prototype._restoreFocusAndFocusContext = function($container) {
  var focusedElement = $container.data('focus');
  var focusContext = $container.data('focusContext');

  if (focusContext) {
    this.session.focusManager.installFocusContext($container, focusedElement || scout.focusRule.AUTO);
  } else if (focusedElement) {
    this.session.focusManager.requestFocus(focusedElement);
  } else {
    this.session.focusManager.validateFocus();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/* global FastClick */

/**
 * Provides information about the device and its supported features.<p>
 * The informations are detected lazily.
 *
 * @singleton
 */
scout.Device = function(userAgent) {
  this.userAgent = userAgent;
  this.features = {};
  this.system = scout.Device.System.UNKNOWN;
  this.type = scout.Device.Type.DESKTOP;
  this.browser = scout.Device.Browser.UNKNOWN;
  this.browserVersion = 0;
  this.scrollbarWidth;

  // --- device specific configuration
  // initialize with empty string so that it can be used without calling initUnselectableAttribute()
  // this property is used with regular JQuery attr(key, value) Syntax and in cases where we create
  // DOM elements by creating a string.
  this.unselectableAttribute = scout.Device.DEFAULT_UNSELECTABLE_ATTRIBUTE;
  this.tableAdditionalDivRequired = false;

  if (userAgent) {
    this._parseSystem(userAgent);
    this._parseSystemVersion(userAgent);
    this._parseBrowser(userAgent);
    this._parseBrowserVersion(userAgent);
  }
};

scout.Device.DEFAULT_UNSELECTABLE_ATTRIBUTE = {
  key: null,
  value: null,
  string: ''
};

scout.Device.vendorPrefixes = ['Webkit', 'Moz', 'O', 'ms', 'Khtml'];

scout.Device.Browser = {
  UNKNOWN: 'Unknown',
  FIREFOX: 'Firefox',
  CHROME: 'Chrome',
  INTERNET_EXPLORER: 'InternetExplorer',
  EDGE: 'Edge',
  SAFARI: 'Safari'
};

scout.Device.System = {
  UNKNOWN: 'Unknown',
  IOS: 'IOS',
  ANDROID: 'ANDROID'
};

scout.Device.Type = {
  DESKTOP: 'DESKTOP',
  TABLET: 'TABLET',
  MOBILE: 'MOBILE'
};

/**
 * Called during bootstrap by index.html before the session startup.<p>
 * Precalculates the value of some attributes to store them
 * in a static way (and prevent many repeating function calls within loops).<p>
 * Also loads device specific scripts (e.g. fast click for ios devices)
 */
scout.Device.prototype.bootstrap = function() {
  var promises = [];

  // Precalculate value and store in a simple property, to prevent many function calls inside loops (e.g. when generating table rows)
  this.unselectableAttribute = this.getUnselectableAttribute();
  this.tableAdditionalDivRequired = this.isTableAdditionalDivRequired();
  this.scrollbarWidth = this._detectScrollbarWidth();
  this.type = this._detectType(this.userAgent);

  if (this._needsFastClick()) {
    // We use Fastclick to prevent the 300ms delay when touching an element.
    promises.push(this._loadFastClickDeferred());
  } else if (this.isIos()){
    this._installActiveHandler();
  }

  if (this.hasOnScreenKeyboard()) {
    promises.push(this._loadJQueryMobileDeferred());
  }
  return promises;
};

/**
 * The 300ms delay exists because the browser does not know whether the user wants to just tab or wants to zoom using double tab.
 * Therefore most browsers add the delay only if zoom is enabled. This works for firefox, chrome (>=32) and safari/ios (>=9.3).
 * It does not work if safari is opened in standalone/homescreen mode. For IE (and safari since ios 9.3) it can be disabled using a css property called touch-action.
 *
 * By default, zooming is disabled and home screen mode is enabled, see meta tags viewport and apple-mobile-web-app-capable in head.html
 */
scout.Device.prototype._needsFastClick = function() {
  if (!this.isIos()) {
    // Currently only IOS still has the issue -> don't load the script for other systems and browsers
    return false;
  }

  if (this.systemVersion >= 9.3 && !this.isStandalone()) {
    // With Safari >= 9.3 the delay is gone if zooming is disabled, but not for the home screen / web app mode.
    return false;
  }

  // -> load only for older IOS devices or if standalone mode is enabled
  return true;
};

scout.Device.prototype._loadFastClickDeferred = function() {
  return this._loadScriptDeferred('res/fastclick-1.0.6.js', function() {
    FastClick.attach(document.body);
    $.log.info('FastClick script loaded and attached');
  });
};

scout.Device.prototype._loadJQueryMobileDeferred = function() {
  return this._loadScriptDeferred('res/jquery.mobile.custom-1.4.5.js', function() {
    $.log.info('JQuery Mobile script loaded');
  });
};

scout.Device.prototype._loadScriptDeferred = function(scriptUrl, doneFunc) {
  return $
    .injectScript(scriptUrl)
    .done(doneFunc);
};

/**
 * IOs does only trigger :active when touching an element if a touchstart listener is attached
 * Unfortunately, the :active is also triggered when scrolling, there is no delay.
 * To fix this we would have to work with a custom active class which will be toggled on touchstart/end
 */
scout.Device.prototype._installActiveHandler = function() {
  document.addEventListener('touchstart', function() {}, false);
};

scout.Device.prototype.hasOnScreenKeyboard = function() {
  return this.supportsFeature('_onScreenKeyboard', function() {
    return this.isIos() || this.isAndroid() || this.isWindowsTablet();
  }.bind(this));
};

/**
 * Safari shows a tooltip if ellipsis are displayed due to text truncation. This is fine but, unfortunately, it cannot be prevented.
 * Because showing two tooltips at the same time (native and custom) is bad, the custom tooltip cannot be displayed.
 * @returns {Boolean}
 */
scout.Device.prototype.isCustomEllipsisTooltipPossible = function() {
  return this.browser !== scout.Device.Browser.SAFARI;
};

scout.Device.prototype.isIos = function() {
  return scout.Device.System.IOS === this.system;
};

scout.Device.prototype.isAndroid = function() {
  return scout.Device.System.ANDROID === this.system;
};

/**
 * The best way we have to detect a Microsoft Surface Tablet in table mode is to check if
 * the scrollbar width is 0 pixel. In desktop mode the scrollbar width is > 0 pixel.
 */
scout.Device.prototype.isWindowsTablet = function() {
  return scout.Device.Browser.EDGE === this.browser && this.scrollbarWidth === 0;
};

/**
 * @returns true if navigator.standalone is true which is the case for iOS home screen mode
 */
scout.Device.prototype.isStandalone = function() {
  return !!window.navigator.standalone;
};

/**
 * This method returns false for very old browsers. Basically we check for the first version
 * that supports ECMAScript 5. This methods excludes all browsers that are known to be
 * unsupported, all others (e.g. unknown engines) are allowed by default.
 */
scout.Device.prototype.isSupportedBrowser = function(browser, version) {
  browser = scout.nvl(browser, this.browser);
  version = scout.nvl(version, this.browserVersion);
  var browsers = scout.Device.Browser;
  if ((browser === browsers.INTERNET_EXPLORER && version < 9) ||
    (browser === browsers.CHROME && version < 23) ||
    (browser === browsers.FIREFOX && version < 21) ||
    (browser === browsers.SAFARI && version < 7)) {
    return false;
  }
  return true;
};

/**
 * Can not detect type until DOM is ready because we must create a DIV to measure the scrollbars.
 */
scout.Device.prototype._detectType = function(userAgent) {
  if (scout.Device.System.ANDROID === this.system) {
    if (userAgent.indexOf('Mobile') > -1) {
      return scout.Device.Type.MOBILE;
    } else {
      return scout.Device.Type.TABLET;
    }
  } else if (scout.Device.System.IOS === this.system) {
    if (userAgent.indexOf('iPad') > -1) {
      return scout.Device.Type.TABLET;
    } else {
      return scout.Device.Type.MOBILE;
    }
  } else if (this.isWindowsTablet()) {
    return scout.Device.Type.TABLET;
  }
  return scout.Device.Type.DESKTOP;
};

scout.Device.prototype._parseSystem = function(userAgent) {
  if (userAgent.indexOf('iPhone') > -1 || userAgent.indexOf('iPad') > -1) {
    this.system = scout.Device.System.IOS;
  } else if (userAgent.indexOf('Android') > -1) {
    this.system = scout.Device.System.ANDROID;
  }
};

/**
 * Currently only supports IOS
 */
scout.Device.prototype._parseSystemVersion = function(userAgent) {
  var versionRegex,
    System = scout.Device.System;
  if (this.system === System.IOS) {
    versionRegex = / OS ([0-9]+\.?[0-9]*)/;
    // replace all _ with .
    userAgent = userAgent.replace(/_/g, '.');
  }
  if (versionRegex) {
    this.systemVersion = this._parseVersion(userAgent, versionRegex);
  }
};

scout.Device.prototype._parseBrowser = function(userAgent) {
  if (userAgent.indexOf('Firefox') > -1) {
    this.browser = scout.Device.Browser.FIREFOX;
  } else if (userAgent.indexOf('MSIE') > -1 || userAgent.indexOf('Trident') > -1) {
    this.browser = scout.Device.Browser.INTERNET_EXPLORER;
  } else if (userAgent.indexOf('Edge') > -1) {
    // must check for Edge before we do other checks, because the Edge user-agent string
    // also contains matches for Chrome and Webkit.
    this.browser = scout.Device.Browser.EDGE;
  } else if (userAgent.indexOf('Chrome') > -1) {
    this.browser = scout.Device.Browser.CHROME;
  } else if (userAgent.indexOf('Safari') > -1) {
    this.browser = scout.Device.Browser.SAFARI;
  }
};

/**
 * Version regex only matches the first number pair
 * but not the revision-version. Example:
 * - 21     match: 21
 * - 21.1   match: 21.1
 * - 21.1.3 match: 21.1
 */
scout.Device.prototype._parseBrowserVersion = function(userAgent) {
  var versionRegex, browsers = scout.Device.Browser;
  if (this.browser === browsers.INTERNET_EXPLORER) {
    // with internet explorer 11 user agent string does not contain the 'MSIE' string anymore
    // additionally in new version the version-number after Trident/ is not the browser-version
    // but the engine-version.
    if (userAgent.indexOf('MSIE') > -1) {
      versionRegex = /MSIE ([0-9]+\.?[0-9]*)/;
    } else {
      versionRegex = /rv:([0-9]+\.?[0-9]*)/;
    }
  } else if (this.browser === browsers.EDGE) {
    versionRegex = /Edge\/([0-9]+\.?[0-9]*)/;
  } else if (this.browser === browsers.SAFARI) {
    versionRegex = /Version\/([0-9]+\.?[0-9]*)/;
  } else if (this.browser === browsers.FIREFOX) {
    versionRegex = /Firefox\/([0-9]+\.?[0-9]*)/;
  } else if (this.browser === browsers.CHROME) {
    versionRegex = /Chrome\/([0-9]+\.?[0-9]*)/;
  }
  if (versionRegex) {
    this.browserVersion = this._parseVersion(userAgent, versionRegex);
  }
};

scout.Device.prototype._parseVersion = function(userAgent, versionRegex) {
  var matches = versionRegex.exec(userAgent);
  if (Array.isArray(matches) && matches.length === 2) {
    return parseFloat(matches[1]);
  }
};

scout.Device.prototype.supportsFeature = function(property, checkFunc) {
  if (this.features[property] === undefined) {
    this.features[property] = checkFunc(property);
  }
  return this.features[property];
};

/**
 * Currently this method should be used when you want to check if the device is "touch only" -
 * which means the user has no keyboard or mouse. Some hybrids like Surface tablets in desktop mode are
 * still touch devices, but support keyboard and mouse at the same time. In such cases this method will
 * return false, since the device is not touch only.
 *
 * Currently this method returns the same as hasOnScreenKeyboard(). Maybe the implementation here will be
 * different in the future.
 */
scout.Device.prototype.supportsTouch = function() {
  return this.supportsFeature('_touch', this.hasOnScreenKeyboard.bind(this));
};

scout.Device.prototype.supportsFile = function() {
  return (window.File ? true : false);
};

scout.Device.prototype.supportsCssAnimation = function() {
  return this.supportsCssProperty('animation');
};

/**
 * Used to determine if browser supports full history API.
 * Note that IE9 only partially supports the API, pushState and replaceState functions are missing.
 * @see: https://developer.mozilla.org/de/docs/Web/API/Window/history
 */
scout.Device.prototype.supportsHistoryApi = function() {
  return !!(window.history && window.history.pushState);
};

scout.Device.prototype.supportsCssGradient = function() {
  var testValue = 'linear-gradient(to left, #000 0%, #000 50%, transparent 50%, transparent 100% )';
  return this.supportsFeature('gradient', this.checkCssValue.bind(this, 'backgroundImage', testValue, function(actualValue) {
    return (actualValue + '').indexOf('gradient') > 0;
  }));
};

scout.Device.prototype.supportsCssUserSelect = function() {
  return this.supportsCssProperty('userSelect');
};

scout.Device.prototype.supportsInternationalization = function() {
  return window.Intl && typeof window.Intl === 'object';
};

/**
 * Returns true if the device supports the download of resources in the same window as the single page app is running.
 * With "download" we mean: change <code>window.location.href</code> to the URL of the resource to download. Some browsers don't
 * support this behavior and require the resource to be opened in a new window with <code>window.open</code>.
 */
scout.Device.prototype.supportsDownloadInSameWindow = function() {
  return scout.Device.Browser.FIREFOX !== this.browser;
};

scout.Device.prototype.hasPrettyScrollbars = function() {
  return this.supportsFeature('_prettyScrollbars', function check(property) {
    return this.scrollbarWidth === 0;
  }.bind(this));
};

scout.Device.prototype.supportsCopyFromDisabledInputFields = function() {
  return scout.Device.Browser.FIREFOX !== this.browser;
};

scout.Device.prototype.supportsFocusEmptyBeforeDiv = function() {
  // preventing blur is bad for touch devices because it prevents that the keyboard can close -> return true for touch devices
  // TODO [6.1] cgu we should look for a better solution which doesn't require preventDefault -> Maybe create separate divs instead of :before for checkbox and radiobuttons
  return scout.Device.Browser.FIREFOX !== this.browser || this.supportsTouch();
};

scout.Device.prototype.supportsCssProperty = function(property) {
  return this.supportsFeature(property, function check(property) {
    if (document.body.style[property] !== undefined) {
      return true;
    }

    property = property.charAt(0).toUpperCase() + property.slice(1);
    for (var i = 0; i < scout.Device.vendorPrefixes.length; i++) {
      if (document.body.style[scout.Device.vendorPrefixes[i] + property] !== undefined) {
        return true;
      }
    }
    return false;
  });
};

scout.Device.prototype.supportsGeolocation = function() {
  if (navigator.geolocation) {
    return true;
  }
  return false;
};

scout.Device.prototype.checkCssValue = function(property, value, checkFunc) {
  // Check if property is supported at all, otherwise div.style[property] would just add it and checkFunc would always return true
  if (document.body.style[property] === undefined) {
    return false;
  }
  var div = document.createElement('div');
  div.style[property] = value;
  if (checkFunc(div.style[property])) {
    return true;
  }

  property = property.charAt(0).toUpperCase() + property.slice(1);
  for (var i = 0; i < scout.Device.vendorPrefixes.length; i++) {
    var vendorProperty = scout.Device.vendorPrefixes[i] + property;
    if (document.body.style[vendorProperty] !== undefined) {
      div.style[vendorProperty] = value;
      if (checkFunc(div.style[vendorProperty])) {
        return true;
      }
    }
  }
  return false;
};

/**
 * Returns '' for modern browsers, that support the 'user-select' CSS property.
 * Returns ' unselectable="on"' for IE9.
 * This string can be used to add to any HTML element as attribute.
 */
scout.Device.prototype.getUnselectableAttribute = function() {
  return this.supportsFeature('_unselectableAttribute', function(property) {
    if (this.supportsCssUserSelect()) {
      return scout.Device.DEFAULT_UNSELECTABLE_ATTRIBUTE;
    }
    // required for IE 9
    return {
      key: 'unselectable',
      value: 'on',
      string: ' unselectable="on"'
    };
  }.bind(this));
};

/**
 * Returns false for modern browsers, that support CSS table-cell properties restricted
 * with a max-width and hidden overflow. Returns true if an additional div level is required.
 */
scout.Device.prototype.isTableAdditionalDivRequired = function() {
  return this.supportsFeature('_tableAdditionalDivRequired', function(property) {
    var $test = $('body')
      .appendDiv()
      .text('Scout')
      .css('visibility', 'hidden')
      .css('display', 'table-cell')
      .css('max-width', '1px')
      .css('overflow', 'hidden');
    var result = $test.width() > 1;
    $test.remove();
    return result;
  }.bind(this));
};

scout.Device.prototype.requiresIframeSecurityAttribute = function() {
  return this.supportsFeature('_requiresIframeSecurityAttribute', function(property) {
    var test = document.createElement('iframe');
    var supportsSandbox = ('sandbox' in test);

    if (supportsSandbox) {
      return false;
    } else {
      return ('security' in test);
    }
  }.bind(this));
};

scout.Device.prototype._detectScrollbarWidth = function(userAgent) {
  var $measure = $('body')
    .appendDiv()
    .attr('id', 'MeasureScrollbar')
    .css('width', 50)
    .css('height', 50)
    .css('overflow-y', 'scroll'),
    measureElement = $measure[0];
  var scrollbarWidth = measureElement.offsetWidth - measureElement.clientWidth;
  $measure.remove();
  return scrollbarWidth;
};

scout.Device.prototype.toString = function() {
  return 'scout.Device[' +
    'system=' + this.system +
    ' browser=' + this.browser +
    ' browserVersion=' + this.browserVersion +
    ' type=' + this.type +
    ' scrollbarWidth=' + this.scrollbarWidth +
    ' features=' + JSON.stringify(this.features) + ']';
};

scout.device = new scout.Device(navigator.userAgent);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Simple helper to determine if two consecutive 'mousedown' events should be considered as a double click.
 *
 * How to use:
 * 1. Feed all mousedown events to the mousedown() method.
 * 2. The method doubleClicked() returns true if the two last added events happened so fast after
 *    each other that hey should be considered a 'double click'. If the distance or interval between
 *    the last two events is too large, false is returned.
 *
 * Options:
 * [maxDoubleClickInterval, default=500]
 *   Maximum time in milliseconds between two consecutive mousedown events to consider as a double
 *   click event. If the interval is larger than this value, doubleClicked() will return false.
 * [maxDoubleClickDistance, default=10]
 *   Maximum distance (in both directions) between two consecutive mousedown events to consider as
 *   a double click event. If the distance is larger than this value, doubleClicked() will return false.
 */
scout.DoubleClickSupport = function(options) {
  options = options || {};

  this._lastPosX;
  this._lastPosY;
  this._lastTimestamp;

  this._maxDoubleClickInterval = options.maxDoubleClickInterval || 500; // ms
  this._maxDoubleClickDistance = options.maxDoubleClickDistance || 10; // px
  this._doubleClicked = false;
};

scout.DoubleClickSupport.prototype.mousedown = function(event) {
  if (event && event.type === 'mousedown') {
    var posX = scout.nvl(event.pageX, 0);
    var posY = scout.nvl(event.pageY, 0);
    var timestamp = Date.now();
    var isDoubleClick = false;
    if (this._lastTimestamp !== undefined) {
      var interval = timestamp - this._lastTimestamp;
      if (interval <= this._maxDoubleClickInterval) {
        var distance = Math.max(Math.abs(posX - this._lastPosX), Math.abs(posY - this._lastPosY));
        if (distance <= this._maxDoubleClickDistance) {
          // Double click detected
          isDoubleClick = true;
        }
      }
    }
    this._lastPosX = posX;
    this._lastPosY = posY;
    this._lastTimestamp = timestamp;
    this._doubleClicked = isDoubleClick;
  }
};

scout.DoubleClickSupport.prototype.doubleClicked = function() {
  return this._doubleClicked;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.dragAndDrop = {

  SCOUT_TYPES: {
    FILE_TRANSFER: 1 << 0, // IDNDSupport.TYPE_FILE_TRANSFER (NOSONAR)
    JAVA_ELEMENT_TRANSFER: 1 << 1, // IDNDSupport.TYPE_JAVA_ELEMENT_TRANSFER (NOSONAR)
    TEXT_TRANSFER: 1 << 2, // IDNDSupport.TYPE_TEXT_TRANSFER (NOSONAR)
    IMAGE_TRANSFER: 1 << 3 // IDNDSupport.TYPE_IMAGE_TRANSFER (NOSONAR)
  },

  /**
   * Mapping function from scout drag types to browser drag types.
   *
   * @param scoutTypesArray array of scout.dragAndDrop.SCOUT_TYPES
   * @returns {Array} return array
   */
  scoutTypeToDragTypeMapping: function(scoutTypesArray) {
    scoutTypesArray = scout.arrays.ensure(scoutTypesArray);
    var ret = [];
    if (scoutTypesArray.indexOf(this.SCOUT_TYPES.FILE_TRANSFER) >= 0) {
      ret.push('Files');
    }
    return ret;
  },

  /**
   * Check if specific scout type is supported by dataTransfer, if event is not handled by this field (desktop might handle it)
   *
   * @param event including event.originalEvent.dataTransfer
   * @param fieldAllowedTypes allowed types on field (integer, bitwise comparision used)
   * @param scoutTypeArray e.g. scout.dragAndDrop.FILE_TRANSFER
   */
  verifyDataTransferTypesScoutTypes: function(event, scoutTypeArray, fieldAllowedTypes) {
    scoutTypeArray = scout.arrays.ensure(scoutTypeArray);
    var dragTypeArray = [];

    // check if any scout type is allowed for field allowed types (or no field allowed types defined)
    if (fieldAllowedTypes !== undefined) {
      scoutTypeArray.forEach(function fieldAllowedTypesContainsElement(scoutType) {
        if (fieldAllowedTypes & scoutType === scoutType) { // NOSONAR
          scout.arrays.pushAll(dragTypeArray, this.scoutTypeToDragTypeMapping(scoutTypeArray));
        }
      }.bind(this));
    } else {
      dragTypeArray = this.scoutTypeToDragTypeMapping(scoutTypeArray);
    }

    if (Array.isArray(dragTypeArray) && dragTypeArray.length > 0) {
      this.verifyDataTransferTypes(event, dragTypeArray);
    }
  },

  /**
   * Check if specific type is supported by dataTransfer, if event is not handled by this field (upstream field might handle it, at the latest desktop)
   *
   * @param dataTransfer dataTransfer object (not dataTransfer.types)
   * @param needleArray e.g. 'Files'
   */
  verifyDataTransferTypes: function(event, needleArray) {
    var dataTransfer = event.originalEvent.dataTransfer;

    if (this.dataTransferTypesContains(dataTransfer, needleArray)) {
      event.stopPropagation();
      event.preventDefault();
      return true;
    }
    return false;
  },

  /**
   * dataTransfer.types might be an array (Chrome, IE) or a DOMStringList.
   *
   * Unfortunately there is no intersecting contains method for both types.
   *
   * @param dataTransfer dataTransfer object (not dataTransfer.types)
   * @param scoutTypesArray e.g. scout.dragAndDrop.FILE_TRANSFER
   */
  dataTransferTypesContainsScoutTypes: function(dataTransfer, scoutTypesArray) {
    scoutTypesArray = scout.arrays.ensure(scoutTypesArray);
    var dragTypesArray = scout.dragAndDrop.scoutTypeToDragTypeMapping(scoutTypesArray);
    return this.dataTransferTypesContains(dataTransfer, dragTypesArray);
  },

  /**
   * dataTransfer.types might be an array (Chrome, IE) or a DOMStringList.
   *
   * Unfortunately there is no intersecting contains method for both types.
   *
   * @param dataTransfer dataTransfer object (not dataTransfer.types)
   * @param needleArray e.g. 'Files'
   */
  dataTransferTypesContains: function(dataTransfer, needleArray) {
    needleArray = scout.arrays.ensure(needleArray);
    if (dataTransfer && dataTransfer.types) {
      if (Array.isArray(dataTransfer.types) && scout.arrays.containsAny(dataTransfer.types, needleArray)) {
        // Array: indexOf function
        return true;
      } else if (dataTransfer.types.contains) {
        // DOMStringList: contains function
        return needleArray.some(function containsElement(element) {
          return dataTransfer.types.contains(element);
        });
      }
    }
    return false;
  },

  handler: function(target, options) {
    options = options || {};
    options.target = target;
    return new scout.DragAndDropHandler(options);
  }
};

scout.DragAndDropHandler = function(options) {
  options = options || {};
  $.extend(this, options);
  this.supportedScoutTypes = scout.arrays.ensure(options.supportedScoutTypes);

  this._onDragEnterHandler = this._onDragEnter.bind(this);
  this._onDragOverHandler = this._onDragOver.bind(this);
  this._onDropHandler = this._onDrop.bind(this);
};

scout.DragAndDropHandler.prototype.install = function($element, selector) {
  if (this.$element) {
    throw new Error('Already installed.');
  }
  this.selector = selector;
  this.$element = $element;
  this.$element.on('dragenter', this.selector, this._onDragEnterHandler)
    .on('dragover', this.selector, this._onDragOverHandler)
    .on('drop', this.selector, this._onDropHandler);
};

scout.DragAndDropHandler.prototype.uninstall = function() {
  this.$element.off('dragenter', this.selector, this._onDragEnterHandler)
    .off('dragover', this.selector, this._onDragOverHandler)
    .off('drop', this.selector, this._onDropHandler);
  this.$element = null;
  this.selector = null;
};

scout.DragAndDropHandler.prototype._onDragEnter = function(event) {
  this._onDragEnterOrOver(event);
};

scout.DragAndDropHandler.prototype._onDragOver = function(event) {
  this._onDragEnterOrOver(event);
};

scout.DragAndDropHandler.prototype._onDragEnterOrOver = function(event) {
  scout.dragAndDrop.verifyDataTransferTypesScoutTypes(event, this.supportedScoutTypes, this.dropType());
};

scout.DragAndDropHandler.prototype._onDrop = function(event) {
  if (this.supportedScoutTypes.indexOf(scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER) >= 0 &&
    this.dropType() & scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER === scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER && // NOSONAR
    scout.dragAndDrop.dataTransferTypesContainsScoutTypes(event.originalEvent.dataTransfer, scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER)) {
    event.stopPropagation();
    event.preventDefault();

    var files = event.originalEvent.dataTransfer.files;
    if (files.length >= 1) {
      this.target.session.uploadFiles(this.target, files,
        this.additionalDropProperties ? this.additionalDropProperties(event) : undefined,
        this.dropMaximumSize ? this.dropMaximumSize() : undefined,
        this.allowedTypes ? this.allowedTypes() : undefined);
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.EventSupport = function() {
  this._eventListeners = [];
};

scout.EventSupport.prototype._assertFunc = function(func) {
  if (!func) {
    throw new Error('Missing callback function');
  }
};

/**
 * Registers the given func for the event specified by the type param.
 *
 * @param type event-name
 * @param func callback function executed when event is triggered. An event object is passed to the func as first parameter
 * @param origFunc (optional) used internally when func is registered with one(). The property is set on the listener
 *   object so the event-handler can be de-registered by using the original function.
 */
scout.EventSupport.prototype.on = function(type, func, origFunc) {
  this._assertFunc(func);
  var listener = {
    type: type,
    func: func,
    origFunc: origFunc
  };
  this.addListener(listener);
  return listener;
};

/**
 * Registers the given func for the event specified by the type param.
 * The event is only triggered one time, and after that it is automatically de-registered by calling the off() function.
 *
 * @param type event-name
 * @param func callback function executed when event is triggered. An event object is passed to the func as first parameter
 */
scout.EventSupport.prototype.one = function(type, func) {
  this._assertFunc(func);
  var that = this,
    offFunc = function(event) {
      that.off(type, offFunc);
      func(event);
    }.bind(this);
  return this.on(type, offFunc, func);
};

scout.EventSupport.prototype.off = function(type, func) {
  if (!type && !func) {
    return;
  }

  for (var i = this._eventListeners.length - 1; i >= 0; i--) {
    var listener = this._eventListeners[i];
    var funcMatches = (func === listener.func || func === listener.origFunc);
    var typeMatches = (type === listener.type);
    var remove = false;
    if (func && type) {
      remove = (funcMatches && typeMatches);
    } else if (func) {
      remove = funcMatches;
    } else { // always type. all other cases have been checked above
      remove = typeMatches;
    }

    if (remove) {
      this._eventListeners.splice(i, 1);
    }
  }
};

scout.EventSupport.prototype.addListener = function(listener) {
  this._eventListeners.push(listener);
};

scout.EventSupport.prototype.removeListener = function(listener) {
  scout.arrays.remove(this._eventListeners, listener);
};

scout.EventSupport.prototype.count = function(type) {
  var count = 0;
  this._eventListeners.forEach(function(listener) {
    if (type && type !== listener.type) {
      return;
    }
    count++;
  });
  return count;
};

scout.EventSupport.prototype.trigger = function(type, event) {
  event = event || {};
  event.type = type;

  var i, listener, listeners = this._eventListeners.slice();
  for (i = 0; i < listeners.length; i++) {
    listener = listeners[i];
    if (!listener.type || typeMatches(event.type, listener.type)) {
      listener.func(event);
    }
  }

  // ---- Helper functions -----

  function typeMatches(eventType, listenerType) {
    var i, types = listenerType.split(' ');
    if (types.length === 1) {
      return eventType === listenerType;
    }
    // support for multi type definition 'type1 type2 [...]'
    for (i = 0; i < types.length; i++) {
      if (eventType === types[i]) {
        return true;
      }
    }
    return false;
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.fonts = {

  _deferred: $.Deferred(),

  /**
   * Indicates whether all fonts have been loaded successfully. Check this variable before
   * waiting for the promise object returned by preloader().
   */
  loadingComplete: true,

  /**
   * Start preloading the specified fonts.
   * @param fonts (optional) array of fonts
   */
  bootstrap: function(fonts) {
    if (!fonts || fonts.length === 0) {
      return;
    }

    // Start preloading
    this.loadingComplete = false;
    this.preload({
      fonts: fonts,
      onComplete: function(success) {
        this.loadingComplete = true;
        this._deferred.resolve();
      }.bind(this)
    });
  },

  /**
   * @return  a promise object that is notified when the font preloading was completed.
   *          Important: Before waiting for this promise, always check that value of
   *          this.loadingComplete first! Do not wait for the promise when loadingComplete
   *          is true, because the promise will never be resolved.
   */
  preloader: function() {
    return this._deferred.promise();
  },

  /**
   * Loads the specified fonts in a hidden div, forcing the browser to load them.
   *
   * Options:
   *   [fonts]
   *     A single string or object (or an array of them) specifying which fonts should
   *     be preloaded. A string is interpreted as font-family. If the style is relevant,
   *     too, an object with the properties 'font-family' and 'style' should be provided.
   *     Alternatively, the style can be specified in the string after the font name,
   *     separated by a pipe character ('|').
   *   [onComplete]
   *     Mandatory function to be called when all of the specified fonts have been
   *     loaded or if a timeout occurs. An argument 'success' is given to indicate
   *     whether loading was completed successfully or execution was interrupted by
   *     a timeout. If this option is omitted, the call to this method returns immediately.
   *   [timeout]
   *     Optional timeout in milliseconds. If fonts could not be loaded within this time,
   *     loading is stopped and the onComplete method is called with argument 'false'.
   *     Default is 30 seconds.
   *
   * Examples:
   *   preload({fonts: 'Sauna Pro'});
   *   preload({fonts: 'Sauna Pro|font-style:italic'});
   *   preload({fonts: 'Sauna Pro | font-style: italic; font-weight: 700'});
   *   preload({fonts: 'Sauna Pro', onComplete: handleLoadFinished});
   *   preload({fonts: ['Sauna Pro', 'Dolly Pro']});
   *   preload({fonts: {family:'Sauna', style: 'font-style:italic; font-weight:700'}, timeout: 999});
   *   preload({fonts: ['Fakir-Black', {family:'Fakir-Italic', style:'font-style:italic'}], timeout: 2500, onComplete: function() { setCookie('fakir','loaded') }});
   *
   * Inspired by Zenfonts (https://github.com/zengabor/zenfonts, public domain).
   */
  preload: function(options) {
    options = options || {};
    var fonts = options.fonts || [];
    if (!Array.isArray(fonts)) {
      fonts = [fonts];
    }
    if (!options.onComplete) {
      // preloading is not useful, because there is no callback on success
      return;
    }

    // these fonts are compared to the custom fonts, strings separated by comma
    var testFonts = 'monospace';

    // Create a DIV for each font
    var divs = [];
    fonts.forEach(function(font) {
      // Convert to object
      if (typeof font === 'string') {
        var m = font.match(/^(.*?)\s*\|\s*(.*)$/);
        if (m) {
          font = {
            family: m[1],
            style: m[2]
          };
        } else {
          font = {
            family: font
          };
        }
      }
      font.family = font.family || '';
      font.style = font.style || '';

      // Create DIV with default font
      // (Hide explicitly with inline style to prevent visible text when, for some reason, the CSS file cannot be loaded)
      var $body = $('body'),
        $div = $body.appendDiv('font-preloader')
          .text('ABC abc 123 .,_')
          .css('visibility', 'hidden')
          .css('font-family', testFonts);

      // Remember size, set new font, and then measure again
      var originalWidth = $div.outerWidth();
      $div.data('original-width', originalWidth);
      $div.css('font-family', '\'' + font.family + '\',' + testFonts);
      if (font.style) {
        var style = ($div.attr('style') || '').trim();
        var sep = (style.substr(-1) === ';' ? '' : ';') + (style ? ' ' : '');
        $div.attr('style', style + sep + font.style);
      }

      if ($div.outerWidth() !== originalWidth) {
        // Font already loaded, nothing to do
        $div.remove();
      } else {
        // Remember DIV
        divs.push($div);
      }
    }.bind(this));
    if (divs.length === 0) {
      // No fonts need to be watched, everything is loaded already
      complete(true);
      return;
    }

    var onFinished = complete;
    var timeout = scout.nvl(options.timeout, 30 * 1000); // default timeout is 30 sec
    var watchTimerId, timeoutTimerId;
    if (timeout && timeout >= 0) {
      // Add timeout
      timeoutTimerId = setTimeout(function() {
        clearTimeout(watchTimerId);
        complete(false);
      }.bind(this), timeout);
      onFinished = function() {
        clearTimeout(timeoutTimerId);
        complete(true);
      };
    }

    // Start watching (initially 50ms delay)
    watchWidthChange(50, onFinished);

    // ----- Helper functions -----

    function watchWidthChange(delay, onFinished) {
      // Check each DIV
      var i = divs.length;
      while (i--) {
        var $div = divs[i];
        if ($div.outerWidth() !== $div.data('original-width')) {
          divs.splice(i, 1);
          $div.remove();
        }
      }
      if (divs.length === 0) {
        // All completed
        onFinished(true);
        return;
      }

      // Watch again after a small delay
      watchTimerId = setTimeout(function() {
        // Slowly increase delay up to 1 second
        if (delay < 1000) {
          delay = delay * 1.2;
        }
        watchWidthChange(delay, onFinished);
      }, delay);
    }

    function complete(success) {
      options.onComplete(success);
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.icons = {

  ANGLE_DOWN: 'font:\uF107',
  ANGLE_UP: 'font:\uF106',
  OUTLINE: 'font:\uE043',
  ELLIPSIS_V: 'font:\uE040',
  COLLAPSE: 'font:\uE600',
  HOME: 'font:\uE601',
  SUM: 'font:\ue025',
  AVG: 'font:\ue026',
  MAX: 'font:\ue027',
  MIN: 'font:\ue028',

  ICON_ID_REGEX: /\$\{iconId\:([a-zA-Z0-9_\.]*)\}/,

  /**
   * Returns an Icon object with structured info contained in the iconId string.
   */
  parseIconId: function(iconId) {
    var icon = new scout.Icon();

    if (scout.strings.startsWith(iconId, 'font:')) {
      icon.iconType = scout.Icon.IconType.FONT_ICON;
      iconId = iconId.substr(5);
      if (scout.strings.countCodePoints(iconId) === 1) {
        // default icon-font scoutIcons
        icon.font = scout.Icon.DEFAULT_FONT;
        icon.iconCharacter = iconId;
      } else {
        var tmp = iconId.split(' ');
        icon.font = tmp[0];
        icon.iconCharacter = tmp[1];
      }
    } else {
      icon.iconType = scout.Icon.IconType.BITMAP;
      icon.iconUrl = iconId;
    }

    return icon;
  },

  /**
   * Resolves the value of an iconId property, where the value can contain a reference to
   * an icon constant in these formats:
   * <ul>
   *   <li><code>${iconId:ANGLE_UP}</code> references constant scout.icon.ANGLE_UP</li>
   *   <li><code>${iconId:foo.BAR}</code> references constant foo.icon.BAR, this is used for custom objects with icon constants</li>
   * </ul>
   * @param {string} value
   * @returns {string}
   */
  resolveIconId: function(value) {
    var iconId, tmp,
      result = this.ICON_ID_REGEX.exec(value);
    if (result && result.length === 2) {
      iconId = result[1];
      tmp = iconId.split('.');
      if (tmp.length === 1) {
        // look for icon in scout.icons.[0]
        value = scout.icons[tmp];
      } else if (tmp.length === 2) {
        // look for icon in global object [0].icons.[1]
        value = window[tmp[0]].icons[tmp[1]];
      } else {
        $.log.warn('Invalid iconId: ' + value);
      }
    }
    return value;
  }

};

scout.Icon = function() {
  this.iconType;
  this.font;
  this.iconCharacter;
  this.iconUrl;
};

scout.Icon.IconType = {
  FONT_ICON: 0,
  BITMAP: 1
};

scout.Icon.DEFAULT_FONT = 'scoutIcons';

/**
 * Returns a CSS class based on the used font-name.
 */
scout.Icon.prototype.cssClass = function() {
  if (this.isFontIcon() && this.font !== scout.Icon.DEFAULT_FONT) {
    return 'font-' + this.font;
  } else {
    return '';
  }
};

/**
 * Returns a CSS class string to be used with JQuery.add/removeClass().
 */
scout.Icon.prototype.appendCssClass = function(cssClass) {
  var additionalCssClass = this.cssClass();
  if (additionalCssClass.length > 0) {
    return cssClass + ' ' + additionalCssClass;
  } else {
    return cssClass;
  }
};

scout.Icon.prototype.isFontIcon = function() {
  return this.iconType === scout.Icon.IconType.FONT_ICON;
};

scout.Icon.prototype.isBitmap = function() {
  return this.iconType === scout.Icon.IconType.BITMAP;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.inspector = {

  /**
   * Adds inspector info (e.g. classId) from the given 'model' to the DOM. The target element
   * is either the given '$container' or model.$container. Nothing happens if model or target
   * element is undefined.
   */
  applyInfo: function(model, $container) {
    if (!model) {
      return;
    }
    $container = $container || model.$container;
    if (!$container) {
      return;
    }
    $container.toggleAttr('data-id', !!model.id, model.id);
    $container.toggleAttr('data-modelclass', !!model.modelClass, model.modelClass);
    $container.toggleAttr('data-classid', !!model.classId, model.classId);
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.locales = {

  localesMap: {},

  bootstrap: function(url) {
    url = scout.nvl(url, 'res/locales.json');
    return $.ajaxJson(url)
      .done(this.init.bind(this));
  },

  init: function(data) {
    data.forEach(function(locale) {
      this.localesMap[locale.languageTag] = locale;
    }, this);
  },

  get: function(languageTag) {
    return this.localesMap[languageTag];
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/* global log4javascript */
scout.logging = {
  defaultLevel: 'trace',

  /***
   * Loads log4javascript.min.js if logging is enabled.
   *
   * @returns $.deferred
   */
  bootstrap: function() {
    var promise;
    var location = new scout.URL();
    var enabled = location.getParameter('logging');
    $.log = new scout.NullLogger();
    if (enabled) {
      var initLog4Javascript = function() {
        var logLevel = scout.logging.parseLevel(location.getParameter('logLevel'));
        if (!logLevel) {
          logLevel = scout.logging.parseLevel(scout.logging.defaultLevel);
        }
        log4javascript.getDefaultLogger().setLevel(logLevel);
        $.log = log4javascript.getDefaultLogger();
      };
      if (typeof log4javascript === 'undefined') {
        // If log4javascript is not yet installed, dynamically load the library
        promise = $.injectScript('res/log4javascript.js')
          .done(function(script, textStatus) {
            initLog4Javascript();
          });
      } else {
        initLog4Javascript();
      }
    }
    return promise;
  },

  parseLevel: function(level) {
    if (!level) {
      return;
    }
    level = level.toLowerCase();
    switch (level) {
      case 'trace':
        return log4javascript.Level.TRACE;
      case 'debug':
        return log4javascript.Level.DEBUG;
      case 'info':
        return log4javascript.Level.INFO;
      case 'warn':
        return log4javascript.Level.WARN;
      case 'error':
        return log4javascript.Level.ERROR;
      case 'fatal':
        return log4javascript.Level.FATAL;
    }
  }
};

scout.NullLogger = function() {
  // empty
};
scout.NullLogger.prototype = {
  trace: function() {},
  debug: function() {},
  info: function() {},
  warn: function() {},
  error: function() {},
  fatal: function() {},
  isEnabledFor: function(level) {
    return false;
  },
  isTraceEnabled: function() {
    return false;
  },
  isDebugEnabled: function() {
    return false;
  },
  isInfoEnabled: function() {
    return false;
  },
  isWarnEnabled: function() {
    return false;
  },
  isErrorEnabled: function() {
    return false;
  },
  isFatalEnabled: function() {
    return false;
  }
};

scout.LookupCall = function() {
};

scout.LookupCall.prototype.init = function(model) {
  this._init(model);
};

scout.LookupCall.prototype._init = function(model) {
  $.extend(this, model);
};

/**
 * @returns Promise
 */
scout.LookupCall.prototype.textById = function(id) {
  // to be implemented by subclasses
};

scout.CodeLookupCall = function() {
  scout.CodeLookupCall.parent.call(this);
  this.codeType;
};
scout.inherits(scout.CodeLookupCall, scout.LookupCall);

scout.CodeLookupCall.prototype._init = function(model) {
  scout.CodeLookupCall.parent.prototype._init.call(this, model);
  if (!this.session) {
    throw new Error('missing property \'session\'');
  }
};

scout.CodeLookupCall.prototype.textById = function(id) {
  if (id === null || id === undefined) {
    return $.Deferred().resolve(null);
  }
  var code = scout.codes.get(this.codeType, id);
  return $.Deferred().resolve(code.text(this.session.locale));
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Pendant for org.eclipse.scout.rt.platform.resource.MimeType enumeration.
 */
scout.mimeTypes = {

  TEXT_PLAIN: 'text/plain',
  TEXT_HTML: 'text/html',

  IMAGE_PNG: 'image/png',
  IMAGE_JPG: 'image/jpg',
  IMAGE_JPEG: 'image/jpeg',
  IMAGE_GIF: 'image/gif',

  JSON: 'application/json'

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.models = {

  modelMap: {},

  /**
   * @param modelsUrl relative URL points to the *-models.json file. Example: 'myproject-models.json'.
   */
  bootstrap: function(modelsUrl) {
    scout.assertParameter('modelsUrl', modelsUrl);
    return $.ajaxJson(modelsUrl)
      .done(this.init.bind(this));
  },

  init: function(data) {
    this.modelMap = data;
  },

  /**
   * Returns a json model from modelMap. The model needs to be of type 'model'.
   *
   * @param {string} modelId the id of the model
   * @param {Object} [parent] if this parameter is given, a property 'parent' will be assigned to this parameter
   * @returns {Object}
   */
  getModel: function(modelId, parent) {
    var model = scout.models._get(modelId, 'model');
    if (parent) {
      model.parent = parent;
    }
    return model;
  },

  /**
   * returns a json extension from modelMap. The extension needs to be of type 'extension'
   * @param extensionId the id of the extension
   * @returns {Object}
   */
  getExtension: function(extensionId) {
    return scout.models._get(extensionId, 'extension');
  },

  /**
   * returns a copy of the json file in modelMap
   * @param id json file id
   * @param type value of type property
   * @returns {Object}
   */
  _get: function(id, type) {
    var json = this.modelMap[id];
    if (!json) {
      throw new Error('No JSON file defined for id=\'' + id + '\'. ' +
        'Check if file .json is listed in your *-module.json ' +
        'and if id matches the filename of the file .json file');
    }
    if(!json.type || json.type != type) {
      throw new Error(id + ' is not of type \''+ type + '\'');
    }
    return $.extend(true, {}, json);
  },

  /**
   * extends parentModel with the contents of extension. The extension property can be an object or an array of objects.
   * ParentModel will be changed and returned.
   * @param extension extension to the parentModel. Needs a property id on the parentModel to find the extension point.
   * Syntax of the extension:
   * Adding or overriding a property:
   * {
   *  "id": "..."
   *  "type": "extension"
   *  "extensions": [{
   *      "operation": "appendTo"
   *      "target": {
   *      "id": "someObjectID"
   *      }
   *      "extension": {
   *        "propertyX": "xyz"
   *      }
   *     }
   *    ]
   *  }
   * Adding new Object to the tree:
   * {
   *  "id": "..."
   *  "type": "extension"
   *  "extensions": [{
   *      "operation": "insert"
   *      "target": {
   *      "id": "someObjectID"
   *      "property": "collectionOfsomeObject"
   *      "before": "somObjectIDInPropertyArray"    //(alternative "index":0)
   *      }
   *      "extension": {
   *          "id": "newObjectID",
   *           "propertyx": "someThing",
   *           "collectiony": [...]
   *      }
   *     }
   *    ]
   *  }
   *
   *  to extend the root object directly, target.root: true can be used instead of target.id
   * @param parentModel object which contains id's as properties
   * @returns parentModel extended by extension
   */
  extend: function (extension, parentModel) {
    if (typeof extension === 'string') {
      extension = scout.models.getExtension(extension);
    }
    scout.assertParameter('extensions', extension.extensions);
    extension.extensions.forEach(function (extensionConfig) {
      scout.assertParameter('operation', extensionConfig.operation);
      var target = extensionConfig.target;
      scout.assertParameter('target', target);
      var targetObject;
      if (target.root) {
        targetObject = parentModel;
      } else {
        targetObject = scout.objects.findChildObjectByKey(parentModel, 'id', target.id);
      }
      if (!targetObject) {
        throw new Error('Extensions ' + extension.id + ':Target not found: {id: ' + target.id + '}');
      }
      if (extensionConfig.operation === 'appendTo') {
        $.extend(targetObject, extensionConfig.extension);
      } else if (extensionConfig.operation === 'insert') {
        targetObject[target.property] = targetObject[target.property] || [];
        var targetArray = targetObject[target.property];
        var insertAt = targetArray.length;
        if (target.before) {
          insertAt = scout.arrays.findIndex(targetArray, function (element) {
            return element.id === target.before;
          });
          if (insertAt === -1) {
            insertAt = targetArray.length;
          }
        }
        if ($.isNumeric(target.index)) {
          insertAt = target.index;
        }
        scout.arrays.insertArray(targetArray, extensionConfig.extension, insertAt);
      }
    }.bind(this));
    return parentModel;
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.numbers = {

  /**
   * Converts the given decimal number to base-62 (i.e. the same value, but
   * represented by [a-zA-Z0-9] instead of only [0-9].
   */
  toBase62: function(number) {
    if (number === undefined) {
      return undefined;
    }
    var symbols = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');
    var base = 62;
    var s = '';
    var n;
    while (number >= 1) {
      n = Math.floor(number / base);
      s = symbols[(number - (base * n))] + s;
      number = n;
    }
    return s;
  },

  /**
   * Returns a random sequence of characters out of the set [a-zA-Z0-9] with the
   * given length. The default length is 8.
   */
  randomId: function(length) {
    length = length || 8;
    var alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    var result = '';
    for (var i = 0; i < length; i++) {
      result += alphabet[Math.floor(Math.random() * alphabet.length)];
    }
    return result;
  },

  _correlationCounter: 1,

  /**
   * Generates a random ID suitable for use as correlation ID.
   *
   * Example:
   *
   *   Hq5JY2kz3n/27
   *
   * The ID is generated from two different alphabets: 1. only letter, 2. only digits. By
   * always selecting a random digit after two random characters, accidental "rude words"
   * can be prevented.
   *
   * The characters[01olOL] are not used at all because they are easily confused.
   *
   * For a length of 11 (default), this method can theoretically generate over 200 trillion
   * different IDs:
   *
   *   46^7 * 8^3 = 223'138'640'494'592
   *
   * To further reduce the risk of collisions, a monotonically increasing counter is added
   * at the end of the result string (separated by "/").
   */
  correlationId: function(length) {
    length = length || 11;
    var letters = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ';
    var digits = '23456789';
    var result = '';
    for (var i = 0; i < length; i++) {
      if ((i + 1) % 3 === 0) {
        result += digits[Math.floor(Math.random() * digits.length)];
      } else {
        result += letters[Math.floor(Math.random() * letters.length)];
      }
    }
    return result + '/' + (this._correlationCounter++);
  },

  /**
   * Rounds a number to the given number of decimal places.
   *
   * Numbers should not be rounded with the built-in Number.toFixed() method, since it
   * behaves differently on different browsers. However, it is safe to apply toFixed()
   * to the result of this method to ensure a fixed number of decimal places (filled up
   * with 0's) because this operation does not involve any rounding anymore.
   * <p>
   * If decimalPlaces is omitted, the number will be rounded to integer by default.
   * Rounding mode {@link scout.numbers.RoundingMode.HALF_UP} is used as default.
   */
  round: function(number, roundingMode, decimalPlaces) {
    if (number === null || number === undefined) {
      return number;
    }
    decimalPlaces = decimalPlaces || 0;

    // Do _not_ multiply with powers of 10 here, because that might cause rounding errors!
    // Example: 1.005 with 2 decimal places would result in 100.49999999999999
    number = this.shiftDecimalPoint(number, decimalPlaces);

    switch (roundingMode) {
      case scout.numbers.RoundingMode.UP:
        if (number < 0) {
          number = -Math.ceil(Math.abs(number));
        } else {
          number = Math.ceil(number);
        }
        break;
      case scout.numbers.RoundingMode.DOWN:
        if (number < 0) {
          number = -Math.floor(Math.abs(number));
        } else {
          number = Math.floor(number);
        }
        break;
      case scout.numbers.RoundingMode.CEILING:
        number = Math.ceil(number);
        break;
      case scout.numbers.RoundingMode.FLOOR:
        number = Math.floor(number);
        break;
      case scout.numbers.RoundingMode.HALF_DOWN:
        if (number < 0) {
          number = Math.round(number);
        } else {
          number = -Math.round(-number);
        }
        break;
        // case scout.numbers.RoundingMode.HALF_EVEN:
        // case scout.numbers.RoundingMode.UNNECESSARY:
        // not implemented, default is used.
      default:
        // scout.numbers.RoundingMode.HALF_UP is used as default
        if (number < 0) {
          number = -Math.round(Math.abs(number));
        } else {
          number = Math.round(number);
        }
    }

    return this.shiftDecimalPoint(number, -decimalPlaces);
  },

  /**
   * Shifts the decimal point in the given number by a certain distance. While the result is also
   * number, the method uses string operations to move the decimal point. This prevents rounding
   * errors as long as the number does not exceed JavaScript's Number precision.
   *
   * The argument 'move' describes the distance how far the decimal point should be moved:
   *     0 = do no move      (1.57 --> 1.57)
   *   > 0 = move to right   (1.57 --> 15.7)
   *   < 0 = move to left    (1.57 --> 0.157)
   */
  shiftDecimalPoint: function(number, move) {
    if (number === null || number === undefined || !move) {
      return number;
    }

    var sign = (number ? (number < 0 ? -1 : 1) : 0);
    var distance = Math.abs(move);

    number = Math.abs(number);
    var s = scout.strings.asString(number);
    var a;
    if (move < 0) {
      // move to left
      s = scout.strings.repeat('0', distance) + s;
      a = s.split('.', 2);
      if (a.length === 1) {
        s = s.substr(0, s.length - distance) + '.' + s.substr(s.length - distance);
      } else {
        s = a[0].substr(0, a[0].length - distance) + '.' + a[0].substr(a[0].length - distance) + a[1];
      }
    } else if (move > 0) {
      // move to right
      s += scout.strings.repeat('0', distance);
      a = s.split('.', 2);
      if (a.length === 2) {
        s = a[0] + a[1].substr(0, distance) + '.' + a[1].substr(distance);
      }
    }
    // Remove multiple leading zeros to prevent interpretation as octal number
    s = s.replace(/^0*(\d)/g, '$1');
    return Number(s) * sign;
  }

};

/**
 * Enum providing rounding-modes for number columns and fields.
 *
 * @see RoundingMode.java
 */
scout.numbers.RoundingMode = {
  UP: 'UP',
  DOWN: 'DOWN',
  CEILING: 'CEILING',
  FLOOR: 'FLOOR',
  HALF_UP: 'HALF_UP',
  HALF_DOWN: 'HALF_DOWN',
  HALF_EVEN: 'HALF_EVEN',
  UNNECESSARY: 'UNNECESSARY'
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.objects = {

  /**
   * Copies all the properties (including the ones from the prototype.) from dest to source
   * @memberOf scout.objects
   */
  copyProperties: function(source, dest) {
    var propertyName;
    for (propertyName in source) {
      dest[propertyName] = source[propertyName];
    }
  },

  /**
   * Copies the own properties (excluding the ones from the prototype) from dest to source
   * @memberOf scout.objects
   */
  copyOwnProperties: function(source, dest) {
    var propertyName;
    for (propertyName in source) {
      if (source.hasOwnProperty(propertyName)) {
        dest[propertyName] = source[propertyName];
      }
    }
  },

  /**
   * Counts and returns the properties of a given object.
   */
  countOwnProperties: function(obj) {
    var count = 0;
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        count++;
      }
    }
    return count;
  },

  /**
   * Copies the specified properties (including the ones from the prototype.) from dest to source.
   * Properties that already exist on dest are NOT overwritten.
   */
  extractProperties: function(source, dest, properties) {
    properties.forEach(function(propertyName) {
      if (!dest[propertyName]) {
        dest[propertyName] = source[propertyName];
      }
    });
    return dest;
  },

  /**
   * returns
   *  - true if the obj has at least one of the given properties.
   *  - false if the obj has none of the given properties.
   *
   * @param obj
   * @param properties a single property or an array of properties
   * @returns {Boolean}
   */
  someOwnProperties: function(obj, properties) {
    var propArr = scout.arrays.ensure(properties);
    return propArr.some(function(prop) {
      return obj.hasOwnProperty(prop);
    });
  },

  /**
   * returns
   *  - true if the obj or its prototypes have at least one of the given properties.
   *  - false if the obj or its prototypes have none of the given properties.
   *
   * @param obj
   * @param properties a single property or an array of properties
   * @returns {Boolean}
   */
  someProperties: function(obj, properties) {
    var propArr = scout.arrays.ensure(properties);
    return propArr.some(function(prop) {
      return prop in obj;
    });
  },

  valueCopy: function(obj) {
    // Nothing to be done for immutable things
    if (obj === undefined || obj === null || typeof obj !== 'object') {
      return obj;
    }
    var copy;
    // Arrays
    if (Array.isArray(obj)) {
      copy = [];
      for (var i = 0; i < obj.length; i++) {
        copy[i] = scout.objects.valueCopy(obj[i]);
      }
      return copy;
    }
    // All other objects
    copy = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        copy[prop] = scout.objects.valueCopy(obj[prop]);
      }
    }
    return copy;
  },

  /**
   * Returns the first object with the given property and propertyValue or null if there is no such object within parentObj.
   * @param parentObj
   * @param property property to search for
   * @param propertyValue value of the property
   * @returns {Object}
   */
  findChildObjectByKey: function(parentObj, property, propertyValue) {
    if (parentObj === undefined || parentObj === null || typeof parentObj !== 'object') {
      return null;
    }
    if (parentObj[property] === propertyValue) {
      return parentObj;
    }
    var child;
    if (Array.isArray(parentObj)) {
      for (var i = 0; i < parentObj.length; i++) {
        child = scout.objects.findChildObjectByKey(parentObj[i], property, propertyValue);
        if (child) {
          return child;
        }
      }
    }
    for (var prop in parentObj) {
      if (parentObj.hasOwnProperty(prop)) {
        child = scout.objects.findChildObjectByKey(parentObj[prop], property, propertyValue);
        if (child) {
          return child;
        }
      }
    }
    return null;
  },

  /**
   * Returns true if the given object is an object but _not_ an array.
   */
  isPlainObject: function(obj) {
    return (typeof obj === 'object' && !Array.isArray(obj));
  },

  /**
   * Returns the given property if the object is truthy.
   */
  optProperty: function(obj, property) {
    if (obj) {
      return obj[property];
    }
    return null;
  },

  /**
   * Returns true if:
   * - obj is not undefined or null
   * - obj not isNaN
   * - obj isFinite
   *
   * This method is handy in cases where you want to check if a number is set. Since you cannot write:
   *   if (myNumber) { ...
   *
   * Because when myNumber === 0 would also resolve to false. In that case use instead:
   *   if (isNumber(myNumber)) { ...
   *
   * @param obj
   * @returns {Boolean}
   */
  isNumber: function(obj) {
    return obj !== null && !isNaN(obj) && isFinite(obj);
  },

  isString: function(obj) {
    return typeof obj === 'string';
  },

  isNullOrUndefined: function(obj) {
    return obj === null || obj === undefined;
  },

  /**
   * Returns values from the given (map) object. By default only values of 'own' properties are returned.
   *
   * @returns {Array} an Array with values
   * @param {Object} obj
   * @param {boolean} [all] can be set to true to return all properties instead of own properties
   */
  values: function(obj, all) {
    var values = [];
    if (obj) {
      for (var key in obj) {
        if (all || obj.hasOwnProperty(key)) {
          values.push(obj[key]);
        }
      }
    }
    return values;
  },

  /**
   * Java-like equals method. Compares the given objects by checking with ===, if that fails, the function
   * checks if both objects have an equals function and use the equals function to compare the two objects
   * by value.
   * @returns True if both objects are equals by reference or by value
   */
  equals: function(objA, objB) {
    if (objA === objB) {
      return true;
    }
    // both objects have an equals() method
    if ((objA && objB) && (objA.equals && objB.equals)) {
      return objA.equals(objB);
    }
    return false;
  },

  /**
   * Compares a list of properties of two objects by using the equals method for each property.
   */
  propertiesEquals: function(objA, objB, properties) {
    var i, property;
    for (i = 0; i < properties.length; i++) {
      property = properties[i];
      if (!scout.objects.equals(objA[property], objB[property])) {
        return false;
      }
    }
    return true;
  },

  /**
   * @returns the function identified by funcName from the given object. The function will return an error
   *     if that function does not exist. Use this function if you modify an existing framework function
   *     to find problems after refactorings / renamings as soon as possible.
   */
  mandatoryFunction: function(obj, funcName) {
    var func = obj[funcName];
    if (!func || typeof func !== 'function') {
      throw new Error('Function \'' + funcName + '\' does not exist on object. Check if it has been renamed or moved.', obj);
    }
    return func;
  },

  /**
   * Use this method to replace a function on a prototype of an object. It checks if that function exists
   * by calling <code>mandatoryFunction</code>.
   */
  replacePrototypeFunction: function(obj, funcName, func) {
    var proto = obj.prototype;
    this.mandatoryFunction(proto, funcName);
    proto[funcName] = func;
  },

  /**
   * @returns a real Array for the pseudo-array 'arguments'.
   */
  argumentsToArray: function(args) {
    return Array.prototype.slice.call(args);
  },

  /**
   * Used to loop over 'arguments' pseudo-array with forEach.
   */
  forEachArgument: function(args, func) {
    return this.argumentsToArray(args).forEach(func);
  },

  /**
   * TODO [5.2] bsh: Document
   *
   * How to use:
   *   scout.objects.checkFunctionOverrides().join('\n')
   */
  checkFunctionOverrides: function() {
    var whitelist = [
      'ModelAdapter.init',
      'ModelAdapter._init',
      'Calendar.init'
    ];
    var result1 = [
      'Legend:',
      '[!] Function includes super call, and parent function uses arguments',
      ' ~  Function includes super call, but parent function does not use arguments',
      '    Function does not include super call',
      '',
      'Wrong number of arguments:'
    ];
    var result2 = ['Different argument names:'];

    for (var prop in scout) {
      if (!scout.hasOwnProperty(prop)) {
        continue;
      }
      var o = scout[prop];
      // Only check functions that have a "parent"
      if (typeof o === 'function' && o.parent) {
        for (var name in o.prototype) {
          if (!o.prototype.hasOwnProperty(name)) {
            continue;
          }
          var fn = o.prototype[name];
          // Ignore constructor, inherited properties and non-functions
          if (name === 'constructor' || !o.prototype.hasOwnProperty(name) || typeof fn !== 'function') {
            continue;
          }
          var args = getFunctionArguments(fn);
          // Check all parents
          var parent = o.parent;
          while (parent) {
            var parentFn = parent.prototype[name];
            if (parent.prototype.hasOwnProperty(name) && typeof parentFn === 'function') {
              var parentArgs = getFunctionArguments(parentFn);
              // Check arguments (at least all of the parent args must be present)
              var mismatch = false;
              for (var i = 0; i < parentArgs.length; i++) {
                if (args.length < i || args[i] !== parentArgs[i]) {
                  mismatch = true;
                  break;
                }
              }
              var fname = prop + '.' + name;
              if (mismatch && whitelist.indexOf(fname) === -1) { // && args.length !== parentArgs.length) {
                // Collect found mismatch
                var result = fname + '(' + args.join(', ') + ') does not correctly override ' + getPrototypeOwner(parentFn) + '.' + name + '(' + parentArgs.join(', ') + ')';
                var includesSuperCall = (fn.toString().match(new RegExp('scout.' + scout.strings.quote(prop) + '.parent.prototype.' + scout.strings.quote(name) + '.call\\(')) !== null);
                var parentFunctionUsesArguments = false;
                if (includesSuperCall) {
                  for (var j = 0; j < parentArgs.length; j++) {
                    var m = parentFn.toString().match(new RegExp('[^.\\w]' + scout.strings.quote(parentArgs[j]) + '[^\\w]', 'g'));
                    if (m !== null && m.length > 1) {
                      parentFunctionUsesArguments = true;
                      break;
                    }
                  }
                }
                result = (includesSuperCall ? (parentFunctionUsesArguments ? '[!]' : ' ~ ') : '   ') + ' ' + result;
                if (args.length !== parentArgs.length) {
                  result1.push(result);
                } else {
                  result2.push(result);
                }
              }
            }
            parent = parent.parent;
          }
        }
      }
    }

    result1.push('');
    return result1.concat(result2);

    // ----- Helper functions -----

    function getFunctionArguments(fn) {
      var FN_COMMENTS = /\/\*.*?\*\/|\/\/.*$/mg; // removes comments in function declaration
      var FN_ARGS = /^function[^(]*\((.*?)\)/m; // fetches all arguments in m[1]

      if (typeof fn !== 'function') {
        throw new Error('Argument is not a function: ' + fn);
      }

      var m = fn.toString().replace(FN_COMMENTS, '').match(FN_ARGS);
      var args = [];
      if (m !== null) {
        m[1].split(',').forEach(function(arg, i) {
          arg = arg.trim();
          if (arg.length > 0) {
            args.push(arg);
          }
        });
      }
      return args;
    }

    function getPrototypeOwner(fx) {
      for (var prop in scout) {
        if (!scout.hasOwnProperty(prop)) {
          continue;
        }
        var o = scout[prop];
        if (typeof o === 'function') {
          for (var name in o.prototype) {
            if (!o.prototype.hasOwnProperty(name)) {
              continue;
            }
            var fn = o.prototype[name];
            // Ignore constructor, inherited properties and non-functions
            if (name === 'constructor' || !o.prototype.hasOwnProperty(name) || typeof fn !== 'function') {
              continue;
            }
            if (fn === fx) {
              return prop;
            }
          }
        }
      }
      return '';
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Polyfill for IE9 providing a simple implementation of FormData (as used by FileChooser.js)
 *
 * Only supports the append() and the toString() method. Does not work in modern browsers, because
 * it uses obsolete File.getAsBinary (https://developer.mozilla.org/de/docs/Web/API/File/getAsBinary).
 *
 * Rules for generating the boundary:
 * http://stackoverflow.com/a/4656646
 *
 * How to use this polyfill with jQuery:
 * http://stackoverflow.com/a/5976031
 */
scout.polyfills = {

  install: function(window) {
    if (window.FormData) {
      // Nothing to do
      return;
    }

    window.FormData = function() {
      this.polyfill = true; // Marker
      this._boundary = 'ScoutFormData-' + scout.numbers.randomId(50);
      this._data = [];
      this._crlf = '\r\n';
    };

    window.FormData.prototype.append = function(key, value, filename) {
      var element = [key, value, filename];
      this._data.push(element);
    };

    window.FormData.prototype.getContent = function() {
      var result = '';
      this._data.forEach(function(element) {
        var key = element[0];
        var value = element[1];
        var filename = element[2];

        result += '--' + this._boundary + this._crlf;
        if (scout.device.supportsFile() && value instanceof window.File) {
          // File
          var file = value;
          filename = filename || file.name || key;
          result += 'Content-Disposition: form-data; name="' + key + '"; filename="' + filename + '"' + this._crlf;
          result += 'Content-Type: ' + file.type + this._crlf;
          result += this._crlf;
          result += (file.getAsBinary ? file.getAsBinary() : 'UNKNOWN CONTENT') + this._crlf;
        } else {
          // Everything else
          result += 'Content-Disposition: form-data; name="' + key + '";' + this._crlf;
          result += this._crlf;
          result += value + this._crlf;
        }
      }.bind(this));
      result += '--' + this._boundary + '--';
      return result;
    };

    window.FormData.prototype.applyToAjaxOptions = function(ajaxOpts) {
      if (!ajaxOpts) {
        return;
      }
      // Make sure no text encoding stuff is done by xhr
      ajaxOpts.xhr = function() {
        var xhr = $.ajaxSettings.xhr();
        xhr.send = xhr.sendAsBinary || xhr.send; // sendAsBinary only exists in older browsers
        return xhr;
      };
      // Manually set content type (with boundary)
      ajaxOpts.contentType = 'multipart/form-data; boundary=' + this._boundary;
      // Generate content
      ajaxOpts.data = this.getContent();
    };
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Range = function(from, to) {
  this.from = from;
  this.to = to;
};

scout.Range.prototype.equals = function(other) {
  return this.from === other.from && this.to === other.to;
};

scout.Range.prototype.subtract = function(other) {
  // other is empty
  if (other.size() === 0) {
    return [new scout.Range(this.from, this.to)];
  }
  // other is greater
  if (this.from >= other.from && this.to <= other.to) {
    return [new scout.Range(0, 0)];
  }
  // other is contained completely
  if (other.from >= this.from && other.to <= this.to) {
    var range1 = new scout.Range(this.from, other.from);
    var range2 = new scout.Range(other.to, this.to);
    if (range1.size() === 0) {
      return [range2];
    }
    if (range2.size() === 0) {
      return [range1];
    }
    return [range1, range2];
  }
  // other overlaps on the bottom
  if (other.from > this.from && other.from < this.to) {
    return [new scout.Range(this.from, other.from)];
  }
  // other overlaps on the top
  if (this.from > other.from && this.from < other.to) {
    return [new scout.Range(other.to, this.to)];
  }
  // other is outside
  return [new scout.Range(this.from, this.to)];
};


scout.Range.prototype.shrink = function(other) {
  // other is empty
  if (other.size() === 0) {
    return new scout.Range(this.from, this.to);
  }
  // other is greater
  if (this.from >= other.from && this.to <= other.to) {
    return new scout.Range(0, 0);
  }
  // other is contained completely
  if (other.from >= this.from && other.to <= this.to) {
    return new scout.Range(this.from, other.to);
  }
  // other overlaps on the bottom
  if (other.from >= this.from && other.from < this.to) {
    return new scout.Range(this.from, other.from);
  }
  // other overlaps on the top
  if (this.from > other.from && this.from < other.to) {
    return new scout.Range(other.to, this.to);
  }
  if(other.to<this.from){
    return new scout.Range(this.from-other.size()-1, this.to-other.size()-1);
  }
  // other is outside
  return new scout.Range(this.from, this.to);
};


scout.Range.prototype.union = function(other) {
  if (this.to < other.from || other.to < this.from) {
    var range1 = new scout.Range(this.from, this.to);
    var range2 = new scout.Range(other.from, other.to);
    if (range1.size() === 0) {
      return [range2];
    }
    if (range2.size() === 0) {
      return [range1];
    }
    return [range1, range2];
  }
  return [new scout.Range(Math.min(this.from, other.from), Math.max(this.to, other.to))];
};

scout.Range.prototype.intersect = function(other) {
  if (this.to <= other.from || other.to <= this.from) {
    return new scout.Range(0, 0);
  }
  return new scout.Range(Math.max(this.from, other.from), Math.min(this.to, other.to));
};

scout.Range.prototype.size = function(other) {
  return this.to - this.from;
};

scout.Range.prototype.contains = function(value) {
  return this.from <= value && value < this.to;
};

scout.Range.prototype.toString = function() {
  return 'scout.Range[' +
    'from=' + (this.from === null ? 'null' : this.from) +
    ' to=' + (this.to === null ? 'null' : this.to) + ']';
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Status = function(model) {
  this.message;
  this.severity;
  $.extend(this, model);
};

scout.Status.Severity = {
  OK: 0x01,
  INFO: 0x100,
  WARNING: 0x10000,
  ERROR: 0x1000000
};

scout.Status.cssClasses = 'has-error has-warning has-info';

scout.Status.prototype.cssClass = function() {
  return scout.Status.cssClassForSeverity(this.severity);
};

/**
 * @returns true if severity is OK or INFO, false if severity is WARNING or ERROR.
 */
scout.Status.prototype.isValid = function() {
  return this.severity === scout.Status.Severity.OK ||
         this.severity === scout.Status.Severity.INFO;
};

scout.Status.prototype.isError = function() {
  return this.severity === scout.Status.Severity.ERROR;
};

/**
 * @return a clone of this Status instance.
 */
scout.Status.prototype.clone = function() {
  var modelClone = $.extend({}, this);
  return new scout.Status(modelClone);
};

scout.Status.prototype.equals = function(o) {
  if (!(o instanceof scout.Status)) {
    return false;
  }
  return scout.objects.propertiesEquals(this, o,
      ['severity', 'message', 'invalidDate', 'invalidTime']);
};

/**
 * Null-safe static clone method.
 */
scout.Status.clone = function(original) {
  return original ? original.clone() : null;
};

scout.Status.cssClassForSeverity = function(severity) {
  var isInfo = (severity > scout.Status.Severity.OK);
  var isWarning = (severity > scout.Status.Severity.INFO);
  var isError = (severity > scout.Status.Severity.WARNING);

  if (isError) {
    return 'has-error';
  }
  if (isWarning) {
    return 'has-warning';
  }
  if (isInfo) {
    return 'has-info';
  }
  return '';
};

scout.Status.animateStatusMessage = function($status, message) {
  if (scout.strings.endsWith(message, '...')) {
    var $elipsis = $status.makeSpan('elipsis');
    for (var i = 0; i < 3; i++) {
      $elipsis.append($status.makeSpan('animate-dot delay-' + i, '.'));
    }
    message = message.substring(0, message.length - 3);
    $status.empty().text(message).append($elipsis);
  } else {
    $status.text(message);
  }
};

scout.Status.ensure = function(status) {
  if (!status) {
    return status;
  }
  if (status instanceof scout.Status) {
    return status;
  }
  return new scout.Status(status);
};

/**
 * @returns a Status object with severity OK.
 */
scout.Status.ok = function() {
  return new scout.Status({
    severity: scout.Status.Severity.OK
  });
};

/**
 * @returns a Status object with severity INFO.
 */
scout.Status.info = function() {
  return new scout.Status({
    severity: scout.Status.Severity.INFO
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.strings = {

  /**
   * @param text
   * @param encodeHtml defaults to true
   * @memberOf scout.strings
   */
  nl2br: function(text, encodeHtml) {
    if (!text) {
      return text;
    }
    text = this.asString(text);
    encodeHtml = scout.nvl(encodeHtml, true);
    if (encodeHtml) {
      text = scout.strings.encode(text);
    }
    return text.replace(/\n/g, '<br>').replace(/\r/g, '');
  },

  insertAt: function(text, insertText, position) {
    if (!text) {
      return text;
    }
    text = this.asString(text);
    insertText = this.asString(insertText);
    if (insertText && (typeof position === 'number' || position instanceof Number) && position >= 0) {
      return text.substr(0, position) + insertText + text.substr(position);
    }
    return text;
  },

  /**
   * @returns true if the given string contains any non-space characters
   */
  hasText: function(text) {
    if (text === undefined || text === null) {
      return false;
    }
    text = this.asString(text);
    if (typeof text !== 'string' || text.length === 0) {
      return false;
    }
    return !/^\s*$/.test(text);
  },

  /**
   * Inverse operation of hasText(string). Used because empty(s) is more readable than !hasText(s).
   * @returns true if the given string is not set or contains only white-space characters.
   */
  empty: function(text) {
    return !scout.strings.hasText(text);
  },

  repeat: function(pattern, count) {
    if (pattern === undefined || pattern === null) {
      return pattern;
    }
    if (typeof count !== 'number' || count < 1) {
      return '';
    }
    var result = '';
    for (var i = 0; i < count; i++) {
      result += pattern;
    }
    return result;
  },

  padZeroLeft: function(string, padding) {
    string = this.asString(string);
    if (string === undefined || string === null || typeof padding !== 'number' || padding < 1 || (string + '').length >= padding) {
      return string;
    }
    var z = scout.strings.repeat('0', padding) + string;
    return z.slice(-padding);
  },

  startsWith: function(fullString, startString) {
    if (fullString === undefined || fullString === null || startString === undefined || startString === null) {
      return false;
    }
    if (startString.length === 0) {
      return true; // every string starts with the empty string
    }
    if (fullString.length === 0) {
      return false; // empty string cannot start with non-empty string
    }
    fullString = this.asString(fullString);
    startString = this.asString(startString);
    return (fullString.substr(0, startString.length) === startString);
  },

  endsWith: function(fullString, endString) {
    if (fullString === undefined || fullString === null || endString === undefined || endString === null) {
      return false;
    }
    if (endString.length === 0) {
      return true; // every string ends with the empty string
    }
    if (fullString.length === 0) {
      return false; // empty string cannot end with non-empty string
    }
    fullString = this.asString(fullString);
    endString = this.asString(endString);
    return (fullString.substr(-endString.length) === endString);
  },

  /**
   * Returns the number of occurrences of 'separator' in 'string'
   */
  count: function(string, separator) {
    if (!string || separator === undefined || separator === null) {
      return 0;
    }
    string = this.asString(string);
    separator = this.asString(separator);
    return string.split(separator).length - 1;
  },

  // Cache used by scout.strings.encode(). Also referenced in stringsSpec.js.
  _encodeElement: null,

  /**
   * Encodes the html of the given string.
   */
  encode: function(string) {
    if (!string) {
      return string;
    }
    var elem = scout.strings._encodeElement;
    if (!elem) {
      elem = window.document.createElement('div');
      // cache it to prevent creating an element every time
      scout.strings._encodeElement = elem;
    }
    elem.textContent = string;
    return elem.innerHTML;
  },

  /**
   * Returns the plain text of the given html string using simple tag replacement.<p>
   * Tries to preserve the new lines. Since it does not consider the style, it won't be right in any cases.
   * A div for example always generates a new line, even if display style is not set to block.
   */
  plainText: function(text) {
    if (!text) {
      return text;
    }
    text = this.asString(text);

    // Regexp is used to replace the tags.
    // It is not possible to use jquery's text() function or to create a html element and use textContent, because the new lines get omitted.
    // Node.innerText would preserve the new lines but it is not supported by firefox

    // Preserve new lines
    text = text.replace(/<br>|<br\/>|<\/p>|<p\/>|<\/div>|<\/li>|<\/tr>/gi, '\n');

    // Separate td with ' '
    text = text.replace(/<\/td>/gi, ' ');

    // Replace remaining tags
    text = text.replace(/<[^>]+>/gi, '');

    // Remove spaces at the beginning and end of each line
    text = text.replace(/^[ ]+/gm, '');
    text = text.replace(/[ ]+$/gm, '');

    // Replace character html entities (e.g. &nbsp;, &gt;, ...)
    var textarea = scout.strings.plainTextElement;
    if (!textarea) {
      textarea = document.createElement('textarea');
      // cache it to prevent creating an element every time
      scout.strings.plainTextElement = textarea;
    }
    textarea.innerHTML = text;
    return textarea.value;
  },

  /**
   * Joins a list of strings to a single string using the given separator. Elements that are
   * not defined or have zero length are ignored. The default return value is the empty string.
   *
   * @param separator String to use as separator
   * @param varargs List of strings to join
   */
  join: function(separator) {
    separator = this.asString(separator);
    var s = '';
    for (var i = 1; i < arguments.length; i++) {
      var arg = this.asString(arguments[i]);
      if (arg) {
        if (s && separator) {
          s += separator;
        }
        s += arg;
      }
    }
    return s;
  },

  /**
   * If the given 'string' has text, it is returned with the 'prefix' and 'suffix'
   * prepended and appended, respectively. Otherwise, the empty string is returned.
   */
  box: function(prefix, string, suffix) {
    prefix = this.asString(prefix);
    string = this.asString(string);
    suffix = this.asString(suffix);
    var s = '';
    if (this.hasText(string)) {
      if (prefix) {
        s += prefix;
      }
      s += string;
      if (suffix) {
        s += suffix;
      }
    }
    return s;
  },

  /**
   * If the given 'string' has text, its first letter is returned in lower case,
   * the remainder is unchanged. Otherwise, the empty string is returned.
   */
  lowercaseFirstLetter: function(string) {
    if (string === undefined || string === null) {
      return string;
    }
    string = this.asString(string);
    var s = '';
    if (this.hasText(string)) {
      s = string.charAt(0).toLowerCase() + string.slice(1);
    }
    return s;
  },

  /**
   * Quotes a string for use in a regular expression, i.e. escapes all characters with special meaning.
   */
  quote: function(string) {
    if (string === undefined || string === null) {
      return string;
    }
    string = this.asString(string);
    // see "escapeRegExp()" from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& = last match
  },

  /**
   * If the given input is not of type string, it is converted to a string (using the standard
   * JavaScript "String()" function). Inputs 'null' and 'undefined' are returned as they are.
   */
  asString: function(input) {
    if (input === undefined || input === null) {
      return input;
    }
    if (typeof input === 'string' || input instanceof String) {
      return input;
    }
    return String(input);
  },

  /**
   * Returns an empty string '', when given string is null or undefined.
   * This is a shortcut for <code>scout.nvl(string, '')</code>.
   */
  nvl: function(string) {
    return scout.nvl(string, '');
  },

  toUpperCaseFirstLetter: function(string) {
    return string.substring(0, 1).toUpperCase() + string.substring(1);
  },

  /**
   * Returns the number of unicode characters in the given string.
   * As opposed to the string.length property, astral symbols are
   * counted as one single character.
   * Example: <code>'\uD83D\uDC4D'.length</code> returns 2, whereas
   * <code>scout.strings.countCharpoints('\uD83D\uDC4D')</code> returns 1.
   * (\uD83D\uDC4D is Unicode Character 'THUMBS UP SIGN' (U+1F44D))
   */
  countCodePoints: function(string) {
    return string
      // Replace every surrogate pair with a BMP symbol.
      .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '_')
      // and then get the length.
      .length;
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.styles = {

  /**
   * @memberOf scout.styles
   */
  styleMap: {},

  /**
   * Generates an invisible div and appends it to the body, only once. The same div will be reused on subsequent calls.
   * Adds the given css class to that element and returns a style object containing the values for every given property.
   * The style is cached. Subsequent calls with the same css class will return the same style object.
   */
  get: function(cssClass, properties) {
    var style = scout.styles.styleMap[cssClass];
    // ensure array
    properties = scout.arrays.ensure(properties);
    properties = properties.map(function(prop) {
      return {
        name: prop,
        // replace property names like 'max-width' in 'maxWidth'
        nameCamelCase: prop.replace(/\-(.)/g,
          function(match, p1) {
            return p1.toUpperCase();
          })
      };
    });

    // ensure style
    if (!style) {
      style = {};
      scout.styles.put(cssClass, style);
    }

    var notResolvedProperties = properties.filter(function(prop) {
      return !(prop.nameCamelCase in style);
    });
    if (notResolvedProperties.length === 0) {
      return style;
    }

    // resolve missing properties
    var elem = scout.styles.element;
    if (!elem) {
      elem = window.document.createElement('div');
      elem.style.display = 'none';
      window.document.body.appendChild(elem);
      scout.styles.element = elem;
    }
    elem.className = cssClass;
    var computedStyle = window.getComputedStyle(elem);
    notResolvedProperties.forEach(function(property) {
      style[property.nameCamelCase] = computedStyle[property.name];
    });
    elem.className = '';

    return style;
  },

  put: function(cssClass, style) {
    this.styleMap[cssClass] = style;
  },

  /**
   * Creates an rgb object based on the given rgb string with the format rgb(0, 0, 0).
   */
  rgb: function(rgbString) {
    var rgb = rgbString.replace(/\s/g, '').match(/^rgba?\(([0-9]+),([0-9]+),([0-9]+)/i);
    return {
      red: parseInt(rgb[1], 10),
      green: parseInt(rgb[2], 10),
      blue: parseInt(rgb[3], 10)
    };
  },

  /**
   * Example: Dialog-PLAIN-12
   */
  parseFontSpec: function(pattern) {
    var fontSpec = {};
    if (scout.strings.hasText(pattern)) {
      var tokens = pattern.split(/[-_,\/.;]/);
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i].toUpperCase();
        // styles
        if (token === 'NULL' || token === '0') {
          // nop (undefined values)
        } else if (token === 'PLAIN') {
          // nop
        } else if (token === 'BOLD') {
          fontSpec.bold = true;
        } else if (token === 'ITALIC') {
          fontSpec.italic = true;
        } else {
          // size or name
          if (/^\d+$/.test(token)) {
            fontSpec.size = token;
          } else if (token !== 'NULL') {
            fontSpec.name = token;
          }
        }
      }
    }
    return fontSpec;
  },

  modelToCssColor: function(color) {
    var cssColor = '';
    if (/^[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$/.test(color)) { // hex color
      cssColor = '#' + color;
    } else if (/^[A-Za-z0-9().,%-]+$/.test(color)) { // named colors or color functions
      cssColor = color;
    }
    return cssColor;
  },

  /**
   * Returns a string with CSS definitions for use in an element's "style" attribute. All CSS relevant
   * properties of the given object are converted to CSS definitions, namely foreground color, background
   * color and font.
   *
   * If an $element is provided, the CSS definitions are directly applied to the element. This can be
   * useful if the "style" attribute is shared and cannot be replaced in it's entirety.
   *
   * If propertyPrefix is provided, the prefix will be applied to the properties, e.g. if the prefix is
   * 'label' the properties labelFont, labelBackgroundColor and labelForegroundColor are used instead of
   * just font, backgroundColor and foregroundColor.
   */
  legacyStyle: function(obj, $element, propertyPrefix) {
    var cssColor = '',
      cssBackgroundColor = '',
      cssFontWeight = '',
      cssFontStyle = '',
      cssFontSize = '',
      cssFontFamily = '';

    propertyPrefix = propertyPrefix || '';

    if (typeof obj === 'object' && obj !== null) {
      cssColor = scout.styles.modelToCssColor(obj[scout.strings.lowercaseFirstLetter(propertyPrefix + 'ForegroundColor')]);
      cssBackgroundColor = scout.styles.modelToCssColor(obj[scout.strings.lowercaseFirstLetter(propertyPrefix + 'BackgroundColor')]);

      var fontProperty = scout.strings.lowercaseFirstLetter(propertyPrefix + 'Font');
      if (fontProperty in obj) {
        var fontSpec = this.parseFontSpec(obj[fontProperty]);
        if (fontSpec.bold) {
          cssFontWeight = 'bold';
        }
        if (fontSpec.italic) {
          cssFontStyle = 'italic';
        }
        if (fontSpec.size) {
          cssFontSize = fontSpec.size + 'pt';
        }
        if (fontSpec.name) {
          cssFontFamily = fontSpec.name;
        }
      }
    }

    // Apply CSS properties
    if ($element) {
      $element
        .css('color', cssColor)
        .css('background-color', cssBackgroundColor)
        .css('font-weight', cssFontWeight)
        .css('font-style', cssFontStyle)
        .css('font-size', cssFontSize)
        .css('font-family', cssFontFamily);
    }

    // Build style string
    var style = '';
    if (cssColor) {
      style += 'color: ' + cssColor + '; ';
    }
    if (cssBackgroundColor) {
      style += 'background-color: ' + cssBackgroundColor + '; ';
    }
    if (cssFontWeight) {
      style += 'font-weight: ' + cssFontWeight + '; ';
    }
    if (cssFontStyle) {
      style += 'font-style: ' + cssFontStyle + '; ';
    }
    if (cssFontSize) {
      style += 'font-size: ' + cssFontSize + '; ';
    }
    if (cssFontFamily) {
      style += 'font-family: ' + cssFontFamily + '; ';
    }

    return style;
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Input is expected to be encoded. Output (toString()) is also encoded.
 * If no URL is passed, 'window.location.href' is used as input.
 */
scout.URL = function(url) {
  if (url === undefined) {
    url = window.location.href;
  }
  var urlParts = /^([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/.exec(url || '');
  // encoded
  this.baseUrlRaw = urlParts[1];
  this.queryPartRaw = urlParts[2];
  this.hashPartRaw = urlParts[3];
  // un-encoded (!)
  this.parameterMap = scout.URL._parse(this.queryPartRaw);
};

scout.URL.prototype.getParameter = function(param) {
  if (typeof param !== 'string') {
    throw new Error('Illegal argument type: ' + param);
  }
  var value = this.parameterMap[param];
  if (Array.isArray(value)) {
    return value.sort(scout.URL._sorter);
  }
  return value;
};

scout.URL.prototype.removeParameter = function(param) {
  if (typeof param !== 'string') {
    throw new Error('Illegal argument type: ' + param);
  }
  delete this.parameterMap[param];
  return this;
};

scout.URL.prototype.setParameter = function(param, value) {
  if (typeof param !== 'string') {
    throw new Error('Illegal argument type: ' + param);
  }
  if (param === '') { // ignore empty keys
    return;
  }
  this.parameterMap[param] = value;
  return this;
};

scout.URL.prototype.addParameter = function(param, value) {
  if (typeof param !== 'string') {
    throw new Error('Illegal argument type: ' + param);
  }
  if (param === '') { // ignore empty keys
    return;
  }
  scout.URL._addToMap(this.parameterMap, param, value);
  return this;
};

scout.URL.prototype.toString = function() {
  var result = this.baseUrlRaw;

  if (Object.keys(this.parameterMap).length) {
    // Built a sorted string of all formatted parameterMap entries
    var reconstructedQueryPart = Object.keys(this.parameterMap).sort(scout.URL._sorter).map(function(key) {
      var value = this.getParameter(key);
      // For multiple values, generate a parameter string for each value
      if (Array.isArray(value)) {
        return value.map(
          function(innerKey, innerIndex) {
            return scout.URL._formatQueryParam(key, value[innerIndex]);
          }
        ).join('&');
      }
      return scout.URL._formatQueryParam(key, value);
    }.bind(this)).join('&');
    result += '?' + reconstructedQueryPart;
  }

  if (this.hashPartRaw) {
    result += '#' + this.hashPartRaw;
  }

  return result;
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * Helper function to sort arrays alphabetically, nulls in front
 *
 * @memberOf scout.URL
 */
scout.URL._sorter = function(a, b) {
  return a === null ? -1 : b === null ? 1 : a.toString().localeCompare(b);
};

/**
 * Helper function to build a query parameter with value
 *
 * @memberOf scout.URL
 */
//
scout.URL._formatQueryParam = function(key, value) {
  var s = encodeURIComponent(key);
  if (value !== undefined && value !== null) {
    s += '=' + encodeURIComponent(value);
  }
  return s;
};

/**
 * Helper function to add an key-value pair to a map. If the key is added multiple
 * times, the value is converted to an array.
 *
 * @memberOf scout.URL
 */
scout.URL._addToMap = function(map, key, value) {
  if (map === undefined) {
    throw new Error("Argument 'map' must not be null");
  }
  if (key === undefined) {
    throw new Error("Argument 'key' must not be null");
  }
  if (key in map) {
    var oldValue = map[key];
    if (Array.isArray(oldValue)) {
      oldValue.push(value);
    } else {
      map[key] = [oldValue, value];
    }
  } else {
    map[key] = value;
  }
};

/**
 * Helper function to parse the given (encoded) query string and return
 * it as (un-encoded) map of key-value pairs.
 *
 * @memberOf scout.URL
 */
scout.URL._parse = function(queryPart) {
  var queryString = (queryPart || '').replace(/\+/g, ' '),
    pattern = /([^&=]+)(=?)([^&]*)/g,
    map = {},
    m, key, value;

  while ((m = pattern.exec(queryString))) {
    key = decodeURIComponent(m[1]);
    value = decodeURIComponent(m[3]);
    if (value === '' && m[2] !== '=') {
      value = null;
    }
    scout.URL._addToMap(map, key, value);
  }
  return map;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.filters = {

  /**
   * Ensures the given parameter is an array
   */
  ensure: function(array) {
    if (!array) {
      return [];
    }
    if (!Array.isArray(array)) {
      return [array];
    }
    return array;
  },

  /**
   * Returns a function that always evaluates to 'true'.
   */
  returnTrue: function() {
    return true;
  },

  /**
   * Returns a function that always evaluates to 'false'.
   */
  returnFalse: function() {
    return false;
  },

  /**
   * Returns a filter to accept only elements which are located outside the given container, meaning not the container itself nor one of its children.
   *
   * @param DOM or jQuery container.
   */
  outsideFilter: function(container) {
    container = container instanceof $ ? container[0] : container;
    return function() {
      return this !== container && !$.contains(container, this);
    };
  },

  /**
   * Returns a filter to accept only elements which are not the given element.
   *
   * @param DOM or jQuery element.
   */
  notSameFilter: function(element) {
    element = element instanceof $ ? element[0] : element;
    return function() {
      return this !== element;
    };
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.hAlign = {
  LEFT: 'left',
  RIGHT: 'right',
  CENTER: 'center'
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.aggregation = {

  sumStart: function() {
    return null;
  },

  sumStep: function(currentState, newVal) {
    if (typeof newVal === 'number') {
      currentState = (currentState || 0) + newVal;
    }
    return currentState;
  },

  sumFinish: function(currentState) {
    return currentState;
  },

  sumSymbol: scout.icons.SUM,

  avgStart: function() {
    return {
      sum: 0,
      count: 0
    };
  },

  avgStep: function(currentState, newVal) {
    if (typeof newVal === 'number') {
      currentState.sum += newVal;
      currentState.count += 1;
    }
    return currentState;
  },

  avgFinish: function(currentState) {
    if (currentState.count && currentState.count > 0) {
      return (currentState.sum * 1.0) / currentState.count;
    }
  },

  avgSymbol: scout.icons.AVG,

  minStart: function() {
    return null;
  },

  minStep: function(currentState, newVal) {
    if (typeof newVal === 'number') {
      if (typeof currentState === 'number') {
        if (newVal < currentState) {
          currentState = newVal;
        }
      } else {
        currentState = newVal;
      }
    }
    return currentState;
  },

  minFinish: function(currentState) {
    return currentState;
  },

  minSymbol: scout.icons.MIN,

  maxStart: function() {
    return null;
  },

  maxStep: function(currentState, newVal) {
    if (typeof newVal === 'number') {
      if (typeof currentState === 'number') {
        if (newVal > currentState) {
          currentState = newVal;
        }
      } else {
        currentState = newVal;
      }
    }
    return currentState;
  },

  maxFinish: function(currentState) {
    return currentState;
  },

  maxSymbol: scout.icons.MAX

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BackgroundJobPollingStatus = {
  STOPPED: 'stopped',
  RUNNING: 'running',
  FAILURE: 'failure'
};

scout.BackgroundJobPollingSupport = function(enabled) {
  this.enabled = !!enabled;
  this.status = scout.BackgroundJobPollingStatus.STOPPED;
};

scout.BackgroundJobPollingSupport.prototype.setFailed = function() {
  this.status = scout.BackgroundJobPollingStatus.FAILURE;
};

scout.BackgroundJobPollingSupport.prototype.setRunning = function() {
  this.status = scout.BackgroundJobPollingStatus.RUNNING;
};

scout.BackgroundJobPollingSupport.prototype.setStopped = function() {
  this.status = scout.BackgroundJobPollingStatus.STOPPED;
};

scout.BackgroundJobPollingSupport.prototype.isFailed = function() {
  return (this.status === scout.BackgroundJobPollingStatus.FAILURE);
};

scout.BackgroundJobPollingSupport.prototype.isRunning = function() {
  return (this.status === scout.BackgroundJobPollingStatus.RUNNING);
};

scout.BackgroundJobPollingSupport.prototype.isStopped = function() {
  return (this.status === scout.BackgroundJobPollingStatus.STOPPED);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BusyIndicator = function() {
  scout.BusyIndicator.parent.call(this);
};
scout.inherits(scout.BusyIndicator, scout.Widget);

scout.BusyIndicator.prototype._init = function(options) {
  scout.BusyIndicator.parent.prototype._init.call(this, options);

  this._cancellable = (options.cancellable === undefined ? true : !!options.cancellable);
};

/**
 * @override
 */
scout.BusyIndicator.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.BusyIndicator.prototype._initKeyStrokeContext = function() {
  scout.BusyIndicator.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([
    new scout.ClickActiveElementKeyStroke(this, [
      scout.keys.SPACE, scout.keys.ENTER
    ]),
    new scout.CloseKeyStroke(this, function() {
      return this.$cancelButton;
    }.bind(this))
  ]);
};

scout.BusyIndicator.prototype._render = function($parent) {
  // 1. Render modality glasspanes (must precede adding the busy indicator to the DOM)
  this._glassPaneRenderer = new scout.GlassPaneRenderer(this.session, this, true);
  this._glassPaneRenderer.renderGlassPanes();
  this._glassPaneRenderer.eachGlassPane(function($glassPane) {
    $glassPane.addClass('busy');
  });

  // 2. Render busy indicator (still hidden by CSS, will be shown later in setTimeout.
  // But don't use .hidden, otherwise the box' size cannot be calculated correctly!)
  this.$container = $parent.appendDiv('busyindicator invisible');

  var $handle = this.$container.appendDiv('drag-handle');
  this.$container.makeDraggable($handle);

  this.$content = this.$container.appendDiv('busyindicator-content');
  this.$label = this.$content.appendDiv('busyindicator-label');

  if (this._cancellable) {
    this.$buttons = this.$container.appendDiv('busyindicator-buttons');
    var boxButtons = new scout.BoxButtons(this.$buttons);
    this.$cancelButton = boxButtons.addButton({
      text: this.session.text('Cancel'),
      onClick: this._onClickCancel.bind(this)
    });
    this.$cancelButton.css('width', '100%');
  } else {
    this.$content.addClass('no-buttons');
  }

  // Render properties
  this.$label.text(this.session.text('ui.PleaseWait_'));

  // Prevent resizing when message-box is dragged off the viewport
  this.$container.addClass('calc-helper');
  this.$container.css('min-width', this.$container.width());
  this.$container.removeClass('calc-helper');
  // Now that all texts, paddings, widths etc. are set, we can calculate the position
  this._position();

  // Show busy box with a delay of 2.5 seconds.
  this._busyIndicatorTimeoutId = setTimeout(function() {
    this.$container.removeClass('invisible').addClassForAnimation('animate-open');
    // Validate first focusable element
    // FIXME dwi: maybe, this is not required if problem with single-button form is solved!
    this.session.focusManager.validateFocus();
  }.bind(this), 2500);
};

scout.BusyIndicator.prototype._onClickCancel = function(event) {
  this.trigger('cancel', event);
};

scout.BusyIndicator.prototype._postRender = function() {
  scout.BusyIndicator.parent.prototype._postRender.call(this);
  this.session.focusManager.installFocusContext(this.$container, scout.focusRule.AUTO);
};

scout.BusyIndicator.prototype._remove = function() {
  // Remove busy box (cancel timer in case it was not fired yet)
  clearTimeout(this._busyIndicatorTimeoutId);

  // Remove glasspane
  this._glassPaneRenderer.eachGlassPane(function($glassPane) {
    $glassPane.removeClass('busy');
  });
  this._glassPaneRenderer.removeGlassPanes();
  this.session.focusManager.uninstallFocusContext(this.$container);

  scout.BusyIndicator.parent.prototype._remove.call(this);
};

scout.BusyIndicator.prototype._position = function() {
  this.$container.cssMarginLeft(-this.$container.outerWidth() / 2);
};

/**
 * Used by CloseKeyStroke.js
 */
scout.BusyIndicator.prototype.close = function() {
  if (this.$cancelButton && this.session.focusManager.requestFocus(this.$cancelButton)) {
    this.$cancelButton.focus();
    this.$cancelButton.click();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Event = function(target, type, data) {
  scout.assertParameter('target', target);
  scout.assertParameter('type', type);
  $.extend(this, data);
  this.target = target;
  this.type = type;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Locale = function(model) {
  this.languageTag = model.languageTag;
  this.decimalFormatPatternDefault = model.decimalFormatPatternDefault;
  this.decimalFormatSymbols = model.decimalFormatSymbols;

  if (this.decimalFormatPatternDefault && this.decimalFormatSymbols) {
    this.decimalFormat = new scout.DecimalFormat(model);
  }

  this.dateFormatPatternDefault = model.dateFormatPatternDefault;
  this.dateFormatSymbols = model.dateFormatSymbols;

  if (this.dateFormatPatternDefault && this.dateFormatSymbols) {
    this.dateFormat = new scout.DateFormat(model);
  }
};

scout.PropertyChangeEventFilter = function() {
  this._filterProperties = {};
};

scout.PropertyChangeEventFilter.prototype.addFilterForProperties = function(properties) {
  scout.objects.copyProperties(properties, this._filterProperties);
};

scout.PropertyChangeEventFilter.prototype.filter = function(propertyName, value) {
  if (!this._filterProperties.hasOwnProperty(propertyName)) {
    return false;
  }
  var filterPropertyValue = this._filterProperties[propertyName];
  return scout.objects.equals(filterPropertyValue, value);
};

scout.PropertyChangeEventFilter.prototype.reset = function() {
  this._filterProperties = {};
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Reconnector = function(session) {
  this.session = session;
  this.interval = 3000;
};

scout.Reconnector.prototype.start = function() {
  this._schedulePing();
};

scout.Reconnector.prototype._schedulePing = function() {
  if (this.pingScheduled) {
    return;
  }

  this.pingScheduled = true;
  setTimeout(function() {
    this.ping();
    this.pingScheduled = false;
  }.bind(this), this.interval);
};

scout.Reconnector.prototype.ping = function() {
  this.pingTime = new Date();
  this.session.onReconnecting();

  var request = {
    ping: true
  };

  var ajaxOptions = this.session.defaultAjaxOptions(request);

  $.ajax(ajaxOptions)
    .done(onAjaxDone.bind(this))
    .fail(onAjaxFail.bind(this));

  // --- Helper methods ---

  function onAjaxDone(data) {
    this._onSuccess(data);
  }

  function onAjaxFail(jqXHR, textStatus, errorThrown) {
    this._onFailure(request, jqXHR, textStatus, errorThrown);
  }
};

scout.Reconnector.prototype._onSuccess = function() {
  this.session.onReconnectingSucceeded();
};

scout.Reconnector.prototype._onFailure = function() {
  var minDuration = 1000;
  var pingDuration = new Date().getTime() - this.pingTime.getTime();

  if (pingDuration > minDuration) {
    this._onFailureImpl();
  } else {
    //Wait at least a certain time before informing about connection failure (to prevent flickering of the reconnecting notification)
    setTimeout(function() {
      this._onFailureImpl();
    }.bind(this), minDuration - pingDuration);
  }
};

scout.Reconnector.prototype._onFailureImpl = function() {
  this.session.onReconnectingFailed();
  this._schedulePing();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ResponseQueue = function(session) {
  this.session = session;
  this.queue = [];
  this.lastProcessedSequenceNo = 0;
  this.nextExpectedSequenceNo = 1;

  this.force = false;
  this.forceTimeoutId = null;
};

scout.ResponseQueue.FORCE_TIMEOUT = 10 * 1000; // in ms

scout.ResponseQueue.prototype.add = function(response) {
  var sequenceNo = response && response['#'];

  // Ignore responses that were already processed (duplicate detection)
  if (sequenceNo && sequenceNo <= this.lastProcessedSequenceNo) {
    return;
  }

  // "Fast-forward" the expected sequence no. when a combined response is received
  if (response.combined) {
    this.nextExpectedSequenceNo = Math.max(sequenceNo, this.nextExpectedSequenceNo);
  }

  if (!sequenceNo || this.queue.length === 0) { // Handle messages without sequenceNo in the order they were received
    this.queue.push(response);
  } else {
    // Insert at correct position (ascending order)
    var pos = null;
    for (var i = 0; i < this.queue.length; i++) {
      var el = this.queue[i];
      if (el['#'] && el['#'] > sequenceNo) {
        pos = i;
        break;
      }
    }
    if (pos === null) {
      // no element with bigger seqNo found -> insert as last element
      this.queue.push(response);
    } else {
      // insert at position
      scout.arrays.insert(this.queue, response, pos);
    }
  }
};

scout.ResponseQueue.prototype.process = function(response) {
  if (response) {
    this.add(response);
  }

  // Process the queue in ascending order
  var responseSuccess = true;
  var missingResponse = false;
  var nonProcessedResponses = [];
  for (var i = 0; i < this.queue.length; i++) {
    var el = this.queue[i];
    var sequenceNo = el['#'];

    // For elements with a sequence number, check if they are in the expected order
    if (sequenceNo) {
      if (this.nextExpectedSequenceNo && !this.force && !missingResponse) {
        missingResponse = (this.nextExpectedSequenceNo !== sequenceNo);
      }
      if (missingResponse) {
        // Sequence is not complete, process those messages later
        nonProcessedResponses.push(el);
        continue;
      }
    }

    // Handle the element
    var success = this.session.processJsonResponseInternal(el);
    // Only return success value of the response that was passed to the process() call
    if (response && el === response) {
      responseSuccess = success;
    }

    // Update the expected next sequenceNo
    if (sequenceNo) {
      this.lastProcessedSequenceNo = sequenceNo;
      this.nextExpectedSequenceNo = sequenceNo + 1;
    }
  }
  // Keep non-processed events (because they are not in sequence) in the queue
  this.queue = nonProcessedResponses;

  this._checkTimeout();

  return responseSuccess;
};

scout.ResponseQueue.prototype.size = function() {
  return this.queue.length;
};

scout.ResponseQueue.prototype._checkTimeout = function() {
  // If there are non-processed elements, schedule a job that forces the processing of those
  // elements after a certain timeout to prevent the "blocked forever syndrome" if a response
  // was lost on the network.
  if (this.queue.length === 0) {
    clearTimeout(this.forceTimeoutId);
    this.forceTimeoutId = null;
  } else if (!this.forceTimeoutId) {
    this.forceTimeoutId = setTimeout(function() {
      try {
        var s = '[';
        for (var i = 0; i < this.queue.length; i++) {
          if (i > 0) {
            s += ', ';
          }
          s += (scout.strings.box('#', this.queue[i]['#']) || '<none>');
        }
        s += ']';
        this.session.sendLogRequest('Expected response #' + this.nextExpectedSequenceNo + ' still missing after ' +
            scout.ResponseQueue.FORCE_TIMEOUT + ' ms. Forcing response queue to process ' + this.size() + ' elements: ' + s);
      } catch (error) {
        // nop
      }
      this.force = true;
      try {
        this.process();
      }
      finally {
        this.force = false;
        this.forceTimeoutId = null;
      }
    }.bind(this), scout.ResponseQueue.FORCE_TIMEOUT);
  }
};

scout.ResponseQueue.prototype.prepareRequest = function(request) {
  request['#ACK'] = this.lastProcessedSequenceNo;
};

scout.ResponseQueue.prototype.prepareHttpRequest = function(ajaxOptions) {
  ajaxOptions.headers = ajaxOptions.headers || {};
  ajaxOptions.headers['X-Scout-#ACK'] = this.lastProcessedSequenceNo;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Session = function() {
  this.$entryPoint;
  this.partId = 0;

  this.url = new scout.URL();
  this.userAgent = new scout.UserAgent(scout.device.type, scout.device.supportsTouch());
  this.locale;
  this.textMap = new scout.TextMap();

  this.ready = false; // true after desktop has been completely rendered
  this.unloading = false; // true when 'beforeOnload' event has been triggered
  this.unloaded = false; // true after unload event has been received from the window
  this.loggedOut = false;
  this.inspector = false;
  this.desktop;
  this.layoutValidator = new scout.LayoutValidator();
  this.detachHelper = new scout.DetachHelper(this);
  this.focusManager;
  this.keyStrokeManager;

  // TODO [6.1] BSH/CGU/AWE: Split in "RemoteSession" and "???" (maybe move to App)
  this.uiSessionId; // assigned by server on session startup (OWASP recommendation, see https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern).
  this.clientSessionId = sessionStorage.getItem('scout:clientSessionId');
  this.forceNewClientSession = false;
  this.remote = false;
  this.remoteUrl = 'json';
  this.modelAdapterRegistry = {};
  this.ajaxRequests = [];
  this.asyncEvents = [];
  this.responseQueue = new scout.ResponseQueue(this);
  this.requestsPendingCounter = 0;
  this.suppressErrors = false;
  this.requestTimeoutCancel = 5000; // ms
  this.requestTimeoutPoll = 75000; // ms
  this.requestTimeoutPing = 5000; // ms
  this.backgroundJobPollingSupport = new scout.BackgroundJobPollingSupport(true);

  // This property is enabled by URL parameter &adapterExportEnabled=1. Default is false
  this.adapterExportEnabled = false;
  this._adapterDataCache = {};
  this._busyCounter = 0; // >0 = busy
  this._busyIndicator;
  this._busyIndicatorTimeoutId;
  this._deferred;
  this._fatalMessagesOnScreen = {};

  // FIXME [awe] 6.1 - rename in RootAdapter, should also have a widget, see FIXME in Session#_processEvents
  this.rootAdapter = new scout.ModelAdapter();
  this.rootAdapter.init({
    session: this,
    id: '1',
    objectType: 'GlobalAdapter'
  });
  this.rootAdapter.createWidget({
    session: this,
    id: '1',
    objectType: 'NullWidget'
  }, new scout.NullWidget());
};

/**
 * $entryPoint is required to create a new session.
 *
 * The 'options' argument holds all optional values that may be used during
 * initialization (it is the same object passed to the scout.init() function).
 * The following 'options' properties are read by this constructor function:
 *   [portletPartId]
 *     Optional, default is 0. Necessary when multiple UI sessions are managed
 *     by the same window (portlet support). Each session's partId must be unique.
 *   [clientSessionId]
 *     Identifies the 'client instance' on the UI server. If the property is not set
 *     (which is the default case), the clientSessionId is taken from the browser's
 *     session storage (per browser window, survives F5 refresh of page). If no
 *     clientSessionId can be found, a new one is generated on the server.
 *   [userAgent]
 *     Default: DESKTOP
 *   [backgroundJobPollingEnabled]
 *     Unless websockets is used, this property turns on (default) or off background
 *     polling using an async ajax call together with setTimeout()
 *   [suppressErrors]
 *     Basically added because of Jasmine-tests. When working with async tests that
 *     use setTimeout(), sometimes the Jasmine-Maven plug-in fails and aborts the
 *     build because there were console errors. These errors always happen in this
 *     class. That's why we can skip suppress error handling with this flag.
 *   [focusManagerActive]
 *     Forces the focus manager to be active or not. If undefined, the value is
 *     auto detected by Device.js.
 */
scout.Session.prototype.init = function(model) {
  var options = model || {};

  if (!options.$entryPoint) {
    throw new Error('$entryPoint is not defined');
  }
  this.$entryPoint = options.$entryPoint;
  this.partId = scout.nvl(options.portletPartId, this.partId);
  this.forceNewClientSession = scout.nvl(this.url.getParameter('forceNewClientSession'), options.forceNewClientSession);
  if (this.forceNewClientSession) {
    this.clientSessionId = null;
  } else {
    this.clientSessionId = scout.nvl(options.clientSessionId, this.clientSessionId);
  }
  this.userAgent = scout.nvl(options.userAgent, this.userAgent);
  this.suppressErrors = scout.nvl(options.suppressErrors, this.suppressErrors);
  if (options.locale) {
    this.locale = options.locale;
    this.textMap = scout.texts.get(this.locale.languageTag);
  }
  // FIXME CGU [6.1] flag necessary for modeladapter, remove it
  this.remote = scout.nvl(options.remote, this.remote);
  if (options.backgroundJobPollingEnabled === false) {
    this.backgroundJobPollingSupport.enabled = false;
  }

  // Set inspector flag by looking at URL params. This is required when running in offline mode.
  // In online mode, the server may override this flag again, see _processStartupResponse().
  if (this.url.getParameter('debug') === 'true' || this.url.getParameter('inspector') === 'true') {
    this.inspector = true;
  }

  if (this.url.getParameter('adapterExportEnabled') === 'true') {
    this.adapterExportEnabled = true;
  }

  // Install focus management for this session (cannot be created in constructor, because this.$entryPoint is required)
  this.focusManager = new scout.FocusManager({
    session: this,
    active: options.focusManagerActive
  });
  this.keyStrokeManager = new scout.KeyStrokeManager(this);
};

scout.Session.prototype._throwError = function(message) {
  if (!this.suppressErrors) {
    throw new Error(message);
  }
};

scout.Session.prototype.unregisterModelAdapter = function(modelAdapter) {
  delete this.modelAdapterRegistry[modelAdapter.id];
};

scout.Session.prototype.registerModelAdapter = function(modelAdapter) {
  if (modelAdapter.id === undefined) {
    throw new Error('modelAdapter.id must be defined');
  }
  this.modelAdapterRegistry[modelAdapter.id] = modelAdapter;
};

scout.Session.prototype.getModelAdapter = function(id) {
  return this.modelAdapterRegistry[id];
};

scout.Session.prototype.getWidget = function(adapterId) {
  if (!adapterId) {
    return null;
  }
  if (typeof adapterId !== 'string') {
    throw new Error('typeof adapterId must be string');
  }
  var adapter = this.getModelAdapter(adapterId);
  if (!adapter) {
    return null;
  }
  var widget = adapter.widget;
  return widget;
};

scout.Session.prototype.getOrCreateWidget = function(adapterId, parent) {
  if (!adapterId) {
    return null;
  }
  if (typeof adapterId !== 'string') {
    throw new Error('typeof adapterId must be string');
  }
  var widget = this.getWidget(adapterId);
  if (widget) {
    return widget;
  }
  var adapterData = this._getAdapterData(adapterId);
  if (!adapterData) {
    throw new Error('no adapterData found for adapterId=' + adapterId);
  }
  var adapter = this.createModelAdapter(adapterData);
  return adapter.createWidget(adapterData, parent);
};

scout.Session.prototype.createModelAdapter = function(adapterData) {
  var objectType = adapterData.objectType;
  var createOpts = {};

  var objectTypeParts = objectType.split(scout.ObjectFactory.MODEL_VARIANT_SEPARATOR);
  if (objectTypeParts.length >= 2) {
    objectType = objectTypeParts[0] + 'Adapter' + scout.ObjectFactory.MODEL_VARIANT_SEPARATOR + objectTypeParts[1];
    // If no adapter exists for the given variant then create an adapter without variant.
    // Mostly variant is only essential for the widget, not the adapter
    createOpts.variantLenient = true;
  } else {
    objectType = objectType + 'Adapter';
  }

  // TODO BSH/CGU Add classId/modelClass? Think about if IDs should be different for widgets (maybe prefix with 'w')
  var adapterModel = {
    id: adapterData.id,
    session: this
  };
  var adapter = scout.create(objectType, adapterModel, createOpts);
  $.log.trace('created new adapter ' + adapter);
  return adapter;
};

/**
 * Sends the request asynchronously and processes the response later.<br>
 * Furthermore, the request is sent delayed. If send is called multiple times
 * during the same user interaction, the events are collected and sent in one
 * request at the end of the user interaction
 */
scout.Session.prototype.sendEvent = function(event, delay) {
  delay = delay || 0;

  this.asyncEvents = this._coalesceEvents(this.asyncEvents, event);
  this.asyncEvents.push(event);
  // Use the specified delay, except another event is already scheduled. In that case, use the minimal delay.
  // This ensures that an event with a long delay doesn't hold back another event with a short delay.
  this._asyncDelay = Math.min(delay, scout.nvl(this._asyncDelay, delay));

  clearTimeout(this._sendTimeoutId);
  this._sendTimeoutId = setTimeout(function() {
    this._sendTimeoutId = null;
    this._asyncDelay = null;
    if (this.areRequestsPending()) {
      // do not send if there are any requests pending because the order matters -> prevents race conditions
      return;
    }
    this._sendNow();
  }.bind(this), this._asyncDelay);
};

scout.Session.prototype._sendStartupRequest = function() {
  // Build startup request (see JavaDoc for JsonStartupRequest.java for details)
  var request = {
    startup: true
  };
  if (this.partId) {
    request.partId = this.partId;
  }
  if (this.clientSessionId) {
    request.clientSessionId = this.clientSessionId;
  }
  request.userAgent = this.userAgent;
  request.sessionStartupParams = this._createSessionStartupParams();

  // Send request
  var ajaxOptions = this.defaultAjaxOptions(request);

  $.ajax(ajaxOptions)
    .done(onAjaxDone.bind(this))
    .fail(onAjaxFail.bind(this));

  // ----- Helper methods -----

  function onAjaxDone(data) {
    this._processStartupResponse(data);
  }

  function onAjaxFail(jqXHR, textStatus, errorThrown) {
    this._setApplicationLoading(false);
    this._processErrorResponse(jqXHR, textStatus, errorThrown, request);
  }
};

/**
 * Creates an object to send to the server as "startupParams".
 *
 * Default params:
 * "url":
 *   browser URL (without query and hash part)
 * "geolocationServiceAvailable":
 *   true if browser supports geo location services
 *
 * Additionally, all query parameters from the URL are put in the resulting object.
 */
scout.Session.prototype._createSessionStartupParams = function() {
  var params = {
    url: this.url.baseUrlRaw,
    geolocationServiceAvailable: scout.device.supportsGeolocation()
  };

  // Extract query parameters from URL and put them in the resulting object
  var urlParameterMap = this.url.parameterMap;
  for (var prop in urlParameterMap) {
    params[prop] = urlParameterMap[prop];
  }
  return params;
};

scout.Session.prototype._processStartupResponse = function(data) {
  // Handle errors from server
  if (data.error) {
    this._processErrorJsonResponse(data.error);
    return;
  }

  if (!data.startupData) {
    throw new Error('Missing startupData');
  }

  // Store clientSessionId in sessionStorage (to send the same ID again on page reload)
  try {
    sessionStorage.setItem('scout:clientSessionId', data.startupData.clientSessionId);
  } catch (err) {
    // ignore errors (e.g. this can happen in "private mode" on Safari)
    $.log.error('Error while storing "scout:clientSessionId" in sessionStorage: ' + err);
  }

  // Assign server generated uiSessionId. It must be sent along with all further requests.
  this.uiSessionId = data.startupData.uiSessionId;

  // Destroy UI session on server when page is closed or reloaded
  $(window)
    .on('beforeunload.' + this.uiSessionId, this._onWindowBeforeUnload.bind(this))
    .on('unload.' + this.uiSessionId, this._onWindowUnload.bind(this));

  // Special case: Page must be reloaded on startup (e.g. theme changed)
  if (data.startupData.reloadPage) {
    scout.reloadPage();
    return;
  }

  // Enable inspector mode if server requests it (e.g. when server is running in development mode)
  if (data.startupData.inspector) {
    this.inspector = true;
  }

  // Register UI session
  this.modelAdapterRegistry[this.uiSessionId] = this; // FIXME cgu: maybe better separate session object from event processing, create ClientSession.js?. If yes, desktop should not have rootadapter as parent, see 406

  // Store adapters to adapter data cache
  if (data.adapterData) {
    this._copyAdapterData(data.adapterData);
  }

  // Create the desktop
  this._putLocaleData(data.startupData.locale, data.startupData.textMap);
  // Extract client session data without creating a model adapter for it. It is (currently) only used to transport the desktop's adapterId.
  var clientSessionData = this._getAdapterData(data.startupData.clientSession);
  this.desktop = this.getOrCreateWidget(clientSessionData.desktop, this.rootAdapter.widget);
  var renderDesktopImpl = function() {
    this._renderDesktop();

    // In case the server sent additional events, process them
    if (data.events) {
      this.processingEvents = true;
      try {
        this._processEvents(data.events);
      } finally {
        this.processingEvents = false;
      }
    }

    // Ensure layout is valid (explicitly layout immediately and don't wait for setTimeout to run to make layouting invisible to the user)
    this.layoutValidator.validate();
    this.focusManager.validateFocus();

    // Start poller
    this._resumeBackgroundJobPolling();

    this.ready = true;

    $.log.info('Session initialized. Detected ' + scout.device);
    if ($.log.isDebugEnabled()) {
      $.log.debug('size of _adapterDataCache after session has been initialized: ' + scout.objects.countOwnProperties(this._adapterDataCache));
      $.log.debug('size of modelAdapterRegistry after session has been initialized: ' + scout.objects.countOwnProperties(this.modelAdapterRegistry));
    }
  }.bind(this);

  this.render(renderDesktopImpl);
};

scout.Session.prototype.render = function(renderFunc) {
  // Render desktop after fonts have been preloaded (this fixes initial layouting issues when font icons are not yet ready)
  if (scout.fonts.loadingComplete) {
    renderFunc();
  } else {
    scout.fonts.preloader().then(renderFunc);
  }
};

scout.Session.prototype._sendUnloadRequest = function() {
  var request = {
    uiSessionId: this.uiSessionId,
    unload: true,
    showBusyIndicator: false
  };
  // Send request
  this._sendRequest(request);
};

scout.Session.prototype._sendNow = function() {
  if (this.asyncEvents.length === 0) {
    // Nothing to send -> return
    return;
  }
  var request = {
    uiSessionId: this.uiSessionId,
    events: this.asyncEvents
  };
  // Busy indicator required when at least one event requests it
  request.showBusyIndicator = request.events.some(function(event) {
    return scout.nvl(event.showBusyIndicator, true);
  });
  this.responseQueue.prepareRequest(request);
  // Send request
  this._sendRequest(request);
  this.asyncEvents = [];
};

scout.Session.prototype._coalesceEvents = function(previousEvents, event) {
  if (!event.coalesce) {
    return previousEvents;
  }
  var filter = $.negate(event.coalesce).bind(event);
  return previousEvents.filter(filter);
};

scout.Session.prototype._sendRequest = function(request) {
  if (!request) {
    return; // nothing to send
  }

  if (this.offline) {
    this._handleSendWhenOffline(request);
    return;
  }

  if (request.unload && navigator.sendBeacon) {
    // The unload request must _not_ be sent asynchronously, because the browser would cancel
    // it when the page unload is completed. Because the support for synchronous AJAX request
    // will apparently be dropped eventually, we use the "sendBeacon" method to send the unload
    // request to the server (we don't expect an answer). Not all browsers support this method,
    // therefore we check for its existence and fall back to (legacy) synchronous AJAX call
    // when it is missing. More information:
    // - http://stackoverflow.com/questions/15479103/can-beforeunload-unload-be-used-to-send-xmlhttprequests-reliably
    // - https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/7nKMdg_ALcc
    // - https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon
    var msg = new Blob([this._requestToJson(request)], {
      type: 'application/json; charset=UTF-8'
    });
    navigator.sendBeacon(this._decorateUrl(this.remoteUrl, request), msg);
    return;
  }

  var ajaxOptions = this.defaultAjaxOptions(request);

  var busyHandling = scout.nvl(request.showBusyIndicator, true);
  if (request.unload) {
    ajaxOptions.async = false;
  }
  this._performUserAjaxRequest(ajaxOptions, busyHandling, request);
};

scout.Session.prototype._handleSendWhenOffline = function(request) {
  // Note: Firefox is offline when page is unloaded

  // No need to queue the request when request does not contain events (e.g. log request, unload request)
  if (!request.events) {
    return;
  }

  // Merge request with queued event
  if (this._queuedRequest) {
    if (this._queuedRequest.events) {
      // 1. Remove request events from queued events
      request.events.forEach(function(event) {
        this._queuedRequest.events = this._coalesceEvents(this._queuedRequest.events, event);
      }.bind(this));
      // 2. Add request events to end of queued events
      this._queuedRequest.events = this._queuedRequest.events.concat(request.events);
    } else {
      this._queuedRequest.events = request.events;
    }
  } else {
    this._queuedRequest = request;
  }
  this.layoutValidator.validate();
};

scout.Session.prototype.defaultAjaxOptions = function(request) {
  request = request || {};
  var url = this._decorateUrl(this.remoteUrl, request);

  var ajaxOptions = {
    type: 'POST',
    dataType: 'json',
    contentType: 'application/json; charset=UTF-8',
    cache: false,
    url: url,
    data: this._requestToJson(request)
  };

  // Ensure that certain request don't run forever. When a timeout occurs, the session
  // is put into offline mode. Note that normal requests should NOT be limited, because
  // the server processing might take very long (e.g. long running database query).
  if (request.cancel) {
    ajaxOptions.timeout = this.requestTimeoutCancel;
  }
  if (request.ping) {
    ajaxOptions.timeout = this.requestTimeoutPing;
  }
  if (request.pollForBackgroundJobs) {
    ajaxOptions.timeout = this.requestTimeoutPoll;
  }
  return ajaxOptions;
};

scout.Session.prototype._decorateUrl = function(url, request) {
  var urlHint = null;
  // Add dummy URL parameter as marker (for debugging purposes)
  if (request.unload) {
    urlHint = 'unload';
  } else if (request.pollForBackgroundJobs) {
    urlHint = 'poll';
  } else if (request.ping) {
    urlHint = 'ping';
  } else if (request.cancel) {
    urlHint = 'cancel';
  } else if (request.log) {
    urlHint = 'log';
  } else if (request.syncResponseQueue) {
    urlHint = 'sync';
  }
  if (urlHint) {
    url = new scout.URL(url).addParameter(urlHint).toString();
  }
  return url;
};

scout.Session.prototype._requestToJson = function(request) {
  return JSON.stringify(request, function(key, value) {
    // Replacer function that filter certain properties from the resulting JSON string.
    // See https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
    var ignore =
      (this === request && key === 'showBusyIndicator') ||
      (this instanceof scout.Event && scout.isOneOf(key, 'showBusyIndicator', 'coalesce'));
    return (ignore ? undefined : value);
  });
};

scout.Session.prototype._performUserAjaxRequest = function(ajaxOptions, busyHandling, request) {
  if (busyHandling) {
    this.setBusy(true);
  }
  this.requestsPendingCounter++;

  var jsError = null,
    success = false;

  var xhr = $.ajax(ajaxOptions)
    .done(onAjaxDone.bind(this))
    .fail(onAjaxFail.bind(this))
    .always(onAjaxAlways.bind(this));
  this.registerAjaxRequest(xhr);

  // ----- Helper methods -----

  function onAjaxDone(data) {
    try {
      // Note: remove busy handling _before_ processing the response, otherwise the focus cannot be set
      // correctly, because the glasspane of the busy indicator is still visible.
      if (busyHandling) {
        this.setBusy(false);
      }
      success = this.responseQueue.process(data);
    } catch (err) {
      jsError = jsError || err;
    }
  }

  function onAjaxFail(jqXHR, textStatus, errorThrown) {
    try {
      if (busyHandling) {
        this.setBusy(false);
      }
      this._processErrorResponse(jqXHR, textStatus, errorThrown, request);
    } catch (err) {
      jsError = jsError || err;
    }
  }

  function onAjaxAlways(data, textStatus, errorThrown) {
    this.unregisterAjaxRequest(xhr);
    this.requestsPendingCounter--;
    this.layoutValidator.validate();

    // "success" is false when either
    // a) an HTTP error occurred or
    // b) a JSON response with the error flag set (UI processing error) was returned
    if (success) {
      this._resumeBackgroundJobPolling();
      this._fireRequestFinished(data);

      // Send events that happened while begin offline
      var queuedRequest = this._queuedRequest;
      if (queuedRequest) {
        this._queuedRequest = null;
        this.responseQueue.prepareRequest(queuedRequest);
        this._sendRequest(queuedRequest);
      }

      // If there already is a another request pending, send it now
      // But only if it should not be sent delayed
      if (!this._sendTimeoutId) {
        this._sendNow();
      }
    }

    // Throw previously caught error
    if (jsError) {
      throw jsError;
    }
  }
};

scout.Session.prototype.registerAjaxRequest = function(xhr) {
  if (xhr) {
    this.ajaxRequests.push(xhr);
  }
};

scout.Session.prototype.unregisterAjaxRequest = function(xhr) {
  if (xhr) {
    scout.arrays.remove(this.ajaxRequests, xhr);
  }
};

/**
 * (Re-)starts background job polling when not started yet or when an error occurred while polling.
 * In the latter case, polling is resumed when a user-initiated request has been successful.
 */
scout.Session.prototype._resumeBackgroundJobPolling = function() {
  if (this.backgroundJobPollingSupport.enabled && this.backgroundJobPollingSupport.status !== scout.BackgroundJobPollingStatus.RUNNING) {
    $.log.info('Resume background jobs polling request, status was=' + this.backgroundJobPollingSupport.status);
    this._pollForBackgroundJobs();
  }
};

/**
 * Polls the results of jobs running in the background. Note: we cannot use the _sendRequest method here
 * since we don't want any busy handling in case of background jobs. The request may take a while, since
 * the server doesn't return until either a time-out occurs or there's something in the response when
 * a model job is done and no request initiated by a user is running.
 */
scout.Session.prototype._pollForBackgroundJobs = function() {
  var request = {
    uiSessionId: this.uiSessionId,
    pollForBackgroundJobs: true
  };
  this.responseQueue.prepareRequest(request);

  this.backgroundJobPollingSupport.setRunning();

  var ajaxOptions = this.defaultAjaxOptions(request);

  var xhr = $.ajax(ajaxOptions)
    .done(onAjaxDone.bind(this))
    .fail(onAjaxFail.bind(this))
    .always(onAjaxAlways.bind(this));
  this.registerAjaxRequest(xhr);

  // --- Helper methods ---

  function onAjaxDone(data) {
    if (data.error) {
      // Don't schedule a new polling request, when an error occurs
      // when the next user-initiated request succeeds, we re-enable polling
      // otherwise the polling would ping the server to death in case of an error
      $.log.warn('Polling request failed. Interrupt polling until the next user-initiated request succeeds');
      this.backgroundJobPollingSupport.setFailed();
      if (this.areRequestsPending()) {
        // Add response to queue, handle later by _performUserAjaxRequest()
        this.responseQueue.add(data);
      } else {
        // No user request pending, handle immediately
        this.responseQueue.process(data);
      }
    } else if (data.sessionTerminated) {
      $.log.warn('Session terminated, stopped polling for background jobs');
      // If were are not yet logged out, redirect to the logout URL (the session that initiated the
      // session invalidation will receive a dedicated logout event, redirect is handled there).
      if (!this.loggedOut && data.redirectUrl) {
        this.logout(data.redirectUrl);
      }
    } else {
      if (this.areRequestsPending()) {
        // Add response to queue, handle later by _performUserAjaxRequest()
        this.responseQueue.add(data);
      } else {
        // No user request pending, handle immediately
        this.responseQueue.process(data);
        this.layoutValidator.validate();
      }
      setTimeout(this._pollForBackgroundJobs.bind(this));
    }
  }

  function onAjaxFail(jqXHR, textStatus, errorThrown) {
    this.backgroundJobPollingSupport.setFailed();
    this._processErrorResponse(jqXHR, textStatus, errorThrown, request);
  }

  function onAjaxAlways(data, textStatus, errorThrown) {
    this.unregisterAjaxRequest(xhr);
  }
};

/**
 * Do NOT call this method directly, always use the response queue:
 *
 *   session.responseQueue.process(data);
 *
 * Otherwise, the response queue's expected sequence number will get out of sync.
 */
scout.Session.prototype.processJsonResponseInternal = function(data) {
  var success = false;
  if (data.error) {
    this._processErrorJsonResponse(data.error);
  } else {
    this._processSuccessResponse(data);
    success = true;
  }
  return success;
};

scout.Session.prototype._processSuccessResponse = function(message) {
  if (message.adapterData) {
    this._copyAdapterData(message.adapterData);
  }

  if (message.events) {
    this.processingEvents = true;
    try {
      this._processEvents(message.events);
    } finally {
      this.processingEvents = false;
    }
  }

  if ($.log.isDebugEnabled()) {
    var cacheSize = scout.objects.countOwnProperties(this._adapterDataCache);
    $.log.debug('size of _adapterDataCache after response has been processed: ' + cacheSize);
    cacheSize = scout.objects.countOwnProperties(this.modelAdapterRegistry);
    $.log.debug('size of modelAdapterRegistry after response has been processed: ' + cacheSize);
  }
};

scout.Session.prototype._copyAdapterData = function(adapterData) {
  var count = 0;
  var prop;

  for (prop in adapterData) {
    this._adapterDataCache[prop] = adapterData[prop];
    count++;
  }
  if (count > 0) {
    $.log.debug('Stored ' + count + ' properties in adapterDataCache');
  }
};

/**
 * @param textStatus 'timeout', 'abort', 'error' or 'parseerror' (see http://api.jquery.com/jquery.ajax/)
 */
scout.Session.prototype._processErrorResponse = function(jqXHR, textStatus, errorThrown, request) {
  $.log.error('errorResponse: status=' + jqXHR.status + ', textStatus=' + textStatus + ', errorThrown=' + errorThrown);

  var offline = (
    // Status code = 0 -> no connection
    !jqXHR.status ||
    // Status code >= 12000 comes from windows, see http://msdn.microsoft.com/en-us/library/aa383770%28VS.85%29.aspx. Not sure if it is necessary for IE >= 9.
    jqXHR.status >= 12000 ||
    // Status code 502 = Bad Gateway
    // Status code 503 = Service Unavailable
    // Status code 504 = Gateway Timeout
    // Those codes usually happen when some network component between browser and UI server (e.g. a load balancer)
    // has a short outage, most likely only temporarily. Therefore, we treat them like a lost connection.
    // Otherwise, the polling loop would break, eventually causing the HTTP session to be invalidated on the
    // server due to inactivity. Going offline starts the reconnector which regularly emits ping requests.
    // This allows us to reconnect to the server as soon as the connection is fixed, hopefully saving the
    // HTTP session from inactivation.
    jqXHR.status === 502 ||
    jqXHR.status === 503 ||
    jqXHR.status === 504
  );

  if (offline) {
    if (this.ready) {
      this.goOffline();
      if (!this._queuedRequest && request && !request.pollForBackgroundJobs) {
        this._queuedRequest = request;
      }
      return;
    }
    // Not ready yet (startup request)
    errorThrown = errorThrown || this.optText('ui.ConnectionInterrupted', 'Connection interrupted');
  }

  // Show error message
  var boxOptions = {
    header: this.optText('ui.NetworkError', 'Network error'),
    body: scout.strings.join(' ', (jqXHR.status || ''), errorThrown),
    yesButtonText: this.optText('ui.Reload', 'Reload'),
    yesButtonAction: function() {
      scout.reloadPage();
    },
    noButtonText: (this.ready ? this.optText('ui.Ignore', 'Ignore') : null)
  };
  this.showFatalMessage(boxOptions, jqXHR.status + '.net');
};

scout.Session.prototype._processErrorJsonResponse = function(jsonError) {
  // Default values for fatal message boxes
  var boxOptions = {
    header: this.optText('ui.ServerError', 'Server error') + ' (' + this.optText('ui.ErrorCodeX', 'Code ' + jsonError.code, jsonError.code) + ')',
    body: jsonError.message,
    yesButtonText: this.optText('ui.Reload', 'Reload'),
    yesButtonAction: function() {
      scout.reloadPage();
    }
  };

  // Customize for specific error codes
  if (jsonError.code === 5) { // JsonResponse.ERR_STARTUP_FAILED
    // there are no texts yet if session startup failed
    boxOptions.header = jsonError.message;
    boxOptions.body = null;
    boxOptions.yesButtonText = 'Retry';
  } else if (jsonError.code === 10) { // JsonResponse.ERR_SESSION_TIMEOUT
    boxOptions.header = this.optText('ui.SessionTimeout', boxOptions.header);
    boxOptions.body = this.optText('ui.SessionExpiredMsg', boxOptions.body);
  } else if (jsonError.code === 20) { // JsonResponse.ERR_UI_PROCESSING
    boxOptions.header = this.optText('ui.UnexpectedProblem', boxOptions.header);
    boxOptions.body = scout.strings.join('\n\n',
      this.optText('ui.InternalProcessingErrorMsg', boxOptions.body, ' (' + this.optText('ui.ErrorCodeX', 'Code 20', '20') + ')'),
      this.optText('ui.UiInconsistentMsg', ''));
    boxOptions.noButtonText = this.optText('ui.Ignore', 'Ignore');
  } else if (jsonError.code === 30) { // JsonResponse.ERR_UNSAFE_UPLOAD
    boxOptions.header = this.optText('ui.UnsafeUpload', boxOptions.header);
    boxOptions.body = this.optText('ui.UnsafeUploadMsg', boxOptions.body);
    boxOptions.yesButtonText = this.optText('ui.Ok', 'Ok');
    boxOptions.yesButtonAction = function() {};
  }
  this.showFatalMessage(boxOptions, jsonError.code);
};

scout.Session.prototype._fireRequestFinished = function(message) {
  if (!this._deferred) {
    return;
  }
  if (message.events) {
    for (var i = 0; i < message.events.length; i++) {
      this._deferredEventTypes.push(message.events[i].type);
    }
  }
  if (this.requestsPendingCounter === 0) {
    this._deferred.resolve(this._deferredEventTypes);
    this._deferred = null;
    this._deferredEventTypes = null;
  }
};

/**
 * Shows a UI-only message box.
 *
 * @param options
 *          Options for the message box, see scout.MessageBox
 * @param errorCode
 *          If defined, a second call to this method with the same errorCode will
 *          do nothing. Can be used to prevent double messages for the same error.
 */
scout.Session.prototype.showFatalMessage = function(options, errorCode) {
  if (errorCode) {
    if (this._fatalMessagesOnScreen[errorCode]) {
      return;
    }
    this._fatalMessagesOnScreen[errorCode] = true;
  }
  this._setApplicationLoading(false);

  options = options || {};
  var model = {
      session: this,
      parent: this.desktop || new scout.NullWidget(),
      iconId: options.iconId,
      severity: scout.nvl(options.severity, scout.MessageBox.SEVERITY.ERROR),
      header: options.header,
      body: options.body,
      hiddenText: options.hiddenText,
      yesButtonText: options.yesButtonText,
      noButtonText: options.noButtonText,
      cancelButtonText: options.cancelButtonText
    },
    messageBox = scout.create('MessageBox', model),
    $entryPoint = options.entryPoint || this.$entryPoint;

  messageBox.on('action', function(event) {
    delete this._fatalMessagesOnScreen[errorCode];
    messageBox.destroy();
    var option = event.option;
    if (option === 'yes' && options.yesButtonAction) {
      options.yesButtonAction.apply(this);
    } else if (option === 'no' && options.noButtonAction) {
      options.noButtonAction.apply(this);
    } else if (option === 'cancel' && options.cancelButtonAction) {
      options.cancelButtonAction.apply(this);
    }
  }.bind(this));
  messageBox.render($entryPoint);
};

scout.Session.prototype.uploadFiles = function(target, files, uploadProperties, maxTotalSize, allowedTypes) {
  var formData = new FormData(),
    totalSize = 0;

  if (uploadProperties) {
    $.each(uploadProperties, function(key, value) {
      formData.append(key, value);
    });
  }

  $.each(files, function(index, value) {
    if (!allowedTypes || allowedTypes.length === 0 || scout.isOneOf(value.type, allowedTypes)) {
      totalSize += value.size;
      formData.append('files', value, value.name || '');
    }
  }.bind(this));

  if (!maxTotalSize) {
    maxTotalSize = 5 * 1024 * 1024; // 5 MB as default maximum size
  }

  // very large files must not be sent to server otherwise the whole system might crash (for all users).
  if (totalSize > maxTotalSize) {
    var boxOptions = {
      header: this.text('ui.FileSizeLimitTitle'),
      body: this.text('ui.FileSizeLimit', (maxTotalSize / 1024 / 1024)),
      yesButtonText: this.optText('Ok', 'Ok')
    };

    this.showFatalMessage(boxOptions);
    return;
  }

  var uploadAjaxOptions = {
    async: true,
    type: 'POST',
    url: 'upload/' + this.uiSessionId + '/' + target.id,
    cache: false,
    // Don't touch the data (do not convert it to string)
    processData: false,
    // Do not automatically add content type (otherwise, multipart boundary would be missing)
    contentType: false,
    data: formData
  };
  // Special handling for FormData polyfill
  if (formData.polyfill) {
    formData.applyToAjaxOptions(uploadAjaxOptions);
  }
  this.responseQueue.prepareHttpRequest(uploadAjaxOptions);

  var busyHandling = !this.areRequestsPending();
  this._performUserAjaxRequest(uploadAjaxOptions, busyHandling);
};

scout.Session.prototype.goOffline = function() {
  if (this.offline) {
    return; // already offline
  }
  this.offline = true;

  // Abort pending ajax requests. Because the error handlers alter the "this.ajaxRequest" array,
  // the loop must operate on a copy of the original array.
  this.ajaxRequests.slice().forEach(function(xhr) {
    xhr.abort();
  });

  // In Firefox, the current async polling request is interrupted immediately when the page is unloaded. Therefore,
  // an offline message would appear at once on the desktop. When reloading the page, all elements are cleared anyway,
  // thus we wait some short period of time before displaying the message and starting the reconnector. If
  // we find that goOffline() was called because of request unloading, we skip the unnecessary part. Note that
  // FF doesn't guarantee that _onWindowUnload() is called before this setTimeout() function is called. Therefore,
  // we have to look at another property "unloading" that is set earlier in _onWindowBeforeUnload().
  setTimeout(function() {
    if (this.unloading || this.unloaded) {
      return;
    }
    this.rootAdapter.goOffline();
    if (!this.reconnector) {
      this.reconnector = new scout.Reconnector(this);
    }
    this.reconnector.start();
  }.bind(this), 100);
};

scout.Session.prototype.goOnline = function() {
  this.offline = false;

  var request = {
    uiSessionId: this.uiSessionId,
    syncResponseQueue: true
  };
  this._sendRequest(request); // implies "_resumeBackgroundJobPolling", and also sends queued request

  this.rootAdapter.goOnline();
};

scout.Session.prototype.onReconnecting = function() {
  if (this.desktop) {
    this.desktop.onReconnecting();
  }
};

scout.Session.prototype.onReconnectingSucceeded = function() {
  if (this.desktop) {
    this.desktop.onReconnectingSucceeded();
  }
  this.goOnline();
};

scout.Session.prototype.onReconnectingFailed = function() {
  if (this.desktop) {
    this.desktop.onReconnectingFailed();
  }
};

scout.Session.prototype.listen = function() {
  if (!this._deferred) {
    this._deferred = $.Deferred();
    this._deferredEventTypes = [];
  }
  return this._deferred;
};

scout.Session.prototype.areEventsQueued = function() {
  return this.asyncEvents.length > 0;
};

scout.Session.prototype.areBusyIndicatedEventsQueued = function() {
  return this.asyncEvents.some(function(event) {
    return scout.nvl(event.showBusyIndicator, true);
  });
};

scout.Session.prototype.areResponsesQueued = function() {
  return this.responseQueue.size() > 0;
};

scout.Session.prototype.areRequestsPending = function() {
  return this.requestsPendingCounter > 0;
};

scout.Session.prototype.setBusy = function(busy) {
  if (busy) {
    if (this._busyCounter === 0) {
      this._renderBusy();
    }
    this._busyCounter++;
  } else {
    this._busyCounter--;
    // Do not remove busy indicators if there is a scheduled request which will run immediately to prevent busy cursor flickering
    if (this._busyCounter === 0 && (!this.areBusyIndicatedEventsQueued() || this.offline)) {
      this._removeBusy();
    }
  }
};

scout.Session.prototype._renderBusy = function() {
  if (this._busyIndicatorTimeoutId !== null && this._busyIndicatorTimeoutId !== undefined) {
    // Do not schedule it twice
    return;
  }
  // Don't show the busy indicator immediately. Set a short timer instead (which may be
  // cancelled again if the busy state returns to false in the meantime).
  this._busyIndicatorTimeoutId = setTimeout(function() {
    if (this._busyIndicator) {
      // busy indicator is already showing
      return;
    }
    if (!this.desktop || !this.desktop.rendered) {
      return; // No busy indicator without desktop (e.g. during shutdown)
    }
    this._busyIndicator = scout.create('BusyIndicator', {
      parent: this.desktop
    });
    this._busyIndicator.on('cancel', this._onCancelProcessing.bind(this));
    this._busyIndicator.render(this.$entryPoint);
  }.bind(this), 500);
};

scout.Session.prototype._removeBusy = function() {
  // Clear pending timer
  clearTimeout(this._busyIndicatorTimeoutId);
  this._busyIndicatorTimeoutId = null;

  // Remove busy indicator (if it was already created)
  if (this._busyIndicator) {
    this._busyIndicator.destroy();
    this._busyIndicator = null;
  }
};

scout.Session.prototype._onCancelProcessing = function(event) {
  var busyIndicator = this._busyIndicator;
  if (!busyIndicator) {
    return; // removed in the mean time
  }
  busyIndicator.off('cancel');

  // Set "canceling" state in busy indicator (after 100ms, would not look good otherwise)
  setTimeout(function() {
    if (busyIndicator.rendered) { // not closed yet
      busyIndicator.$label.addClass('cancelled');
      busyIndicator.$buttons.remove();
      busyIndicator.$content.addClass('no-buttons');
    }
  }.bind(this), 100);

  this._sendCancelRequest();
};

scout.Session.prototype._sendCancelRequest = function() {
  this._sendRequest({
    uiSessionId: this.uiSessionId,
    cancel: true
  });
};

/**
 * Sends a request containing the error message for logging purpose.
 * The request is sent immediately (does not await pending requests)
 */
scout.Session.prototype.sendLogRequest = function(message) {
  var request = {
    uiSessionId: this.uiSessionId,
    log: true,
    message: message
  };
  if (this.currentEvent) {
    request.event = {
      target: this.currentEvent.target,
      type: this.currentEvent.type
    };
  }

  // Do not use _sendRequest to make sure a log request has no side effects and will be sent only once
  var ajaxOptions = this.defaultAjaxOptions(request);

  var xhr = $.ajax(ajaxOptions)
    .always(onAjaxAlways.bind(this));
  this.registerAjaxRequest(xhr);

  // ----- Helper methods -----

  function onAjaxAlways(data, textStatus, errorThrown) {
    this.unregisterAjaxRequest(xhr);
  }
};

scout.Session.prototype._setApplicationLoading = function(applicationLoading) {
  if (applicationLoading) {
    this._applicationLoadingTimeoutId = setTimeout(function() {
      if (!this.desktop || !this.desktop.rendered) {
        this.$entryPoint.appendDiv('application-loading').hide().fadeIn();
      }
    }.bind(this), 500);
  } else {
    clearTimeout(this._applicationLoadingTimeoutId);
    this._applicationLoadingTimeoutId = null;
    this.$entryPoint.children('.application-loading').remove();
  }
};

scout.Session.prototype._processEvents = function(events) {
  var i = 0;
  while (i < events.length) {
    var event = events[i];
    this.currentEvent = event;

    var adapter = this.getModelAdapter(event.target);
    if (!adapter) {
      // Sometimes events seem to happen "too early", e.g. when a "requestFocus" event for a field is
      // encountered before the "showForm" event has been processed. If the target adapter cannot be
      // resolved, we try the other events first, expecting them to trigger the creation of the event
      // adapter. As soon as a event could be processed successfully, we try our postponed event again.
      $.log.debug("Postponing '" + event.type + "' for adapter with ID " + event.target);
      i++;
      continue;
    }
    // Remove the successful event and reset the pointer to the start of the remaining events (to
    // retry previously postponed events).
    events.splice(i, 1);
    i = 0;

    $.log.debug("Processing event '" + event.type + "' for adapter with ID " + event.target);
    adapter.onModelEvent(event);
    adapter.resetEventFilters();
  }
  this.currentEvent = null;

  // If there are still events whose target could not be resolved, throw an error
  if (events.length) {
    throw new Error('Could not resolve event targets: [' + events.map(function(el) {
      return '"' + el.target + '"';
    }).join(', ') + ']');
  }
};

scout.Session.prototype.start = function() {
  $.log.info('Session starting...');

  // After a short time, display a loading animation (will be removed again in _renderDesktop)
  this._setApplicationLoading(true);

  // Send startup request
  this._sendStartupRequest();
};

// FIXME [awe] 6.1 : discuss with C.GU. Session requires same methods as ModelAdapter, but it is NOT a ModelAdapter currently
// guess we need a SessionAdapter.js - I noticed this in a jasmine test where _processEvents is called an the adapter is the Session
// (event.type=disposeAdapter), also see resetEventFilters method
scout.Session.prototype.onModelEvent = function(event) {
  if (event.type === 'localeChanged') {
    this._onLocaleChanged(event);
  } else if (event.type === 'logout') {
    this._onLogout(event);
  } else if (event.type === 'disposeAdapter') {
    this._onDisposeAdapter(event);
  } else if (event.type === 'reloadPage') {
    this._onReloadPage(event);
  } else {
    $.log.warn('Model action "' + event.type + '" is not supported by UI session');
  }
};

scout.Session.prototype.resetEventFilters = function() {
  // NOP
};

scout.Session.prototype._onLocaleChanged = function(event) {
  this._putLocaleData(event.locale, event.textMap);
};

scout.Session.prototype._putLocaleData = function(locale, textMap) {
  this.locale = new scout.Locale(locale);
  this.textMap = new scout.TextMap(textMap);
  // FIXME bsh: inform components to reformat display text? also check Collator in scout.comparators.TEXT
};

scout.Session.prototype._renderDesktop = function() {
  this.desktop.render(this.$entryPoint);
  this.desktop.invalidateLayoutTree(false);
  this._setApplicationLoading(false);
};

scout.Session.prototype._onLogout = function(event) {
  this.logout(event.redirectUrl);
};

scout.Session.prototype.logout = function(logoutUrl) {
  this.loggedOut = true;
  // TODO [6.1] BSH Check if there is a better solution (e.g. send a flag from server "action" = [ "redirect" | "closeWindow" ])
  if (this.forceNewClientSession) {
    this.desktop.$container.window(true).close();
  } else {
    // remember current url to not lose query parameters
    try {
      sessionStorage.setItem('scout:loginUrl', window.location.href);
    } catch (err) {
      // ignore errors (e.g. this can happen in "private mode" on Safari)
      $.log.error('Error while storing "scout:loginUrl" in sessionStorage: ' + err);
    }
    // Clear everything and reload the page. We wrap that in setTimeout() to allow other events to be executed normally before.
    setTimeout(function() {
      scout.reloadPage({
        redirectUrl: logoutUrl
      });
    }.bind(this));
  }
};

scout.Session.prototype._onDisposeAdapter = function(event) {
  // Model adapter was disposed on server -> dispose it on the UI, too
  var adapter = this.getModelAdapter(event.adapter);
  if (adapter) { // adapter may be null if it was never sent to the UI, e.g. a form that was opened and closed in the same request
    adapter.destroy();
  }
};

scout.Session.prototype._onReloadPage = function(event) {
  // Don't clear the body, because other events might be processed before the reload and
  // it could cause errors when all DOM elements are already removed.
  scout.reloadPage({
    clearBody: false
  });
};

scout.Session.prototype._onWindowBeforeUnload = function() {
  $.log.info('Session before unloading...');
  // TODO BSH Cancel pending requests

  // Set a flag that indicates unloading before _onWindowUnload() is called.
  // See goOffline() why this is necessary.
  this.unloading = true;
  setTimeout(function() {
    // Because there is no callback when the unloading was cancelled, we always
    // reset the flag after a short period of time.
    this.unloading = false;
  }.bind(this), 200);
};

scout.Session.prototype._onWindowUnload = function() {
  $.log.info('Session unloading...');
  this.unloaded = true;

  // Close popup windows
  if (this.desktop) {
    this.desktop.formController.closePopupWindows();
  }

  // Destroy UI session on server (only when the server did not not initiate the logout,
  // otherwise the UI session would already be disposed)
  if (!this.loggedOut) {
    this._sendUnloadRequest();
  }
};

/**
 * Returns the adapter-data sent with the JSON response from the adapter-data cache. Note that this operation
 * removes the requested element from the cache, thus you cannot request the same ID twice. Typically once
 * you've requested an element from this cache an adapter for that ID is created and stored in the adapter
 * registry which too exists on this session object.
 */
scout.Session.prototype._getAdapterData = function(id) {
  var adapterData = this._adapterDataCache[id];
  var deleteAdapterData = !this.adapterExportEnabled;
  if (deleteAdapterData) {
    delete this._adapterDataCache[id];
  }
  return adapterData;
};

scout.Session.prototype.getAdapterData = function(id) {
  return this._adapterDataCache[id];
};

scout.Session.prototype.text = function(textKey) {
  return scout.TextMap.prototype.get.apply(this.textMap, arguments);
};

scout.Session.prototype.optText = function(textKey, defaultValue) {
  return scout.TextMap.prototype.optGet.apply(this.textMap, arguments);
};

scout.Session.prototype.textExists = function(textKey) {
  return this.textMap.exists(textKey);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.UserAgent = function(deviceType, touch) {
  if (!deviceType) {
    throw new Error('deviceType needs to be defined');
  }
  this.deviceType = deviceType;
  this.touch = scout.nvl(touch, false);
};

scout.WidgetEventTypeFilter = function() {
  this.filters = [];
};

scout.WidgetEventTypeFilter.prototype.addFilter = function(filterFunc) {
  this.filters.push(filterFunc);
};

scout.WidgetEventTypeFilter.prototype.addFilterForEventType = function(eventType) {
  this.filters.push(function(event) {
    return event.type === eventType;
  });
};

scout.WidgetEventTypeFilter.prototype.filter = function(event) {
  return this.filters.some(function(filterFunc) {
    return filterFunc(event);
  });
};

scout.WidgetEventTypeFilter.prototype.reset = function() {
  this.filters = [];
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * This file contains helpers for graphical operations and JavaScript ports from java.awt classes
 */
scout.graphics = {

  /**
   * Returns the preferred size of $elem.
   * Precondition: $elem and it's parents must not be hidden (display: none. Visibility: hidden would be ok
   * because in this case the browser reserves the space the element would be using).
   *
   * OPTION                   DEFAULT VALUE   DESCRIPTION
   * ------------------------------------------------------------------------------------------------------
   * includeMargin            false           Whether to include $elem's margins in the returned size.
   *
   * useCssSize               false           If true, the width and height properties are set to '' while
   *                                          measuring, thus allowing existing CSS rules to influence the
   *                                          sizes. If set to false, the sizes are set to 'auto' or the
   *                                          corresponding hint values (see below).
   *
   * widthHint                undefined       If useCssSize is false, this value is used as width (in pixels)
   *                                          instead of 'auto'. Useful to get the preferred height for a
   *                                          given width.
   *
   * heightHint               undefined       Same as 'widthHint' but for the height.
   *
   * restoreScrollPositions   true            By default, the $elem's scrolling position is saved and restored
   *                                          during the execution of this method (because applying
   *                                          intermediate styles for measurement might change the current
   *                                          position). If the calling method does that itself, you should
   *                                          set this option to false to prevent overriding the stored
   *                                          scrolling position in $elem's data attributes.
   *
   * @memberOf scout.graphics
   */
  prefSize: function($elem, options) {
    // Return 0/0 if element is not displayed (display: none).
    // We don't use isVisible by purpose because isVisible returns false for elements with visibility: hidden which is wrong here (we would like to be able to measure hidden elements)
    if (!$elem[0] || $elem.isDisplayNone()) {
      return new scout.Dimension(0, 0);
    }

    options = options || {};

    var defaults = {
      includeMargin: false,
      useCssSize: false,
      widthHint: undefined,
      heightHint: undefined,
      restoreScrollPositions: true
    };
    options = $.extend({}, defaults, options);

    var oldStyle = $elem.attr('style');
    var oldScrollLeft = $elem.scrollLeft();
    var oldScrollTop = $elem.scrollTop();

    if (options.restoreScrollPositions) {
      scout.scrollbars.storeScrollPositions($elem);
    }

    // UseCssSize is necessary if the css rules have a fix height or width set.
    // Otherwise setting the width/height to auto could result in a different size
    var newWidth = (options.useCssSize ? '' : scout.nvl(options.widthHint, 'auto'));
    var newHeight = (options.useCssSize ? '' : scout.nvl(options.heightHint, 'auto'));

    // modify properties which prevent reading the preferred size
    $elem.css({
      'width': newWidth,
      'height': newHeight
    });

    // measure
    var bcr = $elem[0].getBoundingClientRect();
    var prefSize = new scout.Dimension(bcr.width, bcr.height);
    if (options.includeMargin) {
      prefSize.width += $elem.cssMarginX();
      prefSize.height += $elem.cssMarginY();
    }

    // reset the modified style attribute
    $elem.attrOrRemove('style', oldStyle);
    $elem.scrollLeft(oldScrollLeft);
    $elem.scrollTop(oldScrollTop);

    if (options.restoreScrollPositions) {
      scout.scrollbars.restoreScrollPositions($elem);
    }

    // Ensure resulting numbers are integers. getBoundingClientRect() might correctly return fractional values
    // (because of the browser's sub-pixel rendering). However, if we use those numbers to set the size
    // of an element using CSS, it gets rounded or cut off. The behavior is not defined amongst different
    // browser engines.
    // Example:
    // - Measured size from this method:      h = 345.239990234375
    // - Set the size to an element:          $elem.css('height', h + 'px')
    // - Results:
    //     IE                   <div id="elem" style="height: 345.23px">     [Fractional part cut off after two digits]
    //     Firefox & Chrome     <div id="elem" style="height: 345.24px">     [Fractional part rounded to three digits]
    prefSize.width = Math.ceil(prefSize.width);
    prefSize.height = Math.ceil(prefSize.height);

    return prefSize;
  },

  /* These functions are designed to be used with box-sizing:box-model. The only reliable
   * way to set the size of a component when working with box model is to use css('width/height'...)
   * in favor of width/height() functions.
   */
  /**
   * Returns the size of the component, insets included.
   * @param includeMargin when set to true, returned dimensions include margins of component, default is <code>false</code>.
   */
  getSize: function($comp, includeMargin) {
    if (!$comp[0] || $comp.isDisplayNone()) {
      return new scout.Dimension(0, 0);
    }
    var bcr = $comp[0].getBoundingClientRect();
    var size = new scout.Dimension(bcr.width, bcr.height);
    if (scout.nvl(includeMargin, false)) {
      size.width += $comp.cssMarginX();
      size.height += $comp.cssMarginY();
    }
    // see comments in prefSize()
    size.width = Math.ceil(size.width);
    size.height = Math.ceil(size.height);
    return size;
  },

  setSize: function($comp, vararg, height) {
    var size = vararg instanceof scout.Dimension ?
      vararg : new scout.Dimension(vararg, height);
    $comp
      .cssWidth(size.width)
      .cssHeight(size.height);
  },

  /**
   * Returns the size of a visible component or (0,0) when component is invisible.
   */
  getVisibleSize: function($comp, includeMargin) {
    if ($comp.length === 1 && $comp.isVisible()) {
      return scout.graphics.getSize($comp, includeMargin);
    } else {
      return new scout.Dimension(0, 0);
    }
  },

  /**
   * Returns the inset-dimensions of the component (padding, margin, border).
   */
  getInsets: function($comp, options) {
    options = options || {};
    var i,
      directions = ['top', 'right', 'bottom', 'left'],
      insets = [0, 0, 0, 0],
      includeMargin = options.includeMargin !== undefined ? options.includeMargin : false,
      includePadding = options.includePadding !== undefined ? options.includePadding : true,
      includeBorder = options.includeBorder !== undefined ? options.includeBorder : true;

    for (i = 0; i < directions.length; i++) {
      if (includeMargin) {
        insets[i] += $comp.cssPxValue('margin-' + directions[i]);
      }
      if (includePadding) {
        insets[i] += $comp.cssPxValue('padding-' + directions[i]);
      }
      if (includeBorder) {
        insets[i] += $comp.cssPxValue('border-' + directions[i] + '-width');
      }
    }
    return new scout.Insets(insets[0], insets[1], insets[2], insets[3]);
  },

  getMargins: function($comp) {
    return scout.graphics.getInsets($comp, {
      includeMargin: true,
      includePadding: false,
      includeBorder: false
    });
  },

  getBounds: function($comp) {
    var parseCssPosition = function(prop) {
      var value = $comp.css(prop);
      return 'auto' === value ? 0 : parseInt(value, 10);
    };
    return new scout.Rectangle(
      parseCssPosition('left'),
      parseCssPosition('top'),
      $comp.outerWidth(true),
      $comp.outerHeight(true));
  },

  setBounds: function($comp, vararg, y, width, height) {
    var bounds = vararg instanceof scout.Rectangle ?
      vararg : new scout.Rectangle(vararg, y, width, height);
    $comp
      .cssLeft(bounds.x)
      .cssTop(bounds.y)
      .cssWidth(bounds.width)
      .cssHeight(bounds.height);
  },

  /**
   * Sets the location (CSS properties left, top) of the component.
   * @param vararg integer value for X position OR instance of scout.Point
   * @param y (optional) integer value for Y position
   * @returns
   */
  setLocation: function($comp, vararg, y) {
    var point = vararg instanceof scout.Point ?
      vararg : new scout.Point(vararg, y);
    $comp
      .cssLeft(point.x)
      .cssTop(point.y);
  },

  bounds: function($elem, includeSizeMargin, includePosMargin) {
    //FIXME cgu: merge with getBounds, ask awe why parseCssPosition is used, or rename getBounds to cssBounds
    return scout.graphics._bounds($elem, $elem.position(), includeSizeMargin, includePosMargin);
  },

  offsetBounds: function($elem, includeSizeMargin, includePosMargin) {
    return scout.graphics._bounds($elem, $elem.offset(), includeSizeMargin, includePosMargin);
  },

  _bounds: function($elem, pos, includeSizeMargin, includePosMargin) {
    if (includePosMargin) {
      pos.left += $elem.cssMarginLeft();
      pos.top += $elem.cssMarginTop();
    }
    var size = scout.graphics.getSize($elem, includeSizeMargin);
    return new scout.Rectangle(pos.left, pos.top, size.width, size.height);
  },

  debugOutput: function($comp) {
    if (!$comp) {
      return '$comp is undefined';
    }
    if (!($comp instanceof $)) {
      $comp = $($comp);
    }
    if ($comp.length === 0) {
      return '$comp doesn\t match any elements';
    }
    var attrs = '';
    if ($comp.attr('id')) {
      attrs += 'id=' + $comp.attr('id');
    }
    if ($comp.attr('class')) {
      attrs += ' class=' + $comp.attr('class');
    }
    if ($comp.attr('data-modelclass')) {
      attrs += ' data-modelclass=' + $comp.attr('data-modelclass');
    }
    if (attrs.length === 0) {
      var html = scout.nvl($comp.html(), '');
      if (html.length > 30) {
        html = html.substring(0, 30) + '...';
      }
      attrs = html;
    }
    return 'Element[' + attrs.trim() + ']';
  }
};

/**
 * JavaScript port from java.awt.Point.
 */
scout.Point = function(x, y) {
  this.x = x || 0;
  this.y = y || 0;
};

scout.Point.prototype.toString = function() {
  return 'Point[x=' + this.x + ' y=' + this.y + ']';
};

scout.Point.prototype.equals = function(o) {
  if (!o) {
    return false;
  }
  return (this.x === o.x && this.y === o.y);
};

scout.Point.prototype.clone = function(o) {
  return new scout.Point(this.x, this.y);
};

/**
 * JavaScript port from java.awt.Dimension.
 * @param vararg width (number) or otherDimension (scout.Dimension)
 * @param height number or undefined (when vararg is scout.Dimension)
 */
scout.Dimension = function(vararg, height) {
  if (vararg instanceof scout.Dimension) {
    this.width = vararg.width;
    this.height = vararg.height;
  } else {
    this.width = vararg || 0;
    this.height = height || 0;
  }
};

scout.Dimension.prototype.toString = function() {
  return 'Dimension[width=' + this.width + ' height=' + this.height + ']';
};

scout.Dimension.prototype.equals = function(o) {
  if (!o) {
    return false;
  }
  return (this.width === o.width && this.height === o.height);
};

scout.Dimension.prototype.clone = function() {
  return new scout.Dimension(this.width, this.height);
};

scout.Dimension.prototype.subtract = function(insets) {
  return new scout.Dimension(
    this.width - insets.horizontal(),
    this.height - insets.vertical());
};

scout.Dimension.prototype.add = function(insets) {
  return new scout.Dimension(
    this.width + insets.horizontal(),
    this.height + insets.vertical());
};

/**
 * JavaScript port from java.awt.Rectangle.
 */
scout.Rectangle = function(x, y, width, height) {
  this.x = x || 0;
  this.y = y || 0;
  this.width = width || 0;
  this.height = height || 0;
};

scout.Rectangle.prototype.equals = function(o) {
  if (!o) {
    return false;
  }
  return (this.x === o.x && this.y === o.y && this.width === o.width && this.height === o.height);
};

scout.Rectangle.prototype.toString = function() {
  return 'Rectangle[x=' + this.x + ' y=' + this.y + ' width=' + this.width + ' height=' + this.height + ']';
};

scout.Rectangle.prototype.clone = function(o) {
  return new scout.Rectangle(this.x, this.y, this.width, this.height);
};

scout.Rectangle.prototype.center = function() {
  return new scout.Point(this.x + this.width / 2, this.y + this.height / 2);
};

scout.Rectangle.prototype.contains = function(x, y) {
  return y >= this.y && y < this.y + this.height && x >= this.x && x < this.x + this.width;
};

scout.Rectangle.prototype.subtract = function(insets) {
  return new scout.Rectangle(
    this.x + insets.left,
    this.y + insets.top,
    this.width - insets.right,
    this.height - insets.bottom);
};

scout.Rectangle.prototype.union = function(r) {
  var tx2 = this.width;
  var ty2 = this.height;
  if (tx2 < 0 || ty2 < 0) {
    // This rectangle has negative dimensions...
    // If r has non-negative dimensions then it is the answer.
    // If r is non-existant (has a negative dimension), then both
    // are non-existant and we can return any non-existant rectangle
    // as an answer.  Thus, returning r meets that criterion.
    // Either way, r is our answer.
    return new scout.Rectangle(r.x, r.y, r.width, r.height);
  }
  var rx2 = r.width;
  var ry2 = r.height;
  if (rx2 < 0 || ry2 < 0) {
    return new scout.Rectangle(this.x, this.y, this.width, this.height);
  }
  var tx1 = this.x;
  var ty1 = this.y;
  tx2 += tx1;
  ty2 += ty1;
  var rx1 = r.x;
  var ry1 = r.y;
  rx2 += rx1;
  ry2 += ry1;
  if (tx1 > rx1) {
    tx1 = rx1;
  }
  if (ty1 > ry1) {
    ty1 = ry1;
  }
  if (tx2 < rx2) {
    tx2 = rx2;
  }
  if (ty2 < ry2) {
    ty2 = ry2;
  }
  tx2 -= tx1;
  ty2 -= ty1;
  // tx2,ty2 will never underflow since both original rectangles
  // were already proven to be non-empty
  // they might overflow, though...
  if (tx2 > Number.MAX_VALUE) {
    tx2 = Number.MAX_VALUE;
  }
  if (ty2 > Number.MAX_VALUE) {
    ty2 = Number.MAX_VALUE;
  }
  return new scout.Rectangle(tx1, ty1, tx2, ty2);
};

/**
 * JavaScript port from java.awt.Insets.
 */
scout.Insets = function(top, right, bottom, left) {
  this.top = top || 0;
  this.right = right || 0;
  this.bottom = bottom || 0;
  this.left = left || 0;
};

scout.Insets.prototype.equals = function(o) {
  return this.top === o.top &&
    this.right === o.right &&
    this.bottom === o.bottom &&
    this.left === o.left;
};

scout.Insets.prototype.horizontal = function() {
  return this.right + this.left;
};

scout.Insets.prototype.vertical = function() {
  return this.top + this.bottom;
};

scout.Insets.prototype.toString = function() {
  return 'Insets[top=' + this.top + ' right=' + this.right + ' bottom=' + this.bottom + ' left=' + this.left + ']';
};

scout.Insets.prototype.clone = function() {
  return new scout.Insets(this.top, this.right, this.bottom, this.left);
};

/**
 * JavaScript port from java.util.TreeSet.
 */
scout.TreeSet = function() {
  this.array = [];
  this.properties = {};
};

scout.TreeSet.prototype.add = function(value) {
  if (!this.contains(value)) {
    this.array.push(value);
    this.array.sort();
    this.properties[value] = true;
  }
};

scout.TreeSet.prototype.size = function() {
  return this.array.length;
};

scout.TreeSet.prototype.contains = function(value) {
  return (value in this.properties);
};

scout.TreeSet.prototype.last = function() {
  return this.array[this.array.length - 1];
};

/**
 * HtmlEnvironment is used in place of org.eclipse.scout.rt.ui.swing.DefaultSwingEnvironment.
 */
scout.HtmlEnvironment = {
  // -------------------------------
  // IMPORTANT:
  // Some of the following constants are also defined in sizes.css. If you change
  // them, be sure to apply them at both places. (Remember to consider margins)
  // -------------------------------
  formRowHeight: 30, // @logical-grid-height
  formRowGap: 10,
  formColumnWidth: 420,
  formColumnGap: 32, // 40 pixel actual form gap - fieldMandatoryIndicatorWidth
  smallColumnGap: 4,
  fieldLabelWidth: 140,
  fieldMandatoryIndicatorWidth: 8, // @mandatory-indicator-width
  fieldStatusWidth: 20 // @field-status-width
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Abstract layout class with functions used by all layout algorithms.
 * Subclasses of AbstactLayout.js must implement the following functions:
 * - layout
 * - preferredLayoutSize
 */
scout.AbstractLayout = function() { //
};

/**
 * Called when layout is invalidated. An implementation should delete cached layout-information
 * when it is invalidated.
 *
 * May be implemented by sub-class.
 */
scout.AbstractLayout.prototype.invalidate = function() { //
};

/**
 * Layouts children of the given $container, according to the implemented layout algorithm.
 * The implementation should call setSize or setBounds on its children.
 *
 * Must be implemented by sub-class.
 */
scout.AbstractLayout.prototype.layout = function($container) { //
};

/**
 * Returns the preferred size of the given $container.
 *
 * @return scout.Dimension preferred size
 */
scout.AbstractLayout.prototype.preferredLayoutSize = function($container, options) {
  return scout.graphics.prefSize($container, options);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Wrapper for a JQuery selector. Used as replacement for javax.swing.JComponent.
 */
scout.HtmlComponent = function($comp, session) {
  if (!session) {
    throw new Error('session must be defined for ' + this.debug());
  }
  this.$comp = $comp;
  this.layout = new scout.NullLayout();
  this.layoutData;
  this.valid = false;

  /**
   * Flag to indicate that the component has been layouted at least once. Invalidation should NOT reset this flag.
   */
  this.layouted = false;

  /**
   * May be set to temporarily disable invalidation (e.g. if the component gets modified during the layouting process)
   */
  this.suppressInvalidate = false;

  /**
   * Set pixelBasedSizing to false if your component automatically adjusts its size,
   * e.g. by using CSS styling -> setSize won't be called.
   */
  this.pixelBasedSizing = true;
  this.session = session;
};

/**
 * Returns the parent or $comp or null when $comp has no parent.
 * Creates a new instance of HtmlComponent if the parent DOM element has no linked instance yet.
 */
scout.HtmlComponent.prototype.getParent = function() {
  var $parent = this.$comp.parent();
  if ($parent.length === 0) {
    return null;
  } else {
    return scout.HtmlComponent.optGet($parent);
  }
};

/**
 * @returns true if the given htmlComponent is an ancestor, false if not
 */
scout.HtmlComponent.prototype.isDescendantOf = function(htmlComp) {
  var $parent = this.$comp.parent();
  while ($parent.length > 0) {
    if (scout.HtmlComponent.optGet($parent) === htmlComp) {
      return true;
    }
    $parent = $parent.parent();
  }
  return false;
};

/**
 * Computes the preferred height if the component is scrollable and returns it if it is greater than the actual size.
 * If it is not scrollable, the actual height is returned.<p>
 * The returned width is always the actual width because there are no horizontal scrollbars.
 */
scout.HtmlComponent.prototype.getAvailableSize = function() {
  var size = this.getSize(),
    prefSize;

  if (this.scrollable) {
    prefSize = this.getPreferredSize();
    if (prefSize.height > size.height) {
      size.height = prefSize.height;
    }
  }

  return size;
};

/**
 * Invalidates the component (sets the valid property to false).
 */
scout.HtmlComponent.prototype.invalidateLayout = function() {
  this.valid = false;
  if (this.layout) {
    this.layout.invalidate();
  }
};

/**
 * Calls the layout of the component to layout its children but only if the component is not valid.
 * @exception when component has no layout
 */
scout.HtmlComponent.prototype.validateLayout = function() {
  if (!this.layout) {
    throw new Error('Called layout() but component has no layout');
  }
  if (!this.valid) {
    this.layouting = true;
    this.layout.layout(this.$comp);
    this.layouting = false;
    this.layouted = true;
    // Save size for later use (necessary if pixelBasedSizing is set to false)
    this.size = this.getSize();
    this.valid = true;
  }
};

/**
 * Performs invalidateLayout() and validateLayout() subsequently.
 */
scout.HtmlComponent.prototype.revalidateLayout = function() {
  this.invalidateLayout();
  this.validateLayout();
};

/**
 * Invalidates the component-tree up to the next validate root, but only if invalidateParents is set to true.
 */
scout.HtmlComponent.prototype.invalidateLayoutTree = function(invalidateParents) {
  if (this.suppressInvalidate) {
    return;
  }
  if (scout.nvl(invalidateParents, true)) {
    this.session.layoutValidator.invalidateTree(this); // will call invalidateLayout(), which sets this.valid = false
  } else {
    this.valid = false;
    this.session.layoutValidator.invalidate(this);
  }
};

/**
 * Layouts all invalid components
 */
scout.HtmlComponent.prototype.validateLayoutTree = function() {
  this.session.layoutValidator.validate();
};

/**
 * Performs invalidateLayoutTree() and validateLayoutTree() subsequently.
 */
scout.HtmlComponent.prototype.revalidateLayoutTree = function() {
  this.invalidateLayoutTree();
  this.validateLayoutTree();
};

/**
 * Marks the end of the parent invalidation. <p>
 * A component is a validate root if its size does not depend on the visibility or bounds of its children.<p>
 * Example: It is not necessary to relayout the whole form if just the label of a form field gets invisible.
 * Only the form field container needs to be relayouted. In this case the form field container is the validate root.
 */
scout.HtmlComponent.prototype.isValidateRoot = function() {
  if (this.validateRoot) {
    return true;
  }
  if (!this.layoutData || !this.layoutData.isValidateRoot) {
    return false;
  }
  return this.layoutData.isValidateRoot();
};

/**
 * Sets the given layout.
 */
scout.HtmlComponent.prototype.setLayout = function(layout) {
  this.layout = layout;
  if (layout.cssClass) {
    this.$comp.addClass(layout.cssClass);
  }
};

/**
 * Returns the preferred size of the component, insets included.
 * @exception When component has no layout
 */
scout.HtmlComponent.prototype.getPreferredSize = function(options) {
  if (!this.layout) {
    throw new Error('Called getPreferredSize() but component has no layout');
  }
  options = options || {};
  var prefSize = this.layout.preferredLayoutSize(this.$comp, options);
  $.log.trace('(HtmlComponent#getPreferredSize) ' + this.debug() + ' widthHint=' + options.widthHint + ' heightHint=' + options.heightHint + ' preferredSize=' + prefSize);
  return prefSize;
};

/**
 * Returns the inset-dimensions of the component (padding and border, no margin).
 */
scout.HtmlComponent.prototype.getInsets = function(options) {
  return scout.graphics.getInsets(this.$comp, options);
};

scout.HtmlComponent.prototype.getMargins = function() {
  return scout.graphics.getMargins(this.$comp);
};

/**
 * Returns the size of the component, insets included.
 * @param includeMargins when set to true, returned dimensions include margins of component
 */
scout.HtmlComponent.prototype.getSize = function(includeMargins) {
  return scout.graphics.getSize(this.$comp, includeMargins);
};

/**
 * Sets the size of the component, insets included. Which means: the method subtracts the components insets
 * from the given size before setting the width/height of the component.
 */
scout.HtmlComponent.prototype.setSize = function(size) {
  if (!this.isAttachedAndVisible()) {
    // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong
    return;
  }
  var oldSize = this.size;
  if (!size.equals(oldSize)) {
    this.invalidateLayout();
  }
  if (this.pixelBasedSizing) {
    scout.graphics.setSize(this.$comp, size);
  }
  this.validateLayout();
};

scout.HtmlComponent.prototype.getBounds = function() {
  return scout.graphics.getBounds(this.$comp);
};

scout.HtmlComponent.prototype.offsetBounds = function() {
  return scout.graphics.offsetBounds(this.$comp);
};

/**
 * Delegation to scout.graphics.setLocation
 * @param location scout.Point
 */
scout.HtmlComponent.prototype.setLocation = function(location) {
  scout.graphics.setLocation(this.$comp, location);
};

scout.HtmlComponent.prototype.setBounds = function(bounds) {
  if (!this.isAttachedAndVisible()) {
    // don't invalidate the layout if component is invisible because sizes may not be read correctly and therefore prefSize will be wrong
    return;
  }
  var oldBounds = this.getBounds();
  if (!oldBounds.equals(bounds)) {
    this.invalidateLayout();
  }
  scout.graphics.setBounds(this.$comp, bounds);
  this.validateLayout();
};

/**
 * Sets the component to its preferred size.
 */
scout.HtmlComponent.prototype.pack = function() {
  var preferredSize = this.getPreferredSize();
  this.setSize(preferredSize);
};

/**
 * Checks whether $comp is in the DOM or has been removed or detached.<br>
 * Also returns false if the $comp does not belong to a window (defaultView) anymore. This may happen if it belonged to a popup window which is now closed
 */
scout.HtmlComponent.prototype.isAttached = function() {
  return this.$comp.isAttached() && this.$comp.window(true);
};

scout.HtmlComponent.prototype.isVisible = function() {
  return this.$comp.isVisible();
};

scout.HtmlComponent.prototype.isAttachedAndVisible = function() {
  return this.isAttached() && this.isVisible();
};

scout.HtmlComponent.prototype.debug = function() {
  return scout.graphics.debugOutput(this.$comp);
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * Creates a new HtmlComponent and links it to the given $comp element, so it can be
 * retrieved again with scout.HtmlComponent.get($comp).
 *
 * @memberOf scout.HtmlComponent
 */
scout.HtmlComponent.install = function($comp, session) {
  if (!$comp) {
    throw new Error('Missing argument "$comp"');
  }
  if (!session) {
    throw new Error('Missing argument "session"');
  }

  var htmlComp = new scout.HtmlComponent($comp, session);
  // link DOM element with the new instance
  $comp.data('htmlComponent', htmlComp);

  return htmlComp;
};

/**
 * Static method to get the HtmlComponent associated with the given DOM $comp.
 * Throws an error when data 'htmlComponent' is not set.
 *
 * @memberOf scout.HtmlComponent
 */
scout.HtmlComponent.get = function($comp) {
  var htmlComp = this.optGet($comp);
  if (!htmlComp) {
    var details = '';
    if ($comp) {
      details = '\nClass: ' + $comp.attr('class');
      details += '\nId: ' + $comp.attr('id');
      details += '\nAttached: ' + $comp.isAttached();
    }
    throw new Error('data "htmlComponent" is undefined.' + details);
  }
  return htmlComp;
};

/**
 * @memberOf scout.HtmlComponent
 */
scout.HtmlComponent.optGet = function($comp) {
  return $comp && $comp.data('htmlComponent');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.LayoutConstants = {
  MIN: 0,
  PREF: 1,
  MAX: 2,
  EPS: 1e-6
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.LayoutValidator = function() {
  this._invalidComponents = [];
  this._validateTimeoutId = null;
  this._postValidateFunctions = [];
};

scout.LayoutValidator.prototype.invalidateTree = function(htmlComp) {
  var validateRoot,
    htmlCompParent = htmlComp;

  // Mark every parent as invalid until validate root
  while (htmlCompParent) {
    htmlComp = htmlCompParent;
    htmlComp.invalidateLayout();
    if (htmlComp.isValidateRoot()) {
      validateRoot = htmlComp;
      break;
    }
    htmlCompParent = htmlComp.getParent();
  }

  if (!htmlCompParent) {
    validateRoot = htmlComp;
  }

  this.invalidate(validateRoot);
};

scout.LayoutValidator.prototype.invalidate = function(htmlComp) {
  var position = 0;
  // Don't insert if already inserted
  if (this._invalidComponents.indexOf(htmlComp) >= 0) {
    return;
  }

  // Make sure it will be inserted before any descendant
  // This prevents multiple layouting of the descendant
  this._invalidComponents.forEach(function(invalidComponent, i) {
    if (invalidComponent.isDescendantOf(htmlComp)) {
      return;
    }
    position++;
  }, this);

  // Add validate root to list of invalid components. These are the starting point for a subsequent call to validate().
  scout.arrays.insert(this._invalidComponents, htmlComp, position);

  // Schedule validation
  if (this._validateTimeoutId === null) {
    this._validateTimeoutId = setTimeout(function() {
      this.validate();
    }.bind(this));
  }
};

/**
 * Layouts all invalid components (as long as they haven't been removed).
 */
scout.LayoutValidator.prototype.validate = function() {
  clearTimeout(this._validateTimeoutId);
  this._validateTimeoutId = null;
  this._invalidComponents.slice().forEach(function(comp) {
    if (comp.isAttached()) { // don't layout components which don't exist anymore or are detached from the DOM
      comp.validateLayout();
      scout.arrays.remove(this._invalidComponents, comp);
    }
  }, this);
  this._postValidateFunctions.slice().forEach(function(func) {
    func();
    scout.arrays.remove(this._postValidateFunctions, func);
  }, this);
};

/**
 * Removes those components from this._invalidComponents which have the given container as ancestor.
 * The idea is to remove all components whose ancestor is about to be removed from the DOM.
 */
scout.LayoutValidator.prototype.cleanupInvalidComponents = function($parentContainer){
  this._invalidComponents.slice().forEach(function(comp){
    if (comp.$comp.closest($parentContainer).length > 0){
      scout.arrays.remove(this._invalidComponents, comp);
    }
  }, this);
};

/**
 * Runs the given function at the end of validate().
 */
scout.LayoutValidator.prototype.schedulePostValidateFunction = function(func) {
  if (func) {
    this._postValidateFunctions.push(func);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * JavaScript port of org.eclipse.scout.rt.ui.swing.form.fields.SwingScoutFormFieldGridData.
 * Merged with the base class LogicalGridData (for the default values). We don't need the base
 * class standalone, since we only used LGL for the group-box body in Html UI.
 */
scout.LogicalGridData = function(vararg) {
  this.gridx = 0;
  this.gridy = 0;
  this.gridw = 1;
  this.gridh = 1;
  this.weightx = 0.0;
  this.weighty = 0.0;
  this.useUiWidth = false;
  this.useUiHeight = false;
  this.widthHint = 0;
  this.heightHint = 0;
  this.horizontalAlignment = -1;
  this.verticalAlignment = -1;
  this.fillHorizontal = true;
  this.fillVertical = true;
  this.topInset = 0;

  if (vararg instanceof scout.LogicalGridData) {
    // copy properties from LGD template
    scout.objects.copyProperties(vararg, this);
  } else if (vararg instanceof scout.Widget) {
    // work with widget / validate
    this.widget = vararg;
  } else {
    // NOP - default CTOR
  }
};

scout.LogicalGridData.prototype.validate = function() {
  if (!this.widget) {
    return;
  }

  var data = this.widget.gridData;
  // setup constraints
  this.gridx = data.x;
  this.gridy = data.y;
  this.gridw = data.w;
  this.gridh = data.h;
  this.weightx = data.weightX;
  this.weighty = data.weightY;
  if (this.weightx < 0) {
    // inherit
    this.weightx = Math.max(1.0, this.gridw);
  }
  if (this.weighty < 0) {
    // inherit
    this.weighty = this._inheritWeightY();
  }
  this.useUiWidth = data.useUiWidth;
  this.useUiHeight = data.useUiHeight;
  this.horizontalAlignment = data.horizontalAlignment;
  this.verticalAlignment = data.verticalAlignment;
  this.fillHorizontal = data.fillHorizontal;
  this.fillVertical = data.fillVertical;
  this.widthHint = data.widthInPixel;
  this.heightHint = data.heightInPixel;

  // when having the label on top, the row height has to be increased
  if (this.widget.labelVisible && this.widget.$label && this.widget.labelPosition === scout.FormField.LABEL_POSITION_TOP) {
    this.logicalRowHeightAddition = scout.HtmlEnvironment.formRowHeight;
  }
};

scout.LogicalGridData.prototype._inheritWeightY = function() {
  var d = this._inheritWeightYRec(this.widget);
  if (d === null) {
    var data = this.widget.gridData;
    if (data.weightY >= 0) {
      d = data.weightY;
    } else {
      d = data.h >= 2 ? data.h : 0;
    }
  }
  return d;
};

scout.LogicalGridData.prototype._inheritWeightYRec = function(f) {
  var found = false,
    sumWy = 0;
  if (f instanceof scout.CompositeField) {
    var i, inheritWeightY, child, children = f.getFields();
    for (i = 0; i < children.length; i++) {
      child = children[i];
      if (child.visible) {
        var data = child.gridData;
        if (data.weightY < 0) {
          inheritWeightY = this._inheritWeightYRec(child);
          if (inheritWeightY !== null) {
            found = true;
            sumWy += inheritWeightY;
          }
        } else {
          found = true;
          sumWy += data.weightY;
        }
      }
    }
  } else {
    sumWy = (f.gridData.h >= 2 ? f.gridData.h : 0);
    found = true;
  }
  if (found) {
    return sumWy;
  } else {
    return null;
  }
};

scout.LogicalGridData.prototype.isValidateRoot = function() {
  return !this.useUiHeight && !this.useUiWidth && this.fillVertical && this.fillHorizontal;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * JavaScript port of org.eclipse.scout.rt.ui.swing.LogicalGridLayout.
 */
scout.LogicalGridLayout = function(hgap, vgap) {
  scout.LogicalGridLayout.parent.call(this);
  this.cssClass = 'logical-grid-layout';
  this.validityBasedOnContainerSize = new scout.Dimension();
  this.valid = false;
  this.m_info;
  this.m_hgap = hgap || 0;
  this.m_vgap = vgap || 0;
};
scout.inherits(scout.LogicalGridLayout, scout.AbstractLayout);

scout.LogicalGridLayout.prototype._verifyLayout = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    containerSize = htmlContainer.getSize();

  if (!this.valid || !this.validityBasedOnContainerSize.equals(containerSize)) {
    this.validityBasedOnContainerSize = containerSize;
    this.validateLayout($container);
    this.valid = true;
  }
};

/**
 * @override
 */
scout.LogicalGridLayout.prototype.invalidate = function() {
  this.valid = false;
};

scout.LogicalGridLayout.prototype.validateLayout = function($container) {
  var visibleComps = [], visibleCons = [], cons;

  $container.children().each(function (idx, elem) {
    var $comp = $(elem);
    var htmlComp = scout.HtmlComponent.optGet($comp);
    if (htmlComp && $comp.isVisible()) {
      visibleComps.push($comp);
      cons = htmlComp.layoutData;
      cons.validate();
      visibleCons.push(cons);
    }
  });
  this.m_info = new scout.LogicalGridLayoutInfo(visibleComps, visibleCons, this.m_hgap, this.m_vgap);
  $.log.trace('(LogicalGridLayout#validateLayout) $container=' + scout.HtmlComponent.get($container).debug());
};

scout.LogicalGridLayout.prototype.layout = function($container) {
  this._verifyLayout($container);
  var htmlContainer = scout.HtmlComponent.get($container),
    containerSize = htmlContainer.getAvailableSize(),
    containerInsets = htmlContainer.getInsets();
  $.log.trace('(LogicalGridLayout#layout) container ' + htmlContainer.debug() + ' size=' + containerSize + ' insets=' + containerInsets);
  var cellBounds = this.m_info.layoutCellBounds(containerSize, containerInsets);

  // Set bounds of components
  var r1, r2, r, d, $comp, i, htmlComp, data, delta, margins;
  for (i = 0; i < this.m_info.$components.length; i++) {
    $comp = this.m_info.$components[i];
    htmlComp = scout.HtmlComponent.get($comp);
    data = this.m_info.gridDatas[i];
    r1 = cellBounds[data.gridy][data.gridx];
    r2 = cellBounds[data.gridy + data.gridh - 1][data.gridx + data.gridw - 1];
    r = r1.union(r2);
    if (data.topInset > 0) {
      r.y += data.topInset;
      r.height -= data.topInset;
    }
    margins = htmlComp.getMargins();
    r.width -= margins.horizontal();
    r.height -= margins.vertical();
    if (data.fillHorizontal && data.fillVertical) {
      // ok
    } else {
      d = this.m_info.compSize[i];
      if (!data.fillHorizontal && d.width < r.width) {
        delta = r.width - d.width;
        r.width = d.width;
        if (data.horizontalAlignment === 0) {
          // Do ceil the result as other layout managers of Java also handle floating calculation results that way.
          // This is important if being used in conjunction with another layout manager.
          // E.g. the editable checkbox in inline table cell is a JCheckBox and rendered by LogicalGridLayout,
          // whereas the default boolean representation in a table cell is simply an image on a label positioned by
          // default layout manager. If switching in between of edit and non-edit mode, the widget would bounce otherwise.
          r.x += Math.ceil(delta / 2.0);
        } else if (data.horizontalAlignment > 0) {
          r.x += delta;
        }
      }
      if (!data.fillVertical && d.height < r.height) {
        delta = r.height - d.height;
        if (data.heightHint === 0) {
          r.height = d.height;
        } else {
          r.height = data.heightHint;
        }
        if (data.verticalAlignment === 0) {
          // Do ceil the result as other layout managers of Java also handle floating calculation results that way.
          // This is important if being used in conjunction with another layout manager.
          // E.g. the editable checkbox in inline table cell is a JCheckBox and rendered by LogicalGridLayout,
          // whereas the default boolean representation in a table cell is simply an image on a label positioned by
          // default layout manager. If switching in between of edit and non-edit mode, the widget would bounce otherwise.
          r.y += Math.ceil(delta / 2.0);
        } else if (data.verticalAlignment > 0) {
          r.y += delta;
        }
      }
    }
    $.log.trace('(LogicalGridLayout#layout) comp=' + htmlComp.debug() + ' bounds=' + r);
    htmlComp.setBounds(r);
  }
};

scout.LogicalGridLayout.prototype.preferredLayoutSize = function($container) {
  return this.getLayoutSize($container, scout.LayoutConstants.PREF);
};

scout.LogicalGridLayout.prototype.getLayoutSize = function($container, sizeflag) {
  this._verifyLayout($container);
  var dim = new scout.Dimension();
  // w
  var i, w, h, useCount = 0;
  for (i = 0; i < this.m_info.cols; i++) {
    w = this.m_info.width[i][sizeflag];
    if (useCount > 0) {
      dim.width += this.m_hgap;
    }
    dim.width += w;
    useCount++;
  }
  // h
  useCount = 0;
  for (i = 0; i < this.m_info.rows; i++) {
    h = this.m_info.height[i][sizeflag];
    if (useCount > 0) {
      dim.height += this.m_vgap;
    }
    dim.height += h;
    useCount++;
  }
  // insets
  var insets = scout.HtmlComponent.get($container).getInsets();
  dim.width += insets.horizontal();
  dim.height += insets.vertical();
  return dim;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * JavaScript port of org.eclipse.scout.rt.ui.swing.LogicalGridLayoutInfo.
 */
scout.LogicalGridLayoutInfo = function($components, cons, hgap, vgap) {
  this.gridDatas = [];
  this.$components = $components;
  this.cols;
  this.rows;
  this.width = [];
  this.height = [];
  this.weightX;
  this.weightY;
  this.m_hgap = hgap;
  this.m_vgap = vgap;
  this.m_cellBounds = [];

  // create a modifiable copy of the grid datas
  var i, gd, x, y;
  for (i = 0; i < cons.length; i++) {
    this.gridDatas[i] = new scout.LogicalGridData(cons[i]);
  }
  if ($components.length === 0) {
    this.cols = 0;
    this.rows = 0;
    this.width = [];
    this.height = [];
    this.weightX = [];
    this.weightY = [];
    return;
  }
  // eliminate unused rows and columns
  var usedCols = new scout.TreeSet();
  var usedRows = new scout.TreeSet();
  // ticket 86645 use member gridDatas instead of param cons
  for (i = 0; i < this.gridDatas.length; i++) {
    gd = this.gridDatas[i];
    if (gd.gridx < 0) {
      gd.gridx = 0;
    }
    if (gd.gridy < 0) {
      gd.gridy = 0;
    }
    if (gd.gridw < 1) {
      gd.gridw = 1;
    }
    if (gd.gridh < 1) {
      gd.gridh = 1;
    }
    for (x = gd.gridx; x < gd.gridx + gd.gridw; x++) {
      usedCols.add(x);
    }
    for (y = gd.gridy; y < gd.gridy + gd.gridh; y++) {
      usedRows.add(y);
    }
  }
  var maxCol = usedCols.last();
  for (x = maxCol; x >= 0; x--) {
    if (!usedCols.contains(x)) {
      // eliminate column
      // ticket 86645 use member gridDatas instead of param cons
      for (i = 0; i < this.gridDatas.length; i++) {
        gd = this.gridDatas[i];
        if (gd.gridx > x) {
          gd.gridx--;
        }
      }
    }
  }
  var maxRow = usedRows.last();
  for (y = maxRow; y >= 0; y--) {
    if (!usedRows.contains(y)) {
      // eliminate row
      // ticket 86645 use member gridDatas instead of param cons
      for (i = 0; i < this.gridDatas.length; i++) {
        gd = this.gridDatas[i];
        if (gd.gridy > y) {
          // ticket 86645
          gd.gridy--;
        }
      }
    }
  }
  //
  this.cols = usedCols.size();
  this.rows = usedRows.size();
  this.width = [];
  this.height = [];
  this.weightX = [];
  this.weightY = [];
  $.log.trace('(LogicalGridLayoutInfo#CTOR) $components.length=' + $components.length + ' usedCols=' + this.cols + ' usedRows=' + this.rows);
  this._initializeInfo(hgap, vgap);
};

scout.LogicalGridLayoutInfo.prototype._initializeInfo = function(hgap, vgap) {
  var comp,
    compCount = this.$components.length,
    compSize = [];
  // cache component sizes and cleanup constraints
  var $comp, cons, d;
  for (var i = 0; i < compCount; i++) {
    $comp = this.$components[i];
    cons = this.gridDatas[i];
    if (cons.useUiHeight || cons.useUiWidth || !cons.fillVertical || !cons.fillHorizontal) {
      // Only read preferred size if really needed by the logical grid layout
      d = this.uiSizeInPixel($comp);
      if ($.log.isTraceEnabled()) {
        comp = scout.HtmlComponent.optGet($comp);
        $.log.trace('(LogicalGridLayoutInfo#initializeInfo $comp = ' + comp ? comp.debug() : '' + ' size=' + d);
      }
    } else {
      d = new scout.Dimension(0, 0);
    }
    if (cons.widthHint > 0) {
      d.width = cons.widthHint;
    }
    if (cons.heightHint > 0) {
      d.height = cons.heightHint;
    }
    compSize[i] = d;
    if (cons.gridx < 0) {
      cons.gridx = 0;
    }
    if (cons.gridy < 0) {
      cons.gridy = 0;
    }
    if (cons.gridw < 1) {
      cons.gridw = 1;
    }
    if (cons.gridh < 1) {
      cons.gridh = 1;
    }
    if (cons.gridx >= this.cols) {
      cons.gridx = this.cols - 1;
    }
    if (cons.gridy >= this.rows) {
      cons.gridy = this.rows - 1;
    }
    if (cons.gridx + cons.gridw - 1 >= this.cols) {
      cons.gridw = this.cols - cons.gridx;
    }
    if (cons.gridy + cons.gridh >= this.rows) {
      cons.gridh = this.rows - cons.gridy;
    }
  }
  this.compSize = compSize;
  this._initializeColumns(compSize, hgap);
  this._initializeRows(compSize, vgap);
};

scout.LogicalGridLayoutInfo.prototype._initializeColumns = function(compSize, hgap) {
  var compCount = compSize.length;
  var prefWidths = scout.arrays.init(this.cols, 0);
  var fixedWidths = scout.arrays.init(this.cols, false);
  var i, j, k, prefw, cons;
  for (i = 0; i < compCount; i++) {
    cons = this.gridDatas[i];
    if (cons.gridw === 1) {
      if (cons.widthHint > 0) {
        prefw = cons.widthHint;
      } else if (cons.useUiWidth) {
        prefw = compSize[i].width;
      } else {
        prefw = this.logicalWidthInPixel(cons);
      }
      prefw = Math.floor(prefw);
      for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {
        prefWidths[j] = Math.max(prefWidths[j], prefw);
        if (cons.weightx === 0) {
          fixedWidths[j] = true;
        }
      }
    }
  }
  for (i = 0; i < compCount; i++) {
    cons = this.gridDatas[i];
    if (cons.gridw > 1) {
      var hSpan = cons.gridw;
      var spanWidth = 0;
      var distWidth;
      // pref
      for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {
        if (!fixedWidths[j]) {
          spanWidth += prefWidths[j];
        }
      }
      if (cons.widthHint > 0) {
        distWidth = cons.widthHint - spanWidth - (hSpan - 1) * hgap;
      } else if (cons.useUiWidth) {
        distWidth = compSize[i].width - spanWidth - (hSpan - 1) * hgap;
      } else {
        distWidth = this.logicalWidthInPixel(cons) - spanWidth - (hSpan - 1) * hgap;
      }
      if (distWidth > 0) {
        var equalWidth = Math.floor((distWidth + spanWidth) / hSpan);
        var remainder = (distWidth + spanWidth) % hSpan;
        var last = -1;
        for (j = cons.gridx; j < cons.gridx + cons.gridw && j < this.cols; j++) {
          if (fixedWidths[j]) {
            prefWidths[last = j] = prefWidths[j];
          } else {
            prefWidths[last = j] = Math.max(equalWidth, prefWidths[j]);
          }
          if (cons.weightx === 0) {
            fixedWidths[j] = true;
          }
        }
        if (last > -1) {
          prefWidths[last] += remainder;
        }
      }
    }
  }

  var lc = scout.LayoutConstants;
  for (i = 0; i < this.cols; i++) {
    this.width[i] = [];
    if (fixedWidths[i]) {
      this.width[i][lc.MIN] = prefWidths[i];
      this.width[i][lc.PREF] = prefWidths[i];
      this.width[i][lc.MAX] = prefWidths[i];
    } else {
      this.width[i][lc.MIN] = 0; // must be exactly 0!
      this.width[i][lc.PREF] = prefWidths[i];
      this.width[i][lc.MAX] = 10240;
    }
  }

  // averaged column weights, normalized so that sum of weights is equal to
  // 1.0
  for (i = 0; i < this.cols; i++) {
    if (fixedWidths[i]) {
      this.weightX[i] = 0;
    } else {
      var weightSum = 0;
      var weightCount = 0;
      for (k = 0; k < compCount; k++) {
        cons = this.gridDatas[k];
        if (cons.weightx > 0 && cons.gridx <= i && i <= cons.gridx + cons.gridw - 1) {
          weightSum += (cons.weightx / cons.gridw);
          weightCount++;
        }
      }
      this.weightX[i] = (weightCount > 0 ? weightSum / weightCount : 0);
    }
  }
  var sumWeightX = 0;
  for (i = 0; i < this.cols; i++) {
    sumWeightX += this.weightX[i];
  }
  if (sumWeightX >= 1e-6) {
    var f = 1.0 / sumWeightX;
    for (i = 0; i < this.cols; i++) {
      this.weightX[i] = this.weightX[i] * f;
    }
  }
};

scout.LogicalGridLayoutInfo.prototype._initializeRows = function(compSize, vgap) {
  var compCount = compSize.length;
  var prefHeights = scout.arrays.init(this.rows, 0);
  var fixedHeights = scout.arrays.init(this.rows, false);
  var i, j, k, prefh, cons;
  for (i = 0; i < compCount; i++) {
    cons = this.gridDatas[i];
    if (cons.gridh === 1) {
      if (cons.heightHint > 0) {
        prefh = cons.heightHint;
      } else if (cons.useUiHeight) {
        prefh = compSize[i].height;
      } else {
        prefh = this.logicalHeightInPixel(cons);
      }
      prefh = Math.floor(prefh);
      for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {
        prefHeights[j] = Math.max(prefHeights[j], prefh);
        if (cons.weighty === 0) {
          fixedHeights[j] = true;
        }
      }
    }
  }
  for (i = 0; i < compCount; i++) {
    cons = this.gridDatas[i];
    if (cons.gridh > 1) {
      var vSpan = cons.gridh;
      var spanHeight = 0;
      var distHeight;
      // pref
      for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {
        if (!fixedHeights[j]) {
          spanHeight += prefHeights[j];
        }
      }
      if (cons.heightHint > 0) {
        distHeight = cons.heightHint - spanHeight - (vSpan - 1) * vgap;
      } else if (cons.useUiHeight) {
        distHeight = compSize[i].height - spanHeight - (vSpan - 1) * vgap;
      } else {
        distHeight = this.logicalHeightInPixel(cons) - spanHeight - (vSpan - 1) * vgap;
      }
      if (distHeight > 0) {
        var equalHeight = Math.floor((distHeight + spanHeight) / vSpan);
        var remainder = (distHeight + spanHeight) % vSpan;
        var last = -1;
        for (j = cons.gridy; j < cons.gridy + cons.gridh && j < this.rows; j++) {
          if (fixedHeights[j]) {
            prefHeights[last = j] = prefHeights[j];
          } else {
            prefHeights[last = j] = Math.max(equalHeight, prefHeights[j]);
          }
          if (cons.weighty === 0) {
            fixedHeights[j] = true;
          }
        }
        if (last > -1) {
          prefHeights[last] += remainder;
        }
      }
    }
  }

  var lc = scout.LayoutConstants;
  for (i = 0; i < this.rows; i++) {
    this.height[i] = [];
    if (fixedHeights[i]) {
      this.height[i][lc.MIN] = prefHeights[i];
      this.height[i][lc.PREF] = prefHeights[i];
      this.height[i][lc.MAX] = prefHeights[i];
    } else {
      this.height[i][lc.MIN] = 0; // must be exactly 0!
      this.height[i][lc.PREF] = prefHeights[i];
      this.height[i][lc.MAX] = 10240;
    }
  }

  // averaged row weights, normalized so that sum of weights is equal to 1.0
  for (i = 0; i < this.rows; i++) {
    if (fixedHeights[i]) {
      this.weightY[i] = 0;
    } else {
      var weightSum = 0;
      var weightCount = 0;
      for (k = 0; k < compCount; k++) {
        cons = this.gridDatas[k];
        if (cons.weighty > 0 && cons.gridy <= i && i <= cons.gridy + cons.gridh - 1) {
          weightSum += (cons.weighty / cons.gridh);
          weightCount++;
        }
      }
      this.weightY[i] = (weightCount > 0 ? weightSum / weightCount : 0);
    }
  }
  var sumWeightY = 0;
  for (i = 0; i < this.rows; i++) {
    sumWeightY += this.weightY[i];
  }
  if (sumWeightY >= 1e-6) {
    var f = 1.0 / sumWeightY;
    for (i = 0; i < this.rows; i++) {
      this.weightY[i] = this.weightY[i] * f;
    }
  }
};

scout.LogicalGridLayoutInfo.prototype.layoutCellBounds = function(size, insets) {
  var w = this.layoutSizes(size.width - insets.horizontal() - Math.max(0, (this.cols - 1) * this.m_hgap), this.width, this.weightX);
  var h = this.layoutSizes(size.height - insets.vertical() - Math.max(0, (this.rows - 1) * this.m_vgap), this.height, this.weightY);
  this.m_cellBounds = scout.arrays.init(this.rows, null);
  var y = insets.top,
    r, x, c;
  for (r = 0; r < this.rows; r++) {
    x = insets.left;
    this.m_cellBounds[r] = scout.arrays.init(this.cols, null);
    for (c = 0; c < this.cols; c++) {
      this.m_cellBounds[r][c] = new scout.Rectangle(x, y, w[c], h[r]);
      x += w[c];
      x += this.m_hgap;
    }
    y += h[r];
    y += this.m_vgap;
  }
  return this.m_cellBounds;
};

scout.LogicalGridLayoutInfo.prototype.layoutSizes = function(targetSize, sizes, weights) {
  var i;
  var outSizes = scout.arrays.init(sizes.length, 0);
  if (targetSize <= 0) {
    for (i = 0; i < sizes.length; i++) {
      outSizes[i] = sizes[i][scout.LayoutConstants.MIN];
    }
    return outSizes;
  }
  var sumSize = 0;
  var tmpWeight = scout.arrays.init(weights.length, 0.0);
  var sumWeight = 0;
  for (i = 0; i < sizes.length; i++) {
    outSizes[i] = sizes[i][scout.LayoutConstants.PREF];
    sumSize += outSizes[i];
    tmpWeight[i] = weights[i];
    /**
     * auto correction: if weight is 0 and min / max sizes are NOT equal then
     * set weight to 1; if weight<eps set it to 0
     */
    if (tmpWeight[i] < scout.LayoutConstants.EPS) {
      if (sizes[i][scout.LayoutConstants.MAX] > sizes[i][scout.LayoutConstants.MIN]) {
        tmpWeight[i] = 1;
      } else {
        tmpWeight[i] = 0;
      }
    }
    sumWeight += tmpWeight[i];
  }
  // normalize weights
  if (sumWeight > 0) {
    for (i = 0; i < tmpWeight.length; i++) {
      tmpWeight[i] = tmpWeight[i] / sumWeight;
    }
  }
  var deltaInt = targetSize - sumSize;
  // expand or shrink
  if (Math.abs(deltaInt) > 0) {
    // setup accumulators
    /*float[]*/
    var accWeight = scout.arrays.init(tmpWeight.length, 0.0);
    var hasTargets;
    if (deltaInt > 0) {
      // expand
      hasTargets = true;
      while (deltaInt > 0 && hasTargets) {
        hasTargets = false;
        for (i = 0; i < outSizes.length && deltaInt > 0; i++) {
          if (tmpWeight[i] > 0 && outSizes[i] < sizes[i][scout.LayoutConstants.MAX]) {
            hasTargets = true;
            accWeight[i] += tmpWeight[i];
            if (accWeight[i] > 0) {
              accWeight[i] -= 1;
              outSizes[i] += 1;
              deltaInt -= 1;
            }
          }
        }
      }
    } else { // delta<0
      // shrink
      hasTargets = true;
      while (deltaInt < 0 && hasTargets) {
        hasTargets = false;
        for (i = 0; i < outSizes.length && deltaInt < 0; i++) {
          if (tmpWeight[i] > 0 && outSizes[i] > sizes[i][scout.LayoutConstants.MIN]) {
            hasTargets = true;
            accWeight[i] += tmpWeight[i];
            if (accWeight[i] > 0) {
              accWeight[i] -= 1;
              outSizes[i] -= 1;
              deltaInt += 1;
            }
          }
        }
      }
    }
  }
  return outSizes;
};

scout.LogicalGridLayoutInfo.prototype.logicalWidthInPixel = function(cons) {
  var gridW = cons.gridw;
  return (scout.HtmlEnvironment.formColumnWidth * gridW) + (this.m_hgap * Math.max(0, gridW - 1));
};

scout.LogicalGridLayoutInfo.prototype.logicalHeightInPixel = function(cons) {
  var gridH = cons.gridh,
    addition = cons.logicalRowHeightAddition || 0;
  return (scout.HtmlEnvironment.formRowHeight * gridH) + (this.m_vgap * Math.max(0, gridH - 1)) + addition;
};

scout.LogicalGridLayoutInfo.prototype.uiSizeInPixel = function($comp) {
  return scout.HtmlComponent.get($comp).getPreferredSize();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Null Layout.
 */
scout.NullLayout = function() {
  scout.NullLayout.parent.call(this);
};
scout.inherits(scout.NullLayout, scout.AbstractLayout);

scout.NullLayout.prototype.layout = function($container) {
  $container.children().each(function() {
    var htmlComp = scout.HtmlComponent.optGet($(this));
    if (htmlComp) {
      htmlComp.revalidateLayout();
    }
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RowLayout = function() {
  scout.RowLayout.parent.call(this);
};
scout.inherits(scout.RowLayout, scout.AbstractLayout);

scout.RowLayout.prototype.layout = function($container) {
  $container.children().each(function() {
    var htmlComp = scout.HtmlComponent.optGet($(this));
    if (htmlComp) {
      htmlComp.setSize(htmlComp.getPreferredSize());
    }
  });
};

scout.RowLayout.prototype.preferredLayoutSize = function($container) {
  var prefSize = new scout.Dimension(),
    htmlContainer = scout.HtmlComponent.get($container),
    maxWidth = 0;

  $container.children().each(function() {
    var htmlChildPrefSize,
      htmlChild = scout.HtmlComponent.optGet($(this));
    if (htmlChild) {
      htmlChildPrefSize = htmlChild.getPreferredSize()
        .add(htmlChild.getMargins());
      maxWidth = Math.max(htmlChildPrefSize.width, maxWidth);
      prefSize.height += htmlChildPrefSize.height;
      prefSize.width = maxWidth;
    }
  });

  prefSize = prefSize.add(htmlContainer.getInsets());
  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Resizes the child so it has the same size as the container.<br>
 * If no child is provided, the first child in the container is used.
 */
scout.SingleLayout = function(htmlChild) {
  scout.SingleLayout.parent.call(this);
  this._htmlChild = htmlChild;
};
scout.inherits(scout.SingleLayout, scout.AbstractLayout);

scout.SingleLayout.prototype.layout = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container);
  var childSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets()),
    htmlChild = this._htmlChild;

  if (!htmlChild) {
    htmlChild = this._getHtmlSingleChild($container);
  }
  if (htmlChild) {
    htmlChild.setSize(childSize);
  }
};

scout.SingleLayout.prototype.preferredLayoutSize = function($container) {
  var htmlChild = this._htmlChild;
  if (!htmlChild) {
    htmlChild = this._getHtmlSingleChild($container);
  }
  if (htmlChild) {
    return htmlChild.getPreferredSize();
  } else {
    return new scout.Dimension(1, 1);
  }
};

/**
 * @returns a HtmlComponent instance for the first child of the given container or null if the container has no children.
 */
scout.SingleLayout.prototype._getHtmlSingleChild = function($container) {
  var $firstChild = $container.children().first();
  if ($firstChild.length) {
    return scout.HtmlComponent.get($firstChild);
  } else {
    return null;
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.keys = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  ESC: 27,
  ESCAPE: 27,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  SPACE: 32,
  INSERT: 45,
  DELETE: 46,
  0: 48,
  1: 49,
  2: 50,
  3: 51,
  4: 52,
  5: 53,
  6: 54,
  7: 55,
  8: 56,
  9: 57,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  SELECT: 93,
  NUMPAD_0: 96,
  NUMPAD_1: 97,
  NUMPAD_2: 98,
  NUMPAD_3: 99,
  NUMPAD_4: 100,
  NUMPAD_5: 101,
  NUMPAD_6: 102,
  NUMPAD_7: 103,
  NUMPAD_8: 104,
  NUMPAD_9: 105,
  MULTIPLY: 106,
  ADD: 107,
  SUBTRACT: 109,
  DECIMAL_POINT: 110,
  DIVIDE: 111,
  NUM_LOCK: 144,
  SCROLL_LOCK: 145,
  SEMICOLON: 186, //
  DASH: 189,
  COMMA: 188,
  POINT: 190,
  FORWARD_SLASH: 191, //
  OPEN_BRACKET: 219, //'
  BACK_SLASH: 220, //
  CLOSE_BRACKET: 221, //^
  SINGLE_QUOTE: 222, //,
  ANGULAR_BRACKET: 226
};

scout.codesToKeys = {
  8: 'Backspace',
  9: 'Tab',
  13: 'Enter',
  16: 'SHIFT',
  17: 'CTRL',
  18: 'ALT',
  19: 'PAUSE',
  27: 'Esc',
  33: 'Page up',
  34: 'Page down',
  35: 'End',
  36: 'Home',
  37: 'Left',
  38: 'UP',
  39: 'Right',
  40: 'Down',
  32: 'Space',
  45: 'Insert',
  46: 'Delete',
  48: '0',
  49: '1',
  50: '2',
  51: '3',
  52: '4',
  53: '5',
  54: '6',
  55: '7',
  56: '8',
  57: '9',
  65: 'A',
  66: 'B',
  67: 'C',
  68: 'D',
  69: 'E',
  70: 'F',
  71: 'G',
  72: 'H',
  73: 'I',
  74: 'J',
  75: 'K',
  76: 'L',
  77: 'M',
  78: 'N',
  79: 'O',
  80: 'P',
  81: 'Q',
  82: 'R',
  83: 'S',
  84: 'T',
  85: 'U',
  86: 'V',
  87: 'W',
  88: 'X',
  89: 'Y',
  90: 'Z',
  93: 'SELECT',
  112: 'F1',
  113: 'F2',
  114: 'F3',
  115: 'F4',
  116: 'F5',
  117: 'F6',
  118: 'F7',
  119: 'F8',
  120: 'F9',
  121: 'F10',
  122: 'F11',
  123: 'F12',
  96: 'NUMPAD_0',
  97: 'NUMPAD_1',
  98: 'NUMPAD_2',
  99: 'NUMPAD_3',
  100: 'NUMPAD_4',
  101: 'NUMPAD_5',
  102: 'NUMPAD_6',
  103: 'NUMPAD_7',
  104: 'NUMPAD_8',
  105: 'NUMPAD_9',
  106: 'MULTIPLY',
  107: '+',
  109: 'SUBTRACT',
  110: 'DECIMAL_POINT',
  111: '/',
  144: 'Num lock',
  145: 'Scroll lock',
  186: '', //
  189: '-',
  188: ',',
  190: '.',
  191: '',
  219: '\'',
  220: '',
  221: '^',
  222: '',
  226: '<'
};

scout.keyStrokeBox = {
  gap: 4,

  drawSingleKeyBoxItem: function(offset, keyBoxText, $container, ctrl, alt, shift, alignementRight) {
    if (!$container) {
      return;
    }

    var $existingKeyBoxes = $('.key-box', $container);

    var align = alignementRight ? 'right' : 'left';
    if ($existingKeyBoxes.length > 0) {
      var $boxLastAdded = $existingKeyBoxes.first();
      if (alignementRight) {
        offset = $container.outerWidth() - $boxLastAdded.position().left + this.gap;
      } else {
        offset = this.gap + $boxLastAdded.position().left + $boxLastAdded.outerWidth();
      }
    }
    if (shift) {
      keyBoxText = 'Shift ' + keyBoxText;
    }
    if (alt) {
      keyBoxText = 'Alt ' + keyBoxText;
    }
    if (ctrl) {
      keyBoxText = 'Ctrl ' + keyBoxText;
    }
    if ($container.css('position') === 'absolute' || $container.css('position') === 'relative' || ($container.css('position') === 'static' && $existingKeyBoxes.length > 0)) {
      return $container.prependDiv('key-box ', keyBoxText).css(align, '' + offset + 'px');
    } else {
      var pos = $container.position();
      if (pos) {
        return $container.prependDiv('key-box ', keyBoxText).css(align, '' + (pos.left + offset) + 'px');
      } else {
        $.log.warn('(keys#drawSingleKeyBoxItem) pos is undefined. $container=' + $container);
      }
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Key = function(keyStroke, which) {
  this.keyStroke = keyStroke;
  this.which = which;

  this.ctrl = keyStroke.ctrl;
  this.alt = keyStroke.alt;
  this.shift = keyStroke.shift;

  this.keyStrokeMode = keyStroke.keyStrokeMode;
};

scout.Key.prototype.render = function($drawingArea, event) {
  this.$drawingArea = this.keyStroke.renderKeyBox($drawingArea, event);
  return !!this.$drawingArea;
};

scout.Key.prototype.remove = function() {
  this.keyStroke.removeKeyBox(this.$drawingArea);
  this.$drawingArea = null;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Modifier like shift, ctrl or alt used in keystrokes.
 *
 * A keystroke can consist of multiple modifierBitMask, which can be represented by bitwise OR'ing them together.
 */
scout.keyStrokeModifier = {
  NONE: 0, // without any modifier
  CTRL: 1 << 0, // with the ctrl modifier (NOSONAR)
  CTRL_UNDEFINED: 1 << 1, // with or without the ctrl modifier (NOSONAR)
  SHIFT: 1 << 2, // with the shift modifier (NOSONAR)
  SHIFT_UNDEFINED: 1 << 3, // with or without the shift modifier (NOSONAR)
  ALT: 1 << 4, // with the alt modifier (NOSONAR)
  ALT_UNDEFINED: 1 << 5, // with or without the alt modifier (NOSONAR)

  isCtrl: function(modifierBitMask) {
    return this._eval(modifierBitMask, this.CTRL, this.CTRL_UNDEFINED);
  },

  isShift: function(modifierBitMask) {
    return this._eval(modifierBitMask, this.SHIFT, this.SHIFT_UNDEFINED);
  },

  isAlt: function(modifierBitMask) {
    return this._eval(modifierBitMask, this.ALT, this.ALT_UNDEFINED);
  },

  _eval: function(testee, modifier, modifierUndefined) {
    if ((modifierUndefined & testee) > 0) { // NOSONAR
      return undefined;
    } else {
      return (modifier & testee) > 0; // NOSONAR
    }
  },

  toModifierBitMask: function(event) {
    var modifierBitMask = 0;
    modifierBitMask |= event.ctrlKey ? scout.keyStrokeModifier.CTRL : 0; // NOSONAR
    modifierBitMask |= event.altKey ? scout.keyStrokeModifier.ALT : 0; // NOSONAR
    modifierBitMask |= event.shiftKey ? scout.keyStrokeModifier.SHIFT : 0; // NOSONAR
    return modifierBitMask;
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.VirtualKeyStrokeEvent = function(which, ctrl, alt, shift, keyStrokeMode, target) {
  this.which = which;
  this.ctrlKey = ctrl;
  this.metaKey = false;
  this.altKey = alt;
  this.shiftKey = shift;
  this.target = target;
  this.type = keyStrokeMode;

  this._propagationStopped = false;
  this._immediatePropagationStopped = false;
  this._defaultPrevented = false;
};

scout.VirtualKeyStrokeEvent.prototype.stopPropagation = function() {
  this._propagationStopped = true;
};

scout.VirtualKeyStrokeEvent.prototype.stopImmediatePropagation = function() {
  this._immediatePropagationStopped = true;
};

scout.VirtualKeyStrokeEvent.prototype.preventDefault = function() {
  this._defaultPrevented = true;
};

scout.VirtualKeyStrokeEvent.prototype.isPropagationStopped = function() {
  return this._propagationStopped;
};

scout.VirtualKeyStrokeEvent.prototype.isImmediatePropagationStopped = function() {
  return this._immediatePropagationStopped;
};

scout.VirtualKeyStrokeEvent.prototype.isDefaultPrevented = function() {
  return this._defaultPrevented;
};

scout.VirtualKeyStrokeEvent.prototype.isAnyPropagationStopped = function() {
  return this._propagationStopped || this._immediatePropagationStopped;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.KeyStrokeManager = function(session) {
  var $mainEntryPoint = session.$entryPoint;
  this.session = session;
  this._helpRendered = false;
  this._renderedKeys = [];

  this.installTopLevelKeyStrokeHandlers($mainEntryPoint);
};

scout.KeyStrokeManager.prototype.installTopLevelKeyStrokeHandlers = function($container) {
  var
    myWindow = $container.window(true),
    // Swallow F1 (online help) key stroke
    helpHandler = function(event) {
      return !this._isHelpKeyStroke(event);
    }.bind(this),
    // Swallow Backspace (browser navigation) key stroke
    backspaceHandler = function(event) {
      return event.which !== scout.keys.BACKSPACE;
    }.bind(this);

  $container
    .keydown(helpHandler)
    .keyup(helpHandler);
  $container
    .keydown(backspaceHandler)
    .keyup(backspaceHandler);

  if ('onhelp' in myWindow) {
    myWindow.onhelp = scout.filters.returnFalse;
  }
};

/**
 * Installs the given keystroke context. This method has no effect if the context is null, or already installed.
 */
scout.KeyStrokeManager.prototype.installKeyStrokeContext = function(keyStrokeContext) {
  if (!keyStrokeContext) {
    return;
  }

  if (keyStrokeContext._handler) {
    return; // context already installed
  }

  if (!keyStrokeContext.$getBindTarget()) {
    throw new Error('missing bind-target for KeyStrokeContext: ' + keyStrokeContext);
  }

  keyStrokeContext._handler = function(event) {
    if (this.session.focusManager.isElementCovertByGlassPane(keyStrokeContext.$getScopeTarget())) {
      return;
    }

    if (this._isHelpKeyStroke(event)) {
      if (event.originalEvent.renderingHelp || !this._helpRendered) {
        event.originalEvent.renderingHelp = true; // flag to let superior keyStrokeContexts render their help keys
        this._helpRendered = true; // flag to only render help once, if help key is held down
        this._installHelpDisposeListener(event);
        this._renderKeys(keyStrokeContext, event);
      }
    } else {
      this._handleKeyStrokeEvent(keyStrokeContext, event);
    }
  }.bind(this);

  keyStrokeContext._handler.$target = keyStrokeContext.$getBindTarget();
  keyStrokeContext._handler.$target.keydown(keyStrokeContext._handler);
  keyStrokeContext._handler.$target.keyup(keyStrokeContext._handler);
};

/**
 * Uninstalls the given keystroke context. This method has no effect if the context is null, or not installed.
 */
scout.KeyStrokeManager.prototype.uninstallKeyStrokeContext = function(keyStrokeContext) {
  if (!keyStrokeContext) {
    return;
  }
  if (!keyStrokeContext._handler) {
    return; // context not installed
  }

  keyStrokeContext._handler.$target.off('keydown', keyStrokeContext._handler);
  keyStrokeContext._handler.$target.off('keyup', keyStrokeContext._handler);
  keyStrokeContext._handler.$target = null;
  keyStrokeContext._handler = null;
};

/**
 * Visualizes the keys supported by the given keyStrokeContext.
 */
scout.KeyStrokeManager.prototype._renderKeys = function(keyStrokeContext, event) {
  var descendantContexts = event.originalEvent.keyStrokeContexts || [];

  keyStrokeContext.keyStrokes
    .filter(function(keyStroke) {
      var render = keyStroke.renderingHints.render;
      return (typeof render === 'function' ? render.call(keyStroke) : render);
    })
    .forEach(function(keyStroke) {
      var $drawingArea = (keyStroke.field ? keyStroke.field.$container : null) || keyStrokeContext.$getScopeTarget(); // Precedence: keystroke's field container, or the scope target otherwise.
      var keys = keyStroke.keys(); // Get all keys which are handled by the keystroke. Typically, this is a single key.

      keys.forEach(function(key) {
        var virtualKeyStrokeEvent = new scout.VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, event.target);

        if (keyStrokeContext.accept(virtualKeyStrokeEvent) &&
          keyStroke.accept(virtualKeyStrokeEvent) && !this._isPreventedByDescendantContext(key, event.target, descendantContexts)) {
          if (key.render($drawingArea, virtualKeyStrokeEvent)) {
            this._renderedKeys.push(key);
          }
        }
      }, this);
    }, this);

  descendantContexts.push(keyStrokeContext); // Register this keyStrokeContext within the event, so that superior keyStrokeContexts can validate their keys (e.g. not swallowed by a descendant keyStrokeContext).
  event.originalEvent.keyStrokeContexts = descendantContexts;
};

scout.KeyStrokeManager.prototype._isPreventedByDescendantContext = function(key, target, descendantContexts) {
  var virtualKeyStrokeEvent = new scout.VirtualKeyStrokeEvent(key.which, key.ctrl, key.alt, key.shift, key.keyStrokeMode, target);

  // Check whether any descendant keyStrokeContext prevents this keystroke from execution.
  return descendantContexts.some(function(descendantContext) {
    // Ask descendant keyStrokeContext whether this event is swallowed.
    descendantContext.accept(virtualKeyStrokeEvent);
    if (virtualKeyStrokeEvent.isAnyPropagationStopped()) {
      return true;
    }

    // Ask keystrokes of descendant keyStrokeContext whether this event is swallowed.
    return descendantContext.keyStrokes.some(function(descendantKeyStroke) {
      descendantKeyStroke.accept(virtualKeyStrokeEvent);
      return virtualKeyStrokeEvent.isAnyPropagationStopped();
    }, this);
  }, this);
};

/**
 * Handles the keystroke event by the keyStrokeContext's keystroke handlers, but returns immediately once a keystroke requests immediate stop of propagation.
 */
scout.KeyStrokeManager.prototype._handleKeyStrokeEvent = function(keyStrokeContext, event) {
  if (!keyStrokeContext.accept(event)) {
    return;
  }

  // We create a copy of the keyStrokes array, because when a widget is disposed in the handle function
  // of a keystroke, all its keystrokes on the context are deleted. Which means no key stroke is processed
  // anymore. However: creating a copy can be dangerous too, because the handle function must deal with
  // the situation that the widget to which the keystroke belongs, is suddenly destroyed.
  var keyStrokesCopy = keyStrokeContext.keyStrokes.slice();
  keyStrokesCopy.some(function(keyStroke) {
    // Handle numpad keystroke
    event.which = event.which >= 96 && event.which <= 105 ? event.which - 48 : event.which;
    if (!keyStroke.accept(event)) {
      return false;
    }

    // Before handling the keystroke, accept the input of a potential active value field
    if (!keyStroke.preventInvokeAcceptInputOnActiveValueField && (keyStroke.invokeAcceptInputOnActiveValueField || keyStrokeContext.invokeAcceptInputOnActiveValueField)) {
      scout.ValueField.invokeValueFieldAcceptInput(event.target);
    }

    // Handle the keystroke
    keyStroke.invokeHandle(event);

    if (this.session.desktop) { // check that desktop is ready (may be undefined on "Initialization failed" message, would cause an error when the user presses Enter)
      this.session.desktop.trigger('keystrokeConsumed', {
        keyStrokeEvent: event,
        $target: keyStrokeContext.$getBindTarget(),
        keyStroke: keyStroke
      });
    }

    // Break on 'stopImmediate'.
    return event.isImmediatePropagationStopped(); // 'some-loop' breaks on true.
  }, this);
};

scout.KeyStrokeManager.prototype._isHelpKeyStroke = function(event) {
  return event.which === scout.keys.F1;
};

scout.KeyStrokeManager.prototype._installHelpDisposeListener = function(event) {
  var helpDisposeHandler,
    $currentTarget = $(event.currentTarget),
    $myWindow = $currentTarget.window(),
    $topLevelContainer = $currentTarget.entryPoint();

  helpDisposeHandler = function() {
    $topLevelContainer.off('keyup', helpDisposeHandler);
    $myWindow.off('blur', helpDisposeHandler);
    this._helpRendered = false;
    this._renderedKeys.forEach(function(key) {
      key.remove();
    });
    this._renderedKeys = [];
  }.bind(this);

  $topLevelContainer.on('keyup', helpDisposeHandler);
  $myWindow.on('blur', helpDisposeHandler); // once the current browser tab/window is left

  return false;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.KeyStrokeContext = function() {
  /*
   * Holds the target where to bind this context as keydown listener.
   * This can either be a static value or a function to resolve the target.
   */
  this.$bindTarget;
  /*
   * Holds the scope of this context and is used to determine the context's accessibility, meaning not covert by a glasspane.
   * This can either be a static value or a function to resolve the target.
   */
  this.$scopeTarget;
  /*
   * Holds the keystrokes registered within this context.
   */
  this.keyStrokes = [];
  /*
   * Array of interceptors to participate in setting 'stop propagation' flags.
   */
  this.stopPropagationInterceptors = [];

  /*
   * Arrays with combinations of keys to prevent from bubbling up in the DOM tree.
   */
  this._stopPropagationKeys = {};

  /*
   * Indicates whether to invoke 'acceptInput' on a currently focused value field prior handling the keystroke.
   */
  this.invokeAcceptInputOnActiveValueField = false;
};

/**
 * Registers the given keys as 'stopPropagation' keys, meaning that any keystroke event with that key and matching the modifier bit mask is prevented from bubbling the DOM tree up.
 *
 * @param modifierBitMask bitwise OR'ing together modifier constants to match a keystroke event. (KeyStrokeModifier.js)
 * @param keys the keys to match a keystroke event.
 */
scout.KeyStrokeContext.prototype.registerStopPropagationKeys = function(modifierBitMask, keys) {
  this._stopPropagationKeys[modifierBitMask] = this._stopPropagationKeys[modifierBitMask] || [];
  scout.arrays.pushAll(this._stopPropagationKeys[modifierBitMask], keys);
};

/**
 * Use this method to register an interceptor to set propagation flags on context level.
 */
scout.KeyStrokeContext.prototype.registerStopPropagationInterceptor = function(interceptor) {
  this.stopPropagationInterceptors.push(interceptor);
};

/**
 * Returns true if this event is handled by this context, and if so sets the propagation flags accordingly.
 */
scout.KeyStrokeContext.prototype.accept = function(event) {
  // Check whether this event is accepted.
  if (!this._accept(event)) {
    return false;
  }

  // Apply propagation flags to the event.
  this._applyPropagationFlags(event);

  return true;
};

/**
 * Sets the propagation flags to the given event.
 */
scout.KeyStrokeContext.prototype._applyPropagationFlags = function(event) {
  var modifierBitMask = scout.keyStrokeModifier.toModifierBitMask(event);
  var keys = this._stopPropagationKeys[modifierBitMask];

  if (keys && scout.isOneOf(event.which, keys)) {
    event.stopPropagation();
  }

  // Let registered interceptors participate.
  this.stopPropagationInterceptors.forEach(function(interceptor) {
    interceptor(event);
  }, this);
};

scout.KeyStrokeContext.prototype._accept = function(event) {
  return true;
};

/**
 * Registers the given keystroke(s) if not installed yet.
 */
scout.KeyStrokeContext.prototype.registerKeyStroke = function(keyStroke) {
  scout.arrays.ensure(keyStroke)
    .map(this._resolveKeyStroke)
    .filter(function(ks) {
      return this.keyStrokes.indexOf(ks) === -1; // must not be registered yet
    }.bind(this))
    .forEach(function(ks) {
      this.keyStrokes.push(ks);

      // Registers a destroy listener, so that the keystroke is uninstalled once its field is destroyed.
      if (ks.field && !ks.destroyListener) {
        ks.destroyListener = function(event) {
          this.unregisterKeyStroke(ks);
          ks.destroyListener = null;
        }.bind(this);
        ks.field.one('destroy', ks.destroyListener);
      }
    }, this);
};

/**
 * Uninstalls the given keystroke. Has no effect if not installed.
 */
scout.KeyStrokeContext.prototype.unregisterKeyStroke = function(keyStroke) {
  keyStroke = this._resolveKeyStroke(keyStroke);

  if (scout.arrays.remove(this.keyStrokes, keyStroke) && keyStroke.field && keyStroke.destroyListener) {
    keyStroke.field.off('destroy', keyStroke.destroyListener);
    keyStroke.destroyListener = null;
  }
};

scout.KeyStrokeContext.prototype._resolveKeyStroke = function(keyStroke) {
  if (keyStroke instanceof scout.KeyStroke) {
    return keyStroke;
  } else if (keyStroke instanceof scout.Action) {
    return keyStroke.actionKeyStroke;
  } else {
    throw new Error('unsupported keystroke: ' + keyStroke);
  }
};

/**
 * Returns the $target where to bind this context as keydown listener.
 */
scout.KeyStrokeContext.prototype.$getBindTarget = function() {
  return (typeof this.$bindTarget === 'function' ? this.$bindTarget() : this.$bindTarget);
};

/**
 * Returns the scope of this context and is used to determine the context's accessibility, meaning not covert by a glasspane.
 */
scout.KeyStrokeContext.prototype.$getScopeTarget = function() {
  return (typeof this.$scopeTarget === 'function' ? this.$scopeTarget() : this.$scopeTarget);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Keystroke context used for input fields.
 */
scout.InputFieldKeyStrokeContext = function() {
  scout.InputFieldKeyStrokeContext.parent.call(this);

  this.invokeAcceptInputOnActiveValueField = true;

  this.registerStopPropagationKeys(scout.keyStrokeModifier.CTRL, [
    scout.keys.A,
    scout.keys.C,
    scout.keys.Y,
    scout.keys.V,
    scout.keys.Z,
    scout.keys.RIGHT,
    scout.keys.BACKSPACE,
    scout.keys.LEFT,
    scout.keys.HOME,
    scout.keys.END,
    scout.keys.NUMPAD_4,
    scout.keys.NUMPAD_6
  ]);

  this.registerStopPropagationKeys(scout.keyStrokeModifier.CTRL | scout.keyStrokeModifier.SHIFT, [ // NOSONAR
    scout.keys.RIGHT,
    scout.keys.BACKSPACE,
    scout.keys.LEFT,
    scout.keys.HOME,
    scout.keys.END,
    scout.keys.NUMPAD_4,
    scout.keys.NUMPAD_6
  ]);

  this.registerStopPropagationKeys(scout.keyStrokeModifier.SHIFT, [
    scout.keys.RIGHT,
    scout.keys.BACKSPACE,
    scout.keys.LEFT,
    scout.keys.HOME,
    scout.keys.END,
    scout.keys.NUMPAD_4,
    scout.keys.NUMPAD_6
  ]);
  this.registerStopPropagationKeys(scout.keyStrokeModifier.NONE, [
    scout.keys.SEMICOLON,
    scout.keys.DASH,
    scout.keys.COMMA,
    scout.keys.POINT,
    scout.keys.FORWARD_SLASH,
    scout.keys.OPEN_BRACKET,
    scout.keys.BACK_SLASH,
    scout.keys.CLOSE_BRACKET,
    scout.keys.SINGLE_QUOTE,
    scout.keys.MULTIPLY,
    scout.keys.ADD,
    scout.keys.SUBTRACT,
    scout.keys.DECIMAL_POINT,
    scout.keys.DIVIDE,
    scout.keys.NUMPAD_0,
    scout.keys.NUMPAD_1,
    scout.keys.NUMPAD_2,
    scout.keys.NUMPAD_3,
    scout.keys.NUMPAD_4,
    scout.keys.NUMPAD_5,
    scout.keys.NUMPAD_6,
    scout.keys.NUMPAD_7,
    scout.keys.NUMPAD_8,
    scout.keys.NUMPAD_9,
    scout.keys.MULTIPLY,
    scout.keys.END,
    scout.keys.HOME,
    scout.keys.RIGHT,
    scout.keys.BACKSPACE,
    scout.keys.LEFT,
    scout.keys.DELETE,
    scout.keys.SPACE
  ]);
};
scout.inherits(scout.InputFieldKeyStrokeContext, scout.KeyStrokeContext);

scout.InputFieldKeyStrokeContext.prototype._applyPropagationFlags = function(event) {
  scout.InputFieldKeyStrokeContext.parent.prototype._applyPropagationFlags.call(this, event);

  if (event.isPropagationStopped()) {
    return;
  }

  var inputField = $(event.target).is('input:text') || $(event.target).is('textarea');
  if (inputField && (this._isLetterKeyStroke(event) || this._isNumberKeyStroke(event))) {
    event.stopPropagation();
  }
};

scout.InputFieldKeyStrokeContext.prototype._isNumberKeyStroke = function(event) {
  return !event.ctrlKey && event.which >= scout.keys[0] && event.which <= scout.keys[9];
};

scout.InputFieldKeyStrokeContext.prototype._isLetterKeyStroke = function(event) {
  return !event.ctrlKey && event.which >= scout.keys.A && event.which <= scout.keys.Z;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.KeyStroke = function() {
  this.field; // optional model field

  this.which = []; // keys which this keystroke is bound to. Typically, this is a single key, but may be multiple keys if handling the same action (e.g. ENTER and SPACE on a button).
  this.ctrl = false;
  this.alt = false;
  this.shift = false;
  this.preventDefault = true;
  this.stopPropagation = false;
  this.stopImmediatePropagation = false;
  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
  this.repeatable = false; // whether or not the handle method is called multiple times while a key is pressed
  this._handleExecuted = false; // internal flag to remember whether or not the handle method has been executed (reset on keyup)

  // Hints to control rendering of the key(s).
  this.renderingHints = {
    render: function() {
      if (this.field && this.field.rendered !== undefined) {
        return this.field.rendered; // only render key if associated field is visible.
      } else {
        return true; // by default, keystrokes are rendered
      }
    }.bind(this),
    offset: 4,
    hAlign: scout.hAlign.LEFT,
    text: null,
    $drawingArea: function($drawingArea, event) {
      return $drawingArea;
    }
  };

  /**
   * Indicates whether to invoke 'acceptInput' on a currently focused value field prior handling the keystroke.
   */
  this.invokeAcceptInputOnActiveValueField = false;

  /**
   * Indicates whether to prevent the invoke of 'acceptInput' on a currently focused value field prior handling the keystroke,
   * either triggered by previous property or by KeyStrokeContext
   */
  this.preventInvokeAcceptInputOnActiveValueField = false;
};

/**
 * Parses the given keystroke name into the key parts like 'ctrl', 'shift', 'alt' and 'which'.
 */
scout.KeyStroke.prototype.parseAndSetKeyStroke = function(keyStroke) {
  this.alt = this.ctrl = this.shift = false;
  this.which = [];

  if (!keyStroke) {
    return;
  }

  // see org.eclipse.scout.rt.client.ui.action.keystroke.KeyStrokeNormalizer
  keyStroke.split('-').forEach(function(part) {
    if (part === 'alternate' || part === 'alt') {
      this.alt = true;
    } else if (part === 'control' || part === 'ctrl') {
      this.ctrl = true;
    } else if (part === 'shift') {
      this.shift = true;
    } else {
      var key = scout.keys[part.toUpperCase()];
      this.which = key && [key];
    }
  }, this);
};

/**
 * Returns true if this event is handled by this keystroke, and if so sets the propagation flags accordingly.
 */
scout.KeyStroke.prototype.accept = function(event) {
  if (!this._isEnabled()) {
    return false;
  }

  // Reset handleExecuted flag on keyup event
  if (event.type === 'keyup') {
    this._handleExecuted = false;
  }

  // Check whether this event is accepted for execution.
  if (!this._accept(event)) {
    return false;
  }

  // Apply propagation flags to the event.
  this._applyPropagationFlags(event);
  //only accept on correct event type -> keyup or keydown. But propagation flags should be set to prevent execution of upper keyStrokes.
  return event.type === this.keyStrokeMode;
};

/**
 * Method invoked to handle the given keystroke event, and is only called if the event was accepted by 'KeyStroke.accept(event)'.
 */
scout.KeyStroke.prototype.handle = function(event) {
  throw new Error('keystroke event not handled: ' + event);
};

scout.KeyStroke.prototype.invokeHandle = function(event) {
  // if key stroke is repeatable, handle is called each time the key event occurs
  // which means it is executed multiple times while a key is pressed.
  if (this.repeatable) {
    this.handle(event);
    return;
  }

  // if key stroke is not repeatable it should only call execute once until
  // we receive a key up event for that key
  if (!this._handleExecuted) {
    this.handle(event);
    this._handleExecuted = true;
  }
};

/**
 * Method invoked in the context of accepting a keystroke, and returns true if the keystroke is accessible to the user.
 */
scout.KeyStroke.prototype._isEnabled = function() {
  // Hint: do not check for which.length because there are keystrokes without a which, e.g. RangeKeyStroke.js

  if (this.field) {
    // Check visibility
    if (this.field.visible !== undefined && !this.field.visible) {
      return false;
    }
    // Check enabled state
    if (this.field.enabled !== undefined && !this.field.enabled) {
      return false;
    }
  }
  return true;
};

/**
 * Method invoked in the context of accepting a keystroke, and returns true if the event matches this keystroke.
 */
scout.KeyStroke.prototype._accept = function(event) {
  //event.ctrlKey||event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx use in this cases command key
  return this._acceptModifer(this.ctrl, (event.ctrlKey || event.metaKey)) &&
    this._acceptModifer(this.alt, event.altKey) &&
    this._acceptModifer(this.shift, event.shiftKey) &&
    scout.isOneOf(event.which, this.which);
};

scout.KeyStroke.prototype._acceptModifer = function(modifier, eventModifier) {
  return modifier === undefined || modifier === eventModifier;
};

/**
 * Method invoked in the context of accepting a keystroke, and sets the propagation flags accordingly.
 */
scout.KeyStroke.prototype._applyPropagationFlags = function(event) {
  if (this.stopPropagation) {
    event.stopPropagation();
  }
  if (this.stopImmediatePropagation) {
    event.stopImmediatePropagation();
  }
  if (this.preventDefault) {
    event.preventDefault();
  }
};

/**
 * Returns the key(s) associated with this keystroke. Typically, this is a single key, but may be multiple if this keystroke is associated with multiple keys, e.g. ENTER and SPACE on a button.
 */
scout.KeyStroke.prototype.keys = function() {
  return this.which.map(function(which) {
    return new scout.Key(this, which);
  }, this);
};

/**
 * Renders the visual representation of this keystroke, with the 'which' as given by the event.
 *
 * @return $drawingArea on which the key was finally rendered.
 */
scout.KeyStroke.prototype.renderKeyBox = function($drawingArea, event) {
  $drawingArea = this.renderingHints.$drawingArea($drawingArea, event);
  if (!$drawingArea || !$drawingArea.length) {
    return null;
  }

  var $keyBox = scout.keyStrokeBox.drawSingleKeyBoxItem(
    this.renderingHints.offset,
    this.renderingHints.text || scout.codesToKeys[event.which],
    $drawingArea,
    this.ctrl, this.alt, this.shift,
    this.renderingHints.hAlign === scout.hAlign.RIGHT);

  this._postRenderKeyBox($drawingArea, $keyBox);
  return $drawingArea;
};

/**
 * Method invoked after this keystroke was rendered, and is typically overwritten to reposition the visual representation.
 */
scout.KeyStroke.prototype._postRenderKeyBox = function($drawingArea) {};

/**
 * Removes the visual representation of this keystroke.
 */
scout.KeyStroke.prototype.removeKeyBox = function($drawingArea) {
  if ($drawingArea) {
    $('.key-box', $drawingArea).remove();
    $('.key-box-additional', $drawingArea).remove();
  }
};

scout.KeyStrokeMode = {
  UP: 'keyup',
  DOWN: 'keydown'
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * KeyStroke which is bound to a range of keys, e.g. ctrl-1 ... ctrl-9.
 */
scout.RangeKeyStroke = function() {
  scout.RangeKeyStroke.parent.call(this);
  this.ranges = [];
};
scout.inherits(scout.RangeKeyStroke, scout.KeyStroke);

scout.RangeKeyStroke.prototype.registerRange = function(from, to) {
  this.ranges.push({
    from: from,
    to: to
  });
};

/**
 * @override KeyStroke.js
 */
scout.RangeKeyStroke.prototype._accept = function(event) {
  //event.ctrlKey||event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx use in this cases command key
  if ((event.ctrlKey || event.metaKey) !== this.ctrl ||
    event.altKey !== this.alt ||
    event.shiftKey !== this.shift
  ) {
    return false;
  }

  return this.ranges.some(function(range) {
    return event.which >= this._getRangeFrom(range) && event.which <= this._getRangeTo(range);
  }, this);
};

/**
 * @override KeyStroke.js
 */
scout.RangeKeyStroke.prototype.keys = function() {
  var keys = [];
  this.ranges.forEach(function(range) {
    var from = this._getRangeFrom(range);
    var to = this._getRangeTo(range);

    for (var which = from; which <= to; which++) {
      keys.push(new scout.Key(this, which));
    }
  }, this);

  return keys;
};

scout.RangeKeyStroke.prototype._getRangeFrom = function(range) {
  return (typeof range.from === 'function' ? range.from() : range.from);
};

scout.RangeKeyStroke.prototype._getRangeTo = function(range) {
  return (typeof range.to === 'function' ? range.to() : range.to);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ContextMenuKeyStroke = function(field, contextFunction, bindObject) {
  scout.ContextMenuKeyStroke.parent.call(this);
  this._contextFunction = contextFunction;
  this._bindObject = bindObject || this;

  this.field = field;
  this.renderingHints.render = false;

  this.which = [scout.keys.SELECT];
  this.ctrl = false;
  this.shift = false;
  this.stopPropagation = true;
};
scout.inherits(scout.ContextMenuKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.ContextMenuKeyStroke.prototype.handle = function(event) {
  this._contextFunction.call(this._bindObject, event);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ClickActiveElementKeyStroke = function(field, which) {
  scout.ClickActiveElementKeyStroke.parent.call(this);
  this.field = field;
  this.which = which;
  this.stopPropagation = true;
  this.renderingHints.render = true;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return event._$activeElement;
  };
};
scout.inherits(scout.ClickActiveElementKeyStroke, scout.KeyStroke);

scout.ClickActiveElementKeyStroke.prototype._accept = function(event) {
  var accepted = scout.ClickActiveElementKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted) {
    return false;
  }

  event._$activeElement = this.field.$container.activeElement();
  return true;
};

/**
 * @override KeyStroke.js
 */
scout.ClickActiveElementKeyStroke.prototype.handle = function(event) {
  event._$activeElement.trigger({
    type: 'click',
    which: 1
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FocusAdjacentElementKeyStroke = function(session, field) {
  scout.FocusAdjacentElementKeyStroke.parent.call(this);
  this.session = session;
  this.field = field;
  this.which = [scout.keys.LEFT, scout.keys.RIGHT];
  this.renderingHints.render = false;
  this.stopPropagation = true;
  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
};
scout.inherits(scout.FocusAdjacentElementKeyStroke, scout.KeyStroke);

scout.FocusAdjacentElementKeyStroke.prototype.handle = function(event) {
  var activeElement = this.field.$container.activeElement(true),
    $focusableElements = this.field.$container.find(':focusable');

  switch (event.which) { // NOSONAR
    case scout.keys.RIGHT:
      if (activeElement === $focusableElements.last()[0]) {
        this.session.focusManager.requestFocus($focusableElements.first());
      } else {
        this.session.focusManager.requestFocus($focusableElements[$focusableElements.index(activeElement) + 1]);
      }

      break;
    case scout.keys.LEFT:
      if (activeElement === $focusableElements.first()[0]) {
        this.session.focusManager.requestFocus($focusableElements.last());
      } else {
        this.session.focusManager.requestFocus($focusableElements[$focusableElements.index(activeElement) - 1]);
      }
      break;
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CloseKeyStroke = function(field, $drawingArea) {
  scout.CloseKeyStroke.parent.call(this);
  this.field = field;
  this.which = [scout.keys.ESC];
  this.renderingHints.render = true;
  this.stopPropagation = true;
  this.renderingHints = {
    render: !!$drawingArea,
    $drawingArea: $drawingArea
  };
};
scout.inherits(scout.CloseKeyStroke, scout.KeyStroke);

scout.CloseKeyStroke.prototype.handle = function(event) {
  this.field.close();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TabItemKeyStroke = function(keyStroke, field) {
  scout.TabItemKeyStroke.parent.call(this);
  this.field = field;
  this.parseAndSetKeyStroke(keyStroke);

  this.renderingHints.offset = 16;
  this.renderingHints.hAlign = scout.hAlign.RIGHT;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.field.$tabContainer;
  }.bind(this);
};
scout.inherits(scout.TabItemKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.TabItemKeyStroke.prototype.handle = function(event) {
  this.field.parent._syncSelectedTab(this.field);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Button utility class for a set of buttons, where each button has an option value.
 *
 * Constructor arguments:
 *
 * @param $parent
 *          required
 * @param onClickHandler
 *          optional, global onClickHandler to attach to each button without a specific clickHandler
 */
scout.BoxButtons = function($parent, onClickHandler) {
  if (!$parent) {
    throw new Error('Missing $parent');
  }
  $parent.addClass('box-buttons');

  this._$parent = $parent;
  this._onClickHandler = onClickHandler;

  this._$buttons = [];
};

/**
 * @param opts
 *          [text]     required, text of button to add
 *          [tabIndex] optional, tabindex to assign (default '0')
 *          [enabled]  optional, if button should be enabled or not (default true)
 *          [onClick]  optional, function to be executed when button is clicked.
 *                               This function does _not_ have to check by itself if the button is
 *                               enabled. If this argument is omitted, the global onClickHandler is
 *                               used (see constructor).
 *          [option]   optional, a string that is assigned to be button and is passed
 *                               to the global onClickHandler as an argument.
 */
scout.BoxButtons.prototype.addButton = function(opts) {
  opts = opts || {};

  var $button = this._$parent.appendDiv()
    .text(opts.text)
    .addClass('box-button')
    .unfocusable()
    .setEnabled(scout.nvl(opts.enabled, true));

  if (!scout.device.supportsTouch()) {
    $button.attr('tabindex', opts.tabIndex || '0');
  }

  if (opts.onClick) {
    var onClick = opts.onClick;
    $button.on('click', function(event) {
      if ($.suppressEventIfDisabled(event)) {
        return;
      }
      onClick(event);
    });
  } else if (this._onClickHandler) {
    $button.on('click', this._onClick.bind(this));
  }
  $button.data('buttonOption', opts.option);

  this._$buttons.push($button);
  return $button;
};

scout.BoxButtons.prototype._onClick = function(event) {
  var $button = $(event.target);
  if ($.suppressEventIfDisabled(event, $button)) {
    return;
  }
  this._onClickHandler(event, $button.data('buttonOption'));
};

scout.BoxButtons.prototype.updateButtonWidths = function(availableWidth) {
  // Find all visible buttons
  var $visibleButtons = [];
  this._$buttons.forEach(function($button) {
    if ($button.isVisible()) {
      $visibleButtons.push($button);
    }
  });

  var hasVisibleButtons = $visibleButtons.length > 0;
  this._$parent.toggleClass('empty', !hasVisibleButtons);

  // Manually calculate equal width fore each button, adding remaining pixels to last button.
  // (We don't use CSS percentage values, because sometimes browser calculations lead to wrong results.)
  availableWidth = availableWidth || this._$parent.width();
  var w = Math.floor(availableWidth / $visibleButtons.length);
  $visibleButtons.forEach(function($button, index) {
    if (index === $visibleButtons.length - 1) {
      w = availableWidth;
    } else {
      availableWidth -= w;
    }
    $button.outerWidth(w);
  });
};

scout.BoxButtons.prototype.buttonCount = function() {
  return this._$buttons.length;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

scout.Carousel = function() {
  scout.Carousel.parent.call(this);
  this._addAdapterProperties(['widgets']);

  // default values
  this.currentItem = 0; // current item
  this.moveThreshold = 0.25; // threshold
  this.widgets = []; // widgets

  this.$carouselFilmstrip; // carousel filmstrip
  this.$carouselItems = []; // carousel items
  this.positionX = 0; // last translation position
};
scout.inherits(scout.Carousel, scout.Widget);

scout.Carousel.prototype._init = function(model) {
  scout.Carousel.parent.prototype._init.call(this, model);
  this._syncGridData(this.gridData);
};

scout.Carousel.prototype._syncGridData = function(gridData) {
  this._setProperty('gridData', new scout.GridData(gridData));
};

scout.Carousel.prototype._render = function($parent) {
  // add container
  this.$container = $parent.appendDiv('carousel');

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.CarouselLayout(this));

  // add content filmstrip
  this.$carouselFilmstrip = this.$container.appendDiv('carousel-filmstrip');
  this._registerCarouselFilmstripEventListeners();
  this.htmlCompFilmstrip = scout.HtmlComponent.install(this.$carouselFilmstrip, this.session);
};

scout.Carousel.prototype._renderProperties = function() {
  scout.Carousel.parent.prototype._renderProperties.call(this);

  this._renderWidgets();
  this._renderCurrentItem(); // must be called after renderWidgets
};

scout.Carousel.prototype.recalcTransformation = function() {
  this.positionX = this.currentItem * this.$container.width() * -1;
  this.$carouselFilmstrip.css({
    "transform": " translateX(" + this.positionX + "px)"
  });
};

scout.Carousel.prototype._renderCurrentItem = function() {
  this._renderItemsInternal(undefined, false);
};

scout.Carousel.prototype._renderItemsInternal = function(item, skipRemove) {
  item = item || this.currentItem;
  if (!skipRemove) {
    this.widgets.forEach(function(w, j) {
      if (w.rendered && (j < item - 1 || j > item + 1)) {
        w.remove();
      }
    }, this);
  }
  for (var i = Math.max(item - 1, 0); i < Math.min(item + 2, this.widgets.length); i++) {
    if (!this.widgets[i].rendered) {
      this.widgets[i].render(this.$carouselItems[i]);
      this.widgets[i].htmlComp.revalidateLayout();
    }
  }
};

scout.Carousel.prototype._registerCarouselFilmstripEventListeners = function() {
  var $window = this.$carouselFilmstrip.window();
  this.$carouselFilmstrip.on('mousedown touchstart', function(event) {
    var origPageX = event.pageX;
    if (!origPageX && event.originalEvent && event.originalEvent.touches && event.originalEvent.touches.length == 1) {
      origPageX = event.originalEvent.touches[0].pageX;
    }
    var origPosition = this.positionX;
    var minPositionX = this.$container.width() - this.$carouselFilmstrip.width();
    var containerWidth = this.$container.width();
    $window.on('mousemove.carouselDrag touchmove.carouselDrag', function(event) {
      var pageX = event.pageX;
      if (!pageX && event.originalEvent && event.originalEvent.touches && event.originalEvent.touches.length == 1) {
        pageX = event.originalEvent.touches[0].pageX;
      }
      var moveX = pageX - origPageX;
      var positionX = origPosition + moveX;
      if (positionX !== this.positionX && positionX <= 0 && positionX >= minPositionX) {
        this.$carouselFilmstrip.css({
          "transform": " translateX(" + positionX + "px)"
        });
        this.positionX = positionX;
        // item
        var i = positionX / containerWidth * -1;
        this._renderItemsInternal(positionX < origPosition ? Math.floor(i) : Math.ceil(i), true);
      }
    }.bind(this));
    $window.on('mouseup.carouselDrag touchend.carouselDrag touchcancel.carouselDrag', function(e) {
      $window.off('.carouselDrag');
      // show only whole items
      var mod = this.positionX % containerWidth;
      var newCurrentItem = this.currentItem;
      if (this.positionX < origPosition && mod / containerWidth < (0 - this.moveThreshold)) { // next
        newCurrentItem = Math.ceil(this.positionX / containerWidth * -1);
      } else if (this.positionX > origPosition && mod / containerWidth >= this.moveThreshold - 1) { // prev
        newCurrentItem = Math.floor(this.positionX / containerWidth * -1);
      }
      this.setCurrentItem(newCurrentItem);
      if (mod !== 0) {
        this.positionX = newCurrentItem * containerWidth * -1;
        this.recalcTransformation();
      }
    }.bind(this));
  }.bind(this));
};

scout.Carousel.prototype._renderWidgets = function() {
  this.$carouselFilmstrip.empty();
  this.$carouselItems = [];

  this.widgets = scout.arrays.ensure(this.widgets);
  this.widgets.forEach(function(widget, i) {
    this.$carouselItems.push(this.$carouselFilmstrip.appendDiv('carousel-item'));
    scout.HtmlComponent.install(this.$carouselItems[i], this.session);
  }, this);
  this.setCurrentItem(0);
};

scout.Carousel.prototype.setCurrentItem = function(currentItem) {
  this.setProperty('currentItem', currentItem);
};

scout.Carousel.prototype.setWidgets = function(widgets) {
  this.setProperty('widgets', widgets);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

scout.CarouselLayout = function(carousel) {
  scout.CarouselLayout.parent.call(this);

  this.carousel = carousel;
};
scout.inherits(scout.CarouselLayout, scout.AbstractLayout);

scout.CarouselLayout.prototype.layout = function($container) {
  // recalculate style transformation after layout
  this.carousel.recalcTransformation();

  var filmstripSize = this.carousel.htmlComp.getAvailableSize()
    .subtract(this.carousel.htmlComp.getInsets())
    .subtract(this.carousel.htmlCompFilmstrip.getMargins());
  var itemSize = this.carousel.htmlComp.getAvailableSize()
    .subtract(this.carousel.htmlComp.getInsets())
    .subtract(this.carousel.htmlCompFilmstrip.getMargins());

  var $carouselItems = this.carousel.$carouselItems;
  filmstripSize.width = $carouselItems.length * filmstripSize.width;
  this.carousel.htmlCompFilmstrip.setSize(filmstripSize);

  $carouselItems.forEach(function(e) {
    var htmlCarouselItem = scout.HtmlComponent.get(e);
    htmlCarouselItem.setSize(itemSize);
  });
};

scout.CarouselLayout.prototype.preferredLayoutSize = function($container) {
  if (this.carousel.currentIndex < this.carousel.$carouselItems.length && this.carousel.currentIndex >= 0) {
    return scout.HtmlComponent.get(this.carousel.$carouselItems[this.carousel.currentIndex]).getPreferredSize();
  }
  return new scout.Dimension(1, 1);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Cell = function() {
  this.$cell;
  this.checked = false;
  this.cssClass;
  this.editable = false;
  this.errorStatus;
  this.horizontalAlignment = -1;
  this.htmlEnabled = false;
  this.iconId;
  this._cachedEncodedText;
  this.text;
  this.value;
};

scout.Cell.prototype.init = function(model) {
  this._init(model);
};

scout.Cell.prototype._init = function(model) {
  $.extend(this, model);
  scout.defaultValues.applyTo(this);
};

scout.Cell.prototype.update = function(model) {
  this.setText(model.text);
  $.extend(this, model);
};

scout.Cell.prototype.setText = function(text) {
  var oldText = this.text;
  this.text = text;

  // reset cached encodedText, so when encodedText() is called the next time
  // will be set to the a new value
  if (oldText !== this.text) {
    this._cachedEncodedText = null;
  }
};

scout.Cell.prototype.encodedText = function() {
  if (!this._cachedEncodedText) {
    // Encode text and cache it, encoding is expensive
    this._cachedEncodedText = scout.strings.encode(this.text);
  }
  return this._cachedEncodedText;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CollapseHandle = function() {
  scout.CollapseHandle.parent.call(this);
  this.leftVisible = false;
  this.rightVisible = false;
};
scout.inherits(scout.CollapseHandle, scout.Widget);

scout.CollapseHandle.prototype._init = function(model) {
  scout.CollapseHandle.parent.prototype._init.call(this, model);

  var defaults = {
    leftVisible: true,
    rightVisible: true
  };
  $.extend(this, defaults, model);
};

scout.CollapseHandle.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('collapse-handle');
  this.$container.on('mousedown', this._onMouseDown.bind(this));

  this.$left = this.$container.appendDiv('collapse-handle-body left');
  this.$right = this.$container.appendDiv('collapse-handle-body right');
};

scout.CollapseHandle.prototype._renderProperties = function() {
  scout.CollapseHandle.parent.prototype._renderProperties.call(this);
  this._renderLeftVisible();
  this._renderRightVisible();
};

scout.CollapseHandle.prototype._renderLeftVisible = function() {
  this.$left.setVisible(this.leftVisible);
  this._updateVisibilityClasses();
};

scout.CollapseHandle.prototype._renderRightVisible = function() {
  this.$right.setVisible(this.rightVisible);
  this._updateVisibilityClasses();
};

scout.CollapseHandle.prototype._updateVisibilityClasses = function() {
  var bothVisible = this.leftVisible && this.rightVisible;
  this.$container.toggleClass('both-visible', bothVisible);
  this.$left.toggleClass('both-visible', bothVisible);
  this.$right.toggleClass('both-visible', bothVisible);
  this.$container.toggleClass('one-visible', (this.leftVisible || this.rightVisible) && !bothVisible);
};

scout.CollapseHandle.prototype.setLeftVisible = function(visible) {
  this.setProperty('leftVisible', visible);
};

scout.CollapseHandle.prototype.setRightVisible = function(visible) {
  this.setProperty('rightVisible', visible);
};

scout.CollapseHandle.prototype._onLeftMouseDown = function(event) {
  this.trigger('action', {
    left: true
  });
};

scout.CollapseHandle.prototype._onRightMouseDown = function(event) {
  this.trigger('action', {
    right: true
  });
};

scout.CollapseHandle.prototype._onMouseDown = function(event) {
  var target = event.target;
  if (this.$left.isOrHas(target)) {
    this.trigger('action', {
      left: true
    });
    return;
  }
  if (this.$right.isOrHas(target)) {
    this.trigger('action', {
      right: true
    });
    return;
  }

  // If there is only one box visible, trigger also when container was clicked
  // Mainly used to make the pixel on the left clickable, when the handle is visible in bench mode
  if (this.$container.hasClass('one-visible')) {
    this.trigger('action', {
      left: this.leftVisible,
      right: this.rightVisible
    });
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * The focus manager ensures proper focus handling based on focus contexts.
 *
 * A focus context is bound to a $container. Once a context is activated, that container defines the tab cycle,
 * meaning that only child elements of that container can be entered by tab. Also, the context ensures proper
 * focus gaining, meaning that only focusable elements can gain focus. A focusable element is defined as an element,
 * which is natively focusable and which is not covert by a glass pane. Furthermore, if a context is unintalled,
 * the previously active focus context is activated and its focus position restored.
 */
scout.FocusManager = function(options) {
  var defaults = {
    // Auto focusing of elements is bad with on screen keyboards -> deactivate to prevent unwanted popping up of the keyboard
    active: !scout.device.supportsTouch(),
    // Preventing blur is bad on touch devices because every touch on a non input field is supposed to close the keyboard which does not happen if preventDefault is used on mouse down
    restrictedFocusGain: !scout.device.supportsTouch()
  };
  $.extend(this, defaults, options);

  if (!this.session) {
    throw new Error('Session expected');
  }

  this._focusContexts = [];
  this._glassPaneTargets = [];

  // Make $entryPoint focusable and install focus context.
  var $mainEntryPoint = this.session.$entryPoint;
  var portletPartId = $mainEntryPoint.data('partid') || '0';
  $mainEntryPoint.attr('tabindex', portletPartId);

  // Restricted focus gain means that not every click outside of the active element necessarily focuses another element but the active element stays focused
  // See _acceptFocusChangeOnMouseDown for details
  if (this.restrictedFocusGain) {
    this.installTopLevelMouseHandlers($mainEntryPoint);
  }
  this.installFocusContext($mainEntryPoint, scout.focusRule.AUTO);
};

scout.FocusManager.prototype.installTopLevelMouseHandlers = function($container) {
  // Install 'mousedown' on top-level $container to accept or prevent focus gain
  $container.on('mousedown', function(event) {
    if (!this._acceptFocusChangeOnMouseDown($(event.target))) {
      event.preventDefault();
    } else {
      // Because in IE DOM elements are focusable without tabindex we have to handle it here -> select next parent with tabindex.
      this._handleIEEvent(event);
    }
    return true;
  }.bind(this));
};

/**
 * Note: this method is a collection of bugfixes for focus problems which only occur on
 * Internet Explorer. Focus handling in IE is different from focus-handling in Chrome and Firefox.
 * Basically this method emulates the focus behavior of the other two browsers, by setting the
 * focus programmatically to the correct element. And yes, the method is ugly since it deals with
 * a lot of specific cases. However: distributing the IE specific bugfix code over several classes
 * wouldn't be much better.
 */
scout.FocusManager.prototype._handleIEEvent = function(event) {
  if (scout.device.browser !== scout.Device.Browser.INTERNET_EXPLORER) {
    return;
  }

  var
    $elementToFocus,
    $element = $(event.target);

  // table fix - required because IE focuses the table-cell element (unlike Chrome and Firefox)
  // that means in IE, the table-cell is focused. But all our styles apply to a focused table
  // that's why we must set the focus programmatically to the closest table in the DOM.
  if ($element.is('.table-cell') || $element.closest('.table-cell').length > 0) {
    this.requestFocus($element.closest('.table'));
    event.preventDefault();
    return;
  }

  // tree fix - same issue as in table
  if ($element.is('.tree-node') || $element.closest('.tree-node').length > 0) {
    this.requestFocus($element.closest('.tree'));
    event.preventDefault();
    return;
  }

  var userSelect = $element.css('user-select');
  var selectableElements =
    'div:not(.desktop),[tabindex]:not([tabindex=-1]),radio,a[href],area[href],input:not([disabled]),' +
    'select:not([disabled]),textarea:not([disabled]),button:not([disabled]),iframe';

  // other fixes (NBU)
  if ($element.not(selectableElements).length === 0) {
    return;
  }

  if ($element.closest('[contenteditable="true"]').length === 0 &&
    ((userSelect && userSelect === 'none') ||
      (!userSelect && $element.closest('div').not('[unselectable="on"]').length === 0)) /* IE 9 has no user-select */ ) {
    $elementToFocus = $element.closest(selectableElements);
    if ($elementToFocus && $elementToFocus.not('[unselectable="on"]').length > 0) {
      this.requestFocus($elementToFocus.get(0));
    }
    event.preventDefault();
  }
};

/**
 * Activates or deactivates focus management.
 *
 * If deactivated, the focus manager still validates the current focus, but never gains focus nor enforces a valid focus position.
 * Once activated, the current focus position is revalidated.
 */
scout.FocusManager.prototype.activate = function(activate) {
  if (this.active !== activate) {
    this.active = activate;
    if ($.log.isDebugEnabled()) {
      $.log.debug('Focus manager active: ' + this.active);
    }
    if (this.active) {
      this.validateFocus();
    }
  }
};

/**
 * Installs a new focus context for the given $container, and sets the $container's initial focus, either by
 * the given rule, or tries to gain focus for the given element.
 */
scout.FocusManager.prototype.installFocusContext = function($container, focusRuleOrElement) {
  var elementToFocus;
  if (!focusRuleOrElement || focusRuleOrElement === scout.focusRule.AUTO) {
    elementToFocus = this.findFirstFocusableElement($container);
  } else if (focusRuleOrElement === scout.focusRule.NONE) {
    elementToFocus = null;
  } else {
    elementToFocus = focusRuleOrElement;
  }

  // Create and register the focus context.
  var focusContext = new scout.FocusContext($container, this);
  this._pushIfAbsendElseMoveTop(focusContext);

  if (elementToFocus) {
    focusContext._validateAndSetFocus(elementToFocus);
  }
};

/**
 * Uninstalls the focus context for the given $container, and activates the last active context.
 * This method has no effect, if there is no focus context installed for the given $container.
 */
scout.FocusManager.prototype.uninstallFocusContext = function($container) {
  var focusContext = this._findFocusContext($container);
  if (!focusContext) {
    return;
  }

  // Filter to exclude the current focus context's container and any of its child elements to gain focus.
  var filter = scout.filters.outsideFilter(focusContext.$container);

  // Remove and dispose the current focus context.
  scout.arrays.remove(this._focusContexts, focusContext);
  focusContext._dispose();

  // Activate last active focus context.
  var activeFocusContext = this._findActiveContext();
  if (activeFocusContext) {
    activeFocusContext._validateAndSetFocus(activeFocusContext._lastValidFocusedElement, filter);
  }
};

/**
 * Returns whether there is a focus context installed for the given $container.
 */
scout.FocusManager.prototype.isFocusContextInstalled = function($container) {
  return !!this._findFocusContext($container);
};

/**
 * Checks if the given element is accessible, meaning not covert by a glasspane.
 *
 * @param element a HTMLElement or a jQuery collection
 */
scout.FocusManager.prototype.isElementCovertByGlassPane = function(element) {
  if (!this._glassPaneTargets.length) {
    return false; // no glasspanes active.
  }

  // Checks whether the element is a child of a glasspane target.
  // If so, the some-iterator returns immediately with true.
  return this._glassPaneTargets.some(function($glassPaneTarget) {
    return $(element).closest($glassPaneTarget).length !== 0;
  });
};

/**
 * Registers the given glasspane target, so that the focus cannot be gained on the given target nor on its child elements.
 */
scout.FocusManager.prototype.registerGlassPaneTarget = function(glassPaneTarget) {
  this._glassPaneTargets.push(glassPaneTarget);
  this.validateFocus();
};

/**
 * Unregisters the given glasspane target, so that the focus can be gained again for the target or one of its child controls.
 */
scout.FocusManager.prototype.unregisterGlassPaneTarget = function(glassPaneTarget) {
  scout.arrays.remove(this._glassPaneTargets, glassPaneTarget);
  this.validateFocus();
};

/**
 * Enforces proper focus on the currently active focus context.
 *
 * @param filter
 *        Filter to exclude elements to gain focus.
 */
scout.FocusManager.prototype.validateFocus = function(filter) {
  var activeContext = this._findActiveContext();
  if (activeContext) {
    activeContext._validateAndSetFocus(activeContext._lastValidFocusedElement, filter);
  }
};

/**
 * Requests the focus for the given element, but only if being a valid focus location.
 *
 * @return true if focus was gained, or false otherwise.
 */
scout.FocusManager.prototype.requestFocus = function(element, filter) {
  element = element instanceof $ ? element[0] : element;

  var activeContext = this._findActiveContext();
  if (activeContext) {
    activeContext._validateAndSetFocus(element, filter);
  }

  return scout.focusUtils.isActiveElement(element);
};

/**
 * Finds the first focusable element of the given $container, or null if not found.
 */
scout.FocusManager.prototype.findFirstFocusableElement = function($container, filter) {
  var firstElement, firstDefaultButton, firstButton, i, candidate, $candidate, $menuParents, $tabParents, $boxButtons,
    $entryPoint = $container.entryPoint(),
    $candidates = $container
    .find(':focusable')
    .addBack(':focusable') /* in some use cases, the container should be focusable as well, e.g. context menu without focusable children */
    .not($entryPoint) /* $entryPoint should never be a focusable candidate. However, if no focusable candidate is found, 'FocusContext._validateAndSetFocus' focuses the $entryPoint as a fallback. */
    .filter(filter || scout.filters.returnTrue);

  for (i = 0; i < $candidates.length; i++) {
    candidate = $candidates[i];
    $candidate = $(candidate);

    // Check whether the candidate is accessible and not covert by a glass pane.
    if (this.isElementCovertByGlassPane(candidate)) {
      continue;
    }
    // Check if the element (or one of its parents) does not want to be the first focusable element
    // FIXME awe, bsh: (focus) replace this concept with Form#renderInitialFocusEnabled: currently we cannot set
    // that property on the model (only by JS). Add a model-property so we can do this on the model.
    // May be useful for ticket-form too, since that form currently focuses a random link in the
    // history table.
    if ($candidate.is('.prevent-initial-focus') || $candidate.closest('.prevent-initial-focus').length > 0) {
      continue;
    }

    if (!firstElement && !($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {
      firstElement = candidate;
    }

    if (!firstDefaultButton && $candidate.is('.default-menu')) {
      firstDefaultButton = candidate;
    }

    $menuParents = $candidate.parents('.menubar');
    $tabParents = $candidate.parents('.tab-area');
    $boxButtons = $candidate.parents('.box-buttons');
    if (($menuParents.length > 0 || $tabParents.length > 0 || $boxButtons.length > 0) && !firstButton && ($candidate.hasClass('button') || $candidate.hasClass('menu-item'))) {
      firstButton = candidate;
    } else if (!$menuParents.length && !$tabParents.length && !$boxButtons.length && typeof candidate.focus === 'function') { //inline buttons and menues are selectable before choosing button or menu from bar
      return candidate;
    }
  }
  if (firstDefaultButton) {
    return firstDefaultButton;
  } else if (firstButton) {
    if (firstButton !== firstElement && firstElement) {
      var $tabParentsButton = $(firstButton).parents('.tab-area'),
        $firstItem = $(firstElement),
        $tabParentsFirstElement = $(firstElement).parents('.tab-area');
      if ($tabParentsFirstElement.length > 0 && $tabParentsButton.length > 0 && $firstItem.is('.tab-item')) {
        return firstElement;
      }
    }
    return firstButton;
  }
  return firstElement;
};

/**
 * Returns the currently active focus context, or null if not applicable.
 */
scout.FocusManager.prototype._findActiveContext = function() {
  return scout.arrays.last(this._focusContexts);
};

/**
 * Returns the focus context which is associated with the given $container, or null if not applicable.
 */
scout.FocusManager.prototype._findFocusContext = function($container) {
  return scout.arrays.find(this._focusContexts, function(focusContext) {
    return focusContext.$container === $container;
  });
};

/**
 * Returns whether to accept a 'mousedown event'.
 */
scout.FocusManager.prototype._acceptFocusChangeOnMouseDown = function($element) {
  // 1. Prevent focus gain when glasspane is clicked.
  //    Even if the glasspane is not focusable, this check is required because the glasspane might be contained in a focusable container
  //    like table. Use case: outline modality with table-page as 'outlineContent'.
  if ($element.hasClass('glasspane')) {
    return false;
  }

  // 2. Prevent focus gain if covert by glasspane.
  if (this.isElementCovertByGlassPane($element)) {
    return false;
  }

  // 3. Prevent focus gain on elements excluded to gain focus by mouse, e.g. buttons.
  if (!scout.focusUtils.isFocusableByMouse($element)) {
    return false;
  }

  // 4. Allow focus gain on focusable elements.
  if ($element.is(':focusable')) {
    return true;
  }

  // 5. Allow focus gain on elements with selectable content, e.g. the value of a label field.
  if (scout.focusUtils.isSelectableText($element)) {
    return true;
  }

  // 6. Allow focus gain on elements with a focusable parent, e.g. when clicking on a row in a table.
  if (scout.focusUtils.containsParentFocusableByMouse($element, $element.entryPoint())) {
    return true;
  }

  return false;
};

/**
 * Registers the given focus context, or moves it on top if already registered.
 */
scout.FocusManager.prototype._pushIfAbsendElseMoveTop = function(focusContext) {
  scout.arrays.remove(this._focusContexts, focusContext);
  this._focusContexts.push(focusContext);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * A focus context is associated with a $container, and controls how to focus elements within that $container.
 */
scout.FocusContext = function($container, focusManager) {
  this.$container = $container;
  this.focusManager = focusManager;

  this._lastValidFocusedElement = null; // variable to store the last valid focus position; used to restore focus once being re-activated.
  this._focusedField = null;

  // Notice: Any listener is installed on $container and not on $field level, except 'remove' listener because does not bubble.
  this._keyDownListener = this._onKeyDown.bind(this);
  this._focusInListener = this._onFocusIn.bind(this);
  this._focusOutListener = this._onFocusOut.bind(this);
  this._hideListener = this._onHide.bind(this);
  this._removeListener = this._onRemove.bind(this);

  this.$container
    .on('keydown', this._keyDownListener)
    .on('focusin', this._focusInListener)
    .on('focusout', this._focusOutListener)
    .on('hide', this._hideListener);
};

scout.FocusContext.prototype._dispose = function() {
  this.$container
    .off('keydown', this._keyDownListener)
    .off('focusin', this._focusInListener)
    .off('focusout', this._focusOutListener)
    .off('hide', this._hideListener);
  $(this._focusedField).off('remove', this._removeListener);
};

/**
 * Method invoked once a 'keydown' event is fired to control proper tab cycle.
 */
scout.FocusContext.prototype._onKeyDown = function(event) {
  if (event.which === scout.keys.TAB) {
    var activeElement = this.$container.activeElement(true),
      $focusableElements = this.$container.find(':tabbable:visible'),
      firstFocusableElement = $focusableElements.first()[0],
      lastFocusableElement = $focusableElements.last()[0],
      focusedElement;
    // Forward Tab
    if (!event.shiftKey) {
      // If the last focusable element is focused, or the focus is on the container, set the focus to the first focusable element
      if (firstFocusableElement && (activeElement === lastFocusableElement || activeElement === this.$container[0])) {
        $.suppressEvent(event);
        this._validateAndSetFocus(firstFocusableElement);
        focusedElement = firstFocusableElement;
      } else if($focusableElements.length>0){
        focusedElement = $focusableElements.get($focusableElements.index(activeElement) + 1);
      }
      else{
        $.suppressEvent(event);
        return;
      }
    }
    // Backward Tab (Shift+TAB)
    else {
      // If the first focusable element is focused, or the focus is on the container, set the focus to the last focusable element
      if (lastFocusableElement && (activeElement === this.$container[0] || activeElement === firstFocusableElement)) {
        $.suppressEvent(event);
        this._validateAndSetFocus(lastFocusableElement);
        focusedElement = firstFocusableElement;
      } else if($focusableElements.length>0){
        focusedElement = $focusableElements.get($focusableElements.index(activeElement) - 1);
      } else{
        $.suppressEvent(event);
        return;
      }
    }
    var $focusableElement = $(focusedElement),
      containerBounds = scout.graphics.offsetBounds($focusableElement),
      $scrollable = $focusableElement.scrollParent();
    if (!scout.scrollbars.isLocationInView(new scout.Point(containerBounds.x, containerBounds.y), $scrollable)) {
      scout.scrollbars.scrollTo($scrollable, $focusableElement);
    }
  }
};

/**
 * Method invoked once a 'focusin' event is fired by this context's $container or one of its child controls.
 */
scout.FocusContext.prototype._onFocusIn = function(event) {
  var $target = $(event.target);
  $target.on('remove', this._removeListener);
  this._focusedField = event.target;

  // Do not update current focus context nor validate focus if target is $entryPoint.
  // That is because focusing the $entryPoint is done whenever no control is currently focusable, e.g. due to glasspanes.
  if (event.target === this.$container.entryPoint(true)) {
    return;
  }

  // Make this context the active context (nothing done if already active) and validate the focus event.
  this.focusManager._pushIfAbsendElseMoveTop(this);
  this._validateAndSetFocus(event.target);

  event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.
};

/**
 * Method invoked once a 'focusout' event is fired by this context's $container or one of its child controls.
 */
scout.FocusContext.prototype._onFocusOut = function(event) {
  $(event.target).off('remove', this._removeListener);
  this._focusedField = null;

  event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event. Otherwise, that 'parent context' would be activated as well.
};

/**
 * Method invoked once a child element of this context's $container is removed.
 */
scout.FocusContext.prototype._onRemove = function(event) {
  // This listener is installed on the focused element only.

  this._validateAndSetFocus(null, scout.filters.notSameFilter(event.target));

  event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.
};

/**
 * Method invoked once a child element of this context's $container is hidden.
 */
scout.FocusContext.prototype._onHide = function(event) {
  if ($(event.target).isOrHas(this._lastValidFocusedElement)) {
    this._validateAndSetFocus(null, scout.filters.notSameFilter(event.target));

    event.stopPropagation(); // Prevent a possible 'parent' focus context to consume this event.
  }
};

/**
 * Focuses the given element if being a child of this context's container and matches the given filter (if provided).
 *
 * @param element
 *        the element to gain focus, or null to focus the context's first focusable element matching the given filter.
 * @param filter
 *        filter to control which element to gain focus, or null to accept all focusable candidates.
 */
scout.FocusContext.prototype._validateAndSetFocus = function(element, filter) {
  // Ensure the element to be a child element, or set it to null otherwise.
  if (element && !$.contains(this.$container[0], element)) {
    element = null;
  }

  var elementToFocus = null;
  if (!element) {
    elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);
  } else if (!filter || filter.call(element)) {
    elementToFocus = element;
  } else {
    elementToFocus = this.focusManager.findFirstFocusableElement(this.$container, filter);
  }

  // Store the element to be focused, and regardless of whether currently covert by a glass pane or the focus manager is not active. That is for later focus restore.
  this._lastValidFocusedElement = elementToFocus;

  // Focus the element.
  this._focus(elementToFocus);
};

/**
 * Focuses the requested element.
 */
scout.FocusContext.prototype._focus = function(elementToFocus) {
  // Only focus element if focus manager is active
  if (!this.focusManager.active) {
    return;
  }

  // Check whether the element is covert by a glasspane
  if (this.focusManager.isElementCovertByGlassPane(elementToFocus)) {
    elementToFocus = null;
  }

  // Focus $entryPoint if current focus is to be blured.
  // Otherwise, the HTML body would be focused which makes global keystrokes (like backspace) not to work anymore.
  elementToFocus = elementToFocus || this.$container.entryPoint(true);

  // Only focus element if different to current focused element
  if (scout.focusUtils.isActiveElement(elementToFocus)) {
    return;
  }

  var $elementToFocus = $(elementToFocus);
  var $el;

  // For each element on the way to the root, remember the current scroll position. When setting
  // the focus to a new element, the browser will try to scroll this element to the visible range.
  // To prevent a "jumping" UI, we will restore the old scroll position after the focus() call.
  for ($el = $elementToFocus; $el.length > 0; $el = $el.parent()) {
    $el.data('oldScrollPosition', {
      left: $el.scrollLeft(),
      top: $el.scrollTop()
    });
  }

  // Focus the requested element
  $elementToFocus.focus();
  if ($.log.isDebugEnabled()) {
    $.log.debug('Focus set to ' + scout.graphics.debugOutput(elementToFocus));
  }

  // Restore scroll positions
  for ($el = $elementToFocus; $el.length > 0; $el = $el.parent()) {
    var oldScrollPosition = $el.data('oldScrollPosition');
    $el.removeData('oldScrollPosition');
    $el.scrollLeft(oldScrollPosition.left);
    $el.scrollTop(oldScrollPosition.top);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Utility methods for focus.
 */
scout.focusUtils = {

  /**
   * @return whether the given element is focusable by mouse.
   * @memberOf scout.focusUtils
   */
  isFocusableByMouse: function(element) {
    var $element = $(element);
    return !$element.hasClass('unfocusable') && !$element.closest('.unfocusable').length;
  },

  /**
   * @return whether the given element has a parent which is focusable by mouse.
   */
  containsParentFocusableByMouse: function(element, entryPoint) {
    var $focusableParentElements = $(element)
      .parents(':focusable')
      .not(entryPoint) /* Exclude $entryPoint as all elements are its descendants. However, the $entryPoint is only focusable to provide Portlet support. */
      .filter(function() {
        return scout.focusUtils.isFocusableByMouse(this);
      });
    return ($focusableParentElements.length > 0);
  },

  /**
   * @return whether the given element contains content which is selectable to the user, e.g. to be copied into clipboard.
   * It also returns true for disabled text-fields, because the user must be able to select and copy text from these text-fields.
   */
  isSelectableText: function(element) {
    var $element = $(element);

    // Find closest element which has a 'user-select' with a value other than 'auto'. If that value
    // is 'none', the text is not selectable. This code mimics the "inheritance behavior" of the CSS
    // property "-moz-user-select: -moz-none" as described in [1].  This does not seem to work in some
    // cases in Firefox, even with bug [2] fixed. As a workaround, we implement the desired behavior here.
    //
    // Note: Some additional CSS rules are required for events other than 'mousedown', see main.css.
    //
    // [1] https://developer.mozilla.org/en-US/docs/Web/CSS/user-select
    // [2] https://bugzilla.mozilla.org/show_bug.cgi?id=648624
    var $el = $element;
    while ($el.css('user-select') === 'auto') {
      $el = $el.parent();
      // Fix for Firefox: parent of BODY element is HtmlDocument. When calling $el.css on the HtmlDocument
      // Firefox throws an error that ownerDocument is undefined. Thus we don't go higher than BODY element
      // and assume body is never selectable.
      if ($el.is('body')) {
        return false;
      }
    }
    if ($el.css('user-select') === 'none') {
      return false;
    }

    if ($element.is('input[disabled][type=text], textarea[disabled]')) {
      return true;
    }
    var text = $element
      .clone()
      .children()
      .remove()
      .end()
      .text()
      .trim();
    return (text.length > 0);
  },


  /**
   * Returns true if the given HTML element is the active element in its own document, false otherwise
   * @param element
   */
  isActiveElement: function(element) {
    if (!element) {
      return false;
    }
    var activeElement;
    if (element instanceof $) {
      activeElement = element.activeElement(true);
      element = element[0];
    } else {
      activeElement = element.ownerDocument.activeElement;
    }
    return activeElement === element;
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Rule describing how to resolve a focusable element.
 *
 * @see FocusManager.js
 */
scout.focusRule = {
  /**
   * Indicates to focus the first focusable element.
   */
  AUTO: 'auto',
  /**
   * Indicates to not focus any element.
   */
  NONE: 'none'
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Is used to render glasspane after the glasspane targets are set. This case occurs when a child is rendered before a parent is rendered-> on reload page.
 */
scout.DeferredGlassPaneTarget = function() {
  this.$glassPaneTargets;
  this.glassPaneRenderer;
};

scout.DeferredGlassPaneTarget.prototype.ready = function($glassPaneTargets) {
  this.$glassPaneTargets = $glassPaneTargets;
  this.renderWhenReady();
};

scout.DeferredGlassPaneTarget.prototype.rendererReady = function(glassPaneRenderer) {
  this.glassPaneRenderer = glassPaneRenderer;
  this.renderWhenReady();
};

scout.DeferredGlassPaneTarget.prototype.removeGlassPaneRenderer = function(glassPaneRenderer) {
  if (this.glassPaneRenderer === glassPaneRenderer) {
    this.glassPaneRenderer = null;
  }
};

scout.DeferredGlassPaneTarget.prototype.renderWhenReady = function() {
  if (this.glassPaneRenderer && this.$glassPaneTargets && this.$glassPaneTargets.length > 0) {
    this.$glassPaneTargets.forEach(function($glassPaneTarget) {
      this.glassPaneRenderer.renderGlassPane($glassPaneTarget[0]);
    }.bind(this));
  }
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * @param widget a not rendered scout.Widget
 * @findGlassPaneTargets function which returns the targets
 */
scout.DeferredGlassPaneTarget.createFor = function(widget, findGlassPaneTargets) {
  if (widget.rendered) {
    throw new Error('Don\'t call this function if widget is already rendered.');
  }

  var deferred = new scout.DeferredGlassPaneTarget();
  var renderedHandler = function(event) {
    var elements = findGlassPaneTargets();
    deferred.ready(elements);
  };

  widget.one('render', renderedHandler);
  widget.one('destroy', function() {
    widget.off('render', renderedHandler);
  }.bind(widget));
  return [deferred];
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Renders glassPanes over the 'glassPaneTargets' of an element.
 */
scout.GlassPaneRenderer = function(session, element, enabled) {
  this._element = element;
  this._enabled = enabled;
  this.session = session;
  this._$glassPanes = [];
  this._$glassPaneTargets = [];
  this._deferredGlassPanes = [];
};

scout.GlassPaneRenderer.prototype.renderGlassPanes = function() {
  this.findGlassPaneTargets().forEach(function(glassPaneTarget) {
    if (glassPaneTarget instanceof scout.DeferredGlassPaneTarget) {
      glassPaneTarget.rendererReady(this);
      this._deferredGlassPanes.push(glassPaneTarget);
    } else {
      this.renderGlassPane(glassPaneTarget);
    }
  }, this);
};

scout.GlassPaneRenderer.prototype.renderGlassPane = function(glassPaneTarget) {
  var $glassPane;

  // Render glasspanes onto glasspane targets.
  $glassPane = $(glassPaneTarget)
    .appendDiv('glasspane')
    .on('mousedown', this._onMousedown.bind(this));

  // Glasspanes in popup-windows must be visible, otherwise the user cannot recognize that the popup
  // is blocked, since the element that blocks (e.g a message-box) may be opened in the main-window.
  if ($glassPane.window(true).popupWindow) {
    $glassPane.addClass('dark');
  }

  this._$glassPanes.push($glassPane);
  this._$glassPaneTargets.push(glassPaneTarget);

  // Register 'glassPaneTarget' in focus manager.
  this.session.focusManager.registerGlassPaneTarget(glassPaneTarget);
};

scout.GlassPaneRenderer.prototype.removeGlassPanes = function() {
  // Remove glass-panes
  this._$glassPanes.forEach(function($glassPane) {
    $glassPane.remove();
  });

  //Unregister all deferedGlassPaneTargets
  this._deferredGlassPanes.forEach(function(glassPaneTarget) {
    glassPaneTarget.removeGlassPaneRenderer(this);
  }, this);

  this._deferredGlassPanes = [];

  // Unregister glasspane targets from focus manager
  this._$glassPaneTargets.forEach(function($glassPaneTarget) {

    this.session.focusManager.unregisterGlassPaneTarget($glassPaneTarget);
  }, this);

  this._$glassPanes = [];
  this._$glassPaneTargets = [];
};

scout.GlassPaneRenderer.prototype.eachGlassPane = function(func) {
  this._$glassPanes.forEach(function($glassPane) {
    func($glassPane);
  });
};

scout.GlassPaneRenderer.prototype.findGlassPaneTargets = function() {
  if (!this._enabled) {
    return []; // No glasspanes to be rendered, e.g. for none-modal dialogs.
  }

  var parent = this._element.displayParent || this.session.desktop; // use Desktop if no parent set.
  if (!parent || !parent.rendered) {
    return []; // No parent, e.g. during startup to display fatal errors.
  }

  if (!parent.glassPaneTargets) {
    return []; // Parent is not a valid display parent.
  }

  return parent.glassPaneTargets();
};

scout.GlassPaneRenderer.prototype._onMousedown = function(event) {
  var $animationTarget = null;

  if (this._element instanceof scout.Form && this._element.isView()) {
    // If the blocking element is a view, the $container cannot be animated (this only works for dialogs). Instead,
    // highlight the view tab (or the overflow item, if the view tab is not visible).

    $animationTarget = this.session.desktop.bench.getViewTab(this._element).$container;
    if (!$animationTarget.isVisible()) {
      $animationTarget = $animationTarget.siblings('.overflow-tab-item');
    }
  } else if (this._element.$container) {
    $animationTarget = this._element.$container;
  }

  if ($animationTarget) {
    $animationTarget.addClassForAnimation('animate-modality-highlight', {
      // remove animate-open as well, user may click the glasspane before the widget itself was able to remove the animate-open class
      classesToRemove: 'animate-modality-highlight animate-open'
    });
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Scrollbar = function() {
  scout.Scrollbar.parent.call(this);

  this._beginDefault = 0;
  this._thumbRange;
  this._scrollSize;
  this._offsetSize;
  this._onScrollWheelHandler = this._onScrollWheel.bind(this);
  this._onScrollHandler = this._onScroll.bind(this);
  this._onScrollbarMousedownHandler = this._onScrollbarMousedown.bind(this);
  this._onThumbMousedownHandler = this._onThumbMousedown.bind(this);
  this._onDocumentMousemoveHandler = this._onDocumentMousemove.bind(this);
  this._onDocumentMouseupHandler = this._onDocumentMouseup.bind(this);
  this._fixScrollbarHandler = this._fixScrollbar.bind(this);
  this._unfixScrollbarHandler = this._unfixScrollbar.bind(this);
};
scout.inherits(scout.Scrollbar, scout.Widget);

scout.Scrollbar.prototype._init = function(options) {
  scout.Scrollbar.parent.prototype._init.call(this, options);
  var defaults = {
    axis: 'y',
    borderless: false,
    mouseWheelNeedsShift: false
  };

  $.extend(this, defaults, options);
};

scout.Scrollbar.prototype._render = function($parent) {
  this._begin = 0;
  this.$container = $parent.appendDiv('scrollbar')
    .addClass(this.axis + '-axis');
  this._$thumb = this.$container.appendDiv('scrollbar-thumb')
    .addClass(this.axis + '-axis');
  if (this.borderless) {
    this.$container.addClass('borderless');
  }

  this._dim = this.axis === 'x' ? 'Width' : 'Height';
  this._dir = this.axis === 'x' ? 'left' : 'top';
  this._dirReverse = this.axis === 'x' ? 'right' : 'bottom';
  this._scrollDir = this.axis === 'x' ? 'scrollLeft' : 'scrollTop';

  // Install listeners
  $parent
    .on('DOMMouseScroll mousewheel', this._onScrollWheelHandler)
    .on('scroll', this._onScrollHandler)
    .data('scrollbars').forEach(function(scrollbar) {
      scrollbar.on('scrollstart', this._fixScrollbarHandler);
      scrollbar.on('scrollend', this._unfixScrollbarHandler);
    }.bind(this));
  this.$container.on('mousedown', this._onScrollbarMousedownHandler);
  this._$thumb.on('mousedown', this._onThumbMousedownHandler);
};

scout.Scrollbar.prototype._onScrollWheel = function(event) {
  var w, d;
  if (!this.$container.isVisible()) {
    return true; // ignore scroll wheel event if there is no scroll bar visible
  }
  if (event.ctrlKey) {
    return true; // allow ctrl + mousewheel to zoom the page
  }
  if (this.mouseWheelNeedsShift !== event.shiftKey) {
    // only scroll if shift modifier matches
    return true;
  }
  event = event.originalEvent || this.$container.window(true).event.originalEvent;
  w = event.wheelDelta ? -event.wheelDelta / 2 : event.detail * 20;
  d = this._scrollSize / this._offsetSize;

  this.trigger('scrollstart');
  this.scroll(w / d);
  this.trigger('scrollend');
  return false;
};

scout.Scrollbar.prototype._onScroll = function(event) {
  this.update();
};

scout.Scrollbar.prototype._onScrollbarMousedown = function(event) {
  this.trigger('scrollstart');
  this._scrollTo(event);
  this.trigger('scrollend');
};

scout.Scrollbar.prototype._onThumbMousedown = function(event) {
  this.trigger('scrollstart');
  this._begin = (this.axis === 'x' ? event.pageX : event.pageY) - this._$thumb.offset()[this._dir];
  this._$thumb.addClass('scrollbar-thumb-move');
  this._$thumb.document()
    .on('mousemove', this._onDocumentMousemoveHandler)
    .one('mouseup', this._onDocumentMouseupHandler);
  return false;
};

scout.Scrollbar.prototype._onDocumentMousemove = function(event) {
  if (!this.rendered) {
    // Scrollbar may be removed in the meantime
    return;
  }
  this._scrollTo(event);
};

scout.Scrollbar.prototype._onDocumentMouseup = function(event) {
  var $document = $(event.currentTarget);
  $document.off('mousemove', this._onDocumentMousemoveHandler);
  if (this.rendered) {
    this._$thumb.removeClass('scrollbar-thumb-move');
  }
  this.trigger('scrollend');
  return false;
};

scout.Scrollbar.prototype._scrollTo = function(event) {
  var begin = this._begin === 0 ? this._beginDefault : this._begin;
  var end = (this.axis === 'x' ? event.pageX : event.pageY) - this._$thumb.offset()[this._dir];
  this.scroll(end - begin);
};

scout.Scrollbar.prototype._remove = function() {
  // Uninstall listeners
  this.$parent
    .off('DOMMouseScroll mousewheel', this._onScrollWheelHandler)
    .off('scroll', this._onScrollHandler)
    .data('scrollbars').forEach(function(scrollbar) {
      scrollbar.off('scrollstart', this._fixScrollbarHandler);
      scrollbar.off('scrollend', this._unfixScrollbarHandler);
    }.bind(this));
  this.$container.off('mousedown', this._onScrollbarMousedownHandler);
  this._$thumb.off('mousedown', '', this._onThumbMousedownHandler);

  scout.Scrollbar.parent.prototype._remove.call(this);
};

/**
 * do not use this internal method
 */
scout.Scrollbar.prototype.update = function() {
  var margin = this.$container['cssMargin' + this.axis.toUpperCase()](),
    scrollPos = this.$parent[this._scrollDir](),
    scrollLeft = this.$parent.scrollLeft(),
    scrollTop = this.$parent.scrollTop();

  this.reset();
  this._offsetSize = this.$parent[0]['offset' + this._dim];
  this._scrollSize = this.$parent[0]['scroll' + this._dim];

  // calc size and range of thumb
  var thumbSize = Math.max(this._offsetSize * this._offsetSize / this._scrollSize - margin, 30);
  this._thumbRange = this._offsetSize - thumbSize - margin;

  // set size of thumb
  this._$thumb.css(this._dim.toLowerCase(), thumbSize);
  this._beginDefault = thumbSize / 2;

  // set location of thumb
  var posNew = scrollPos / (this._scrollSize - this._offsetSize) * this._thumbRange;
  this._$thumb.css(this._dir, posNew);

  // show scrollbar
  if (this._offsetSize >= this._scrollSize) {
    this.$container.css('display', 'none');
  } else {
    this.$container.css('display', '');
  }

  // Position the scrollbar(s)
  // Always update both to make sure every scrollbar (x and y) is positioned correctly
  this.$container.cssRight(-1 * scrollLeft);
  this.$container.cssBottom(-1 * scrollTop);
};

/*
 * Resets thumb size and scrollbar position to make sure it does not extend the scrollSize
 */
scout.Scrollbar.prototype.reset = function() {
  this._$thumb.css(this._dim.toLowerCase(), 0);
  this.$container.cssRight(0);
  this.$container.cssBottom(0);
};

scout.Scrollbar.prototype.scroll = function(posDiff) {
  var scrollbarOffset = this.$container.offset(),
    thumbOffset = this._$thumb.offset(),
    posOld = thumbOffset[this._dir] - scrollbarOffset[this._dir],
    posNew = Math.min(this._thumbRange, Math.max(0, posOld + posDiff)),
    scrollPos = (this._scrollSize - this._offsetSize) / this._thumbRange * posNew;

  this.$parent[this._scrollDir](scrollPos);

  // Thumb and scrollbar would be updated by the scroll handler. To make it more fluent it is done here as well
  this._$thumb.css(this._dir, posNew);
  this.$container.css(this._dirReverse, -1 * scrollPos);
};

/**
 * Sets the position to fixed and updates left and top position.
 * This is necessary to prevent flickering in IE.
 */
scout.Scrollbar.prototype._fixScrollbar = function() {
  scout.scrollbars.fix(this.$container);
};

/**
 * Reverts the changes made by fixScrollbar.
 */
scout.Scrollbar.prototype._unfixScrollbar = function() {
  this._unfixTimeoutId = scout.scrollbars.unfix(this.$container, this._unfixTimeoutId);
};

scout.Scrollbar.prototype.notifyBeforeScroll = function() {
  this.trigger('scrollstart');
};

scout.Scrollbar.prototype.notifyAfterScroll = function() {
  this.trigger('scrollend');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.scrollbars = {

  /**
   * Static function to install a scrollbar on a container.
   * When the client supports pretty native scrollbars, we use them by default.
   * Otherwise we install JS-based scrollbars. In that case the install function
   * creates a new scrollbar.js. For native scrollbars we
   * must set some additional CSS styles.
   *
   * @memberOf scout.scrollbars
   */

  _$scrollables: {},

  getScrollables: function(session) {
    // return scrollables for given session
    if (session) {
      return this._$scrollables[session] || [];
    }

    // return all scrollables, no matter to which session they belong
    var $scrollables = [];
    scout.objects.values(this._$scrollables).forEach(function($scrollablesPerSession) {
      scout.arrays.pushAll($scrollables, $scrollablesPerSession);
    });
    return $scrollables;
  },

  pushScrollable: function(session, $container) {
    if (this._$scrollables[session]) {
      if (this._$scrollables[session].indexOf($container) > -1) {
        // already pushed
        return;
      }
      this._$scrollables[session].push($container);
    } else {
      this._$scrollables[session] = [$container];
    }
    $.log.debug('Scrollable added: ' + $container.attr('class') + '. New length: ' + this._$scrollables.length);
  },

  removeScrollable: function(session, $container) {
    var initLength = 0;
    if (this._$scrollables[session]) {
      initLength = this._$scrollables[session].length;
      scout.arrays.$remove(this._$scrollables[session], $container);
      $.log.debug('Scrollable removed: ' + $container.attr('class') + '. New length: ' + this._$scrollables.length);
      if (initLength === this._$scrollables[session].length) {
        throw new Error('scrollable could not be removed. Potential memory leak. ' + $container.attr('class'));
      }
    } else {
      throw new Error('scrollable could not be removed. Potential memory leak. ' + $container.attr('class'));
    }
  },

  install: function($container, options) {
    var scrollbars, scrollbar, nativeScrollbars,
      htmlContainer = scout.HtmlComponent.optGet($container),
      session = options.session || options.parent.session;

    options = options || {};
    options.axis = options.axis || 'both';

    if (options.nativeScrollbars !== undefined) {
      nativeScrollbars = options.nativeScrollbars;
    } else {
      nativeScrollbars = scout.device.hasPrettyScrollbars();
    }
    if (nativeScrollbars) {
      if (scout.device.isIos()) {
        // On ios, container sometimes is not scrollable when installing too early
        // Happens often with nested scrollable containers (e.g. scrollable table inside a form inside a scrollable tree data)
        setTimeout(installNativeScrollbars);
      } else {
        installNativeScrollbars();
      }
    } else {
      installJsScrollbars();
    }
    if (htmlContainer) {
      htmlContainer.scrollable = true;
    }
    $container.data('scrollable', true);
    this.pushScrollable(session, $container);
    return $container;

    function installNativeScrollbars() {
      $.log.debug('use native scrollbars for container ' + scout.graphics.debugOutput($container));
      if (options.axis === 'x') {
        $container
          .css('overflow-x', 'auto')
          .css('overflow-y', 'hidden');
      } else if (options.axis === 'y') {
        $container
          .css('overflow-x', 'hidden')
          .css('overflow-y', 'auto');
      } else {
        $container.css('overflow', 'auto');
      }
      $container.css('-webkit-overflow-scrolling', 'touch');
    }

    function installJsScrollbars() {
      $.log.debug('installing JS-scrollbars for container ' + scout.graphics.debugOutput($container));
      scrollbars = scout.arrays.ensure($container.data('scrollbars'));
      scrollbars.forEach(function(scrollbar) {
        scrollbar.destroy();
      });
      scrollbars = [];
      if (options.axis === 'both') {
        var scrollOptions = $.extend({}, options);
        scrollOptions.axis = 'y';
        scrollbar = scout.create('Scrollbar', scrollOptions);
        scrollbars.push(scrollbar);

        scrollOptions.axis = 'x';
        scrollOptions.mouseWheelNeedsShift = true;
        scrollbar = scout.create('Scrollbar', scrollOptions);
        scrollbars.push(scrollbar);
      } else {
        scrollbar = scout.create('Scrollbar', options);
        scrollbars.push(scrollbar);
      }
      $container.css('overflow', 'hidden');
      $container.data('scrollbars', scrollbars);
      scrollbars.forEach(function(scrollbar) {
        scrollbar.render($container);
        scrollbar.update();
      });
    }
  },

  /**
   * Removes the js scrollbars for the $container, if there are any.<p>
   * Also removes the scrollable from the detachhelper.
   */
  uninstall: function($container, session) {
    if (!$container.data('scrollable')) {
      // was not installed previously -> uninstalling not necessary
      return;
    }

    var scrollbars = $container.data('scrollbars');
    if (scrollbars) {
      scrollbars.forEach(function(scrollbar) {
        scrollbar.destroy();
      });
    }
    this.removeScrollable(session, $container);
    $container.removeData('scrollable');
    $container.css('overflow', '');
    $container.removeData('scrollbars');

    var htmlContainer = scout.HtmlComponent.optGet($container);
    if (htmlContainer) {
      htmlContainer.scrollable = false;
    }
  },

  /**
   * Recalculates the scrollbar size and position.
   * @param $scrollable JQuery element that has .data('scrollbars'), when $scrollable is falsy the function returns immediately
   * @param immediate set to true to immediately update the scrollbar, If set to false,
   *        it will be queued in order to prevent unnecessary updates.
   */
  update: function($scrollable, immediate) {
    if (!$scrollable) {
      return;
    }
    var scrollbars = $scrollable.data('scrollbars');
    if (!scrollbars) {
      return;
    }
    if (immediate) {
      doUpdate();
      return;
    }
    if ($scrollable.data('scrollbarUpdatePending')) {
      return;
    }
    // Executes the update later to prevent unnecessary updates
    setTimeout(function() {
      doUpdate();
      $scrollable.removeData('scrollbarUpdatePending');
    }.bind(this), 0);
    $scrollable.data('scrollbarUpdatePending', true);

    function doUpdate() {
      // Reset the scrollbars first to make sure they don't extend the scrollSize
      scrollbars.forEach(function(scrollbar) {
        if (scrollbar.rendered) {
          scrollbar.reset();
        }
      });
      scrollbars.forEach(function(scrollbar) {
        if (scrollbar.rendered) {
          scrollbar.update();
        }
      });
    }
  },

  reset: function($scrollable) {
    var scrollbars = $scrollable.data('scrollbars');
    if (!scrollbars) {
      return;
    }
    scrollbars.forEach(function(scrollbar) {
      scrollbar.reset();
    });
  },

  /**
   * Scrolls the $scrollable to the given $element (must be a child of $scrollable)
   */
  scrollTo: function($scrollable, $element) {
    var scrollTo,
      scrollOffsetUp = 4,
      scrollOffsetDown = 8,
      scrollableH = $scrollable.height(),
      elementBounds = scout.graphics.offsetBounds($element, false, false),
      scrollableBounds = scout.graphics.offsetBounds($scrollable, false, false),
      elementTop = elementBounds.y - scrollableBounds.y - scrollOffsetUp,
      elementH = elementBounds.height + scrollOffsetDown;

    //There are some elements which has a height of 0 (Checkboxes / Radiobuttons) -> try to get field and figure out its height and offset
    // TODO CGU remove this hack, fix checkbox and radio buttons
    if (elementH === scrollOffsetDown && $element.data('valuefield') && $element.data('valuefield').$container) {
      $element = $element.data('valuefield').$container;
      elementBounds = scout.graphics.offsetBounds($element, false, false);
      elementTop = elementBounds.y - scrollableBounds.y - scrollOffsetUp;
      elementH = elementBounds.height + scrollOffsetDown;
    }

    if (elementTop < 0) {
      scout.scrollbars.scrollTop($scrollable, $scrollable.scrollTop() + elementTop);
    } else if (elementTop + elementH > scrollableH) {
      // On IE, a fractional position gets truncated when using scrollTop -> ceil to make sure the full element is visible
      scrollTo = Math.ceil($scrollable.scrollTop() + elementTop + elementH - scrollableH);
      scout.scrollbars.scrollTop($scrollable, scrollTo);
    }
  },

  /**
   * Horizontally scrolls the $scrollable to the given $element (must be a child of $scrollable)
   *
   */
  scrollHorizontalTo: function($scrollable, $element) {
    var scrollTo,
      scrollableW = $scrollable.width(),
      elementBounds = scout.graphics.bounds($element, true, true),
      elementLeft = elementBounds.x,
      elementW = elementBounds.width;

    if (elementLeft < 0) {
      scout.scrollbars.scrollLeft($scrollable, $scrollable.scrollLeft() + elementLeft);
    } else if (elementLeft + elementW > scrollableW) {
      // On IE, a fractional position gets truncated when using scrollTop -> ceil to make sure the full element is visible
      scrollTo = Math.ceil($scrollable.scrollLeft() + elementLeft + elementW - scrollableW);
      scout.scrollbars.scrollLeft($scrollable, scrollTo);
    }
  },

  scrollTop: function($scrollable, scrollTop) {
    var scrollbar = scout.scrollbars.scrollbar($scrollable, 'y');
    if (scrollbar) {
      // js scrolling
      scrollbar.notifyBeforeScroll();
      $scrollable.scrollTop(scrollTop);
      scrollbar.notifyAfterScroll();
    } else {
      // native scrolling
      $scrollable.scrollTop(scrollTop);
    }
  },

  scrollLeft: function($scrollable, scrollLeft) {
    var scrollbar = scout.scrollbars.scrollbar($scrollable, 'x');
    if (scrollbar) {
      // js scrolling
      scrollbar.notifyBeforeScroll();
      $scrollable.scrollLeft(scrollLeft);
      scrollbar.notifyAfterScroll();
    } else {
      // native scrolling
      $scrollable.scrollLeft(scrollLeft);
    }
  },

  scrollbar: function($scrollable, axis) {
    var scrollbars = $scrollable.data('scrollbars') || [];
    return scout.arrays.find(scrollbars, function(scrollbar) {
      return scrollbar.axis === axis;
    });
  },

  scrollToBottom: function($scrollable) {
    scout.scrollbars.scrollTop($scrollable, $scrollable[0].scrollHeight - $scrollable[0].offsetHeight);
  },

  /**
   * Returns true if the location is visible in the current viewport of the $scrollable, or if $scrollable is null
   * @param location object with x and y properties
   *
   */
  isLocationInView: function(location, $scrollable) {
    if (!$scrollable || $scrollable.length === 0) {
      return true;
    }
    var scrollableOffsetBounds = scout.graphics.offsetBounds($scrollable);
    return scrollableOffsetBounds.contains(location.x, location.y);
  },

  /**
   * Attaches the given handler to each scrollable parent, including $anchor if it is scrollable as well.<p>
   * Make sure you remove the handlers when not needed anymore using offScroll.
   */
  onScroll: function($anchor, handler) {
    handler.$scrollParents = [];
    $anchor.scrollParents().each(function() {
      var $scrollParent = $(this);
      $scrollParent.on('scroll', handler);
      handler.$scrollParents.push($scrollParent);
    });
  },

  offScroll: function(handler) {
    var $scrollParents = handler.$scrollParents;
    if (!$scrollParents) {
      throw new Error('$scrollParents are not defined');
    }
    for (var i = 0; i < $scrollParents.length; i++) {
      var $elem = $scrollParents[i];
      $elem.off('scroll', handler);
    }
  },

  /**
   * Sets the position to fixed and updates left and top position.
   * This is necessary to prevent flickering in IE.
   */
  fix: function($elem) {
    var bounds = scout.graphics.offsetBounds($elem);
    $elem
      .css('position', 'fixed')
      .cssLeft(bounds.x - $elem.cssMarginLeft())
      .cssTop(bounds.y - $elem.cssMarginTop())
      .cssWidth(bounds.width)
      .cssHeight(bounds.height);
  },

  /**
   * Reverts the changes made by fix().
   */
  unfix: function($elem, timeoutId) {
    clearTimeout(timeoutId);
    return setTimeout(function() {
      $elem.css({
        position: 'absolute',
        left: '',
        top: '',
        width: '',
        height: ''
      });
    }.bind(this), 50);
  },

  /**
   * Stores the position of all scrollables that belong to an optional session.
   * @param session (optional) when no session is given, scrollables from all sessions are stored
   */
  storeScrollPositions: function($container, session) {
    var $scrollables = this.getScrollables(session);
    if (!$scrollables) {
      return;
    }

    var scrollTop, scrollLeft;
    $scrollables.forEach(function($scrollable) {
      if ($container.isOrHas($scrollable[0])) {
        scrollTop = $scrollable.scrollTop();
        $scrollable.data('scrollTop', scrollTop);
        scrollLeft = $scrollable.scrollLeft();
        $scrollable.data('scrollLeft', $scrollable.scrollLeft());
        $.log.debug('Stored scroll position for ' + $scrollable.attr('class') + '. Top: ' + scrollTop + '. Left: ' + scrollLeft);
      }
    });
  },

  /**
   * Restores the position of all scrollables that belong to an optional session.
   * @param session (optional) when no session is given, scrollables from all sessions are restored
   */
  restoreScrollPositions: function($container, session) {
    var $scrollables = this.getScrollables(this.session);
    if (!$scrollables) {
      return;
    }

    var scrollTop, scrollLeft;
    $scrollables.forEach(function($scrollable) {
      if ($container.isOrHas($scrollable[0])) {
        scrollTop = $scrollable.data('scrollTop');
        if (scrollTop) {
          $scrollable.scrollTop(scrollTop);
          $scrollable.removeData('scrollTop');
        }
        scrollLeft = $scrollable.data('scrollLeft');
        if (scrollLeft) {
          $scrollable.scrollLeft(scrollLeft);
          $scrollable.removeData('scrollLeft');
        }
        // Also make sure that scroll bar is up to date
        // Introduced for use case: Open large table page, edit entry, press f5
        // -> outline tab gets rendered, scrollbar gets updated with set timeout, outline tab gets detached
        // -> update event never had any effect because it executed after detaching (due to set timeout)
        scout.scrollbars.update($scrollable);
        $.log.debug('Restored scroll position for ' + $scrollable.attr('class') + '. Top: ' + scrollTop + '. Left: ' + scrollLeft);
      }
    });
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Splitter = function() {
  scout.Splitter.parent.call(this);
  this.splitHorizontal;
  this.$anchor;
  this._$root;
  this.ratio;
  this.position; // current splitter position in pixels, updated by updatePosition()
  this._cursorOffset = 0; // distance from cursor to splitter, makes resizing smoother by preventing initial 'jump'
};
scout.inherits(scout.Splitter, scout.Widget);

scout.Splitter.prototype._init = function(options) {
  scout.Splitter.parent.prototype._init.call(this, options);
  this.splitHorizontal = scout.nvl(options.splitHorizontal, true);
  this.$anchor = options.$anchor;
  this._$root = options.$root;
};

scout.Splitter.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('splitter')
    .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis')
    .on('mousedown', this._onMouseDown.bind(this));
  this._$window = $parent.window();
  this._$body = $parent.body();
};

scout.Splitter.prototype.getPosition = function() {
  return this.position;
};

scout.Splitter.prototype.getRatio = function() {
  return this.ratio;
};

/**
 * Sets the splitter position to the specified newSize (in pixels). If the newSize is
 * not specified, the size is calculated automatically by reading the this.$anchor
 * element's bounds.
 *
 * @returns the effective position in pixel.
 * Note: This function does not fire any events.
 */
scout.Splitter.prototype.setPosition = function(newPosition, updateRatio, firePositionChanged) {
  if (!$.isNumeric(newPosition)) {
    // Get size automatically from $anchor element's bounds
    var anchorBounds = scout.graphics.offsetBounds(this.$anchor);
    if (this.splitHorizontal) {
      newPosition = anchorBounds.x + anchorBounds.width;
    } else {
      newPosition = anchorBounds.y + anchorBounds.height;
    }
  }
  if (newPosition === this.position) {
    return;
  }

  this._setPosition(newPosition, updateRatio, firePositionChanged);
  return newPosition;
};

scout.Splitter.prototype._setPosition = function(newPosition, updateRatio, firePositionChanged) {
  firePositionChanged = scout.nvl(firePositionChanged, true);
  if (!$.isNumeric(newPosition)) {
    return;
  }
  if (newPosition === this.position) {
    return;
  }
  if (updateRatio) {
    if (this.splitHorizontal) {
      this.ratio = newPosition / this._$root.outerWidth(true);
    } else {
      this.ratio = newPosition / this._$root.outerHeight(true);
    }
  }
  this.position = newPosition;
  var positionChangedEvent = {
    position: newPosition
  };
  if (firePositionChanged) {
    this.trigger('positionChanged', positionChangedEvent);
  }
  if (this.rendered) {
    // Set the new position (center splitter around 'newPosition')
    var splitterSize = scout.graphics.getVisibleSize(this.$container, true);
    if (this.splitHorizontal) {
      this.$container.cssLeft(newPosition - (splitterSize.width / 2));
    } else {
      this.$container.cssTop(newPosition - (splitterSize.height / 2));
    }
  }
};
scout.Splitter.prototype._onMouseDown = function(event) {
  var splitterCenter = scout.graphics.offsetBounds(this.$container, true).center();

  // Add listeners (we add them to the window to make sure we get the mouseup event even when the cursor it outside the window)
  this._$window
    .on('mousemove.splitter', this._onMouseMove.bind(this))
    .one('mouseup', this._onMouseUp.bind(this));
  // Ensure the correct cursor is always shown while moving
  this._$body.addClass(this.splitHorizontal ? 'col-resize' : 'row-resize');
  this._cursorOffset = {
    left: splitterCenter.x - event.pageX,
    top: splitterCenter.y - event.pageY
  };
  this.trigger('moveStart', {
    position: this._getSplitterPosition(event)
  });
  // Prevent text selection in a form
  event.preventDefault();
};

scout.Splitter.prototype._getSplitterPosition = function(event) {
  var rootBounds = scout.graphics.offsetBounds(this._$root);
  if (this.splitHorizontal) {
    return event.pageX + this._cursorOffset.left - rootBounds.x;
  } else {
    return event.pageY + this._cursorOffset.top - rootBounds.y;
  }
};

scout.Splitter.prototype._onMouseMove = function(event) {
  var splitterPosition = this._getSplitterPosition(event);
  // fire event
  var moveEvent = {
    position: splitterPosition,
    defaultPrevented: false,
    preventDefault: function() {
      this.defaultPrevented = true;
    },
    setPosition: function(newPosition) {
      this.position = newPosition;
    }
  };
  this.trigger('move', moveEvent);
  if (moveEvent.defaultPrevented) {
    return;
  }
  this._setPosition(moveEvent.position, true);
};

scout.Splitter.prototype._onMouseUp = function(event) {
  // Remove listeners and reset cursor
  this._$window.off('mousemove.splitter');
  this._$body.removeClass((this.splitHorizontal ? 'col-resize' : 'row-resize'));
  this.trigger('moveEnd', {
    position: this.position
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Custom JavaScript Date Format
 *
 * Support for formatting and parsing dates based on a pattern string and some locale
 * information from the server model. A subset of the standard Java pattern strings
 * (see SimpleDateFormat) with the most commonly used patterns is supported.
 *
 * This object only operates on the local time zone.
 * <p>
 * locale.dateFormatSymbols contains:
 * <ul>
 * <li>weekdays start with Sunday (starts at 0 and not 1 as it does in java)</li>
 * <li>weekdaysShort start with Sunday (starts at 0 and not 1 as it does in java)</li>
 * <li>months start with January</li>
 * <li>monthsShort start with January<7li>
 * <li>am</li>
 * <li>pm</li>
 *</ul>
 *
 * @see http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html
 */
scout.DateFormatPatternType = {
  YEAR: 'year',
  MONTH: 'month',
  WEEK_IN_YEAR: 'week_in_year',
  DAY_IN_MONTH: 'day_in_month',
  WEEKDAY: 'weekday',
  HOUR_24: 'hour_24',
  HOUR_12: 'hour_12',
  AM_PM: 'am_pm',
  MINUTE: 'minute',
  SECOND: 'second',
  MILLISECOND: 'millisecond'
};

scout.DateFormat = function(locale, pattern) { // NOSONAR
  /*jshint sub:true*/
  this.locale = locale;
  if (this.locale === undefined || this.locale === null) {
    throw new Error('Missing locale');
  }
  this.pattern = pattern || locale.dateFormatPatternDefault;
  if (this.pattern === undefined || this.pattern === null) {
    throw new Error('Missing pattern');
  }

  this.symbols = locale.dateFormatSymbols;
  this.symbols.firstDayOfWeek = 1; // monday //FIXME cgu: deliver from server
  this.symbols.weekdaysOrdered = scout.dates.orderWeekdays(this.symbols.weekdays, this.symbols.firstDayOfWeek);
  this.symbols.weekdaysShortOrdered = scout.dates.orderWeekdays(this.symbols.weekdaysShort, this.symbols.firstDayOfWeek);
  this.symbols.monthsToNumber;
  this.symbols.monthsShortToNumber;

  // List of terms, e.g. split up parts of this.pattern. The length of this array is equal
  // to the length of this._formatFunctions, this._parseFunctions and this._analyzeFunctions.
  this._terms = [];

  // List of format function to be called _in that exact order_ to convert this.pattern
  // to a formatted date string (by sequentially replacing all terms with real values).
  this._formatFunctions = [];

  // List of parse functions to be called _in that exact order_ to convert an input
  // string to a valid JavaScript Date object. This order matches the recognized terms
  // in the pattern. Unrecognized terms are represented by a "constant" function that
  // matches the string itself (e.g. separator characters or spaces).
  this._parseFunctions = [];

  // Array of arrays, same order as _parseFunctions, but term functions are a list of term functions (to support lenient parsing)
  this._analyzeFunctions = [];

  var _dateFormat = this;

  // Local helper (constructor) functions
  /**
   * Definition of a date format pattern.
   *
   * A definition provides the following properties (most of which can be set with the 'options' argument):
   *
   * type:
   *   The "group" where the pattern definition belongs to. E.g. "dd" and "d" belong to the same group "day".
   *   This is used during analysis to find other definitions for the same type. Use one of the constants
   *   defined in scout.DateFormatPatternType.
   *
   * terms:
   *   An array consisting of all pattern terms that this particular definition can handle. Multiple
   *   terms with the same meaning may be accepted (e.g. "yyy", "yy" and "y" can be all used for a
   *   2-digit year formatting, but different parsing rules may apply).
   *
   * acceptedTerm:
   *   Indicates which of the "terms" exactly was accepted for the date pattern.
   *
   * dateFormat:
   *   Reference to the corresponding dateFormat object.
   *
   * formatFunction:
   *   An optional function that is used to format this particular term.
   *   @param formatContext
   *            See documentation at _createFormatContext().
   *   @return
   *            The function may return a string as result. If a string is returned, it is appended
   *            to the formatContext.formattedString automatically. If the formatFunction already did
   *            this, it should return "undefined".
   *
   * parseRegExp:
   *   A optional JavaScript RegExp object that is applied to the input string to extract this
   *   definition's term. The expression _must_ use exactly two capturing groups:
   *   [1] = matched part of the input
   *   [2] = remaining input (will be parsed later by other definitions)
   *   Example: /^(\d{4})(.*)$/
   *
   * applyMatchFunction:
   *   If 'parseRegExp' is set and found a match, and this function is defined, it is called
   *   to apply the matched part to the parseContext.
   *   @param parseContext
   *            See documentation at _createParseContext().
   *   @param match
   *            The first match from the reg exp.
   *   @return
   *            No return value.
   *
   * parseFunction:
   *   If parsing is not possible with a regular expression, this function may be defined to execute
   *   more complex parse logic.
   *   @param parseContext
   *            See documentation at _createParseContext().
   *   @return
   *            A string with the matched part of the input, or null if it did not match.
   */
  var DateFormatPatternDefinition = function(options) { // NOSONAR
    options = options || {};
    this.type = options.type;
    // List of termins meaning the same thing
    if (Array.isArray(options.terms)) {
      this.terms = options.terms;
    } else {
      this.terms = [options.terms];
    }
    this.acceptedTerm = null; // set by accept()
    this.dateFormat = _dateFormat;
    this.formatFunction = options.formatFunction && options.formatFunction.bind(this);
    this.parseRegExp = options.parseRegExp;
    this.applyMatchFunction = options.applyMatchFunction && options.applyMatchFunction.bind(this);
    this.parseFunction = options.parseFunction && options.parseFunction.bind(this);
  };

  DateFormatPatternDefinition.prototype.createFormatFunction = function() {
    return function(formatContext) {
      if (this.formatFunction) {
        var result = this.formatFunction(formatContext);
        if (result !== undefined) { // convenience
          formatContext.formattedString += result;
        }
      }
    }.bind(this);
  };

  DateFormatPatternDefinition.prototype.createParseFunction = function() {
    return function(parseContext) {
      var m, parsedTerm, match;

      var success = false;
      if (this.parseRegExp) {
        // RegEx handling (default)
        m = this.parseRegExp.exec(parseContext.inputString);
        if (m) { // match found
          if (this.applyMatchFunction) {
            this.applyMatchFunction(parseContext, m[1]);
          }
          match = m[1];
          // update remaining string
          parseContext.inputString = m[2];
          success = true;
        }
      }
      if (!success && this.parseFunction) {
        // Custom function
        match = this.parseFunction(parseContext);
        if (match !== null) {
          success = true;
        }
      }

      if (success) {
        // If patternDefinition accepts more than one term, try to choose
        // the form that matches the length of the match.
        parsedTerm = this.terms[0];
        if (this.terms.length > 1) {
          this.terms.some(function(term) {
            if (term.length === match.length) {
              parsedTerm = term;
              return true; // found
            }
            return false; // look further
          });
        }
        parseContext.parsedPattern += parsedTerm;
      }
      return success;
    }.bind(this);
  };

  DateFormatPatternDefinition.prototype.accept = function(term) {
    if (term) {
      // Check if one of the terms matches
      for (var i = 0; i < this.terms.length; i++) {
        if (term === this.terms[i]) {
          this.acceptedTerm = this.terms[i];
          return true;
        }
      }
    }
    this.acceptedTerm = null;
    return false;
  };

  // Build a list of all pattern definitions. This list is then used to build the list of
  // format, parse and analyze functions according to this.pattern.
  //
  // !!! PLEASE NOTE !!!
  // The order of these definitions is important! For each term in the pattern, the list
  // is scanned from the beginning until a definition accepts the term. If the wrong
  // definition was picked, results would be unpredictable.
  //
  // Following the following rules ensures that the algorithm can pick the best matching
  // pattern format definition for each term in the pattern:
  // - Sort definitions by time span, from large (year) to small (milliseconds).
  // - Two definitions of the same type should be sorted by term length, from long
  //   (e.g. MMMM) to short (e.g. M).
  this._patternDefinitions = [
    // --- Year ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.YEAR,
      terms: 'yyyy',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(formatContext.inputDate.getFullYear(), 4).slice(-4);
      },
      parseRegExp: /^(\d{4})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.matchInfo.year = match;
        parseContext.dateInfo.year = Number(match);
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.YEAR,
      terms: ['yyy', 'yy', 'y'],
      formatFunction: function(formatContext) {
        var year = String(formatContext.inputDate.getFullYear());
        var length = (formatContext.exactLength ? this.acceptedTerm.length : 2);
        if (this.acceptedTerm.length === 1) {
          // Return max. 2 digits, no leading zero
          return year.slice(-length);
        }
        // Return max. 2 digits with zero padding
        return scout.strings.padZeroLeft(year, length).slice(-length);
      },
      parseRegExp: /^(\d{1,3})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        if (match.length === 3) {
          parseContext.dateInfo.year = Number(match);
          parseContext.matchInfo.year = match;
          return;
        }
        var shortInputYear = Number(match);
        var startDate = parseContext.startDate || new Date();
        var shortStartYear = Number(String(startDate.getFullYear()).slice(-2));
        var rangeMin = (shortStartYear - 50 < 0 ? shortStartYear + 50 : shortStartYear - 50);
        var yearPrefix = String(scout.strings.padZeroLeft(startDate.getFullYear(), 4)).substr(0, 2);
        if (shortInputYear > rangeMin) {
          yearPrefix = Number(yearPrefix) - 1;
        }
        var year = Number(String(yearPrefix) + scout.strings.padZeroLeft(shortInputYear, 2));
        parseContext.dateInfo.year = year;
        parseContext.matchInfo.year = match;
      }
    }),
    // --- Month ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MONTH,
      terms: 'MMMM',
      formatFunction: function(formatContext) {
        return this.dateFormat.symbols.months[formatContext.inputDate.getMonth()];
      },
      parseFunction: function(parseContext) {
        var i, symbol, re, m;
        for (i = 0; i < this.dateFormat.symbols.months.length; i++) {
          symbol = this.dateFormat.symbols.months[i];
          if (!symbol) {
            continue; // Ignore empty symbols (otherwise, pattern would match everything)
          }
          re = new RegExp('^(' + scout.strings.quote(symbol) + ')(.*)$', 'i');
          m = re.exec(parseContext.inputString);
          if (m) { // match found
            parseContext.dateInfo.month = i;
            parseContext.matchInfo.month = m[1];
            parseContext.inputString = m[2];
            return m[1];
          }
        }
        // No match found so far. In analyze mode, check prefixes.
        if (parseContext.analyze) {
          for (i = 0; i < this.dateFormat.symbols.months.length; i++) {
            symbol = this.dateFormat.symbols.months[i];
            re = new RegExp('^(' + scout.strings.quote(parseContext.inputString) + ')(.*)$', 'i');
            m = re.exec(symbol);
            if (m) { // match found
              parseContext.dateInfo.month = i;
              parseContext.matchInfo.month = symbol;
              parseContext.inputString = '';
              return m[1];
            }
          }
        }
        return null; // no match found
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MONTH,
      terms: 'MMM',
      formatFunction: function(formatContext) {
        return this.dateFormat.symbols.monthsShort[formatContext.inputDate.getMonth()];
      },
      parseFunction: function(parseContext) {
        var i, symbol, re, m;
        for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {
          symbol = this.dateFormat.symbols.monthsShort[i];
          if (!symbol) {
            continue; // Ignore empty symbols (otherwise, pattern would match everything)
          }
          re = new RegExp('^(' + scout.strings.quote(symbol) + ')(.*)$', 'i');
          m = re.exec(parseContext.inputString);
          if (m) { // match found
            parseContext.dateInfo.month = i;
            parseContext.matchInfo.month = m[1];
            parseContext.inputString = m[2];
            return m[1];
          }
        }
        // No match found so far. In analyze mode, check prefixes.
        if (parseContext.analyze) {
          for (i = 0; i < this.dateFormat.symbols.monthsShort.length; i++) {
            symbol = this.dateFormat.symbols.monthsShort[i];
            re = new RegExp('^(' + scout.strings.quote(parseContext.inputString) + ')(.*)$', 'i');
            m = re.exec(symbol);
            if (m) { // match found
              parseContext.dateInfo.month = i;
              parseContext.matchInfo.month = symbol;
              parseContext.inputString = '';
              return m[1];
            }
          }
        }
        return null; // no match found
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MONTH,
      terms: 'MM',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(formatContext.inputDate.getMonth() + 1, 2);
      },
      parseRegExp: /^(\d{2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        var month = Number(match);
        parseContext.dateInfo.month = month - 1;
        parseContext.matchInfo.month = match;
      },
      parseFunction: function(parseContext) {
        // Special case! When regexp did not match, check if input is '0'. In this case (and only
        // if we are in analyze mode), predict '01' as input.
        if (parseContext.analyze) {
          if (parseContext.inputString === '0') {
            // Use current dateInfo to create a date
            var date = this.dateFormat._dateInfoToDate(parseContext.dateInfo);
            if (!date) {
              return null; // parsing failed (dateInfo does not seem to contain a valid string)
            }
            var month = date.getMonth();
            if (month >= 9) {
              month = 0;
              if (parseContext.dateInfo.year === undefined) {
                parseContext.dateInfo.year = Number(date.getFullYear()) + 1;
              } else {
                parseContext.dateInfo.year = parseContext.dateInfo.year + 1;
              }
            }
            parseContext.dateInfo.month = month;
            parseContext.matchInfo.month = scout.strings.padZeroLeft(String(month + 1), 2);
            parseContext.inputString = '';
            return '0';
          }
        }
        return null; // no match found
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MONTH,
      terms: 'M',
      formatFunction: function(formatContext) {
        return String(formatContext.inputDate.getMonth() + 1);
      },
      parseRegExp: /^(\d{1,2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        var month = Number(match);
        parseContext.dateInfo.month = month - 1;
        parseContext.matchInfo.month = match;
      }
    }),
    // --- Week in year ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.WEEK_IN_YEAR,
      terms: 'ww',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(scout.dates.weekInYear(formatContext.inputDate), 2);
      },
      parseRegExp: /^(\d{2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.matchInfo.week = match;
        parseContext.hints.weekInYear = Number(match);
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.WEEK_IN_YEAR,
      terms: 'w',
      formatFunction: function(formatContext) {
        return String(scout.dates.weekInYear(formatContext.inputDate));
      },
      parseRegExp: /^(\d{1,2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.matchInfo.week = match;
        parseContext.hints.weekInYear = Number(match);
      }
    }),
    // --- Day in month ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.DAY_IN_MONTH,
      terms: 'dd',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(formatContext.inputDate.getDate(), 2);
      },
      parseRegExp: /^(\d{2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.day = Number(match);
        parseContext.matchInfo.day = match;
      },
      parseFunction: function(parseContext) {
        // Special case! When regexp did not match, check if input is '0'. In this case (and only
        // if we are in analyze mode), predict '01' as input.
        if (parseContext.analyze) {
          if (parseContext.inputString === '0') {
            parseContext.dateInfo.day = 1;
            parseContext.matchInfo.day = '01';
            parseContext.inputString = '';
            return '0';
          }
        }
        return null; // no match found
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.DAY_IN_MONTH,
      terms: 'd',
      formatFunction: function(formatContext) {
        return String(formatContext.inputDate.getDate());
      },
      parseRegExp: /^(\d{1,2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.day = Number(match);
        parseContext.matchInfo.day = match;
      }
    }),
    // --- Weekday ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.WEEKDAY,
      terms: 'EEEE',
      formatFunction: function(formatContext) {
        return this.dateFormat.symbols.weekdays[formatContext.inputDate.getDay()];
      },
      parseFunction: function(parseContext) {
        var i, symbol, re, m;
        for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {
          symbol = this.dateFormat.symbols.weekdays[i];
          if (!symbol) {
            continue; // Ignore empty symbols (otherwise, pattern would match everything)
          }
          re = new RegExp('^(' + scout.strings.quote(symbol) + ')(.*)$', 'i');
          m = re.exec(parseContext.inputString);
          if (m) { // match found
            parseContext.matchInfo.weekday = m[1];
            parseContext.hints.weekday = i;
            parseContext.inputString = m[2];
            return m[1];
          }
        }
        // No match found so far. In analyze mode, check prefixes.
        if (parseContext.analyze) {
          for (i = 0; i < this.dateFormat.symbols.weekdays.length; i++) {
            symbol = this.dateFormat.symbols.weekdays[i];
            re = new RegExp('^(' + scout.strings.quote(parseContext.inputString) + ')(.*)$', 'i');
            m = re.exec(symbol);
            if (m) { // match found
              parseContext.matchInfo.weekday = symbol;
              parseContext.hints.weekday = i;
              parseContext.inputString = '';
              return m[1];
            }
          }
        }
        return null; // no match found
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.WEEKDAY,
      terms: ['EEE', 'EE', 'E'],
      formatFunction: function(formatContext) {
        return this.dateFormat.symbols.weekdaysShort[formatContext.inputDate.getDay()];
      },
      parseFunction: function(parseContext) {
        var i, symbol, re, m;
        for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {
          symbol = this.dateFormat.symbols.weekdaysShort[i];
          if (!symbol) {
            continue; // Ignore empty symbols (otherwise, pattern would match everything)
          }
          re = new RegExp('^(' + scout.strings.quote(symbol) + ')(.*)$', 'i');
          m = re.exec(parseContext.inputString);
          if (m) { // match found
            parseContext.matchInfo.weekday = m[1];
            parseContext.hints.weekday = i;
            parseContext.inputString = m[2];
            return m[1];
          }
        }
        // No match found so far. In analyze mode, check prefixes.
        if (parseContext.analyze) {
          for (i = 0; i < this.dateFormat.symbols.weekdaysShort.length; i++) {
            symbol = this.dateFormat.symbols.weekdaysShort[i];
            re = new RegExp('^(' + scout.strings.quote(parseContext.inputString) + ')(.*)$', 'i');
            m = re.exec(symbol);
            if (m) { // match found
              parseContext.matchInfo.weekday = symbol;
              parseContext.hints.weekday = i;
              parseContext.inputString = '';
              return m[1];
            }
          }
        }
        return null; // no match found
      }
    }),
    // --- Hour (24h) ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.HOUR_24,
      terms: 'HH',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(formatContext.inputDate.getHours(), 2);
      },
      parseRegExp: /^(\d{2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.hours = Number(match);
        parseContext.matchInfo.hours = match;
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.HOUR_24,
      terms: ['H', 'h'],
      formatFunction: function(formatContext) {
        return String(formatContext.inputDate.getHours());
      },
      parseRegExp: /^(\d{1,2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.hours = Number(match);
        parseContext.matchInfo.hours = match;
      }
    }),
    // --- Hour (12h) ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.HOUR_12,
      terms: 'KK',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft((formatContext.inputDate.getHours() + 11) % 12 + 1, 2);
      },
      parseRegExp: /^(\d{2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.hours = Number(match);
        parseContext.matchInfo.hours = match;
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.HOUR_12,
      terms: 'K',
      formatFunction: function(formatContext) {
        return String((formatContext.inputDate) % 12 + 1);
      },
      parseRegExp: /^(\d{1,2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.hours = Number(match);
        parseContext.matchInfo.hours = match;
      }
    }),
    // --- AM/PM marker ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.AM_PM,
      terms: 'a',
      formatFunction: function(formatContext) {
        if (formatContext.inputDate.getHours() < 12) {
          return this.dateFormat.symbols.am;
        }
        return this.dateFormat.symbols.pm;
      },
      parseFunction: function(parseContext) {
        var am = false,
          pm = false,
          re, m;

        re = new RegExp('^(' + scout.strings.quote(this.dateFormat.symbols.am) + ')(.*)$', 'i');
        m = re.exec(parseContext.inputString);
        if (m) { // match found
          am = true;
          parseContext.matchInfo.ampm = m[1];
          parseContext.inputString = m[2];
        } else {
          re = new RegExp('^(' + scout.strings.quote(this.dateFormat.symbols.pm) + ')(.*)$', 'i');
          m = re.exec(parseContext.inputString);
          if (m) { // match found
            pm = true;
            parseContext.matchInfo.ampm = m[1];
            parseContext.inputString = m[2];
          }
        }

        if (!am && !pm) {
          return null; // no match found
        }
        parseContext.hints.am = am;
        parseContext.hints.pm = pm;
        return m[1];
      }
    }),
    // --- Minute ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MINUTE,
      terms: 'mm',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(formatContext.inputDate.getMinutes(), 2);
      },
      parseRegExp: /^(\d{2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.minutes = Number(match);
        parseContext.matchInfo.minutes = match;
      },
      parseFunction: function(parseContext) {
        // Special case! When regexp did not match, check if input + '0' would make a
        // valid minutes value. If yes, predict this value.
        if (parseContext.analyze) {
          if (scout.isOneOf(parseContext.inputString, '0', '1', '2', '3', '4', '5')) {
            var tenMinutes = parseContext.inputString + '0';
            parseContext.dateInfo.minutes = Number(tenMinutes);
            parseContext.matchInfo.minutes = tenMinutes;
            parseContext.inputString = '';
            return parseContext.inputString;
          }
        }
        return null; // no match found
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MINUTE,
      terms: 'm',
      formatFunction: function(formatContext) {
        return String(formatContext.inputDate.getMinutes());
      },
      parseRegExp: /^(\d{1,2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.minutes = Number(match);
        parseContext.matchInfo.minutes = match;
      }
    }),
    // --- Second ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.SECOND,
      terms: 'ss',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(formatContext.inputDate.getSeconds(), 2);
      },
      parseRegExp: /^(\d{2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.seconds = Number(match);
        parseContext.matchInfo.seconds = match;
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.SECOND,
      terms: 's',
      formatFunction: function(formatContext) {
        return String(formatContext.inputDate.getSeconds());
      },
      parseRegExp: /^(\d{1,2})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.seconds = Number(match);
        parseContext.matchInfo.seconds = match;
      }
    }),
    // --- Millisecond ---
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MILLISECOND,
      terms: 'SSS',
      formatFunction: function(formatContext) {
        return scout.strings.padZeroLeft(formatContext.inputDate.getMilliseconds(), 3);
      },
      parseRegExp: /^(\d{3})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.milliseconds = Number(match);
        parseContext.matchInfo.milliseconds = match;
      }
    }),
    new DateFormatPatternDefinition({
      type: scout.DateFormatPatternType.MILLISECOND,
      terms: 'S',
      formatFunction: function(formatContext) {
        return String(formatContext.inputDate.getMilliseconds());
      },
      parseRegExp: /^(\d{1,3})(.*)$/,
      applyMatchFunction: function(parseContext, match) {
        parseContext.dateInfo.milliseconds = Number(match);
        parseContext.matchInfo.milliseconds = match;
      }
    })
  ];

  // Build a map of pattern definitions by pattern type
  this._patternLibrary = {};
  for (var i = 0; i < this._patternDefinitions.length; i++) {
    var patternDefinition = this._patternDefinitions[i];
    var type = patternDefinition.type;
    if (type) {
      if (!this._patternLibrary[type]) {
        this._patternLibrary[type] = [];
      }
      this._patternLibrary[type].push(patternDefinition);
    }
  }

  this._compile();
};

scout.DateFormat.prototype._compile = function() {
  var i, j, patternDefinitions, patternDefinition, re, m, term, termAccepted, analyseFunctions;

  // Build format, parse and analyze functions for all terms in the DateFormat's pattern.
  // A term is a continuous sequence of the same character.
  re = /(.)\1*/g;
  while ((m = re.exec(this.pattern))) {
    term = m[0];
    this._terms.push(term);

    termAccepted = false;
    for (i = 0; i < this._patternDefinitions.length; i++) {
      patternDefinition = this._patternDefinitions[i];
      if (patternDefinition.accept(term)) {
        // 1. Create and install format function
        this._formatFunctions.push(patternDefinition.createFormatFunction());

        // 2. Create and install parse function
        this._parseFunctions.push(patternDefinition.createParseFunction());

        // 3. Create and install analyze functions (= all parse functions for the same type)
        patternDefinitions = this._patternLibrary[patternDefinition.type];
        analyseFunctions = [];
        for (j = 0; j < patternDefinitions.length; j++) {
          analyseFunctions.push(patternDefinitions[j].createParseFunction());
        }
        this._analyzeFunctions.push(analyseFunctions);

        // Term was processed, continue with next term
        termAccepted = true;
        break;
      }
    }

    // In case term was not accepted by any pattern definition, assume it is a constant string
    if (!termAccepted) {
      // 1. Create and install constant format function
      this._formatFunctions.push(this._createConstantStringFormatFunction(term));
      // 2./3. Create and install parse and analyse functions
      var constantStringParseFunction = this._createConstantStringParseFunction(term);
      this._parseFunctions.push(constantStringParseFunction);
      this._analyzeFunctions.push([constantStringParseFunction]);
    }
  }
};

/**
 * Returns a format function for constant terms (e.g. all parts of a pattern that don't
 * have a DateFormatPatternDefinition).
 */
scout.DateFormat.prototype._createConstantStringFormatFunction = function(term) {
  return function(formatContext) {
    formatContext.formattedString += term;
  };
};

/**
 * Returns a parse function for constant terms (e.g. all parts of a pattern that don't
 * have a DateFormatPatternDefinition).
 */
scout.DateFormat.prototype._createConstantStringParseFunction = function(term) {
  return function(parseContext) {
    if (scout.strings.startsWith(parseContext.inputString, term)) {
      parseContext.inputString = parseContext.inputString.substr(term.length);
      parseContext.parsedPattern += term;
      return true;
    }
    // In analyze mode, constant terms are optional (this supports "020318" --> "02.03.2018")
    if (parseContext.analyze) {
      return true;
    }
    return false;
  };
};

/**
 * Formats the given date according to the date pattern. If the date is missing, the
 * empty string is returned.
 *
 * @param exactLength
 *          May be set to true to force the patterns to use the exact length. For example,
 *          the year pattern 'yyy' would normally format the year using 2 digits. If
 *          the parameter is true, 3 are used. This is mainly useful, when an "analyzed"
 *          date should be formatted again using the "parsedPattern".
 */
scout.DateFormat.prototype.format = function(date, exactLength) {
  if (!date) {
    return '';
  }

  var formatContext = this._createFormatContext(date);
  formatContext.exactLength = scout.nvl(exactLength, false);
  // Apply all formatter functions for this DateFormat to the pattern to replace the
  // different terms with the corresponding value from the given date.
  for (var i = 0; i < this._formatFunctions.length; i++) {
    var formatFunction = this._formatFunctions[i];
    formatFunction(formatContext);
  }
  return formatContext.formattedString;
};

/**
 * Analyzes the given string and returns an information object with all recognized information
 * for the current date format.
 *
 * The result object contains the following properties:
 *
 * inputString:
 *   The original input for the analysis.
 *
 * dateInfo:
 *   An object with all numeric date parts that could be parsed from the input string. Unrecognized
 *   parts are undefined, all others are converted to numbers. Those values may be directly
 *   used in the JavaScript Date() type (month is zero-based!).
 *   Valid properties:
 *   - year, month, day, hours, minutes, seconds, milliseconds
 *
 * matchInfo:
 *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.
 *   While dateInfo may contain the year 1995, the matchInfo may contain "95". Also note that
 *   the month is "one-based", as opposed to dateInfo.month!
 *   Valid properties:
 *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds
 *
 * hints:
 *   An object that contains further recognized date parts that are not needed to define the exact time.
 *   Valid properties:
 *   - am [true / false]
 *   - pm [true / false]
 *   - weekday [number 0-6; 0=sun, 1=mon, etc.]
 *   - weekInYear [number 1-53]
 *
 * parsedPattern:
 *   The pattern that was used to parse the input. This may differ from the date format's pattern.
 *   Example: dateFormat="dd.MM.YYYY", inputString="5.7.2015" --> parsedPattern="d.M.yyyy"
 *
 * predictedDate:
 *   The date that could be predicted from the recognized inputs. If the second method argument
 *   'startDate' is set, this date is used as basis for this predicted date. Otherwise, 'today' is used.
 *
 * error:
 *   Boolean that indicates if analyzing the input was successful (e.g. if the pattern could be parsed
 *   and a date could be predicted).
 */
scout.DateFormat.prototype.analyze = function(text, startDate) {
  var analyzeInfo = this._createAnalyzeInfo(text);
  if (!text) {
    return analyzeInfo;
  }

  var parseContext = this._createParseContext(text);
  parseContext.analyze = true; // Mark context as "analyze mode"
  parseContext.startDate = startDate;
  for (var i = 0; i < this._terms.length; i++) {
    if (parseContext.inputString.length > 0) {
      var parseFunctions = this._analyzeFunctions[i];
      var parsed = false;
      for (var j = 0; j < parseFunctions.length; j++) {
        var parseFunction = parseFunctions[j];
        if (parseFunction(parseContext)) {
          parsed = true;
          break;
        }
      }
      if (!parsed) {
        // Parsing failed
        analyzeInfo.error = true;
        return analyzeInfo;
      }
    } else {
      // Input is fully consumed, now just add the remaining terms from the pattern
      parseContext.parsedPattern += this._terms[i];
    }
  }

  if (parseContext.inputString.length > 0) {
    // There is still input, but the pattern has no more terms --> parsing failed
    analyzeInfo.error = true;
    return analyzeInfo;
  }

  // Try to generate a valid predicted date with the information retrieved so far
  startDate = this._prepareStartDate(startDate);
  if (parseContext.hints.weekday !== undefined) {
    startDate = scout.dates.shiftToNextDayOfType(startDate, parseContext.hints.weekday);
  }
  var predictedDate = this._dateInfoToDate(parseContext.dateInfo, startDate);

  // Update analyzeInfo
  analyzeInfo.dateInfo = parseContext.dateInfo;
  analyzeInfo.matchInfo = parseContext.matchInfo;
  analyzeInfo.hints = parseContext.hints;
  analyzeInfo.parsedPattern = parseContext.parsedPattern;
  analyzeInfo.predictedDate = predictedDate;
  analyzeInfo.error = (!predictedDate);
  return analyzeInfo;
};

/**
 * Parses the given text with the current date format. If the text does not match exactly
 * with the pattern, "null" is returned. Otherwise, the parsed date is returned.
 *
 * The argument 'startDate' is optional. It may set the date where parsed information should
 * be applied to (e.g. relevant for 2-digit years).
 */
scout.DateFormat.prototype.parse = function(text, startDate) {
  if (!text) {
    return null;
  }

  var parseContext = this._createParseContext(text);
  parseContext.startDate = startDate;
  for (var i = 0; i < this._parseFunctions.length; i++) {
    var parseFunction = this._parseFunctions[i];
    if (!parseFunction(parseContext)) {
      return null; // Parsing failed
    }
    if (parseContext.inputString.length === 0) {
      break; // Everything parsed!
    }
  }
  if (parseContext.inputString.length > 0) {
    // Input remaining but no more parse functions available -> parsing failed
    return null;
  }

  // Build date from dateInfo
  var date = this._dateInfoToDate(parseContext.dateInfo, startDate);
  if (!date) {
    return null; // dateInfo could not be converted to a valid date -> parsing failed
  }

  // Handle hints
  if ((parseContext.hints.am || parseContext.hints.pm)) {
    var hours = date.getHours();
    if (hours === 12) {
      hours = 0;
    }
    if (parseContext.hints.pm) {
      hours += 12;
    }
    date.setHours(hours);
  }
  if (parseContext.hints.weekday !== undefined) {
    if (date.getDay() !== parseContext.hints.weekday) {
      return null; // Date and weekday don't match -> parsing failed
    }
  }
  // TODO [5.2] bsh: Handle week of year

  // Return valid date
  return date;
};

scout.DateFormat.prototype._dateInfoToDate = function(dateInfo, startDate) {
  if (!dateInfo) {
    return null;
  }

  // Default date
  startDate = this._prepareStartDate(startDate);

  // Apply date info (Start with "zero date", otherwise the date may become invalid
  // due to JavaScript's automatic date correction, e.g. dateInfo = { day: 11, month: 1 }
  // and startDate = 2015-07-29 would result in invalid date 2015-03-11, because February
  // 2015 does not have 29 days and is "corrected" to March.)
  var result = new Date(1970, 0, 1);

  var validMonth = scout.nvl(dateInfo.month, startDate.getMonth());
  var validYear = scout.nvl(dateInfo.year, startDate.getFullYear());
  // When user entered the day but not (yet) the month, adjust month if possible to propose a valid date
  if (dateInfo.day && !dateInfo.month) {
    // If day "31" does not exist in the proposed month, use the next month
    if (dateInfo.day === 31) {
      var monthsWithThirthyOneDays = [0, 2, 4, 6, 7, 9, 11];
      if (!scout.isOneOf(validMonth, monthsWithThirthyOneDays)) {
        validMonth = validMonth + 1;
      }
    }
    // If day is "29" or "30" and month is february, use next month (except day is "29" and the year is a leap year)
    else if (dateInfo.day >= 29 && validMonth === 1) {
      if (dateInfo.day > 29 || !scout.dates.isLeapYear(validYear)) {
        validMonth = validMonth + 1;
      }
    }
  }
  result.setFullYear(
      validYear,
      validMonth,
      scout.nvl(dateInfo.day, startDate.getDate())
  );

  result.setHours(
      scout.nvl(dateInfo.hours, startDate.getHours()),
      scout.nvl(dateInfo.minutes, startDate.getMinutes()),
      scout.nvl(dateInfo.seconds, startDate.getSeconds()),
      scout.nvl(dateInfo.milliseconds, startDate.getMilliseconds())
  );

  // Validate. A date is considered valid if the value from the dateInfo did
  // not change (JS date automatically converts illegal values, e.g. day 32 is
  // converted to first day of next month).
  if (!isValid(result.getFullYear(), dateInfo.year)) {
    return null;
  }
  if (!isValid(result.getMonth(), dateInfo.month)) {
    return null;
  }
  if (!isValid(result.getDate(), dateInfo.day)) {
    return null;
  }
  if (!isValid(result.getHours(), dateInfo.hours)) {
    return null;
  }
  if (!isValid(result.getMinutes(), dateInfo.minutes)) {
    return null;
  }
  if (!isValid(result.getSeconds(), dateInfo.seconds)) {
    return null;
  }
  if (!isValid(result.getMilliseconds(), dateInfo.milliseconds)) {
    return null;
  }

  return result;

  // ----- Helper functions -----

  function isValid(value, expectedValue) {
    return (expectedValue === undefined || expectedValue === value);
  }
};

/**
 * Returns the date where parsed information should be applied to. The given
 * startDate is used when specified, otherwise a new date is created (today).
 */
scout.DateFormat.prototype._prepareStartDate = function(startDate) {
  if (startDate) {
    // It is important that we don't alter the argument 'startDate', but create an independent copy!
    return new Date(startDate.getTime());
  }
  return scout.dates.trunc(new Date()); // clear time
};

/**
 * Returns the "format context", an object that is initially filled with the input date and is then
 * passed through the various formatting functions. As the formatting progresses, the format context object
 * is updated accordingly. At the end of the process, the object contains the result.
 *
 * The parse context contains the following properties:
 *
 * inputString:
 *   The original input for the parsing. This string will be consumed during the parse process,
 *   and will be empty at the end.
 *
 * dateInfo:
 *   An object with all numeric date parts that could be parsed from the input string. Unrecognized
 *   parts are undefined, all others are converted to numbers.
 *   Valid properties:
 *   - year, month, day, hours, minutes, seconds, milliseconds
 *
 * matchInfo:
 *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.
 *   While dateInfo may contain the year 1995, the matchInfo may contain "95".
 *   Valid properties:
 *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds
 *
 * hints:
 *   An object that contains further recognized date parts that are not needed to define the exact time.
 *   Valid properties:
 *   - am [true / false]
 *   - pm [true / false]
 *   - weekday [number 0-6; 0=sun, 1=mon, etc.]
 *   - weekInYear [number 1-53]
 *
 * analyze:
 *   A flag that indicates if the "analyze mode" is on. This is true when analyze() was called, and
 *   false when parse() was called. It may alter the behavior of the parse functions, i.e. they will
 *   not fail in analyze mode when the pattern does not match exactly.
 *
 * startDate:
 *   A date to be used as reference for date calculations. Is used for example when mapping a 2-digit
 *   year to a 4-digit year.
 */

scout.DateFormat.prototype._createFormatContext = function(inputDate) {
  return {
    inputDate: inputDate,
    formattedString: '',
    exactLength: false
  };
};

/**
 * Returns the "parse context", an object that is initially filled with the input string and is then
 * passed through the various parsing functions. As the parsing progresses, the parse context object
 * is updated accordingly. At the end of the process, the object contains the result.
 *
 * The parse context contains the following properties:
 *
 * inputString:
 *   The original input for the parsing. This string will be consumed during the parse process,
 *   and will be empty at the end.
 *
 * dateInfo:
 *   An object with all numeric date parts that could be parsed from the input string. Unrecognized
 *   parts are undefined, all others are converted to numbers. Those values may be directly
 *   used in the JavaScript Date() type (month is zero-based!).
 *   Valid properties:
 *   - year, month, day, hours, minutes, seconds, milliseconds
 *
 * matchInfo:
 *   Similar to dateInfo, but the parts are defined as strings as they were parsed from the input.
 *   While dateInfo may contain the year 1995, the matchInfo may contain "95". Also note that
 *   the month is "one-based", as opposed to dateInfo.month!
 *   Valid properties:
 *   - year, month, week, day, weekday, hours, ampm, minutes, seconds, milliseconds
 *
 * hints:
 *   An object that contains further recognized date parts that are not needed to define the exact time.
 *   Valid properties:
 *   - am [true / false]
 *   - pm [true / false]
 *   - weekday [number 0-6; 0=sun, 1=mon, etc.]
 *   - weekInYear [number 1-53]
 *
 * analyze:
 *   A flag that indicates if the "analyze mode" is on. This is true when analyze() was called, and
 *   false when parse() was called. It may alter the behavior of the parse functions, i.e. they will
 *   not fail in analyze mode when the pattern does not match exactly.
 *
 * startDate:
 *   A date to be used as reference for date calculations. Is used for example when mapping a 2-digit
 *   year to a 4-digit year.
 */
scout.DateFormat.prototype._createParseContext = function(inputText) {
  return {
    inputString: inputText,
    dateInfo: {},
    matchInfo: {},
    hints: {},
    parsedPattern: '',
    analyze: false,
    startDate: null
  };
};

/**
 * @see analyze()
 */
scout.DateFormat.prototype._createAnalyzeInfo = function(inputText) {
  return {
    inputString: inputText,
    dateInfo: {},
    matchInfo: {},
    hints: {},
    parsedPattern: '',
    predictedDate: null,
    error: false
  };
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Provides formatting of numbers using java format pattern.
 * <p>
 * Compared to the java DecimalFormat the following pattern characters are not considered:
 * <ul>
 *   <li>prefix and suffix</li>
 *   <li>E</li>
 *   <li>%</li>
 * </ul>
 */
scout.DecimalFormat = function(locale, decimalFormatConfiguration) {
  // format function will use these (defaults)
  this.positivePrefix = '';
  this.positiveSuffix = '';
  this.negativePrefix = locale.decimalFormatSymbols.minusSign;
  this.negativeSuffix = '';
  this.groupingChar = locale.decimalFormatSymbols.groupingSeparator;
  this.groupLength = 0;
  this.decimalSeparatorChar = locale.decimalFormatSymbols.decimalSeparator;
  this.zeroBefore = 1;
  this.zeroAfter = 0;
  this.allAfter = 0;

  decimalFormatConfiguration = decimalFormatConfiguration || {};
  this.pattern = decimalFormatConfiguration.pattern || locale.decimalFormatPatternDefault;
  this.multiplier = decimalFormatConfiguration.multiplier || 1;
  this.roundingMode = decimalFormatConfiguration.roundingMode || scout.numbers.RoundingMode.HALF_UP;

  var SYMBOLS = scout.DecimalFormat.PATTERN_SYMBOLS;
  // Check if there are separate subpatterns for positive and negative numbers ("PositivePattern;NegativePattern")
  var split = this.pattern.split(SYMBOLS.patternSeparator);
  // Use the first subpattern as positive prefix/suffix
  var positivePrefixAndSuffix = findPrefixAndSuffix(split[0]);
  this.positivePrefix = positivePrefixAndSuffix.prefix;
  this.positiveSuffix = positivePrefixAndSuffix.suffix;
  if (split.length > 1) {
    // Yes, there is a negative subpattern
    var negativePrefixAndSuffix = findPrefixAndSuffix(split[1]);
    this.negativePrefix = negativePrefixAndSuffix.prefix;
    this.negativeSuffix = negativePrefixAndSuffix.suffix;
    // from now on, only look at the positive subpattern
    this.pattern = split[0];
  } else {
    // No, there is no negative subpattern, so the positive prefix/suffix are used for both positive and negative numbers.
    // Check if there is a minus sign in the prefix/suffix.
    if (this.positivePrefix.indexOf(SYMBOLS.minusSign) !== -1 || this.positiveSuffix.indexOf(SYMBOLS.minusSign) !== -1) {
      // Yes, there is a minus sign in the prefix/suffix. Use this a negativePrefix/Suffix and remove the minus sign from the posistivePrefix/Suffix.
      this.negativePrefix = this.positivePrefix.replace(SYMBOLS.minusSign, locale.decimalFormatSymbols.minusSign);
      this.negativeSuffix = this.positiveSuffix.replace(SYMBOLS.minusSign, locale.decimalFormatSymbols.minusSign);
      this.positivePrefix = this.positivePrefix.replace(SYMBOLS.minusSign, '');
      this.positiveSuffix = this.positiveSuffix.replace(SYMBOLS.minusSign, '');
    } else {
      // No, there is no minus sign in the prefix/suffix. Therefore, use the default negativePrefix/Suffix, but append the positivePrefix/Suffix
      this.negativePrefix = this.positivePrefix + this.negativePrefix;
      this.negativeSuffix = this.negativeSuffix + this.positiveSuffix;
    }
  }

  // find group length
  var posDecimalSeparator = this.pattern.indexOf(SYMBOLS.decimalSeparator);
  if (posDecimalSeparator === -1) {
    posDecimalSeparator = this.pattern.length; // assume decimal separator at end
  }
  var posGroupingSeparator = this.pattern.lastIndexOf(SYMBOLS.groupingSeparator, posDecimalSeparator); // only search before decimal separator
  if (posGroupingSeparator > 0) {
    this.groupLength = posDecimalSeparator - posGroupingSeparator - 1;
  }
  this.pattern = this.pattern.replace(new RegExp('[' + SYMBOLS.groupingSeparator + ']', 'g'), '');

  // split on decimal point
  split = this.pattern.split(SYMBOLS.decimalSeparator);

  // find digits before and after decimal point
  this.zeroBefore = scout.strings.count(split[0], SYMBOLS.zeroDigit);
  if (split.length > 1) { // has decimal point?
    this.zeroAfter = scout.strings.count(split[1], SYMBOLS.zeroDigit);
    this.allAfter = this.zeroAfter + scout.strings.count(split[1], SYMBOLS.digit);
  }

  // Returns an object with the properties 'prefix' and 'suffix', which contain all characters
  // before or after any 'digit-like' character in the given pattern string.
  function findPrefixAndSuffix(pattern) {
    var result = {
      prefix: '',
      suffix: ''
    };
    // Find prefix (anything before the first 'digit-like' character)
    var digitLikeCharacters = SYMBOLS.digit + SYMBOLS.zeroDigit + SYMBOLS.decimalSeparator + SYMBOLS.groupingSeparator;
    var r = new RegExp('^(.*?)[' + digitLikeCharacters + '].*$');
    var matches = r.exec(pattern);
    if (matches !== null) {
      // Ignore single quotes (for special, quoted characters - e.g. Java quotes percentage sign like '%')
      result.prefix = matches[1].replace(new RegExp('\'([^\']+)\'', 'g'), '$1');
    }
    // Find suffix (anything before the first 'digit-like' character)
    r = new RegExp('^.*[' + digitLikeCharacters + '](.*?)$');
    matches = r.exec(pattern);
    if (matches !== null) {
      // Ignore single quotes (for special, quoted characters - e.g. Java quotes percentage sign like '%')
      result.suffix = matches[1].replace(new RegExp('\'([^\']+)\'', 'g'), '$1');
    }
    return result;
  }
};

/**
 * Returns a number for the given numberString, if the string can be converted into a number.
 * Throws an Error otherwise
 */
scout.DecimalFormat.prototype.parse = function(numberString) {
  if (scout.strings.empty(numberString)) {
    return null;
  }
  var pureNumber = numberString
    .replace(new RegExp('[' + this.groupingChar + ']', 'g'), '')
    .replace(new RegExp('[' + this.decimalSeparatorChar + ']', 'g'), '.')
    .replace(/\s/g, '');
  var number = Number(pureNumber);
  if (isNaN(number)) {
    throw new Error(numberString + ' is not a number (NaN)');
  }
  return number;
};

scout.DecimalFormat.prototype.format = function(number, applyMultiplier) {
  applyMultiplier = scout.nvl(applyMultiplier, true);
  if (number === null || number === undefined) {
    return null;
  }

  var prefix = this.positivePrefix;
  var suffix = this.positiveSuffix;

  // apply multiplier
  if (applyMultiplier && this.multiplier !== 1) {
    number *= this.multiplier;
  }

  // round
  number = this.round(number);

  // after decimal point
  var after = '';
  if (this.allAfter) {
    after = number.toFixed(this.allAfter).split('.')[1];
    for (var j = after.length - 1; j > this.zeroAfter - 1; j--) {
      if (after[j] !== '0') {
        break;
      }
      after = after.slice(0, -1);
    }
    if (after) { // did we find any non-zero characters?
      after = this.decimalSeparatorChar + after;
    }
  }

  // absolute value
  if (number < 0) {
    prefix = this.negativePrefix;
    suffix = this.negativeSuffix;
    number = -number;
  }

  // before decimal point
  var before = Math.floor(number);
  before = (before === 0) ? '' : String(before);
  before = scout.strings.padZeroLeft(before, this.zeroBefore);

  // group digits
  if (this.groupLength) {
    for (var i = before.length - this.groupLength; i > 0; i -= this.groupLength) {
      before = before.substr(0, i) + this.groupingChar + before.substr(i);
    }
  }

  // put together and return
  return prefix + before + after + suffix;
};

/**
 * Rounds a number according to the properties of the DecimalFormat.
 */
scout.DecimalFormat.prototype.round = function(number) {
  return scout.numbers.round(number, this.roundingMode, this.allAfter);
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * Literal (not localized!) pattern symbols as defined in http://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html
 */
scout.DecimalFormat.PATTERN_SYMBOLS = {
  digit: '#',
  zeroDigit: '0',
  decimalSeparator: '.',
  groupingSeparator: ',',
  minusSign: '-',
  patternSeparator: ';'
};

scout.DecimalFormat.ensure = function(locale, format) {
  if (!format) {
    return format;
  }
  if (format instanceof scout.DecimalFormat) {
    return format;
  }
  return new scout.DecimalFormat(locale, format);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TextMap = function(textMap) {
  this.map = textMap || {};
};

scout.TextMap.TEXT_KEY_REGEX = /\$\{textKey\:([a-zA-Z0-9\.]*)\}/;

/**
 * Returns the text for the given key.
 * If the key does not exist in this text map, a lookup in the parent text map is done.
 *
 * @param textKey key to lookup the text
 * @param vararg texts to replace the placeholders specified by {0}, {1}, etc.
 */
scout.TextMap.prototype.get = function(textKey) {
  if (!this._exists(textKey)) {
    if (this.parent) {
      return scout.TextMap.prototype.get.apply(this.parent, arguments);
    }
    return '[undefined text: ' + textKey + ']';
  }
  var len = arguments.length,
    text = this.map[textKey];

  if (len === 1) {
    return text;
  }

  for (var i = 1; i < len; i++) {
    text = text.replace(new RegExp('\\{' + (i - 1) + '\\}', 'g'), arguments[i]);
  }
  return text;
};

scout.TextMap.prototype.optGet = function(textKey, defaultValue) {
  if (!this._exists(textKey)) {
    if (this.parent) {
      return scout.TextMap.prototype.optGet.apply(this.parent, arguments);
    }
    return defaultValue;
  }
  if (arguments.length > 2) {
    // dynamically call text() without 'defaultValue' argument
    var args = Array.prototype.slice.call(arguments, 2);
    args.unshift(textKey); // add textKey as first argument
    return scout.TextMap.prototype.get.apply(this, args);
  }
  return this.get(textKey);
};

scout.TextMap.prototype.exists = function(textKey) {
  if (this._exists(textKey)) {
    return true;
  }
  if (this.parent) {
    return this.parent.exists(textKey);
  }
  return false;
};

scout.TextMap.prototype._exists = function(textKey) {
  return this.map.hasOwnProperty(textKey);
};

scout.TextMap.prototype.add = function(textKey, text) {
  this.map[textKey] = text;
};

/**
 * Adds all texts from the given textMap to this textMap
 * @param {Object|scout.TextMap} textMap either a plain object or a {@link scout.TextMap}
 */
scout.TextMap.prototype.addAll = function(textMap) {
  if (!textMap) {
    return;
  }
  if (textMap instanceof scout.TextMap) {
    textMap = textMap.map;
  }
  scout.objects.copyOwnProperties(textMap, this.map);
};

scout.TextMap.prototype.setParent = function(parent) {
  this.parent = parent;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.texts = {

  TEXT_KEY_REGEX: /\$\{textKey\:([^\}]*)\}/,

  textsByLocale: {},

  bootstrap: function(url) {
    url = scout.nvl(url, 'res/texts.json');
    return $.ajaxJson(url)
      .done(this.init.bind(this));
  },

  init: function(model) {
    var languageTags = Object.keys(model);
    languageTags.forEach(function(languageTag) {
      this.get(languageTag).addAll(model[languageTag]);
    }, this);
  },

  /**
   * Links the texts of the given languageTag to make parent lookup possible (e.g. look first in de-CH, then in de, then in default)
   */
  link: function(languageTag) {
    var tags = this.splitLanguageTag(languageTag);
    var child;
    tags.forEach(function(tag) {
      var texts = this._get(tag);
      if (!texts) {
        // If there are no texts for the given tag, create an empty Texts object for linking purpose
        texts = new scout.TextMap();
        this.put(tag, texts);
      }
      if (child) {
        child.setParent(texts);
      }
      child = texts;
    }, this);
  },

  /**
   * Creates an array containing all relevant tags.
   * <p>
   * Examples:<br>
   * - 'de-CH' generates the array: ['de-CH', 'de', 'default']
   * - 'de' generates the array: ['de', 'default']
   * - 'default' generates the array: ['default']
   */
  splitLanguageTag: function(languageTag) {
    var tags = [],
      i = languageTag.lastIndexOf('-');

    tags.push(languageTag);

    while (i >= 0) {
      languageTag = languageTag.substring(0, i);
      tags.push(languageTag);
      i = languageTag.lastIndexOf('-');
    }

    if (languageTag !== 'default') {
      tags.push('default');
    }
    return tags;
  },

  /**
   * Returns the (modifiable) TextMap for the given language tag.
   */
  get: function(languageTag) {
    var texts = this._get(languageTag);
    if (texts) {
      return texts;
    }

    this.link(languageTag);
    texts = this._get(languageTag);
    if (!texts) {
      throw new Error('Texts missing for the language tag ' + languageTag);
    }
    return texts;
  },

  _get: function(languageTag) {
    return this.textsByLocale[languageTag];
  },

  /**
   * Registers the text map for the given locale.
   * If there already is a text map registered for that locale, it will be replaced, meaning existing texts for that locale are deleted.
   *
   * @param {scout.TextMap} textMap
   */
  put: function(languageTag, textMap) {
    this.textsByLocale[languageTag] = textMap;
  },

  /**
   * Extracts NLS texts from the DOM tree. Texts are expected in the following format:
   *
   *   <scout-text data-key="..." data-value="..." />
   *
   * This method returns a map with all found texts. It must be called before scout.prepareDOM()
   * is called, as that method removes all <scout-text> tags.
   */
  readFromDOM: function() {
    var textMap = {};
    $('scout-text').each(function() {
      // No need to unescape strings (the browser did this already)
      var key = $(this).data('key');
      var value = $(this).data('value');
      textMap[key] = value;
    });
    return textMap;
  },

  /**
   * @param key to convert into a string with the form '${textKey:AKey}'.
   * @return text containing the text key like like '${textKey:AKey}'.
   */
  buildKey: function(key) {
    return '${textKey:' + key + '}';
  },

  /**
   * @param value text which contains a text key like '${textKey:AKey}'.
   * @return the resolved key or the unchanged value if the text key could not be extracted.
   */
  resolveKey: function(value) {
    var result = this.TEXT_KEY_REGEX.exec(value);
    if (result && result.length === 2) {
      return result[1];
    }
    return value;
  },

  /**
   * @param value text which contains a text key like '${textKey:AKey}'.
   * @param languageTag the languageTag to use for the text lookup with the resolved key.
   * @return the resolved text in the language of the given session or the unchanged text if the text key could not be extracted.
   */
  resolveText: function(value, languageTag) {
    var key = scout.texts.resolveKey(value);
    if (key !== value) {
      return scout.texts.get(languageTag).get(key);
    }
    return value;
  },

  /**
   * Utility function to easily replace an object property which contains a text key like '${textKey:AKey}'.
   *
   * @param object object having a text property which contains a text-key
   * @param textProperty (optional) name of the property where a text-key should be replaced by a text. By default 'text' is used as property name.
   * @param session (optional) can be undefined when given 'object' has a session property, otherwise mandatory
   */
  resolveTextProperty: function(object, textProperty, session) {
    textProperty = textProperty || 'text';
    session = object.session || session;
    var value = object[textProperty];
    var text = this.resolveText(value, session.locale.languageTag);
    if (text !== value) {
      object[textProperty] = text;
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Tooltip = function() {
  scout.Tooltip.parent.call(this);

  /**
   * Either a String or a function which returns a String
   */
  this.text = '';

  this.arrowPosition = 25;
  this.arrowPositionUnit = '%';
  this.windowPaddingX = 10;
  this.windowPaddingY = 5;
  this.origin;

  /**
   * When the origin point is calculated using $element.offset(),
   * the result is absolute to the window. When positioning the tooltip, the $parent's offset must
   * be subtracted. When the given origin is already relative to the parent, set this option to
   * "true" to disable this additional calculation.
   */
  this.originRelativeToParent = false;
  this.$anchor;
  this.autoRemove = true;
  this.cssClass;
  this.tooltipPosition = 'top';
  this.scrollType = 'position';
  this.htmlEnabled = false;
  this.$content;
};
scout.inherits(scout.Tooltip, scout.Widget);

scout.Tooltip.prototype._render = function($parent) {
  // Auto-detect parent
  this.$parent = this.$parent || (this.$anchor && this.session.$entryPoint);

  this.$container = this.$parent
    .appendDiv('tooltip')
    .hide()
    .data('tooltip', this);

  if (this.cssClass) {
    this.$container.addClass(this.cssClass);
  }

  this.$arrow = this.$container.appendDiv('tooltip-arrow');
  this.$content = this.$container.appendDiv('tooltip-content');
  this._renderText();
  this._renderSeverity();
  this.$container.show();

  if (this.autoRemove) {
    // Every user action will remove the tooltip
    this._mousedownHandler = this._onDocumentMousedown.bind(this);
    this._keydownHandler = this._onDocumentKeydown.bind(this);
    this.$container.document()
      .on('mousedown', this._mousedownHandler)
      .on('keydown', this._keydownHandler);
  }

  if (this.$anchor && this.scrollType) {
    this._scrollHandler = this._onAnchorScroll.bind(this);
    scout.scrollbars.onScroll(this.$anchor, this._scrollHandler);
  }

  // If the tooltip is rendered inside a (popup) dialog, get a reference to the dialog.
  this.dialog = null;
  var parent = this.parent;
  while (parent) {
    if (parent instanceof scout.Form && parent.isDialog()) {
      this.dialog = parent;
      break;
    }
    parent = parent.parent;
  }

  // If inside a dialog, attach a listener to reposition the tooltip when the dialog is moved
  if (this.dialog) {
    this._moveHandler = this.position.bind(this);
    this.dialog.on('move', this._moveHandler);
  }
};

scout.Tooltip.prototype._postRender = function() {
  scout.Tooltip.parent.prototype._postRender.call(this);
  this.position();
};

scout.Tooltip.prototype._remove = function() {
  if (this._mousedownHandler) {
    this.$container.document().off('mousedown', this._mousedownHandler);
    this._mousedownHandler = null;
  }
  if (this._keydownHandler) {
    this.$container.document().off('keydown', this._keydownHandler);
    this._keydownHandler = null;
  }
  if (this._scrollHandler) {
    scout.scrollbars.offScroll(this._scrollHandler);
    this._scrollHandler = null;
  }
  if (this._moveHandler) {
    if (this.dialog) {
      this.dialog.off('move', this._moveHandler);
    }
    this._moveHandler = null;
  }
  this.dialog = null;
  scout.Tooltip.parent.prototype._remove.call(this);
};

scout.Tooltip.prototype.setText = function(text) {
  if (this.text === text) {
    return;
  }
  this._setProperty('text', text);
  if (this.rendered) {
    this._renderText();
    this.position();
  }
};

scout.Tooltip.prototype.setSeverity = function(severity) {
  this.setProperty('severity', severity);
};

scout.Tooltip.prototype._renderText = function() {
  var text = this.text;
  if (this.htmlEnabled) {
    this.$content.html(text);
  } else {
    // use nl2br to allow tooltips with line breaks
    this.$content.html(scout.strings.nl2br(text));
  }
};

scout.Tooltip.prototype._renderSeverity = function() {
  this.$container.removeClass('tooltip-error tooltip-warning tooltip-info');
  this.$container.addClass(this._cssClassForSeverity());
};

scout.Tooltip.prototype._cssClassForSeverity = function() {
  var isInfo = (this.severity > scout.Status.Severity.OK);
  var isWarning = (this.severity > scout.Status.Severity.INFO);
  var isError = (this.severity > scout.Status.Severity.WARNING);

  if (isError) {
    return 'tooltip-error';
  }
  if (isWarning) {
    return 'tooltip-warning';
  }
  if (isInfo) {
    return 'tooltip-info';
  }
  return '';
};

scout.Tooltip.prototype.position = function() {
  var top, left, arrowSize, overlapX, overlapY, x, y, origin,
    tooltipWidth, tooltipHeight, arrowDivWidth, arrowPosition, inView;

  if (this.origin) {
    origin = this.origin;
    x = origin.x;
  } else {
    origin = scout.graphics.offsetBounds(this.$anchor);
    x = origin.x + origin.width / 2;
  }
  y = origin.y;

  if (this.$anchor) {
    // Sticky tooltip must only be visible if the location where the tooltip points is in view (prevents that the tooltip points at an invisible anchor)
    inView = scout.scrollbars.isLocationInView(origin, this.$anchor.scrollParent());
    this.$container.setVisible(inView);
  }

  // this.$parent might not be at (0,0) of the document
  if (!this.originRelativeToParent) {
    var parentOffset = this.$parent.offset();
    x -= parentOffset.left;
    y -= parentOffset.top;
  }

  arrowDivWidth = this.$arrow.outerWidth();
  // Arrow is a div rotated by 45 deg -> visible height is half the div
  arrowSize = scout.Tooltip.computeHypotenuse(arrowDivWidth) / 2;

  tooltipHeight = this.$container.outerHeight();
  tooltipWidth = this.$container.outerWidth();

  // Compute actual arrow position if position is provided in percentage
  arrowPosition = this.arrowPosition;
  if (this.arrowPositionUnit === '%') {
    arrowPosition = tooltipWidth * this.arrowPosition / 100;
  }

  top = y - tooltipHeight - arrowSize;
  left = x - arrowPosition;
  overlapX = left + tooltipWidth + this.windowPaddingX - this.$parent.width();
  overlapY = top - this.windowPaddingY;

  // Move tooltip to the left until it gets fully visible
  if (overlapX > 0) {
    left -= overlapX;
    arrowPosition = x - left;
  }

  // Move tooltip to the bottom, arrow on top
  this.$arrow.removeClass('arrow-top arrow-bottom');
  if (this.tooltipPosition === 'bottom' || overlapY < 0) {
    this.$arrow.addClass('arrow-top');
    top = y + origin.height + arrowSize;
  } else {
    this.$arrow.addClass('arrow-bottom');
  }

  // Make sure arrow is never positioned outside of the tooltip
  arrowPosition = Math.min(arrowPosition, this.$container.outerWidth() - arrowSize);
  arrowPosition = Math.max(arrowPosition, arrowSize);
  this.$arrow.cssLeft(arrowPosition);
  this.$container
    .cssLeft(left)
    .cssTop(top);
};

scout.Tooltip.prototype._onAnchorScroll = function(event) {
  if (!this.rendered) {
    // Scroll events may be fired delayed, even if scroll listener are already removed.
    return;
  }
  if (this.scrollType === 'position') {
    this.position();
  } else if (this.scrollType === 'remove') {
    this.destroy();
  }
};

scout.Tooltip.prototype._onDocumentMousedown = function(event) {
  if (!this.rendered) {
    return false;
  }
  if (this._isMousedownOutside(event)) {
    this._onMousedownOutside(event);
  }
};

scout.Tooltip.prototype._isMousedownOutside = function(event) {
  var $target = $(event.target),
    targetWidget = scout.Widget.getWidgetFor($target);

  // Only remove the tooltip if the click is outside of the container or the $anchor (= status icon)
  // Also ignore clicks if the tooltip is covert by a glasspane
  return !this.isOrHas(targetWidget) &&
    (this.$anchor && !this.$anchor.isOrHas($target[0])) &&
    !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);
};

/**
 * Method invoked once a mouse down event occurs outside the tooltip.
 */
scout.Tooltip.prototype._onMousedownOutside = function() {
  this.destroy();
};

scout.Tooltip.prototype._onDocumentKeydown = function(event) {
  this.destroy();
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * @memberOf scout.Tooltip
 */
scout.Tooltip.computeHypotenuse = function(x) {
  return Math.sqrt(Math.pow(x, 2) + Math.pow(x, 2));
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.tooltips = {
  install: function($comp, options) {
    var support = new scout.TooltipSupport(options);
    support.install($comp);
  },

  uninstall: function($comp) {
    var support = $comp.data('tooltipSupport');
    if (support) {
      support.uninstall($comp);
    }
  },

  /**
   * Convenient function to install tooltip support for ellipsis only.
   */
  installForEllipsis: function($comp, options) {
    var defaultOptions = {
      text: function($label) {
        if ($label.isContentTruncated()) {
          return $label.text();
        }
      },
      nativeTooltip: !scout.device.isCustomEllipsisTooltipPossible()
    };
    options = $.extend({}, defaultOptions, options);
    this.install($comp, options);
  },

  /**
   * Finds every tooltip whose $anchor belongs to $context.
   */
  find: function($context) {
    var $tooltips, i, tooltip,
      tooltips = [];
    $tooltips = $('.tooltip', $context.document(true));

    for (i = 0; i < $tooltips.length; i++) {
      tooltip = $tooltips.eq(i).data('tooltip');
      if ($context.has(tooltip.$anchor).length > 0) {
        tooltips.push(tooltip);
      }
    }
    return tooltips;
  }
};

scout.TooltipSupport = function(options) {
  var defaultOptions = {
    selector: null,
    delay: 600,
    text: undefined,
    nativeTooltip: false
  };
  options = $.extend({}, defaultOptions, options);
  this._options = options;
  this._mouseEnterHandler = this._onMouseEnter.bind(this);
  this._mouseLeaveHandler = this._onMouseLeave.bind(this);
  this._tooltip;
  this._tooltipTimeoutId;
};

scout.TooltipSupport.prototype.install = function($comp) {
  // prevent multiple installation of tooltip support
  if (!$comp.data('tooltipSupport')) {
    $comp
      .on('mouseenter', this._options.selector, this._mouseEnterHandler)
      .on('mouseleave', this._options.selector, this._mouseLeaveHandler)
      .data('tooltipSupport', this);
  }
};

scout.TooltipSupport.prototype.uninstall = function($comp) {
  $comp
    .removeData('tooltipSupport')
    .off('mouseleave', this._options.selector, this._mouseLeaveHandler)
    .off('mouseenter', this._options.selector, this._onMouseEnterHandler);
  this._destroyTooltip();
  clearTimeout(this._tooltipTimeoutId);
};

scout.TooltipSupport.prototype._onMouseEnter = function(event) {
  var $comp = $(event.currentTarget);

  if (this._options.nativeTooltip) {
    var text = this._text($comp);
    $comp.attr('title', text);
  } else {
    clearTimeout(this._tooltipTimeoutId);
    this._tooltipTimeoutId = setTimeout(this._showTooltip.bind(this, $comp), this._options.delay);
  }
};

scout.TooltipSupport.prototype._onMouseLeave = function(event) {
  this._destroyTooltip();
};

scout.TooltipSupport.prototype._destroyTooltip = function() {
  clearTimeout(this._tooltipTimeoutId);
  if (this._tooltip) {
    this._tooltip.destroy();
    this._tooltip = null;
  }
};

scout.TooltipSupport.prototype._text = function($comp) {
  var text = this._options.text || $comp.data('tooltipText');
  if ($.isFunction(text)) {
    text = text($comp);
  }
  return text;
};

scout.TooltipSupport.prototype._showTooltip = function($comp) {
  if (!$comp || !$comp.isAttached()) {
    return; // removed in the meantime (this method is called using setTimeout)
  }
  var text = this._text($comp);
  if (!text) {
    return; // treat undefined and no text as no tooltip
  }

  if (this._tooltip && this._tooltip.rendered) {
    // update existing tooltip
    this._tooltip.setText(text);
  } else {
    // create new tooltip
    var options = $.extend({}, this._options, {
      $anchor: $comp,
      text: text
    });
    this._tooltip = scout.create('Tooltip', options);
    this._tooltip.render();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Action = function() {
  scout.Action.parent.call(this);

  this.enabled = true;
  this.visible = true;
  this.selected = false;
  this.horizontalAlignment = -1;
  this.iconId = '';
  this.tooltipText = '';
  this.text = '';
  this.cssClass = '';
  this.toggleAction = false;
  this.keyStroke = null;

  /**
   * This property decides whether or not the tabindex attribute is set in the DOM.
   */
  this.tabbable = false;

  /**
   * Supported action styles are:
   * - default: regular menu-look, also used in overflow menus
   * - button: menu looks like a button
   */
  this.actionStyle = scout.Action.ActionStyle.DEFAULT;
  this.textVisible = true;
  this.compact = false;
  this._addCloneProperties(['actionStyle', 'cssClass', 'horizontalAlignment', 'iconId', 'selected', 'tabbable', 'text', 'tooltipText', 'toggleAction']);
};
scout.inherits(scout.Action, scout.Widget);

scout.Action.ActionStyle = {
  DEFAULT: 0,
  BUTTON: 1
};

/**
 * @override
 */
scout.Action.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

scout.Action.prototype._init = function(model) {
  scout.Action.parent.prototype._init.call(this, model);
  this.actionKeyStroke = this._createActionKeyStroke();
  this.resolveTextKeys(['text', 'tooltipText']);
  this.resolveIconIds(['iconId']);
  this._syncKeyStroke(this.keyStroke);
};

scout.Action.prototype._renderProperties = function() {
  scout.Action.parent.prototype._renderProperties.call(this);

  this._renderText();
  this._renderIconId();
  this._renderTooltipText();
  this._renderKeyStroke();
  this._renderSelected();
  this._renderTabbable();
  this._renderCompact();
};

scout.Action.prototype._remove = function() {
  this._removeText();
  scout.Action.parent.prototype._remove.call(this);
};

scout.Action.prototype._renderText = function() {
  var text = this.text || '';
  if (text && this.textVisible) {
    if (!this.$text) {
      // Create a separate text element to so that setting the text does not remove the icon
      this.$text = this.$container.appendSpan('text');
    }
    this.$text.text(text);
  } else {
    this._removeText();
  }
};

scout.Action.prototype._removeText = function() {
  if (this.$text) {
    this.$text.remove();
    this.$text = null;
  }
};

scout.Action.prototype._renderIconId = function() {
  var iconId = this.iconId || '';
  this.$container.icon(iconId);
};

/**
 * @override
 */
scout.Action.prototype._renderEnabled = function() {
  this.$container.setEnabled(this.enabled);
  this._updateTooltip();
};

scout.Action.prototype._renderSelected = function() {
  this.$container.select(this.selected);
  this._updateTooltip();
};

scout.Action.prototype._renderKeyStroke = function() {
  var keyStroke = this.keyStroke;
  if (keyStroke === undefined) {
    this.$container.removeAttr('data-shortcut');
  } else {
    this.$container.attr('data-shortcut', keyStroke);
  }
};

scout.Action.prototype._renderTooltipText = function() {
  this._updateTooltip();
};

/**
 * Installs or uninstalls tooltip based on tooltipText, selected and enabled.
 */
scout.Action.prototype._updateTooltip = function() {
  if (this._shouldInstallTooltip()) {
    scout.tooltips.install(this.$container, this._configureTooltip());
  } else {
    scout.tooltips.uninstall(this.$container);
  }
};

scout.Action.prototype._shouldInstallTooltip = function() {
  return this.tooltipText && !this.selected && this.enabled;
};

scout.Action.prototype._renderTabbable = function() {
  this.$container.setTabbable(this.tabbable && !scout.device.supportsTouch());
};

scout.Action.prototype._renderHorizontalAlignment = function() {
  // nothing to render, property is only considered by the menubar
};

scout.Action.prototype._renderCompact = function() {
  this.$container.toggleClass('compact', this.compact);
  this.invalidateLayoutTree();
};

scout.Action.prototype._configureTooltip = function() {
  return {
    parent: this,
    text: this.tooltipText,
    $anchor: this.$container,
    arrowPosition: 50,
    arrowPositionUnit: '%',
    tooltipPosition: this.tooltipPosition
  };
};

/**
 * @return {Boolean}
 *          <code>true</code> if the action has been performed or <code>false</code> if it
 *          has not been performed (e.g. when the button is not enabled).
 */
scout.Action.prototype.doAction = function() {
  if (!this.prepareDoAction()) {
    return false;
  }

  if (this.isToggleAction()) {
    this.setSelected(!this.selected);
  } else {
    this._doAction();
  }
  return true;
};

scout.Action.prototype.toggle = function() {
  if (this.isToggleAction()) {
    this.setSelected(!this.selected);
  }
};

scout.Action.prototype.isToggleAction = function() {
  return this.toggleAction;
};

/**
 * @returns {Boolean} <code>true</code> if the action may be executed, <code>false</code> if it should be ignored.
 */
scout.Action.prototype.prepareDoAction = function() {
  if (!this.enabled || !this.visible) {
    return false;
  }

  return true;
};

scout.Action.prototype._doAction = function() {
  this.trigger('doAction');
};

scout.Action.prototype.setText = function(text) {
  this.setProperty('text', text);
};

scout.Action.prototype.setSelected = function(selected) {
  this.setProperty('selected', selected);
};

scout.Action.prototype._syncKeyStroke = function(keyStroke) {
  this._setProperty('keyStroke', keyStroke);
  this.actionKeyStroke.parseAndSetKeyStroke(keyStroke);
};

scout.Action.prototype.setTabbable = function(tabbable) {
  this.setProperty('tabbable', tabbable);
};

scout.Action.prototype.setTextVisible = function(textVisible) {
  if (this.textVisible === textVisible) {
    return;
  }
  this._setProperty('textVisible', textVisible);
  if (this.rendered) {
    this._renderText();
  }
};

scout.Action.prototype.setCompact = function(compact) {
  if (this.compact === compact) {
    return;
  }
  this.compact = compact;
  if (this.rendered) {
    this._renderCompact();
  }
};

scout.Action.prototype._createActionKeyStroke = function() {
  return new scout.ActionKeyStroke(this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ActionAdapter = function() {
  scout.ActionAdapter.parent.call(this);
  this._addRemoteProperties(['selected']);
};
scout.inherits(scout.ActionAdapter, scout.ModelAdapter);

scout.ActionAdapter.prototype._goOffline = function() {
  this._enabledBeforeOffline = this.widget.enabled;
  this.widget.setEnabled(false);
};

scout.ActionAdapter.prototype._goOnline = function() {
  this.widget.setEnabled(this._enabledBeforeOffline);
};

scout.ActionAdapter.prototype._onWidgetDoAction = function(event) {
  this._send('doAction');
};

scout.ActionAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'doAction') {
    this._onWidgetDoAction(event);
  } else {
    scout.ActionAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ActionKeyStroke = function(action) {
  scout.ActionKeyStroke.parent.call(this);
  this.field = action;
  this.parseAndSetKeyStroke(action.keyStroke);
  this.stopPropagation = true; // TODO [5.2] dwi: Make this configurable in the Scout model. Use case: OK keystrokes should not bubble up, but other should.
  this.stopImmediatePropagation = false; // TODO [5.2] dwi: make this configurable in Scout model.
};
scout.inherits(scout.ActionKeyStroke, scout.KeyStroke);

scout.ActionKeyStroke.prototype._isEnabled = function() {
  if (!this.which.length) {
    return false; // actions without a keystroke are not enabled.
  } else {
    return scout.ActionKeyStroke.parent.prototype._isEnabled.call(this);
  }
};

scout.ActionKeyStroke.prototype.handle = function(event) {
  this.field.doAction();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Used for static pages like login, logout, unsupported-browser and noscript section.
 * Beside custom elements it may contain a header with a logo and a button bar.
 * Note: It does not extend from Widget because widget has too many dependencies which are not needed for this simple use case (login-module does not include these dependencies)
 */
scout.Box = function() {
};

scout.Box.prototype.render = function($parent) {
  this._render($parent);
  this.rendered = true;
};

scout.Box.prototype.remove = function() {
  this.$container.remove();
  this.$container = null;
  this.rendered = false;
};

scout.Box.prototype._render = function($parent) {
  this.$container = $('<div>')
    .addClass('box')
    .appendTo($parent);

  this.$wrapper = $('<div>')
    .addClass('wrapper')
    .appendTo(this.$container);

  this.$content = $('<div>')
    .addClass('box-content')
    .appendTo(this.$wrapper);

  if (this.logoUrl) {
    this.$header = this.$content.appendDiv('header');
    this.$logo = $('<img>')
      .addClass('logo')
      .attr('src', this.logoUrl)
      .appendTo(this.$header);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Popup = function() {
  scout.Popup.parent.call(this);

  this._mouseDownHandler;
  this._scrollHandler;
  this._popupOpenHandler;
  this.anchorBounds;
  this.$anchor;
  this.windowPaddingX;
  this.windowPaddingY;
  this.withFocusContext;
  this.initialFocus;
  this.focusableContainer;
  this.openingDirectionX;
  this.openingDirectionY;
  // hints for the layout to control whether the size should be adjusted if the popup does not fit into the window
  this.trimWidth;
  this.trimHeight;
  // If true, anchor is considered when computing the position and size of the popup
  this.boundToAnchor;
  // If true, the attached mouse down handler will NOT close the popup if the anchor was clicked, the anchor is responsible to close it.
  // This is necessary because the mousedown listener is attached to the capture phase and therefore executed before any other.
  // If anchor was clicked, popup would already be closed and then opened again -> popup could never be closed by clicking the anchor
  this.closeOnAnchorMousedown;
};
scout.inherits(scout.Popup, scout.Widget);

/**
 * @param options:
 *          initialFocus: a function that returns the element to be focused or a <code>scout.focusRule</code>. Default returns <code>scout.focusRule.AUTO</code>
 *          focusableContainer: a boolean whether or not the container of the Popup is focusable
 */
scout.Popup.prototype._init = function(options) {
  scout.Popup.parent.prototype._init.call(this, options);

  this.anchorBounds = options.anchorBounds;
  if (options.location) {
    this.anchorBounds = new scout.Rectangle(options.location.x, options.location.y, 0, 0);
  }
  this.$anchor = options.$anchor;
  this.windowPaddingX = scout.nvl(options.windowPaddingX, 10);
  this.windowPaddingY = scout.nvl(options.windowPaddingY, 5);
  this.openingDirectionX = options.openingDirectionX || 'right';
  this.openingDirectionY = options.openingDirectionY || 'down';
  // Popup is getting moved if it overlaps a border (and not switched as done for y axis) -> do not adjust its size
  this.trimWidth = scout.nvl(options.trimWidth, false);
  this.trimHeight = scout.nvl(options.trimHeight, true);
  this.withFocusContext = scout.nvl(options.installFocusContext, true);
  this.initialFocus = scout.nvl(options.initialFocus, function() {
    return scout.focusRule.AUTO;
  });
  this.focusableContainer = scout.nvl(options.focusableContainer, false);
  this.scrollType = options.scrollType || 'remove';
  this.boundToAnchor = scout.nvl(options.boundToAnchor, true);
  this.closeOnAnchorMousedown = scout.nvl(options.closeOnAnchorMousedown, true);
};

/**
 * @override
 */
scout.Popup.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.Popup.prototype._initKeyStrokeContext = function() {
  scout.Popup.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke(this._createCloseKeyStroke());
};

/**
 * Override this method to provide a key stroke which closes the popup.
 * The default impl. returns a CloseKeyStroke which handles the ESC key.
 */
scout.Popup.prototype._createCloseKeyStroke = function() {
  return new scout.CloseKeyStroke(this);
};

scout.Popup.prototype._createLayout = function() {
  return new scout.PopupLayout(this);
};

scout.Popup.prototype.open = function($parent) {
  this._triggerPopupOpenEvent();

  this._open($parent);

  // Focus the popup
  // It is important that this happens after layouting and positioning, otherwise we'd focus an element
  // that is currently not on the screen. Which would cause the whole desktop to
  // be shifted for a few pixels.
  if (this.withFocusContext) {
    this.session.focusManager.installFocusContext(this.$container, this.initialFocus());
  }

};

scout.Popup.prototype._open = function($parent) {
  this.render($parent);
  this.revalidateLayout();
  this.position();
};

scout.Popup.prototype.render = function($parent) {
  var $popupParent = $parent || this.entryPoint(this.parent.$container);
  scout.Popup.parent.prototype.render.call(this, $popupParent);
};

scout.Popup.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('popup');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.validateRoot = true;
  this.htmlComp.setLayout(this._createLayout());

  // Add programmatic 'tabindex' if the $container itself should be focusable (used by context menu popups with no focusable elements)
  if (this.withFocusContext && this.focusableContainer) {
    this.$container.attr('tabindex', -1);
  }
};

scout.Popup.prototype._postRender = function() {
  scout.Popup.parent.prototype._postRender.call(this);

  this.size();
  this._attachCloseHandler();
  scout.scrollbars.update(this.$body);
};

scout.Popup.prototype._remove = function() {
  if (this.withFocusContext) {
    this.session.focusManager.uninstallFocusContext(this.$container);
  }
  // remove all clean-up handlers
  this._detachCloseHandler();
  scout.Popup.parent.prototype._remove.call(this);
};

scout.Popup.prototype.close = function() {
  this.trigger('close');
  this.destroy();
};

/**
 * Install listeners to close the popup once clicking outside the popup,
 * or changing the anchor's scroll position, or another popup is opened.
 */
scout.Popup.prototype._attachCloseHandler = function() {
  // Install mouse close handler
  // The listener needs to be executed in the capturing phase -> prevents that _onMouseDown will be executed right after the popup gets opened using mouse down, otherwise the popup would be closed immediately
  this._mouseDownHandler = this._onMouseDown.bind(this);
  this.$container.document(true).addEventListener('mousedown', this._mouseDownHandler, true); // true=the event handler is executed in the capturing phase

  // Install popup open close handler
  this._popupOpenHandler = this._onPopupOpen.bind(this);
  this.session.desktop.on('popupopen', this._popupOpenHandler);

  // Install scroll close handler
  if (this.$anchor && this.boundToAnchor && this.scrollType) {
    this._scrollHandler = this._onAnchorScroll.bind(this);
    scout.scrollbars.onScroll(this.$anchor, this._scrollHandler);
  }
};

scout.Popup.prototype._detachCloseHandler = function() {
  // Uninstall scroll close handler
  if (this._scrollHandler) {
    scout.scrollbars.offScroll(this._scrollHandler);
    this._scrollHandler = null;
  }

  // Uninstall popup open close handler
  if (this._popupOpenHandler) {
    this.session.desktop.off('popupopen', this._popupOpenHandler);
    this._popupOpenHandler = null;
  }

  // Uninstall mouse close handler
  if (this._mouseDownHandler) {
    this.$container.document(true).removeEventListener('mousedown', this._mouseDownHandler, true);
    this._mouseDownHandler = null;
  }
};

scout.Popup.prototype._onMouseDown = function(event) {
  // in some cases the mousedown handler is executed although it has been already
  // detached on the _remove() method. However, since we're in the middle of
  // processing the mousedown event, it's too late to detach the event and we must
  // deal with that situation by checking the rendered flag. Otherwise we would
  // run into an error later, since the $container is not available anymore.
  if (!this.rendered) {
    return;
  }
  if (this._isMouseDownOutside(event)) {
    this._onMouseDownOutside(event);
  }
};

scout.Popup.prototype._isMouseDownOutside = function(event) {
  var $target = $(event.target),
    targetWidget;

  if (!this.closeOnAnchorMousedown && this.$anchor && this.$anchor.isOrHas(event.target)) {
    // 1. Often times, click on the anchor opens and 2. click closes the popup
    // If we were closing the popup here, it would not be possible to achieve the described behavior anymore -> let anchor handle open and close.
    return false;
  }

  targetWidget = scout.Widget.getWidgetFor($target);

  // close the popup only if the click happened outside of the popup and its children
  // It is not sufficient to check the dom hierarchy using $container.has($target)
  // because the popup may open other popups which probably is not a dom child but a sibling
  // Also ignore clicks if the popup is covert by a glasspane
  return !this.isOrHas(targetWidget) && !this.session.focusManager.isElementCovertByGlassPane(this.$container[0]);
};

/**
 * Method invoked once a mouse down event occurs outside the popup.
 */
scout.Popup.prototype._onMouseDownOutside = function(event) {
  this.close();
};

/**
 * Method invoked once the 'options.$anchor' is scrolled.
 */
scout.Popup.prototype._onAnchorScroll = function(event) {
  if (!this.rendered) {
    // Scroll events may be fired delayed, even if scroll listener are already removed.
    return;
  }
  if (this.scrollType === 'position') {
    this.position();
  } else if (this.scrollType === 'layoutAndPosition') {
    this.revalidateLayout();
    this.position();
  } else if (this.scrollType === 'remove') {
    this.close();
  }
};

/**
 * Method invoked once a popup is opened.
 */
scout.Popup.prototype._onPopupOpen = function(event) {
  // Make sure child popups don't close the parent popup, we must check parent hierarchy in both directions
  // Use case: Opening of a context menu or cell editor in a form popup
  // Also, popups covered by a glass pane (a modal dialog is open) must never be closed
  // Use case: popup opens a modal dialog. User clicks on a smartfield on this dialog -> underlying popup must not get closed
  if (!this.isOrHas(event.popup) &&
    !event.popup.isOrHas(this) &&
    !this.session.focusManager.isElementCovertByGlassPane(this.$container[0])) {
    this.close();
  }
};

scout.Popup.prototype.prefLocation = function($container, openingDirectionY) {
  var x, y, anchorBounds, height, openingDirectionX;
  if (!this.boundToAnchor || (!this.anchorBounds && !this.$anchor)) {
    return;
  }
  openingDirectionX = 'right'; // always use right at the moment
  openingDirectionY = openingDirectionY || this.openingDirectionY;
  $container.removeClass('up down left right');
  $container.addClass(openingDirectionY + ' ' + openingDirectionX);
  height = $container.outerHeight(true);

  anchorBounds = this.getAnchorBounds();
  x = anchorBounds.x;
  y = anchorBounds.y;
  if (openingDirectionY === 'up') {
    y -= height;
  } else if (openingDirectionY === 'down') {
    y += anchorBounds.height;
  }

  // this.$parent might not be at (0,0) of the document
  var parentOffset = this.$parent.offset();
  x -= parentOffset.left;
  y -= parentOffset.top;

  return {
    x: x,
    y: y
  };
};

scout.Popup.prototype.getAnchorBounds = function() {
  var anchorBounds = this.anchorBounds;
  if (!anchorBounds) {
    anchorBounds = scout.graphics.offsetBounds(this.$anchor);
  }
  return anchorBounds;
};

scout.Popup.prototype.overlap = function($container, location) {
  if (!$container || !location) {
    return;
  }
  var overlapX, overlapY,
    height = $container.outerHeight(),
    width = $container.outerWidth(),
    left = location.x,
    top = location.y;

  overlapX = left + width + this.windowPaddingX - this.session.$entryPoint.outerWidth(true);
  overlapY = top + height + this.windowPaddingY - this.session.$entryPoint.outerHeight(true);
  return {
    x: overlapX,
    y: overlapY
  };
};

scout.Popup.prototype.adjustLocation = function($container, location, switchIfNecessary) {
  var openingDirection, left, top,
    overlap = this.overlap($container, location);

  switchIfNecessary = scout.nvl(switchIfNecessary, true);
  if (overlap.y > 0 && switchIfNecessary) {
    // switch opening direction
    openingDirection = 'up';
    location = this.prefLocation($container, openingDirection);
  }
  left = location.x;
  top = location.y;
  if (overlap.x > 0) {
    // Move popup to the left until it gets fully visible
    left -= overlap.x;
  }
  return {
    x: left,
    y: top
  };
};

scout.Popup.prototype.size = function() {
  var size = this.prefSize(this.$container);
  if (!size) {
    return;
  }
  scout.graphics.setSize(this.$container, size);
};

scout.Popup.prototype.prefSize = function($container) {
  return null;
};

scout.Popup.prototype.position = function(switchIfNecessary) {
  this._validateVisibility();
  this._position(this.$container, switchIfNecessary);
};

scout.Popup.prototype._position = function($container, switchIfNecessary) {
  var location = this.prefLocation($container);
  if (!location) {
    return;
  }
  location = this.adjustLocation($container, location, switchIfNecessary);
  this.setLocation(location);
};

scout.Popup.prototype.setLocation = function(location) {
  this.$container
    .css('left', location.x)
    .css('top', location.y);
  this._triggerLocationChanged();
};

/**
 * Popups with an anchor must only be visible if the anchor is in view (prevents that the popup points at an invisible anchor)
 */
scout.Popup.prototype._validateVisibility = function() {
  if (!this.boundToAnchor || !this.$anchor) {
    return;
  }
  var inView = this._isInView();
  var needsLayouting = this.$container.isVisible() !== inView && inView;
  this.$container.setVisible(inView);
  if (needsLayouting) {
    this.revalidateLayout();
  }
};

scout.Popup.prototype._isInView = function() {
  if (!this.boundToAnchor || !this.$anchor) {
    return;
  }
  var anchorBounds = this.getAnchorBounds();
  return scout.scrollbars.isLocationInView(anchorBounds.center(), this.$anchor.scrollParent());
};

scout.Popup.prototype._triggerLocationChanged = function() {
  this.trigger('locationChanged');
};

/**
 * Fire event that this popup is about to open.
 */
scout.Popup.prototype._triggerPopupOpenEvent = function() {
  this.session.desktop.trigger('popupopen', {
    popup: this
  });
};

scout.Popup.prototype.belongsTo = function($anchor) {
  return this.$anchor[0] === $anchor[0];
};

scout.Popup.prototype.isOpen = function() {
  return this.rendered;
};

scout.Popup.prototype.ensureOpen = function() {
  if (!this.isOpen()) {
    this.open();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PopupLayout = function(popup) {
  scout.PopupLayout.parent.call(this);
  this.popup = popup;
};
scout.inherits(scout.PopupLayout, scout.AbstractLayout);

scout.PopupLayout.prototype.layout = function($container) {
  var popupSize,
    htmlComp = this.popup.htmlComp,
    prefSize = this.preferredLayoutSize($container);

  if (this.popup.boundToAnchor) {
    popupSize = this._adjustSizeWithAnchor(prefSize);
  } else {
    popupSize = this._adjustSize(prefSize);
  }

  scout.graphics.setSize(htmlComp.$comp, popupSize);
};

scout.PopupLayout.prototype._adjustSize = function(prefSize) {
  var popupSize = new scout.Dimension(),
    maxSize = this._calcMaxSize();

  // Ensure the popup is not larger than max size
  popupSize.width = Math.min(maxSize.width, prefSize.width);
  popupSize.height = Math.min(maxSize.height, prefSize.height);

  return popupSize;
};

/**
 * Considers window boundaries.
 *
 * @returns {scout.Dimension}
 */
scout.PopupLayout.prototype._calcMaxSize = function() {
  // Position the popup at the desired location before doing any calculations to consider the preferred bounds
  this.popup.position(false);

  var maxWidth, maxHeight,
    htmlComp = this.popup.htmlComp,
    windowPaddingX = this.popup.windowPaddingX,
    windowPaddingY = this.popup.windowPaddingY,
    popupMargins = htmlComp.getMargins(),
    popupBounds = htmlComp.getBounds(),
    $window = this.popup.$container.window(),
    windowSize = new scout.Dimension($window.width(), $window.height());

  maxWidth = (windowSize.width - popupMargins.horizontal() - popupBounds.x - windowPaddingX);
  maxHeight = (windowSize.height - popupMargins.vertical() - popupBounds.y - windowPaddingY);

  return new scout.Dimension(maxWidth, maxHeight);
};

scout.PopupLayout.prototype._adjustSizeWithAnchor = function(prefSize) {
  var popupSize = new scout.Dimension(),
    maxSize = this._calcMaxSizeAroundAnchor();
  // Decide whether the prefSize can be used or the popup needs to be shrinked so that it fits into the viewport
  // The decision is based on the preferred opening direction
  // Example: The popup would like to be opened right and down
  // If there is enough space on the right and on the bottom -> pref size is used
  // If there is not enough space on the right it checks whether there is enough space on the left
  // If there is enough space on the left -> use preferred width -> The opening direction will be switched using position() at the end
  // If there is not enough space on the left as well, the greater width is used -> Position() will either switch the direction or not, depending on the size of the popup
  // The same happens for y direction if there is not enough space on the bottom
  popupSize.width = prefSize.width;
  if (this.popup.trimWidth) {
    if (this.popup.openingDirectionX === 'right' &&
      prefSize.width > maxSize.right && prefSize.width > maxSize.left) {
      popupSize.width = Math.max(maxSize.right, maxSize.left);
    } else if (this.popup.openingDirectionX === 'left' &&
      prefSize.width > maxSize.left && prefSize.width > maxSize.right) {
      popupSize.width = Math.max(maxSize.right, maxSize.left);
    }
  }
  popupSize.height = prefSize.height;
  if (this.popup.trimHeight) {
    if (this.popup.openingDirectionY === 'down' &&
      prefSize.height > maxSize.bottom && prefSize.height > maxSize.top) {
      popupSize.height = Math.max(maxSize.bottom, maxSize.top);
    } else if (this.popup.openingDirectionY === 'up' &&
      prefSize.height > maxSize.top && prefSize.height > maxSize.bottom) {
      popupSize.height = Math.max(maxSize.bottom, maxSize.top);
    }
  }
  return popupSize;
};

/**
 * Considers window boundaries.
 *
 * @returns {scout.Dimension}
 */
scout.PopupLayout.prototype._calcMaxSizeAroundAnchor = function() {
  var maxWidthLeft, maxWidthRight, maxHeightDown, maxHeightUp,
    htmlComp = this.popup.htmlComp,
    windowPaddingX = this.popup.windowPaddingX,
    windowPaddingY = this.popup.windowPaddingY,
    popupMargins = htmlComp.getMargins(),
    anchorBounds = this.popup.getAnchorBounds(),
    $window = this.popup.$container.window(),
    windowSize = new scout.Dimension($window.width(), $window.height());

  maxWidthRight = (windowSize.width - (anchorBounds.x + anchorBounds.width) - popupMargins.horizontal() - windowPaddingX);
  maxWidthLeft = (anchorBounds.x - popupMargins.horizontal() - windowPaddingX);
  maxHeightDown = (windowSize.height - (anchorBounds.y + anchorBounds.height) - popupMargins.vertical() - windowPaddingY);
  maxHeightUp = (anchorBounds.y - popupMargins.vertical() - windowPaddingY);

  return new scout.Insets(maxHeightUp, maxWidthRight, maxHeightDown, maxWidthLeft);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PopupWithHead = function() {
  scout.PopupWithHead.parent.call(this);
  this.$head;
  this.$body;
  this.$deco;
  this.$parent;
  this._headVisible = true;
  this.resizeHandler = this.onResize.bind(this);
};
scout.inherits(scout.PopupWithHead, scout.Popup);

scout.PopupWithHead.prototype._createLayout = function() {
  return new scout.PopupWithHeadLayout(this);
};

scout.PopupWithHead.prototype._init = function(options) {
  scout.PopupWithHead.parent.prototype._init.call(this, options);

  // Compared to a regular popup, the popup is aligned with the head and either opened left or right,
  // -> the width should be adjusted as well if it does not fit into the window
  this.trimWidth = scout.nvl(options.trimWidth, true);
};

scout.PopupWithHead.prototype._render = function($parent) {
  scout.PopupWithHead.parent.prototype._render.call(this, $parent);
  this.$parent.window().on('resize', this.resizeHandler);

  this.$body = this._$createNewBody();
  if (this._headVisible) {
    this._renderHead();
  }
};

scout.PopupWithHead.prototype.onResize = function() {
  if (!this.rendered) {
    // may already be removed if a parent popup is closed during the resize event
    return;
  }
  this.$parent.window().off('resize', this.resizeHandler);
  this.close();
};

scout.PopupWithHead.prototype._remove = function() {
  this.$parent.window().off('resize', this.resizeHandler);
  scout.PopupWithHead.parent.prototype._remove.call(this);
};

scout.PopupWithHead.prototype._$createNewBody = function() {
  this.$body = this.$container.appendDiv('popup-body');
  this._modifyBody();
  return this.$body;
};

scout.PopupWithHead.prototype.rerenderHead = function() {
  this._removeHead();
  this._renderHead();
};

/**
 * Copies html from this.$headBlueprint, if set.
 */
scout.PopupWithHead.prototype._renderHead = function() {
  this.$deco = this.$container.makeDiv('popup-deco');
  this.$head = this.$container
    .makeDiv('popup-head menu-item')
    .on('mousedown', '', this._onHeadMouseDown.bind(this));
  this.$container
    .prepend(this.$head)
    .append(this.$deco);
  if (this.$headBlueprint) {
    this.$head.html(this.$headBlueprint.html());
    this._modifyHeadChildren();
  }
};

/**
 * Sets CSS classes or CSS-properties on the copied children in the head.
 */
scout.PopupWithHead.prototype._modifyHeadChildren = function() {
  // NOP
};

/**
 * Sets CSS classes or CSS-properties on the body.
 */
scout.PopupWithHead.prototype._modifyBody = function() {
  // NOP
};

scout.PopupWithHead.prototype._removeHead = function() {
  if (this.$head) {
    this.$head.remove();
  }
  if (this.$deco) {
    this.$deco.remove();
  }
};

scout.PopupWithHead.prototype._copyCssClassToHead = function(className) {
  if (this.$headBlueprint && this.$headBlueprint.hasClass(className)) {
    this.$head.addClass(className);
  }
};

scout.PopupWithHead.prototype._onHeadMouseDown = function(event) {
  if (this.$head && this.$head.isOrHas(event.target)) {
    this.close();
  }
};

/**
 * @override
 */
scout.PopupWithHead.prototype._isMouseDownOutside = function(event) {
  if (this.$headBlueprint && this.$headBlueprint.isOrHas(event.target)) {
    // click on the head still belongs to the popup -> not an outside click -> do not close popup
    return false;
  }

  return scout.PopupWithHead.parent.prototype._isMouseDownOutside.call(this, event);
};

scout.PopupWithHead.prototype.appendToBody = function($element) {
  this.$body.append($element);
};

scout.PopupWithHead.prototype.addClassToBody = function(clazz) {
  this.$body.addClass(clazz);
};

/**
 * @override Popup.js
 */
scout.PopupWithHead.prototype._position = function($container, switchIfNecessary) {
  if (!this.$container) {
    //when layouting menu bar menues are first removed and then newly added prevent this.$contaier = null;
    return;
  }
  var openingDirectionX, openingDirectionY, overlap, pos;
  if (!this._headVisible) {
    // If head is not visible, use default implementation and adjust $body to $container
    scout.PopupWithHead.parent.prototype._position.call(this, $container);
    this.$body.removeClass('up down left right');
    openingDirectionY = 'up';
    if ($container.hasClass('down')) {
      openingDirectionY = 'down';
    }
    openingDirectionX = 'right';
    if ($container.hasClass('left')) {
      openingDirectionX = 'left';
    }
    this.$body.addClass(openingDirectionY + ' ' + openingDirectionX);
    return;
  }
  this._positionImpl();

  switchIfNecessary = scout.nvl(switchIfNecessary, true);
  if (switchIfNecessary) {
    pos = $container.offset();
    overlap = this.overlap($container, {
      x: pos.left,
      y: pos.top
    });
    // this.$parent might not be at (0,0) of the document
    var parentOffset = this.$parent.offset();
    overlap.x -= parentOffset.left;
    overlap.y -= parentOffset.top;
    if (overlap.y > 0) {
      // switch opening direction
      openingDirectionY = 'up';
    }
    if (overlap.x > 0) {
      // switch opening direction
      openingDirectionX = 'left';
    }
    if (openingDirectionX || openingDirectionY) {
      // Align again if openingDirection has to be switched
      this._positionImpl(openingDirectionX, openingDirectionY);
    }
  }
};

scout.PopupWithHead.prototype._positionImpl = function(openingDirectionX, openingDirectionY) {
  var pos, headSize, bodySize, bodyWidth, widthDiff, $blueprintChildren, left, top, headInsets, menuInsets,
    bodyTop = 0,
    headTop = 0,
    decoTop = 0;

  openingDirectionX = openingDirectionX || this.openingDirectionX;
  openingDirectionY = openingDirectionY || this.openingDirectionY;
  this.$container.removeClass('up down left right');
  this.$body.removeClass('up down left right');
  this.$container.addClass(openingDirectionY + ' ' + openingDirectionX);
  this.$body.addClass(openingDirectionY + ' ' + openingDirectionX);

  // Make sure the elements inside the header have the same style as to blueprint (menu)
  // This makes it possible to position the content in the header (icon, text) exactly on top of the content of the blueprint
  this.$head.copyCssIfGreater(this.$headBlueprint, 'padding');
  this.$head.height(this.$headBlueprint.height());

  $blueprintChildren = this.$headBlueprint.children();
  this.$head.children().each(function(i) {
    var $headChild = $(this);
    var $blueprintChild = $blueprintChildren.eq(i);
    $headChild.copyCss($blueprintChild, 'margin padding line-height border vertical-align font-size display');
  });

  headSize = scout.graphics.getSize(this.$head, true);
  bodySize = scout.graphics.getSize(this.$body, true);
  bodySize.width = Math.max(bodySize.width, headSize.width);
  bodyWidth = bodySize.width;

  pos = this.$headBlueprint.offset();
  // this.$parent might not be at (0,0) of the document
  var parentOffset = this.$parent.offset();
  pos.left -= parentOffset.left;
  pos.top -= parentOffset.top;

  left = pos.left;
  headInsets = scout.graphics.getInsets(this.$head);
  menuInsets = scout.graphics.getInsets(this.$headBlueprint);
  top = pos.top - headInsets.top + menuInsets.top;

  if (openingDirectionY === 'up') {
    top -= bodySize.height;
    headTop = bodyTop + bodySize.height;
    decoTop = headTop - 1; // -1 is body border (the purpose of deco is to hide the body border)
    this.$container.cssMarginBottom(headSize.height);
    this.$container.css('margin-top', '');
  } else if (openingDirectionY === 'down') {
    headTop -= headSize.height;
    this.$container.cssMarginTop(headSize.height);
    this.$container.css('margin-bottom', '');
  }

  $.log.debug('bodyWidth=' + bodyWidth + ' pos=[left=' + pos.left + ' top=' + pos.top + '] headSize=' + headSize +
    ' headInsets=' + headInsets + ' left=' + left + ' top=' + top);
  this.$head.cssTop(headTop);
  this.$body.cssTop(bodyTop);
  this.$deco.cssTop(decoTop);

  if (openingDirectionX === 'left') {
    widthDiff = bodyWidth - headSize.width;
    left -= widthDiff + headInsets.left - menuInsets.left;
    this.$head.cssLeft(widthDiff);
    this.$body.cssLeft(0);
    this.$deco.cssLeft(widthDiff + this.$head.cssBorderLeftWidth())
      .width(headSize.width - this.$head.cssBorderWidthX());
  } else {
    left = left - headInsets.left + menuInsets.left;
    this.$head.cssLeft(0);
    this.$deco.cssLeft(1)
      .width(headSize.width - 2);
  }

  this.openingDirectionX = openingDirectionX;
  this.openingDirectionY = openingDirectionY;
  this.setLocation(new scout.Point(left, top));

  // Explicitly write the (rounded, by jQuery) sizes to the elements to prevent rounding issues
  scout.graphics.setSize(this.$head, headSize);
  scout.graphics.setSize(this.$body, bodySize);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PopupWithHeadLayout = function(popup) {
  scout.PopupWithHeadLayout.parent.call(this, popup);
};
scout.inherits(scout.PopupWithHeadLayout, scout.PopupLayout);

scout.PopupWithHeadLayout.prototype.layout = function($container) {
  scout.PopupWithHeadLayout.parent.prototype.layout.call(this, $container);

  var htmlComp = this.popup.htmlComp,
    popupSize = htmlComp.getSize();

  //while animating the body animation sets the size.
  if (!this.popup.bodyAnimating) {
    // Set size of body
    popupSize = popupSize.subtract(htmlComp.getInsets());
    if (this._headVisible) {
      var headSize = scout.graphics.getSize(this.popup.$head, true);
      //adjust popupsize if head changed size
      if (popupSize.width < headSize.width) {
        popupSize.width = headSize.width;
        scout.graphics.setSize(htmlComp.$comp, popupSize);
      }
    }

    scout.graphics.setSize(this.popup.$body, popupSize);
  }
};

/**
 * @override
 */
scout.PopupWithHeadLayout.prototype._calcMaxSizeAroundAnchor = function() {
  // Position the popup at the desired location before doing any calculations,
  // but do no try to switch the position if there is not enough space
  this.popup.position(false);

  var maxWidthLeft, maxWidthRight, maxHeightDown, maxHeightUp,
    htmlComp = this.popup.htmlComp,
    windowPaddingX = this.popup.windowPaddingX,
    windowPaddingY = this.popup.windowPaddingY,
    popupBounds = scout.graphics.offsetBounds(htmlComp.$comp),
    popupMargins = htmlComp.getMargins(),
    popupHeadSize = new scout.Dimension(0, 0),
    $window = this.popup.$container.window(),
    windowSize = new scout.Dimension($window.width(), $window.height());

  if (this.popup.$head) {
    popupHeadSize = scout.graphics.getSize(this.popup.$head);
  }

  maxWidthRight = (windowSize.width - popupBounds.x - windowPaddingX);
  maxWidthLeft = (popupBounds.x + popupHeadSize.width - popupMargins.horizontal() - windowPaddingX);
  maxHeightDown = (windowSize.height - popupBounds.y - windowPaddingY);
  // head height is irrelevant because popup has a margin as height as the header
  maxHeightUp = (popupBounds.y - popupMargins.vertical() - windowPaddingY);

  return new scout.Insets(maxHeightUp, maxWidthRight, maxHeightDown, maxWidthLeft);
};

scout.PopupWithHeadLayout.prototype.preferredLayoutSize = function($container) {
  var htmlComp = this.popup.htmlComp,
    prefSize;

  if (!this.popup.bodyAnimating) {
    var popupStyleBackup = this.popup.$container.attr('style');
    this.popup.$container.css({
      width: 'auto',
      height: 'auto'
    });
    prefSize = scout.graphics.prefSize(this.popup.$body, {
        includeMargin: true
      })
      .add(htmlComp.getInsets());
    this.popup.$container.attr('style', popupStyleBackup);
  } else {
    prefSize = scout.graphics.getSize(this.popup.$body, true);
  }

  if (this.popup._headVisible) {
    var headSize = scout.graphics.getSize(this.popup.$head, true);
    prefSize.width = prefSize.width < headSize.width ? headSize.width : prefSize.width;
  }
  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MobilePopup = function() {
  scout.MobilePopup.parent.call(this);
  this.widget;
  this._addAdapterProperties('widget');
};
scout.inherits(scout.MobilePopup, scout.Popup);

scout.MobilePopup.prototype._init = function(options) {
  scout.MobilePopup.parent.prototype._init.call(this, options);

  var defaults = {
    boundToAnchor: false,
    windowPaddingX: 0,
    windowPaddingY: 0,
    closable: true,
    animateRemoval: true
  };
  $.extend(this, defaults, options);
};

scout.MobilePopup.prototype._createLayout = function() {
  return new scout.MobilePopupLayout(this);
};

/**
 * @override Popup.js
 */
scout.MobilePopup.prototype.prefLocation = function($container, openingDirectionY) {
  var popupSize = this.htmlComp.getPreferredSize(),
    windowHeight = $container.window().height(),
    y = Math.max(windowHeight - popupSize.height, 0);
  return new scout.Point(0, y);
};

scout.MobilePopup.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('popup mobile-popup');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.validateRoot = true;
  this.htmlComp.setLayout(this._createLayout());

  this.$header = this.$container.appendDiv('mobile-popup-header');
  this.$title = this.$header.appendDiv('title');
  this.widget.render(this.$container);
  this.widget.htmlComp.pixelBasedSizing = true;
  this._renderTitle();
  this._renderClosable();
};

scout.MobilePopup.prototype._renderClosable = function() {
  this.$container.toggleClass('closable');
  if (this.closable) {
    if (this.$close) {
      return;
    }
    this.$close = this.$title
      .afterDiv('closer')
      .on('click', this.close.bind(this));
  } else {
    if (!this.$close) {
      return;
    }
    this.$close.remove();
    this.$close = null;
  }
};

scout.MobilePopup.prototype._renderTitle = function() {
  this.$title.textOrNbsp(this.title);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MobilePopupLayout = function(popup) {
  scout.MobilePopupLayout.parent.call(this, popup);
};
scout.inherits(scout.MobilePopupLayout, scout.PopupLayout);

scout.MobilePopupLayout.prototype.layout = function($container) {
  scout.MobilePopupLayout.parent.prototype.layout.call(this, $container);

  var htmlPopup = this.popup.htmlComp,
    popupSize = htmlPopup.getSize(),
    htmlWidget = this.popup.widget.htmlComp,
    widgetSize = 0,
    $header = this.popup.$header,
    headerSize = 0;

  popupSize = popupSize.subtract(htmlPopup.getInsets());
  headerSize = scout.graphics.prefSize($header, {
    includeMargin: true
  });
  scout.graphics.setLocation($header, new scout.Point(0, 0));

  widgetSize = popupSize.clone();
  widgetSize.height -= headerSize.height;
  htmlWidget.setLocation(new scout.Point(0, headerSize.height));
  htmlWidget.setSize(widgetSize.subtract(htmlWidget.getMargins()));

  // The first time it gets layouted, add shown class to be able to animate
  if (!htmlPopup.layouted) {
    htmlPopup.$comp.addClassForAnimation('animate-open');
  }
};

/**
 * @override AbstractLayout.js
 */
scout.MobilePopupLayout.prototype.preferredLayoutSize = function($container) {
  var $window = this.popup.$container.window(),
    windowSize = new scout.Dimension($window.width(), $window.height());

  return windowSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TouchPopup = function() {
  scout.TouchPopup.parent.call(this);

  // the original touch field from the form
  this._touchField;
  // the cloned field from the popup
  this._field;
  // the widget placed below the field
  this._widget;
  this._$widgetContainer;
  this._widgetContainerHtmlComp;
};
scout.inherits(scout.TouchPopup, scout.Popup);

scout.TouchPopup.TOP_MARGIN = 45;

scout.TouchPopup.prototype._init = function(options) {
  scout.TouchPopup.parent.prototype._init.call(this, options);
  this._touchField = options.field;

  // clone original touch field
  // original and clone both point to the same popup instance
  this._field = this._touchField.clone(this._fieldOverrides());
  this._initWidget(options);
};

scout.TouchPopup.prototype._fieldOverrides = function() {
  return {
    parent: this,
    popup: this,
    labelPosition: scout.FormField.LABEL_POSITION_ON_FIELD,
    statusVisible: false,
    embedded: true,
    touch: false
  };
};

scout.TouchPopup.prototype._initWidget = function(options) {
  // NOP
};

scout.TouchPopup.prototype._createLayout = function() {
  return new scout.TouchPopupLayout(this);
};

/**
 * @override Popup.js
 */
scout.TouchPopup.prototype.prefLocation = function($container, openingDirectionY) {
  var popupSize = this.htmlComp.getPreferredSize(),
    windowWidth = $container.window().width(),
    x = Math.max(this.windowPaddingX, (windowWidth - popupSize.width) / 2);
  return new scout.Point(x, scout.TouchPopup.TOP_MARGIN);
};

scout.TouchPopup.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('touch-popup');

  this._$widgetContainer = this.$container.appendDiv('touch-popup-widget-container');
  this._widgetContainerHtmlComp = scout.HtmlComponent.install(this._$widgetContainer, this.session);
  this._widgetContainerHtmlComp.setLayout(new scout.SingleLayout());

  // field may render something into the widget container -> render after widget container and move to correct place
  this._field.render(this.$container);

  // Move to top
  this._field.$container.insertBefore(this._$widgetContainer);
  this._field.$container.addClass('touch-popup-field');

  if (this._widget) {
    this._widget.render(this._$widgetContainer);
  }

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.validateRoot = true;
  this.htmlComp.setLayout(this._createLayout());
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TouchPopupLayout = function(popup) {
  scout.TouchPopupLayout.parent.call(this, popup);
};
scout.inherits(scout.TouchPopupLayout, scout.PopupLayout);

scout.TouchPopupLayout.prototype.layout = function($container) {
  scout.TouchPopupLayout.parent.prototype.layout.call(this, $container);

  var popupSize = this.popup.htmlComp.getSize(),
    field = this.popup._field,
    fieldMargins = new scout.Insets(4, 6, 5, 4),
    fieldHeight = field.htmlComp.getPreferredSize().height,
    fieldWidth = popupSize.width - fieldMargins.horizontal(),
    widgetVerticalOffset = fieldHeight + fieldMargins.vertical();

  field.htmlComp.setBounds(new scout.Rectangle(fieldMargins.left, fieldMargins.top, fieldWidth, fieldHeight));
  this.popup._widgetContainerHtmlComp.setBounds(
    new scout.Rectangle(0, widgetVerticalOffset, popupSize.width, popupSize.height - widgetVerticalOffset));
};

/**
 * @override AbstractLayout.js
 */
scout.TouchPopupLayout.prototype.preferredLayoutSize = function($container) {
  var popupWidth = scout.HtmlEnvironment.formColumnWidth,
    popupHeight = scout.HtmlEnvironment.formRowHeight * 15;

  return new scout.Dimension(popupWidth, popupHeight);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DatePicker = function() {
  scout.DatePicker.parent.call(this);

  // Preselected date can only be set if selectedDate is null. The preselected date is rendered differently, but
  // has no function otherwise. (It is used to indicate the day that will be selected when the user presses
  // the UP or DOWN key while no date is selected.)
  this.preselectedDate;
  this.selectedDate;
  this.dateFormat;
  this.viewDate;
  this.allowedDates;
  this.$container;
  this.$currentBox;
  this.$scrollable;
  this._scrollableLeft;
};
scout.inherits(scout.DatePicker, scout.Widget);

scout.DatePicker.prototype._init = function(options) {
  scout.DatePicker.parent.prototype._init.call(this, options);
  options = options || {};
  this.dateFormat = options.dateFormat;
  this.allowedDates = options.allowedDates;
};

scout.DatePicker.prototype._render = function($parent) {
  this.$container = $parent
    .appendDiv('date-picker')
    .on('swipe', this._onSwipe.bind(this));

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.DatePickerLayout(this));

  this._$header = this._append$Header();
  this._$header
    .find('.date-picker-left-y, .date-picker-left-m, .date-picker-right-m, .date-picker-right-y')
    .mousedown(this._onNavigationMouseDown.bind(this));

  this.$container.appendDiv('date-picker-separator');
  this.$scrollable = this.$container.appendDiv('date-picker-scrollable');
  this._scrollableTop = this.$scrollable.position().top;
  this._scrollableLeft = this.$scrollable.position().left;
  // Fix the position of the scrollable in order to do proper scrollable shifting (see _appendAnimated)
  this.$scrollable.css({
    'position': 'absolute',
    left: this._scrollableLeft,
    top: this._scrollableTop
  });
};

scout.DatePicker.prototype.preselectDate = function(date, animated) {
  this.preselectedDate = date;
  this.show(date, null, animated);
};

scout.DatePicker.prototype.selectDate = function(date, animated) {
  this.show(null, date, animated);
};

scout.DatePicker.prototype.show = function(viewDate, selectedDate, animated) {
  var viewDateDiff = 0;

  this.selectedDate = selectedDate;
  if (this.selectedDate) {
    // Clear preselection when a date is selected
    this.preselectedDate = null;
  }

  viewDate = viewDate || this.selectedDate || new Date();
  if (this.viewDate) {
    viewDateDiff = scout.dates.compareMonths(viewDate, this.viewDate);
  }
  this.viewDate = viewDate;

  this._updateHeader(viewDate);

  var $box = this._build$DateBox();
  $box[0].addEventListener('mousewheel', this._onMouseWheel.bind(this), false);

  if (animated && this.$currentBox && viewDateDiff) {
    this._appendAnimated(viewDateDiff, $box);
  } else {
    // Just replace the current month box (new day in the same month has been chosen)
    if (this.$currentBox) {
      this.$currentBox.remove();
    }
    $box.appendTo(this.$scrollable);
    this.htmlComp.revalidateLayout();

  }
  this.$currentBox = $box;
};

scout.DatePicker.prototype._appendAnimated = function(viewDateDiff, $box) {
  var $currentBox = this.$currentBox;
  var newLeft = 0,
    that = this;
  var monthBoxCount = this.$scrollable.find('.date-picker-month').length + 1;

  this.htmlComp.layout._layoutMonth($box);

  this._boxWidth = $box.width();
  var scrollableWidth = monthBoxCount * this._boxWidth;

  // Fix the size of the boxes
  $currentBox
    .width(this._boxWidth)
    .height(this._boxHeight);
  $box
    .width(this._boxWidth)
    .height(this._boxHeight);

  this.$scrollable.width(scrollableWidth);
  if (viewDateDiff > 0) {
    // New view date is larger -> shift left
    $box.appendTo(this.$scrollable);
    newLeft = this._scrollableLeft - (scrollableWidth - this._boxWidth);
  } else {
    // New view date is smaller -> shift right
    this.$scrollable.cssLeft(this._scrollableLeft - this._boxWidth);
    $box.prependTo(this.$scrollable);
    newLeft = this._scrollableLeft;
  }

  // Animate
  // At first: stop existing animation when shifting multiple dates in a row (e.g. with mouse wheel)
  this.$scrollable.
  stop(true).
  animate({
    left: newLeft
  }, 300, function() {
    // Remove every month box beside the new one
    // Its important to use that.$currentBox because $box may already be removed
    // if a new day in the current month has been chosen while the animation is in progress (e.g. by holding down key)
    that.$currentBox.siblings('.date-picker-month').remove();

    // Reset scrollable settings
    that.$scrollable
      .cssLeft(that._scrollableLeft)
      .width(that._boxWidth);
  });
};

scout.DatePicker.prototype._onNavigationMouseDown = function(event) {
  var $target = $(event.currentTarget);
  var diff = $target.data('shift');
  this.shiftViewDate(0, diff, 0);
};

scout.DatePicker.prototype._onDayClick = function(event) {
  var $target = $(event.currentTarget);
  var date = $target.data('date');
  this.trigger('dateSelect', {
    date: date
  });
};

scout.DatePicker.prototype._onSwipe = function(event) {
  var direction = event.swipestop.coords[0] - event.swipestart.coords[0] >= 0 ? -1 : 1;
  this.shiftViewDate(0, direction, 0);
};

scout.DatePicker.prototype._onMouseWheel = function(event) {
  event = event || this.$container.window(true).event;
  var wheelData = event.wheelDelta ? event.wheelDelta / 10 : -event.detail * 3;
  var diff = (wheelData >= 0 ? -1 : 1);
  this.shiftViewDate(0, diff, 0);
  event.preventDefault();
};

scout.DatePicker.prototype.shiftViewDate = function(years, months, days) {
  var date = this.viewDate;

  date = scout.dates.shift(date, years, months, days);
  this.show(date, null, true);
};

scout.DatePicker.prototype.shiftSelectedDate = function(years, months, days) {
  var date = this.preselectedDate;

  if (this.selectedDate) {
    if (this.allowedDates) {
      date = this._findNextAllowedDate(years, months, days);
    } else {
      date = scout.dates.shift(this.selectedDate, years, months, days);
    }
  }

  if (!date) {
    return; // do nothing when no date was found
  }

  this.trigger('dateSelect', {
    date: date,
    shifting: true
  });
  this.selectDate(date, true);
};

scout.DatePicker.prototype._findNextAllowedDate = function(years, months, days) {
  var i, date,
    sum = years + months + days,
    dir = sum > 0 ? 1 : -1,
    now = this.selectedDate || scout.dates.trunc(new Date());

  // if we shift by year or month, shift the 'now' date and then use that date as starting point
  // to find the next allowed date.
  if (years !== 0) {
    now = scout.dates.shift(now, years, 0, 0);
  } else if (months !== 0) {
    now = scout.dates.shift(now, 0, months, 0);
  }

  if (dir === 1) { // find next allowed date, starting from currently selected date
    for (i = 0; i < this.allowedDates.length; i++) {
      date = this.allowedDates[i];
      if (scout.dates.compare(now, date) < 0) {
        return date;
      }
    }
  } else if (dir === -1) { // find previous allowed date, starting from currently selected date
    for (i = this.allowedDates.length - 1; i >= 0; i--) {
      date = this.allowedDates[i];
      if (scout.dates.compare(now, date) > 0) {
        return date;
      }
    }
  }

  return null;
};

scout.DatePicker.prototype._build$DateBox = function() {
  var cl, i, day, dayEnabled, dayInMonth, $day,
    now = new Date(),
    start = new Date(this.viewDate),
    weekdays = this.dateFormat.symbols.weekdaysShortOrdered;

  var $box = this.$container
    .makeDiv('date-picker-month')
    .data('viewDate', this.viewDate);

  // Create weekday header
  weekdays.forEach(function(weekday) {
    $box.appendDiv('date-picker-weekday', weekday);
  });

  // Find start date (-1)
  for (var offset = 0; offset < 42; offset++) {
    start.setDate(start.getDate() - 1);
    var diff = new Date(start.getYear(), this.viewDate.getMonth(), 0).getDate() - start.getDate();
    if ((start.getDay() === 0) && (start.getMonth() !== this.viewDate.getMonth()) && (diff > 1)) {
      break;
    }
  }

  // Create days
  for (i = 0; i < 42; i++) {
    start.setDate(start.getDate() + 1);
    dayInMonth = start.getDate();

    if ((start.getDay() === 6) || (start.getDay() === 0)) {
      cl = (start.getMonth() !== this.viewDate.getMonth() ? ' date-picker-out-weekend' : ' date-picker-weekend');
    } else {
      cl = (start.getMonth() !== this.viewDate.getMonth() ? ' date-picker-out' : '');
    }

    if (scout.dates.isSameDay(start, now)) {
      cl += ' date-picker-now';
    }

    if (scout.dates.isSameDay(start, this.preselectedDate)) {
      cl += ' date-picker-preselected';
    } else if (scout.dates.isSameDay(start, this.selectedDate)) {
      cl += ' date-picker-selected';
    }

    dayEnabled = this._isDateAllowed(start);
    if (!dayEnabled) {
      cl += ' date-picker-disabled';
    }

    day = (dayInMonth <= 9 ? '0' + dayInMonth : dayInMonth);
    $day = $box
      .appendDiv('date-picker-day' + cl, day)
      .data('dayInMonth', dayInMonth)
      .data('date', new Date(start));

    if (dayEnabled) {
      $day.on('click', this._onDayClick.bind(this));
    }
  }

  return $box;
};

scout.DatePicker.prototype._isDateAllowed = function(date) {
  // when allowedDates is empty or not set, any date is allowed
  if (!this.allowedDates || this.allowedDates.length === 0) {
    return true;
  }
  // when allowedDates is set, only dates contained in this array are allowed
  var allowedDateAsTimestamp,
    dateAsTimestamp = date.getTime();
  return this.allowedDates.some(function(allowedDate) {
    allowedDateAsTimestamp = allowedDate.getTime();
    return allowedDateAsTimestamp === dateAsTimestamp;
  });
};

scout.DatePicker.prototype._append$Header = function() {
  var headerHtml =
    '<div class="date-picker-header">' +
    '  <div class="date-picker-left-y" data-shift="-12"></div>' +
    '  <div class="date-picker-left-m" data-shift="-1"></div>' +
    '  <div class="date-picker-right-y" data-shift="12"></div>' +
    '  <div class="date-picker-right-m" data-shift="1"></div>' +
    '  <div class="date-picker-header-month"></div>' +
    '</div>';
  return this.$container
    .appendElement(headerHtml)
    .toggleClass('touch', scout.device.supportsTouch());
};

scout.DatePicker.prototype._updateHeader = function(viewDate) {
  this._$header.find('.date-picker-header-month').text(this._createHeaderText(viewDate));
};

scout.DatePicker.prototype._createHeaderText = function(viewDate) {
  var months = this.dateFormat.symbols.months;
  return months[viewDate.getMonth()] + ' ' + viewDate.getFullYear();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DatePickerLayout = function(datePicker) {
  scout.DatePickerLayout.parent.call(this);
  this._datePicker = datePicker;
  this._cache = {
    monthWidth: 0,
    cssDaySize: 0,
    dayMarginHoriz: 0,
    dayMarginVert: 0,
    dayPaddingTop: 0
  };
};
scout.inherits(scout.DatePickerLayout, scout.AbstractLayout);

scout.DatePickerLayout.COLUMNS = 7;
scout.DatePickerLayout.ROWS = 6; // rows excl. weekday row
scout.DatePickerLayout.DAY_SIZE = 26; // size of day (exkl. padding and margin) is always fix - margin and padding is variable

scout.DatePickerLayout.prototype.layout = function($container) {
  var
  // DOM elements
    $header = $container.find('.date-picker-header'),
    $scrollable = $container.find('.date-picker-scrollable'),
    $month = $container.find('.date-picker-month'),
    // Calculate dimensions
    htmlContainer = scout.HtmlComponent.get($container),
    containerSize = htmlContainer.getSize().subtract(htmlContainer.getInsets()),
    // Header height is also used as height for weekdays (defined by CSS)
    headerHeight = scout.graphics.getSize($header, true).height + 1, // + 1 for separator-line
    scrollableInsets = scout.graphics.getInsets($scrollable),
    scrollableSize = containerSize.subtract(scrollableInsets),
    // picker and all day-elements must be quadratic,
    // otherwise round selection would be an ellipse
    monthHeight = containerSize.height - headerHeight,
    dayWidth = Math.floor(scrollableSize.width / scout.DatePickerLayout.COLUMNS),
    dayHeight = Math.floor((monthHeight - headerHeight) / scout.DatePickerLayout.ROWS),
    dayMarginHoriz = Math.max(0, Math.floor(dayWidth - scout.DatePickerLayout.DAY_SIZE) / 2),
    dayMarginVert  = Math.max(0, Math.floor(dayHeight - scout.DatePickerLayout.DAY_SIZE) / 2),
    monthWidth = dayWidth * scout.DatePickerLayout.COLUMNS,
    monthMarginHoriz = Math.max(0, Math.floor((scrollableSize.width - monthWidth) / 2)),
    // measure first day in calendar, so we know how we must set
    // paddings and margins for each day
    dayTextSize = this._measureDaySize($month),
    cssDaySize = new scout.Dimension(
        dayWidth - 2 * dayMarginHoriz,
        dayHeight - 2 * dayMarginVert),
    dayPaddingTop = Math.max(0, (cssDaySize.height - dayTextSize.height) / 2);

  // we set padding instead of width, because background-color and bottom-border
  // should always use 100% of the popup width
  // we must add the horiz. padding from the scrollable to the header, so the
  // header is aligned
  $header
    .css('padding-left', monthMarginHoriz + scrollableInsets.left + dayMarginHoriz)
    .css('padding-right', monthMarginHoriz + scrollableInsets.right + dayMarginHoriz);

  // only set left margin to center the scrollable
  $scrollable
    .cssWidth(monthWidth + scrollableInsets.horizontal())
    .cssHeight(monthHeight + scrollableInsets.vertical())
    .css('margin-left', monthMarginHoriz);

  // store results in cache (so the can be access during animation, without recalculating the whole layout)
  this._cache.monthWidth = monthWidth;
  this._cache.cssDaySize = cssDaySize;
  this._cache.dayMarginHoriz = dayMarginHoriz;
  this._cache.dayMarginVert = dayMarginVert;
  this._cache.dayPaddingTop = dayPaddingTop;

  this._layoutMonth($month);
};

/**
 * Adds a temporary day DIV (without width, height, padding or margin) to the $month element,
 * measures the size and removes the DIV immediately after measurement.
 */
scout.DatePickerLayout.prototype._measureDaySize = function($month) {
  var $tmpDay = $month
      .appendDiv('date-picker-day')
      .text('30'), // because the string 30 is wider than 11
    size = scout.graphics.getSize($tmpDay);
  $tmpDay.remove();
  return size;
};

/**
 * This functions is used to layout a month separately from the rest of the date-picker container
 * it is used to layout the month box during the animation.
 */
scout.DatePickerLayout.prototype._layoutMonth = function($month) {
  var cache = this._cache;

  // month: only set width, height is given by the popup-size
  $month.width(cache.monthWidth);

  // layout weekdays and days
  $month.find('.date-picker-weekday, .date-picker-day').each(function() {
    var $element = $(this),
      dayInMonth = $element.data('dayInMonth');

    if ($element.hasClass('date-picker-day')) {
      // days
      $element
        .css('margin', cache.dayMarginVert + 'px ' + cache.dayMarginHoriz + 'px')
        .css('padding-top', cache.dayPaddingTop)
        .cssWidth(cache.cssDaySize.width)
        .cssHeight(cache.cssDaySize.height);
      // helps to center days between 10 and 19 nicer (especially when website is zoomed > 100%)
      if (dayInMonth > 9 && dayInMonth < 20) {
        $element.css('padding-right', 2);
      }
    } else {
      // weekdays: only set width and horiz. margins, the rest is defined by CSS
      $element
        .css('margin', '0 ' + cache.dayMarginHoriz + 'px')
        .cssWidth(cache.cssDaySize.width);
    }
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DatePickerPopup = function() {
  scout.DatePickerPopup.parent.call(this);
};
scout.inherits(scout.DatePickerPopup, scout.Popup);

scout.DatePickerPopup.prototype._init = function(options) {
  options.scrollType = options.scrollType || 'layoutAndPosition';
  options.installFocusContext = false;
  scout.DatePickerPopup.parent.prototype._init.call(this, options);

  this.picker = scout.create('DatePicker', {
    parent: this,
    dateFormat: options.dateFormat,
    allowedDates: options.allowedDates
  });
};

scout.DatePickerPopup.prototype._render = function($parent) {
  this.picker.render($parent);
  this.$container = this.picker.$container;
  this.$container.addClass('date-picker-popup');
  this.htmlComp = this.picker.htmlComp;
  this.htmlComp.validateRoot = true;
};

/**
 * @implements DatePickerPopup
 */
scout.DatePickerPopup.prototype.getDatePicker = function() {
  return this.picker;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DatePickerTouchPopup = function() {
  scout.DatePickerTouchPopup.parent.call(this);
};
scout.inherits(scout.DatePickerTouchPopup, scout.TouchPopup);

scout.DatePickerTouchPopup.prototype._init = function(options) {
  scout.DatePickerTouchPopup.parent.prototype._init.call(this, options);
  this._field.on('displayTextChanged', this._onFieldDisplayTextChanged.bind(this));
  this._field.on('timestampChanged', this._onFieldTimestampChanged.bind(this));
};

/**
 * @override TouchPopup.js
 */
scout.DatePickerTouchPopup.prototype._initWidget = function(options) {
  this._widget = scout.create('DatePicker', {
    parent: this,
    dateFormat: options.dateFormat
  });
};

/**
 * @implements DatePickerPopup
 */
scout.DatePickerTouchPopup.prototype.getDatePicker = function() {
  return this._widget;
};

scout.DatePickerTouchPopup.prototype._onFieldDisplayTextChanged = function(event) {
  // Delegate to original field
  this._touchField.dateDisplayText = this._field.dateDisplayText;
  this._touchField.timeDisplayText = this._field.timeDisplayText;
  this._touchField.setDisplayText(event.displayText);
};

scout.DatePickerTouchPopup.prototype._onFieldTimestampChanged = function(event) {
  // Delegate to original field
  this._touchField.timestamp = this._field.timestamp;
  this._touchField.timestampAsDate = this._field.timestampAsDate;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.menus = {

  /**
   * @memberOf scout.menus
   */
  CLOSING_EVENTS: 'mousedown.contextMenu keydown.contextMenu', //FIXME cgu: keydown/keyup is a bad idea -> interferes with ctrl click on table to multi select rows

  filterAccordingToSelection: function(prefix, selectionLength, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {
    var allowedTypes = [];

    if (destination === scout.MenuDestinations.MENU_BAR) {
      allowedTypes = [prefix + '.EmptySpace', prefix + '.SingleSelection', prefix + '.MultiSelection'];
    } else if (destination === scout.MenuDestinations.CONTEXT_MENU) {
      allowedTypes = [prefix + '.SingleSelection', prefix + '.MultiSelection'];
    } else if (destination === scout.MenuDestinations.HEADER) {
      allowedTypes = [prefix + '.Header'];
    }

    if (allowedTypes.indexOf(prefix + '.SingleSelection') > -1 && selectionLength !== 1) {
      scout.arrays.remove(allowedTypes, prefix + '.SingleSelection');
    }
    if (allowedTypes.indexOf(prefix + '.MultiSelection') > -1 && selectionLength <= 1) {
      scout.arrays.remove(allowedTypes, prefix + '.MultiSelection');
    }
    notAllowedTypes = scout.arrays.ensure(notAllowedTypes);
    var fixedNotAllowedTypes = [];
    //ensure prefix
    prefix = prefix + '.';
    notAllowedTypes.forEach(function(type) {
      if (type.slice(0, prefix.length) !== prefix) {
        type = prefix + type;
      }
      fixedNotAllowedTypes.push(type);
    }, this);
    return scout.menus.filter(menus, allowedTypes, onlyVisible, enableDisableKeyStroke, fixedNotAllowedTypes);
  },

  /**
   * Filters menus that don't match the given types, or in other words: only menus with the given types are returned
   * from this method. The visible state is only checked if the parameter onlyVisible is set to true. Otherwise invisible items are returned and added to the
   * menu-bar DOM (invisible, however). They may change their visible state later. If there are any types in notAllowedTypes each menu is checked also against
   * these types and if they are matching the menu is filtered.
   */
  filter: function(menus, types, onlyVisible, enableDisableKeyStrokes, notAllowedTypes) {
    if (!menus) {
      return;
    }
    types = scout.arrays.ensure(types);
    notAllowedTypes = scout.arrays.ensure(notAllowedTypes);

    var filteredMenus = [],
      separatorCount = 0;

    menus.forEach(function(menu) {
      var childMenus = menu.childActions;
      if (childMenus.length > 0) {
        childMenus = scout.menus.filter(childMenus, types, onlyVisible, enableDisableKeyStrokes, notAllowedTypes);
        if (childMenus.length === 0) {
          scout.menus._enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);
          return;
        }
      } // Don't check the menu type for a group
      else if (!scout.menus._checkType(menu, types) || (notAllowedTypes.length !== 0 && scout.menus._checkType(menu, notAllowedTypes))) {
        scout.menus._enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);
        return;
      }

      if (onlyVisible && !menu.visible) {
        scout.menus._enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, true);
        return;
      }
      if (menu.separator) {
        separatorCount++;
      }
      scout.menus._enableDisableMenuKeyStroke(menu, enableDisableKeyStrokes, false);
      filteredMenus.push(menu);
    });

    // Ignore menus with only separators
    if (separatorCount === filteredMenus.length) {
      return [];
    }
    return filteredMenus;
  },

  checkType: function(menu, types) {
    types = scout.arrays.ensure(types);
    if (menu.childActions.length > 0) {
      var childMenus = scout.menus.filter(menu.childActions, types);
      return (childMenus.length > 0);
    }
    return scout.menus._checkType(menu, types);
  },

  _enableDisableMenuKeyStroke: function(menu, activated, exclude) {
    if (activated) {
      menu.excludedByFilter = exclude;
    }
  },

  /**
   * Checks the type of a menu. Don't use this for menu groups.
   */
  _checkType: function(menu, types) {
    if (!types || types.length === 0) {
      return false;
    }
    if (!menu.menuTypes) {
      return false;
    }
    for (var j = 0; j < types.length; j++) {
      if (menu.menuTypes.indexOf(types[j]) > -1) {
        return true;
      }
    }
  },

  showContextMenuWithWait: function(session, func) {
    var argumentsArray = Array.prototype.slice.call(arguments);
    argumentsArray.shift(); // remove argument session
    argumentsArray.shift(); // remove argument func, remainder: all other arguments

    if (session.areRequestsPending() || session.areEventsQueued()) {
      session.listen().done(onEventsProcessed);
    } else {
      func.apply(this, argumentsArray);
    }

    function onEventsProcessed() {
      func.apply(this, argumentsArray);
    }
  },

  createEllipsisMenu: function(options) {
    var defaults = {
      iconId: scout.icons.ELLIPSIS_V,
      tabbable: false
    };
    options = $.extend({}, defaults, options);
    return scout.create('Menu', options);
  },

  moveMenuIntoEllipsis: function(menu, ellipsis) {
    menu.remove();
    menu.overflow = true;
    menu.overflowMenu = ellipsis;
    ellipsis.childActions.unshift(menu); // add as first element
  },

  removeMenuFromEllipsis: function(menu, $parent) {
    menu.overflow = false;
    menu.overflowMenu = null;
    if (!menu.rendered) {
      menu.render($parent);
    }
  }
};

scout.MenuDestinations = {
  MENU_BAR: 1,
  CONTEXT_MENU: 2,
  HEADER: 3
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Menu = function() {
  scout.Menu.parent.call(this);
  this._addAdapterProperties('childActions');

  this.defaultMenu = false;
  this.separator = false;
  this.childActions = [];
  this.menuTypes = [];
  this.popup;
  this.excludedByFilter = false;
  this.subMenuIconVisible = true;

  /**
   * This property is set if this is a subMenu. The property is set when this submenu is rendered.
   */
  this.parentMenu;

  /**
   * This property is true when the menu instance was moved into a overflow-menu
   * when there's not enough space on the screen (see MenuBarLayout.js). When set
   * to true, button style menus must be displayed as regular menus.
   */
  this.overflow = false;

  this._addCloneProperties(['defaultMenu', 'menuTypes', 'overflow', 'separator']);
};
scout.inherits(scout.Menu, scout.Action);

/**
 * @override
 */
scout.Menu.prototype._initKeyStrokeContext = function() {
  scout.Menu.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke(new scout.MenuExecKeyStroke(this));
};

scout.Menu.prototype._render = function($parent) {
  if (this.separator) {
    this._renderSeparator($parent);
  } else {
    this._renderItem($parent);
  }
  this.$container.unfocusable();
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
};

scout.Menu.prototype._remove = function() {
  scout.Menu.parent.prototype._remove.call(this);
  this.$submenuIcon = null;
  this.$subMenuBody = null;
};

scout.Menu.prototype._renderSeparator = function($parent) {
  this.$container = $parent.appendDiv('menu-separator');
};

scout.Menu.prototype._renderItem = function($parent) {
  this.$container = $parent.appendDiv('menu-item');
  if (this.uiCssClass) {
    this.$container.addClass(this.uiCssClass);
  }

  var mouseEventHandler = this._onMouseEvent.bind(this);
  this.$container
    .on('mousedown', mouseEventHandler)
    .on('contextmenu', mouseEventHandler)
    .on('click', mouseEventHandler);
  if (this.childActions.length > 0 && this.text && this.subMenuIconVisible) {
    this.$submenuIcon = this.$container.appendSpan('submenu-icon');
  }

  // when menus with button style are displayed in a overflow-menu,
  // render as regular menu, ignore button styles.
  if (this.isButton() && !this.overflow) {
    this.$container.addClass('menu-button');
  }
};

scout.Menu.prototype._renderSelected = function() {
  if (!this._doActionTogglesSubMenu()) {
    scout.Menu.parent.prototype._renderSelected.call(this);
  }
  if (this.selected) {
    if (this._doActionTogglesSubMenu()) {
      this._renderSubMenuItems(this, this.childActions);
    } else if (this._doActionTogglesPopup()) {
      this._openPopup();
    }
  } else {
    if (this._doActionTogglesSubMenu() && this.rendered) {
      this._removeSubMenuItems(this);
    } else {
      this._closePopup();
      this._closeSubMenues();
    }
  }
};

scout.Menu.prototype._closeSubMenues = function() {
  this.childActions.forEach(function(menu) {
    if (menu._doActionTogglesPopup()) {
      menu._closeSubMenues();
      menu.setSelected(false);
    }
  });
};

scout.Menu.prototype._removeSubMenuItems = function(parentMenu) {
  if (this.parent instanceof scout.ContextMenuPopup) {
    this.parent.removeSubMenuItems(parentMenu, true);
  } else if (this.parent instanceof scout.Menu) {
    this.parent._removeSubMenuItems(parentMenu);
  }
};

scout.Menu.prototype._renderSubMenuItems = function(parentMenu, menus) {
  if (this.parent instanceof scout.ContextMenuPopup) {
    this.parent.renderSubMenuItems(parentMenu, menus, true);
  } else if (this.parent instanceof scout.Menu) {
    this.parent._renderSubMenuItems(parentMenu, menus);
  }
};

scout.Menu.prototype._doActionTogglesSubMenu = function() {
  return this.childActions.length > 0 && (this.parent instanceof scout.ContextMenuPopup || this.parent instanceof scout.Menu);
};

scout.Menu.prototype._getSubMenuLevel = function() {
  if (this.parent instanceof scout.ContextMenuPopup) {
    return 0;
  }
  return scout.Menu.parent.prototype._getSubMenuLevel.call(this) + 1;
};

scout.Menu.prototype._onMouseEvent = function(event) {
  if (event.which !== 1) {
    return; // Other button than left mouse button --> nop
  }

  // If menu has childActions, a popup should be rendered on click. To create
  // the impression of a faster UI, open the popup already on 'mousedown', not
  // on 'click'. All other actions are handled on 'click'.
  if (event.type === 'mousedown' && this._doActionTogglesPopup()) {
    this.doAction();
  } else if ((event.type === 'click' || event.type === 'contextmenu') && !this._doActionTogglesPopup()) {
    this.doAction();
  }
};

/**
 * May be overridden if the criteria to open a popup differs
 */
scout.Menu.prototype._doActionTogglesPopup = function() {
  return this.childActions.length > 0;
};

/**
 * Only render child actions if the sub-menu popup is open.
 */
scout.Menu.prototype._renderChildActions = function() {
  if (scout.objects.optProperty(this.popup, 'rendered')) {
    var $popup = this.popup.$container;
    this.childActions.forEach(function(menu) {
      menu.render($popup);
    });
  }
};

scout.Menu.prototype._renderText = function(text) {
  scout.Menu.parent.prototype._renderText.call(this, text);
  // Ensure submenu-icon is the last element in the DOM
  if (this.$submenuIcon) {
    this.$submenuIcon.appendTo(this.$container);
  }
  this._updateIconAndTextStyle();
  this.invalidateLayoutTree();
};

scout.Menu.prototype._renderIconId = function() {
  scout.Menu.parent.prototype._renderIconId.call(this);
  this._updateIconAndTextStyle();
  this.invalidateLayoutTree();
};

/**
 * @override
 */
scout.Menu.prototype._renderVisible = function() {
  scout.Menu.parent.prototype._renderVisible.call(this);
  this.invalidateLayoutTree();
};

scout.Menu.prototype.isTabTarget = function() {
  return this.enabled && this.visible && (this.isButton() || !this.separator);
};

scout.Menu.prototype._updateIconAndTextStyle = function() {
  var hasText = scout.strings.hasText(this.text) && this.textVisible;
  var hasTextAndIcon = !!(hasText && this.iconId);
  this.$container.toggleClass('menu-textandicon', hasTextAndIcon);
  this.$container.toggleClass('menu-icononly', !hasText);
};

scout.Menu.prototype._closePopup = function() {
  if (this.popup) {
    this.popup.close();
  }
};

scout.Menu.prototype._openPopup = function() {
  if (this.popup) {
    // already open
    return;
  }
  this.popup = this._createPopup();
  this.popup.open();
  this.popup.on('remove', function(event) {
    this.popup = null;
  }.bind(this));
  // Reason for separating remove and close event:
  // Remove may be called if parent (menubar) gets removed or rebuilt.
  // In that case, we do not want to change the selected state because after rebuilding the popup should still be open
  // In every other case the state of the menu needs to be reseted if the popup closes
  this.popup.on('close', function(event) {
    this.setSelected(false);
  }.bind(this));

  if (this.uiCssClass) {
    this.popup.$container.addClass(this.uiCssClass);
  }
};

scout.Menu.prototype._createPopup = function(event) {
  var options = {
    parent: this,
    menu: this,
    ignoreEvent: event,
    openingDirectionX: this.popupOpeningDirectionX,
    openingDirectionY: this.popupOpeningDirectionY
  };

  if (this.parent._filterMenusHandler) {
    options.menuFilter = function(menus, destination, onlyVisible, enableDisableKeyStroke) {
      return this.parent._filterMenusHandler(menus, scout.MenuDestinations.MENU_BAR, onlyVisible, enableDisableKeyStroke);
    }.bind(this);
  }
  return scout.create('MenuBarPopup', options);
};

scout.Menu.prototype._createActionKeyStroke = function() {
  return new scout.MenuKeyStroke(this);
};

scout.Menu.prototype.isToggleAction = function() {
  return this.childActions.length > 0 || this.toggleAction;
};

scout.Menu.prototype.isButton = function() {
  return scout.Action.ActionStyle.BUTTON === this.actionStyle;
};

scout.Menu.prototype.setSelected = function(selected) {
  if (selected === this.selected) {
    return;
  }
  scout.Menu.parent.prototype.setSelected.call(this, selected);
  if (!this._doActionTogglesSubMenu() && !this._doActionTogglesPopup()) {
    return;
  }
  // If menu toggles a popup and is in an ellipsis menu which is not selected it needs a special treatment
  if (this.overflowMenu && !this.overflowMenu.selected) {
    this._handleSelectedInEllipsis();
  }
};

scout.Menu.prototype._handleSelectedInEllipsis = function() {
  // If the selection toggles a popup, open the ellipsis menu as well, otherwise the popup would not be shown
  if (this.selected) {
    this.overflowMenu.setSelected(true);
  }
};

scout.Menu.prototype.clone = function(model) {
  var clone = scout.Menu.parent.prototype.clone.call(this, model);
  var childClones = [];
  this.childActions.forEach(function(child) {
    var childClone = child.clone({parent: clone});
    childClones.push(childClone);
  });
  clone.childActions = childClones;
  return clone;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuAdapter = function() {
  scout.MenuAdapter.parent.call(this);
  this._addAdapterProperties('childActions');
};
scout.inherits(scout.MenuAdapter, scout.ActionAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuKeyStroke = function(action) {
  scout.MenuKeyStroke.parent.call(this, action);
};
scout.inherits(scout.MenuKeyStroke, scout.ActionKeyStroke);

scout.MenuKeyStroke.prototype._isEnabled = function() {
  if (this.field.excludedByFilter) {
    return false;
  } else {
    return scout.MenuKeyStroke.parent.prototype._isEnabled.call(this);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuExecKeyStroke = function(menu) {
  scout.MenuExecKeyStroke.parent.call(this);
  this.field = menu;
  this.which = [scout.keys.SPACE, scout.keys.ENTER];
  this.stopPropagation = true;

  this.renderingHints.offset = 16;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.field.$container;
  }.bind(this);
};
scout.inherits(scout.MenuExecKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.MenuExecKeyStroke.prototype.handle = function(event) {
  this.field.doAction();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuItemsOrder = function(session, objectType) {
  this.session = session;
  this.objectType = objectType;
  this.emptySpaceTypes = ['EmptySpace'];
  this.selectionTypes = ['SingleSelection', 'MultiSelection'];
};

scout.MenuItemsOrder.prototype.order = function(items) {
  var buttons = [],
    emptySpaceItems = [],
    selectionItems = [],
    rightItems = [];

  var isEmptyspaceMenuVisible = false,
  isSelectionMenuVisible =false;
  items.forEach(function(item) {
    // skip separators added dynamically by this class
    if (item.createdBy === this) {
      return;
    }
    if (item.isButton()) {
      buttons.push(item);
    } else if (item.horizontalAlignment === 1) {
      rightItems.push(item);
    } else if (scout.menus.checkType(item, this._menuTypes(this.emptySpaceTypes))) {
      if (item.visible) {
        isEmptyspaceMenuVisible = true;
      }
      emptySpaceItems.push(item);
    } else if (scout.menus.checkType(item, this._menuTypes(this.selectionTypes))) {
      if (item.visible) {
        isSelectionMenuVisible = true;
      }
      selectionItems.push(item);
    }
  }, this);

  // add fixed separator between emptySpace and selection
  if (isEmptyspaceMenuVisible && isSelectionMenuVisible) {
    emptySpaceItems.push(this._createSeparator());
  }

  return {
    left: buttons.concat(emptySpaceItems, selectionItems),
    right: rightItems
  };
};

scout.MenuItemsOrder.prototype._menuTypes = function(types) {
  var i, menuTypes = [];
  types = types || [];
  for (i = 0; i < types.length; i++) {
    menuTypes.push(this.objectType + '.' + types[i]);
  }
  return menuTypes;
};

/**
 * The separator here does not exist in the model delivered by the server-side client.
 * The createdBy property is added to the model to find and destroy items added by the UI later.
 */
scout.MenuItemsOrder.prototype._createSeparator = function() {
  return scout.create('Menu', {
    parent: this.menuBar,
    createdBy: this,
    separator: true
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ContextMenuPopup = function() {
  scout.ContextMenuPopup.parent.call(this);

  // Make sure head won't be rendered, there is a css selector which is applied only if there is a head
  this._headVisible = false;
  this.menuItems = [];
  this.cloneMenuItems = true;
};
scout.inherits(scout.ContextMenuPopup, scout.PopupWithHead);

scout.ContextMenuPopup.prototype._init = function(options) {
  options.focusableContainer = true; // In order to allow keyboard navigation, the popup must gain focus. Because menu-items are not focusable, make the container focusable instead.

  // If menu items are cloned, don't link the original menus with the popup, otherwise they would be removed when the context menu is removed
  if (options.cloneMenuItems === false) {
    this._addAdapterProperties('menuItems');
  }

  scout.ContextMenuPopup.parent.prototype._init.call(this, options);
};

/**
 * @override Popup.js
 */
scout.ContextMenuPopup.prototype._initKeyStrokeContext = function() {
  scout.ContextMenuPopup.parent.prototype._initKeyStrokeContext.call(this);

  scout.menuNavigationKeyStrokes.registerKeyStrokes(this.keyStrokeContext, this, 'menu-item');
};

scout.ContextMenuPopup.prototype._createLayout = function() {
  return new scout.ContextMenuPopupLayout(this);
};

scout.ContextMenuPopup.prototype._render = function($parent) {
  scout.ContextMenuPopup.parent.prototype._render.call(this, $parent);
  this._installScrollbars();
  this._renderMenuItems();
};

scout.ContextMenuPopup.prototype._installScrollbars = function() {
  scout.scrollbars.install(this.$body, {
    parent: this,
    axis: 'y'
  });
};

/**
 * @override
 */
scout.ContextMenuPopup.prototype._remove = function() {
  scout.scrollbars.uninstall(this.$body, this.session);
  scout.ContextMenuPopup.parent.prototype._remove.call(this);
};

scout.ContextMenuPopup.prototype.removeSubMenuItems = function(parentMenu, animated) {
  var duration = 300;

  this.$body = parentMenu.parentMenu.$subMenuBody;
  // move new body to back
  this.$body.insertBefore(parentMenu.$subMenuBody);

  if (parentMenu.parentMenu._doActionTogglesSubMenu) {
    parentMenu.parentMenu._doActionTogglesSubMenu();
  }

  var displayBackup = parentMenu.$subMenuBody.css('display');
  parentMenu.$subMenuBody.css({
    width: 'auto',
    height: 'auto',
    display: 'none'
  });

  var actualBounds = this.htmlComp.getBounds();
  var actualSize = this.htmlComp.getSize();

  this.revalidateLayout();
  this.position();

  parentMenu.$subMenuBody.css('display', displayBackup);
  var position;
  position = parentMenu.$placeHolder.position();

  if (animated && this.rendered) {
    this.bodyAnimating = true;
    parentMenu.$subMenuBody.css({
      width: 'auto',
      height: 'auto'
    });
    var targetSize = this.htmlComp.getSize();
    parentMenu.$subMenuBody.css('box-shadow', 'none');
    this.htmlComp.setBounds(actualBounds);
    if (this.openingDirectionY !== 'up') {
      // set container to element
      parentMenu.$subMenuBody.cssTop();
    }
    // move new body to top of popup
    parentMenu.$subMenuBody.cssHeightAnimated(actualSize.height, parentMenu.$container.cssHeight(), {
      duration: duration,
      queue: false
    });

    var endTopposition = position.top - this.$body.cssHeight(),
      startTopposition = 0 - actualSize.height;

    parentMenu.$subMenuBody.cssTopAnimated(startTopposition, endTopposition, {
      duration: duration,
      queue: false,
      complete: function() {
        if (parentMenu.$container) { //check if $container is not removed before by closing operation.
          scout.scrollbars.uninstall(parentMenu.$subMenuBody, this.session);
          parentMenu.$placeHolder.replaceWith(parentMenu.$container);
          parentMenu.$container.toggleClass('expanded', false);
          this._updateFirstLastClass();
          this.updateNextToSelected('menu-item', parentMenu.$container);

          parentMenu.$subMenuBody.detach();
          this._installScrollbars();
          this.$body.css('box-shadow', "");
          this.bodyAnimating = false;
        }
      }.bind(this)
    });

    this.$body.cssWidthAnimated(actualSize.width, targetSize.width, {
      duration: duration,
      progress: this.revalidateLayout.bind(this),
      queue: false
    });

    if (targetSize.height !== actualSize.height) {
      this.$body.cssHeightAnimated(actualSize.height, targetSize.height, {
        duration: duration,
        queue: false
      });
    }
  }
};

scout.ContextMenuPopup.prototype.renderSubMenuItems = function(parentMenu, menus, animated, initialSubMenuRendering) {
  if (!this.session.desktop.rendered && !initialSubMenuRendering) {
    this.initialSubMenusToRender = {
      parentMenu: parentMenu,
      menus: menus
    };
    return;
  }
  var actualBounds = this.htmlComp.getBounds();
  var actualSize = this.htmlComp.getSize();

  parentMenu.parentMenu.$subMenuBody = this.$body;

  var $all = this.$body.find('.' + 'menu-item');
  $all.toggleClass('next-to-selected', false);

  if (!parentMenu.$subMenuBody) {
    var textPaddingLeft = parentMenu.$container.find('.text').css('padding-left'),
      iconOffset = 0;
    if (parentMenu.iconId && parentMenu.$container.data('$icon').cssWidth() > iconOffset) {
      iconOffset = parentMenu.$container.data('$icon').cssWidth();
    }
    if (textPaddingLeft) {
      textPaddingLeft = textPaddingLeft.replace('px', '');
      textPaddingLeft = Number(textPaddingLeft);
    }
    this.$body = this._$createNewBody();
    parentMenu.$subMenuBody = this.$body;
    this._renderMenuItems(menus, initialSubMenuRendering, Math.max(textPaddingLeft, iconOffset));
  } else {
    // append $body
    this.$body = parentMenu.$subMenuBody;
  }
  var $insertAfterElement = parentMenu.$container.prev();
  var position = parentMenu.$container.position();
  parentMenu.$placeHolder = parentMenu.$container.clone();
  if ($insertAfterElement.length) {
    parentMenu.$placeHolder.insertAfter($insertAfterElement);
  } else {
    parentMenu.parentMenu.$subMenuBody.prepend(parentMenu.$placeHolder);
  }

  this.$body.insertAfter(parentMenu.parentMenu.$subMenuBody);
  this.$body.prepend(parentMenu.$container);
  parentMenu.$container.toggleClass('expanded');

  // sets this.animationBounds;
  this.revalidateLayout();
  this.position();

  this.updateNextToSelected();

  if (animated && this.rendered) {
    var duration = 300;
    this.bodyAnimating = true;
    parentMenu.parentMenu.$subMenuBody.css({
      width: 'auto',
      height: 'auto'
    });
    var targetBounds = this.htmlComp.getBounds();
    var targetSize = this.htmlComp.getSize();
    this.$body.css('box-shadow', 'none');
    // set container to element
    this.$body.cssWidthAnimated(actualSize.width, targetSize.width, {
      duration: duration,
      progress: this.revalidateLayout.bind(this),
      complete: function() {
        this.bodyAnimating = false;
      }.bind(this),
      queue: false
    });

    this.$body.cssHeightAnimated(parentMenu.$container.cssHeight(), targetSize.height, {
      duration: duration,
      queue: false
    });

    var endTopposition = 0 - targetSize.height,
      startTopposition = position.top - parentMenu.parentMenu.$subMenuBody.cssHeight(),
      topMargin = 0;

    // move new body to top of popup.
    this.$body.cssTopAnimated(startTopposition, endTopposition, {
      duration: duration,
      queue: false,
      complete: function() {
        if (parentMenu.parentMenu.$subMenuBody) {
          scout.scrollbars.uninstall(parentMenu.parentMenu.$subMenuBody, this.session);
          parentMenu.parentMenu.$subMenuBody.detach();
          this.$body.cssTop(topMargin);
          this._installScrollbars();
          this._updateFirstLastClass();
          this.$body.css('box-shadow', '');
        }
      }.bind(this)
    });

    if (actualSize.height !== targetSize.height) {
      parentMenu.parentMenu.$subMenuBody.cssHeightAnimated(actualSize.height, targetSize.height, {
        duration: duration,
        queue: false
      });
      this.$container.cssHeight(actualSize.height, targetSize.height, {
        duration: duration,
        queue: false
      });
    }
    if (this.openingDirectionY === 'up') {
      this.$container.cssTopAnimated(actualBounds.y, targetBounds.y, {
        duration: duration,
        queue: false
      }).css('overflow', 'visible');
      // ajust top of head and deco
      this.$head.cssTopAnimated(actualSize.height, targetSize.height, {
        duration: duration,
        queue: false
      });
      this.$deco.cssTopAnimated(actualSize.height - 1, targetSize.height - 1, {
        duration: duration,
        queue: false
      });
    }
  } else {
    if (!initialSubMenuRendering) {
      scout.scrollbars.uninstall(parentMenu.parentMenu.$subMenuBody, this.session);
    }
    parentMenu.parentMenu.$subMenuBody.detach();
    this._installScrollbars();
    this._updateFirstLastClass();
  }
};

scout.ContextMenuPopup.prototype._renderMenuItems = function(menus, initialSubMenuRendering, iconOffset) {
  menus = menus ? menus : this._getMenuItems();
  if (this.menuFilter) {
    menus = this.menuFilter(menus, scout.MenuDestinations.CONTEXT_MENU);
  }

  if (!menus || menus.length === 0) {
    return;
  }

  iconOffset = iconOffset ? iconOffset : 0;
  menus.forEach(function(menu) {
    // Invisible menus are rendered as well because their visibility might change dynamically
    if (menu.separator) {
      return;
    }

    // prevent loosing original parent
    var parentMenu = menu.parent;
    if (this.cloneMenuItems && !menu.cloneOf) {
      menu = menu.cloneAndMirror({
        parent: this
      });
      this._attachCloneMenuListeners(menu);
    }

    // just set once because on second execution of this menu.parent is set to a popup
    if (!menu.parentMenu) {
      menu.parentMenu = parentMenu;
    }
    menu.render(this.$body);
    this._attachMenuListeners(menu);
    iconOffset = this._updateIconAndText(menu, iconOffset);
  }, this);

  this._handleInitialSubMenus(initialSubMenuRendering);
  this._updateFirstLastClass();
};

scout.ContextMenuPopup.prototype._handleInitialSubMenus = function(initialSubMenuRendering) {
  var menusObj;
  while (this.initialSubMenusToRender && !initialSubMenuRendering) {
    menusObj = this.initialSubMenusToRender;
    this.initialSubMenusToRender = undefined;
    this.renderSubMenuItems(menusObj.parentMenu, menusObj.menus, false, true);
  }
};

scout.ContextMenuPopup.prototype._updateIconAndText = function(menu, iconOffset) {
  if (menu.iconId && menu.$container.data('$icon').cssWidth() > iconOffset) {
    iconOffset = menu.$container.data('$icon').cssWidth();
    // update already rendered menu-items
    this.$body.children().each(function(index, element) {
      var $element = $(element);
      var $icon = $element.data('$icon');
      if ($icon && $icon.cssWidth() < iconOffset) {
        $element.find('.text').css('padding-left', iconOffset - $icon.cssWidth());
      } else if (element !== menu.$container[0]) {
        $element.find('.text').css('padding-left', iconOffset);
      }
    });
  } else if (iconOffset && !menu.iconId) {
    menu.$container.find('.text').css('padding-left', iconOffset);
  } else if (menu.$container.data('$icon') && menu.$container.data('$icon').cssWidth() < iconOffset) {
    menu.$container.find('.text').css('padding-left', iconOffset - menu.$container.data('$icon').cssWidth());
  }
  return iconOffset;
};

scout.ContextMenuPopup.prototype._attachMenuListeners = function(menu) {
  var menuItemDoActionHandler = this._onMenuItemDoAction.bind(this);
  var menuItemPropertyChange = this._onMenuItemPropertyChange.bind(this);
  menu.on('doAction', menuItemDoActionHandler);
  menu.on('propertyChange', menuItemPropertyChange);
  this.one('remove', function() {
    menu.off('doAction', menuItemDoActionHandler);
    menu.off('propertyChange', menuItemPropertyChange);
  });
};

scout.ContextMenuPopup.prototype._attachCloneMenuListeners = function(menu) {
  menu.on('doAction', this._onCloneMenuDoAction.bind(this));
  menu.on('propertyChange', this._onCloneMenuPropertyChange.bind(this));
  menu.childActions.forEach(this._attachCloneMenuListeners.bind(this));
};

scout.ContextMenuPopup.prototype._onCloneMenuDoAction = function(event) {
  var menu = event.source;
  menu.cloneOf.doAction();
};

scout.ContextMenuPopup.prototype._onCloneMenuPropertyChange = function(event) {
  if (event.changedProperties.indexOf('selected') !== -1) {
    var menu = event.source;
    // Only trigger property change, setSelected would try to render the selected state which must not happen for the original menu
    menu.cloneOf.triggerPropertyChange('selected', event.oldProperties.selected, event.newProperties.selected);
  }
};

/**
 * @override PopupWithHead.js
 */
scout.ContextMenuPopup.prototype._modifyBody = function() {
  this.$body.addClass('context-menu');
};

scout.ContextMenuPopup.prototype.updateMenuItems = function(menuItems) {
  menuItems = scout.arrays.ensure(menuItems);
  // Only update if list of menus changed. Don't compare this.menuItems, because that list
  // may contain additional UI separators, and may not be in the same order
  if (!scout.arrays.equals(this.menuItems, menuItems)) {
    this.close();
  }
};
/**
 * Override this method to return menu items or actions used to render menu items.
 */
scout.ContextMenuPopup.prototype._getMenuItems = function() {
  return this.menuItems;
};

/**
 * Currently rendered $menuItems
 */
scout.ContextMenuPopup.prototype.$menuItems = function() {
  return this.$body.children('.menu-item');
};

/**
 * Updates the first and last visible menu items with the according css classes.
 * Necessary because invisible menu-items are rendered.
 */
scout.ContextMenuPopup.prototype._updateFirstLastClass = function(event) {
  var $firstMenuItem, $lastMenuItem;

  // TODO [5.2] cgu: after refactoring of menu-item to context-menu-item we can use last/first instead of a fully qualified name. We also could move this function to jquery-scout to make it reusable.
  this.$body.children('.menu-item').each(function() {
    var $menuItem = $(this);
    $menuItem.removeClass('context-menu-item-first context-menu-item-last');

    if ($menuItem.isVisible()) {
      if (!$firstMenuItem) {
        $firstMenuItem = $menuItem;
      }
      $lastMenuItem = $menuItem;
    }
  });
  if ($firstMenuItem) {
    $firstMenuItem.addClass('context-menu-item-first');
  }
  if ($lastMenuItem) {
    $lastMenuItem.addClass('context-menu-item-last');
  }
};

scout.ContextMenuPopup.prototype.updateNextToSelected = function(menuItemClass, $selectedItem) {
  menuItemClass = menuItemClass ? menuItemClass : 'menu-item';
  var $all = this.$body.find('.' + menuItemClass);
  $selectedItem = $selectedItem ? $selectedItem : this.$body.find('.' + menuItemClass + '.selected');

  $all.toggleClass('next-to-selected', false);
  if ($selectedItem.hasClass('selected')) {
    $selectedItem.nextAll(':visible').first().toggleClass('next-to-selected', true);
  }
};

scout.ContextMenuPopup.prototype._onMenuItemDoAction = function(event) {
  this.close();
};

scout.ContextMenuPopup.prototype._onMenuItemPropertyChange = function(event) {
  if (!this.rendered) {
    return;
  }
  if (event.changedProperties.indexOf('visible') !== -1) {
    this._updateFirstLastClass();
  }
  // Make sure menu is positioned correctly afterwards (if it is opened upwards hiding/showing a menu item makes it necessary to reposition)
  this.position();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ContextMenuPopupLayout = function(popup) {
  scout.ContextMenuPopupLayout.parent.call(this, popup);
};
scout.inherits(scout.ContextMenuPopupLayout, scout.PopupWithHeadLayout);

scout.ContextMenuPopupLayout.prototype.layout = function($container) {
  var $menuItems = this.popup.$menuItems();
  this._resetMaxWidthFor($menuItems);
  scout.ContextMenuPopupLayout.parent.prototype.layout.call(this, $container);
  this._setMaxWidthFor($menuItems);
};

scout.ContextMenuPopupLayout.prototype._resetMaxWidthFor = function($menuItems) {
  $menuItems.each(function(pos, item) {
    var $menu = $(item),
      menu = $menu.data('widget');

    if (!menu) {
      // After closing a submenu the link to the widget gets lost
      return;
    }

    if (menu.$text) {
      menu.$text.css('max-width', '');
    }
  }.bind(this));
};

scout.ContextMenuPopupLayout.prototype._setMaxWidthFor = function($menuItems) {
  $menuItems.each(function(pos, item) {
    var $menu = $(item),
      menu = $menu.data('widget');

    if (!menu) {
      // After closing a submenu the link to the widget gets lost
      return;
    }

    if (menu.$text) {
      // Submenu icon is on the right side of the text.
      // If there is not enough space to show the whole menu item (icon, text and submenu icon), the text is truncated.
      // Icon and submenu icon are always shown.
      var textMaxWidth = this._calcTextMaxWidth(menu);
      menu.$text.cssPxValue('max-width', textMaxWidth);
    }
  }.bind(this));
};

scout.ContextMenuPopupLayout.prototype._calcTextMaxWidth = function(menu) {
  var containerWidth = menu.$container.width(),
    $icon = menu.$container.data('$icon'),
    $text = menu.$text,
    $submenuIcon = menu.$submenuIcon,
    textWidth = containerWidth + 1; // add 1px to make it work even if containerWidth is a float

  if ($text && $text.isVisible()) {
    textWidth -= $text.cssMarginX();
  }
  if ($icon && $icon.isVisible()) {
    textWidth -= $icon.outerWidth(true);
  }
  if ($submenuIcon && $submenuIcon.isVisible()) {
    textWidth -= $submenuIcon.outerWidth(true);
  }
  return textWidth;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.menuNavigationKeyStrokes = {

  registerKeyStrokes: function(keyStrokeContext, popup, menuItemClass) {
    keyStrokeContext.registerKeyStroke([
      new scout.MenuNavigationUpKeyStroke(popup, menuItemClass),
      new scout.MenuNavigationDownKeyStroke(popup, menuItemClass),
      new scout.MenuNavigationExecKeyStroke(popup, menuItemClass),
      new scout.MenuExecByNumberKeyStroke(popup, menuItemClass),
      new scout.SubCloseKeyStroke(popup, menuItemClass)
    ]);
  },

  _findMenuItems: function(popup, menuItemClass) {
    return {
      $all: popup.$body.find('.' + menuItemClass),
      $allVisible: popup.$body.find('.' + menuItemClass + ':visible'),
      $selected: popup.$body.find('.' + menuItemClass + '.selected')
    };
  },

  _changeSelection: function($oldItem, $newItem) {
    if ($newItem.length === 0) {
      // do not change selection
      return;
    } else {
      $newItem.select(true).focus();
      if (this.field.updateNextToSelected) {
        this.field.updateNextToSelected(this._menuItemClass, $newItem);
      }
    }
    if ($oldItem.length > 0) {
      $oldItem.select(false);
    }
  }
};

/**
 * MenuNavigationUpKeyStroke
 */
scout.MenuNavigationUpKeyStroke = function(popup, menuItemClass) {
  scout.MenuNavigationUpKeyStroke.parent.call(this);
  this._menuItemClass = menuItemClass;
  this.field = popup;
  this.which = [scout.keys.UP];
  this.renderingHints.render = false;
};
scout.inherits(scout.MenuNavigationUpKeyStroke, scout.KeyStroke);

scout.MenuNavigationUpKeyStroke.prototype.handle = function(event) {
  var menuItems = scout.menuNavigationKeyStrokes._findMenuItems(this.field, this._menuItemClass);
  if (menuItems.$selected.length > 0) {
    scout.menuNavigationKeyStrokes._changeSelection.call(this, menuItems.$selected, menuItems.$selected.prevAll(':visible').first());
  } else {
    scout.menuNavigationKeyStrokes._changeSelection.call(this, menuItems.$selected, menuItems.$allVisible.last());
  }
};

/**
 * MenuNavigationDownKeyStroke
 */
scout.MenuNavigationDownKeyStroke = function(popup, menuItemClass) {
  scout.MenuNavigationDownKeyStroke.parent.call(this);
  this._menuItemClass = menuItemClass;
  this.field = popup;
  this.which = [scout.keys.DOWN];
  this.renderingHints.render = false;
};
scout.inherits(scout.MenuNavigationDownKeyStroke, scout.KeyStroke);

scout.MenuNavigationDownKeyStroke.prototype.handle = function(event) {
  var menuItems = scout.menuNavigationKeyStrokes._findMenuItems(this.field, this._menuItemClass);
  if (menuItems.$selected.length > 0) {
    scout.menuNavigationKeyStrokes._changeSelection.call(this, menuItems.$selected, menuItems.$selected.nextAll(':visible').first());
  } else {
    scout.menuNavigationKeyStrokes._changeSelection.call(this, menuItems.$selected, menuItems.$allVisible.first());
  }
};

/**
 * MenuNavigationExecKeyStroke
 */
scout.MenuNavigationExecKeyStroke = function(popup, menuItemClass) {
  scout.MenuNavigationExecKeyStroke.parent.call(this);
  this._menuItemClass = menuItemClass;
  this.field = popup;
  this.stopImmediatePropagation = true;
  this.which = [scout.keys.ENTER, scout.keys.SPACE];
  this.renderingHints.render = false;
};
scout.inherits(scout.MenuNavigationExecKeyStroke, scout.KeyStroke);

scout.MenuNavigationExecKeyStroke.prototype.handle = function(event) {
  this._simulateLeftClickOnItems(scout.menuNavigationKeyStrokes._findMenuItems(this.field, this._menuItemClass).$selected);
};

scout.MenuNavigationExecKeyStroke.prototype._accept = function(event) {
  var accepted = scout.MenuNavigationExecKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted || this.field.bodyAnimating) {
    return false;
  }
  return accepted;
};

scout.MenuNavigationExecKeyStroke.prototype._simulateLeftClickOnItems = function($menuItems) {
  ['mousedown', 'mouseup', 'click'].forEach(function(eventType) {
    $menuItems.trigger({
      type: eventType,
      which: 1
    });
  }); // simulate left-mouse click (full click event sequence in order, see scout.Menu.prototype._onMouseEvent)
};

/**
 * SubCloseKeyStroke
 */
scout.SubCloseKeyStroke = function(popup, menuItemClass) {
  scout.SubCloseKeyStroke.parent.call(this, popup, menuItemClass);
  this._menuItemClass = menuItemClass;
  this.field = popup;
  this.which = [scout.keys.BACKSPACE];
  this.renderingHints.render = true;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return event._$element;
  }.bind(this);
};

scout.inherits(scout.SubCloseKeyStroke, scout.MenuNavigationExecKeyStroke);

scout.SubCloseKeyStroke.prototype._accept = function(event) {
  var accepted = scout.MenuExecByNumberKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted) {
    return false;
  }

  var menuItems = scout.menuNavigationKeyStrokes._findMenuItems(this.field, this._menuItemClass + '.expanded');

  if (menuItems.$all.length > 0) {
    event._$element = menuItems.$all;
    return true;
  }
  return false;
};

scout.SubCloseKeyStroke.prototype.handle = function(event) {
  if (event._$element) {
    this._simulateLeftClickOnItems(event._$element);
  }
};

/**
 * MenuExecByNumberKeyStroke
 */
scout.MenuExecByNumberKeyStroke = function(popup, menuItemClass) {
  scout.MenuExecByNumberKeyStroke.parent.call(this, popup, menuItemClass);
  this._menuItemClass = menuItemClass;
  this.field = popup;
  this.which = [scout.keys[1], scout.keys[2], scout.keys[3], scout.keys[4], scout.keys[5], scout.keys[6], scout.keys[7], scout.keys[8], scout.keys[9]];
  this.renderingHints.render = true;
  this.renderingHints.hAlign = scout.hAlign.RIGHT;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return event._$element;
  }.bind(this);
};
scout.inherits(scout.MenuExecByNumberKeyStroke, scout.MenuNavigationExecKeyStroke);

scout.MenuExecByNumberKeyStroke.prototype._accept = function(event) {
  var accepted = scout.MenuExecByNumberKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted) {
    return false;
  }

  var menuItems = scout.menuNavigationKeyStrokes._findMenuItems(this.field, this._menuItemClass);
  var index = scout.codesToKeys[event.which];
  event._$element = menuItems.$allVisible.eq(index - 1);

  if (event._$element) {
    return true;
  }
  return false;
};

scout.MenuExecByNumberKeyStroke.prototype.handle = function(event) {
  if (event._$element) {
    this._simulateLeftClickOnItems(event._$element);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ButtonAdapterMenu = function() {
  scout.ButtonAdapterMenu.parent.call(this);
  this._removeAdapterProperties('childActions'); // managed by button

  this._buttonPropertyChangeHandler = this._onButtonPropertyChange.bind(this);
  this._buttonDestroyHandler = this._onButtonDestroy.bind(this);

  this._addCloneProperties(['button']);
};
scout.inherits(scout.ButtonAdapterMenu, scout.Menu);

/**
 * @override Action.js
 */
scout.ButtonAdapterMenu.prototype._init = function(model) {
  scout.ButtonAdapterMenu.parent.prototype._init.call(this, model);
  if (!this.button) {
    throw new Error('Cannot adapt to undefined button');
  }
  this.button.adaptedBy = this;
  this._installListeners();
};

scout.ButtonAdapterMenu.prototype.destroy = function() {
  scout.ButtonAdapterMenu.parent.prototype.destroy.call(this);
  delete this.button.adaptedBy;
};

scout.ButtonAdapterMenu.prototype._installListeners = function() {
  this.button.on('propertyChange', this._buttonPropertyChangeHandler);
  this.button.on('destroy', this._buttonDestroyHandler);
};

scout.ButtonAdapterMenu.prototype._uninstallListeners = function() {
  this.button.off('propertyChange', this._buttonPropertyChangeHandler);
  this.button.off('destroy', this._buttonDestroyHandler);
};

scout.ButtonAdapterMenu.prototype._render = function($parent) {
  scout.ButtonAdapterMenu.parent.prototype._render.call(this, $parent);
  // Convenience: Add ID of original button to DOM for debugging purposes
  this.$container.attr('data-buttonadapter', this.button.id);
};

scout.ButtonAdapterMenu.prototype._onButtonPropertyChange = function(event) {
  // Whenever a button property changes, apply the changes to the menu
  var changedProperties = {};
  event.changedProperties.forEach(function(prop) {
    changedProperties[prop] = event.newProperties[prop];
  });
  changedProperties = scout.ButtonAdapterMenu.adaptButtonProperties(changedProperties);
  for (var prop in changedProperties) { // NOSONAR
    this.setProperty(prop, changedProperties[prop]);
  }
};

scout.ButtonAdapterMenu.prototype._onButtonDestroy = function(event) {
  this.destroy();
  this._uninstallListeners();
};

/**
 * @override Action.js
 */
scout.ButtonAdapterMenu.prototype.doAction = function(srcEvent) {
  if (this.childActions.length > 0) {
    // Popup menu is handled by this menu itself
    return scout.ButtonAdapterMenu.parent.prototype.doAction.call(this, srcEvent);
  }

  // Everything else is delegated to the button
  var actionExecuted = this.button.doAction();
  if (actionExecuted && this.isToggleAction() && this.rendered) {
    this.setSelected(!this.selected);
  }
  return actionExecuted;
};

/**
 * @implements FormField.js
 */
scout.ButtonAdapterMenu.prototype.getFocusableElement = function() {
  if (this.rendered) {
    return this.$container[0];
  }
  return null;
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * @memberOf scout.ButtonAdapterMenu
 */
scout.ButtonAdapterMenu.adaptButtonProperties = function(buttonProperties, menuProperties) {
  menuProperties = menuProperties || {};

  // Plain properties: simply copy, no translation required
  ['enabled', 'visible', 'selected', 'tooltipText', 'keyStroke', 'keyStrokes', 'modelClass', 'classId'].forEach(function(prop) {
    menuProperties[prop] = buttonProperties[prop];
  });

  // Properties requiring special handling (non-trivial mapping)
  menuProperties.text = buttonProperties.label;
  menuProperties.horizontalAlignment = (buttonProperties.gridData ? buttonProperties.gridData.horizontalAlignment : undefined);
  menuProperties.actionStyle = buttonStyleToActionStyle(buttonProperties.displayStyle);
  menuProperties.toggleAction = buttonProperties.displayStyle === scout.Button.DisplayStyle.TOGGLE;
  menuProperties.childActions = buttonProperties.menus;

  // Cleanup: Remove all properties that have value 'undefined' from the result object,
  // otherwise, they would be applied to the model adapter.
  for (var prop in menuProperties) {
    if (menuProperties[prop] === undefined) {
      delete menuProperties[prop];
    }
  }
  return menuProperties;

  // ----- Helper functions -----

  function buttonStyleToActionStyle(buttonStyle) {
    if (buttonStyle === undefined) {
      return undefined;
    }
    if (buttonStyle === scout.Button.DisplayStyle.LINK) {
      return scout.Action.ActionStyle.DEFAULT;
    } else {
      return scout.Action.ActionStyle.BUTTON;
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuBox = function(menuBar) {
  scout.MenuBox.parent.call(this);
  this.horizontalAlignment = 1; // right
  this.compact = false;
  this.menus = [];
  this._addAdapterProperties('menus');
};
scout.inherits(scout.MenuBox, scout.Widget);

scout.MenuBox.prototype._init = function(options) {
  scout.MenuBox.parent.prototype._init.call(this, options);
  this.menus = options.menus || [];
  this.uiMenuCssClass = options.uiMenuCssClass || '';
  this.uiMenuCssClass += ' ' + 'menu-box-item';
  this._initMenus(this.menus);
};

scout.MenuBox.prototype._initMenus = function(menus) {
  menus.forEach(this._initMenu.bind(this));
};

scout.MenuBox.prototype._initMenu = function(menu) {
  menu.uiCssClass = this.uiMenuCssClass;
};

/**
 * @override Widget.js
 */
scout.MenuBox.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('menu-box');

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.MenuBoxLayout(this));
};

scout.MenuBox.prototype._renderProperties = function() {
  scout.MenuBox.parent.prototype._renderProperties.call(this);
  this._renderMenus();
  this._renderCompact();
};

scout.MenuBox.prototype._renderMenus = function() {
  this.menus.forEach(function(menu) {
    menu.render(this.$container);
  }, this);
  this.invalidateLayoutTree();
};

scout.MenuBox.prototype._removeMenus = function() {
  this.menus.forEach(function(menu) {
    menu.remove();
  });
  this.invalidateLayoutTree();
};

scout.MenuBox.prototype._renderCompact = function() {
  this.$container.toggleClass('compact', this.compact);
  this.invalidateLayoutTree();
};

scout.MenuBox.prototype.setCompact = function(compact) {
  this.setProperty('compact', compact);
};

scout.MenuBox.prototype.setMenus = function(menus) {
  this.setProperty('menus', menus);
};

scout.MenuBox.prototype.setHorizontalAlignment = function(horizontalAlignment) {
  this.setProperty('horizontalAlignment', horizontalAlignment);
};

scout.MenuBox.prototype._renderHorizontalAlignment = function() {
  this.invalidateLayoutTree();
};
/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuBoxLayout = function(menuBox) {
  scout.MenuBoxLayout.parent.call(this);
  this.menuBox = menuBox;
  // References to prevent too many DOM updates
  this.firstMenu = null;
  this.lastMenu = null;
};
scout.inherits(scout.MenuBoxLayout, scout.AbstractLayout);

/**
 * @override AbstractLayout.js
 */
scout.MenuBoxLayout.prototype.layout = function($container) {
  var htmlContainer = this.menuBox.htmlComp,
    containerSize = htmlContainer.getSize(),
    menus = this.visibleMenus(),
    menusWidth = 0;

  // Make sure open popups are at the correct position after layouting
  this.menuBox.session.layoutValidator.schedulePostValidateFunction(function() {
    menus.forEach(function(menu) {
      if (menu.popup) {
        menu.popup.position();
      }
    });
  });

  this.updateFirstAndLastMenuMarker(menus);
  this.undoCollapse(menus);
  this.undoCompact(menus);
  this.undoShrink(menus);
  menusWidth = this.actualPrefSize(menus).width;
  if (menusWidth <= containerSize.width) {
    // OK, every menu fits into container
    return;
  }

  // Menus don't fit

  // First approach: Set menuBox into compact mode
  this.compact(menus);
  menusWidth = this.actualPrefSize(menus).width;
  if (menusWidth <= containerSize.width) {
    // OK, every menu fits into container
    return;
  }

  // Second approach: Make text invisible and only show the icon (if available)
  this.shrink(menus);
  menusWidth = this.actualPrefSize(menus).width;
  if (menusWidth <= containerSize.width) {
    // OK, every menu fits into container
    return;
  }

  // Third approach: Create ellipsis and move overflown menus into it
  this.collapse(menus, containerSize, menusWidth);
};

scout.MenuBoxLayout.prototype.preferredLayoutSize = function($container) {
  var menus = this.visibleMenus();

  this.updateFirstAndLastMenuMarker(menus);
  this.undoCollapse(menus);
  this.undoCompact(menus);
  this.undoShrink(menus);

  return this.actualPrefSize();
};

scout.MenuBoxLayout.prototype.compact = function(menus) {
  if (this.menuBox.compactOrig === undefined) {
    this.menuBox.compactOrig = this.compact;
    this.menuBox.htmlComp.suppressInvalidate = true;
    this.menuBox.setCompact(true);
    this.menuBox.htmlComp.suppressInvalidate = false;
  }

  this.compactMenus(menus);
};

scout.MenuBoxLayout.prototype.undoCompact = function(menus) {
  if (this.menuBox.compactOrig !== undefined) {
    this.menuBox.htmlComp.suppressInvalidate = true;
    this.menuBox.setCompact(this.compactOrig);
    this.menuBox.htmlComp.suppressInvalidate = false;
    this.menuBox.compactOrig = undefined;
  }

  this.undoCompactMenus(menus);
};

/**
 * Sets all menus into compact mode.
 */
scout.MenuBoxLayout.prototype.compactMenus = function(menus) {
  menus = menus || this.visibleMenus();
  menus.forEach(function(menu) {
    if (menu.compactOrig !== undefined) {
      // already done
      return;
    }
    menu.compactOrig = menu.compact;
    menu.htmlComp.suppressInvalidate = true;
    menu.setCompact(true);
    menu.htmlComp.suppressInvalidate = false;
  }, this);

  if (this._ellipsis) {
    this._ellipsis.setCompact(true);
  }
};

/**
 * Restores to the previous state of the compact property.
 */
scout.MenuBoxLayout.prototype.undoCompactMenus = function(menus) {
  menus = menus || this.visibleMenus();
  menus.forEach(function(menu) {
    if (menu.compactOrig === undefined) {
      return;
    }
    // Restore old compact state
    menu.htmlComp.suppressInvalidate = true;
    menu.setCompact(menu.compactOrig);
    menu.htmlComp.suppressInvalidate = false;
    menu.compactOrig = undefined;
  }, this);

  if (this._ellipsis) {
    this._ellipsis.setCompact(false);
  }
};

scout.MenuBoxLayout.prototype.shrink = function(menus) {
  this.shrinkMenus(menus);
};

/**
 * Makes the text invisible of all menus with an icon.
 */
scout.MenuBoxLayout.prototype.shrinkMenus = function(menus) {
  menus = menus || this.visibleMenus();
  menus.forEach(function(menu) {
    if (menu.textVisibleOrig !== undefined) {
      // already done
      return;
    }
    if (menu.iconId) {
      menu.textVisibleOrig = menu.textVisible;
      menu.htmlComp.suppressInvalidate = true;
      menu.setTextVisible(false);
      menu.htmlComp.suppressInvalidate = false;
    }
  }, this);
};

scout.MenuBoxLayout.prototype.undoShrink = function(menus) {
  this.undoShrinkMenus(menus);
};

scout.MenuBoxLayout.prototype.undoShrinkMenus = function(menus) {
  menus = menus || this.visibleMenus();
  menus.forEach(function(menu) {
    if (menu.textVisibleOrig === undefined) {
      return;
    }
    // Restore old text visible state
    menu.htmlComp.suppressInvalidate = true;
    menu.setTextVisible(menu.textVisibleOrig);
    menu.htmlComp.suppressInvalidate = false;
    menu.textVisibleOrig = undefined;
  }, this);
};

scout.MenuBoxLayout.prototype.collapse = function(menus, containerSize, menusWidth) {
  this._createAndRenderEllipsis(this.menuBox.$container);
  var collapsedMenus = this._moveOverflowMenusIntoEllipsis(containerSize, menusWidth);
  this.updateFirstAndLastMenuMarker(collapsedMenus);
};

/**
 * Undoes the collapsing by removing ellipsis and rendering non rendered menus.
 */
scout.MenuBoxLayout.prototype.undoCollapse = function(menus) {
  menus = menus || this.visibleMenus();
  this._destroyEllipsis();
  this._removeMenusFromEllipsis(menus, this.menuBox.$container);
};

scout.MenuBoxLayout.prototype._createAndRenderEllipsis = function($container) {
  var ellipsis = scout.menus.createEllipsisMenu({
    parent: this.menuBox,
    horizontalAlignment: 1,
    compact: this.menuBox.compact
  });
  ellipsis.uiCssClass = this.menuBox.uiMenuCssClass;
  ellipsis.render($container);
  this._ellipsis = ellipsis;
};

scout.MenuBoxLayout.prototype._destroyEllipsis = function() {
  if (this._ellipsis) {
    this._ellipsis.destroy();
    this._ellipsis = null;
  }
};

/**
 * Moves every menu which doesn't fit into the container into the ellipsis menu.
 * Returns the list of "surviving" menus (with the ellipsis menu being the last element).
 */
scout.MenuBoxLayout.prototype._moveOverflowMenusIntoEllipsis = function(containerSize, menusWidth) {
  var collapsedMenus = [this._ellipsis];
  var ellipsisSize = scout.graphics.getSize(this._ellipsis.$container, true);
  menusWidth += ellipsisSize.width;
  this.visibleMenus().slice().reverse().forEach(function(menu) {
    var menuSize;
    if (menusWidth > containerSize.width) {
      // Menu does not fit -> move to ellipsis menu
      menuSize = scout.graphics.getSize(menu.$container, true);
      menusWidth -= menuSize.width;
      scout.menus.moveMenuIntoEllipsis(menu, this._ellipsis);
    } else {
      collapsedMenus.unshift(menu); // add as first element
    }
  }, this);
  return collapsedMenus;
};

scout.MenuBoxLayout.prototype._removeMenusFromEllipsis = function(menus) {
  menus = menus || this.visibleMenus();
  menus.forEach(function(menu) {
    scout.menus.removeMenuFromEllipsis(menu, this.menuBox.$container);
  }, this);
};

scout.MenuBoxLayout.prototype.actualPrefSize = function(menus) {
  var menusWidth, prefSize;

  menus = menus || this.visibleMenus();
  menusWidth = this._menusWidth(menus);
  prefSize = scout.graphics.prefSize(this.menuBox.$container, {
    includeMargin: true,
    useCssSize: true
  });
  prefSize.width = menusWidth + this.menuBox.htmlComp.getInsets().horizontal();

  return prefSize;
};

/**
 * @return the current width of all menus incl. the ellipsis
 */
scout.MenuBoxLayout.prototype._menusWidth = function(menus) {
  var menusWidth = 0;
  menus = menus || this.visibleMenus();
  menus.forEach(function(menu) {
    if (menu.rendered) {
      menusWidth += menu.$container.outerWidth(true);
    }
  }, this);
  if (this._ellipsis) {
    menusWidth += this._ellipsis.$container.outerWidth(true);
  }
  return menusWidth;
};

scout.MenuBoxLayout.prototype.compactPrefSize = function(menus) {
  menus = menus || this.visibleMenus();

  this.updateFirstAndLastMenuMarker(menus);
  this.undoCollapse(menus);
  this.undoShrink(menus);
  this.compact(menus);

  return this.actualPrefSize();
};

scout.MenuBoxLayout.prototype.shrinkPrefSize = function(menus) {
  menus = menus || this.visibleMenus();

  this.updateFirstAndLastMenuMarker(menus);
  this.undoCollapse(menus);
  this.compact(menus);
  this.shrink(menus);

  return this.actualPrefSize();
};

scout.MenuBoxLayout.prototype.visibleMenus = function() {
  return this.menuBox.menus.filter(function(menu) {
    return menu.visible;
  }, this);
};

scout.MenuBoxLayout.prototype.updateFirstAndLastMenuMarker = function(menus) {
  // Find first and last rendered menu
  var firstMenu = null;
  var lastMenu = null;
  (menus || []).forEach(function(menu) {
    if (menu.rendered) {
      if (!firstMenu) {
        firstMenu = menu;
      }
      lastMenu = menu;
    }
  });

  // Check if first or last menu has changed (prevents unnecessary DOM updates)
  if (firstMenu !== this.firstMenu || lastMenu !== this.lastMenu) {
    // Remove existing markers
    if (this.firstMenu && this.firstMenu.rendered) {
      this.firstMenu.$container.removeClass('first');
    }
    if (this.lastMenu && this.lastMenu.rendered) {
      this.lastMenu.$container.removeClass('last');
    }
    // Remember found menus
    this.firstMenu = firstMenu;
    this.lastMenu = lastMenu;
    // Add markers to found menus
    if (this.firstMenu) {
      this.firstMenu.$container.addClass('first');
    }
    if (this.lastMenu) {
      this.lastMenu.$container.addClass('last');
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuBar = function() {
  scout.MenuBar.parent.call(this);

  this.menuSorter;
  this.position = 'top'; // or 'bottom'
  this.size = 'small'; // or 'large'
  this.tabbable = true;
  this._internalMenuItems = []; // original list of menuItems that was passed to updateItems(), only used to check if menubar has changed
  this.menuItems = []; // list of menuItems (ordered, may contain additional UI separators, some menus may not be rendered)
  this._orderedMenuItems = {
    left: [],
    right: []
  }; // Object containing "left" and "right" menus
  this.defaultMenu = null;
  this.visible = false;
  this.ellipsis;

  /**
   * This array is === menuItems when menu-bar is not over-sized.
   * When the menu-bar is over-sized, we this property is set be the MenuBarLayout
   * which adds an additional ellipsis-menu, and removes menu items that doesn't
   * fit into the available menu-bar space.
   */
  this.visibleMenuItems = [];

  this._menuItemPropertyChangeListener = function(event) {
    // We do not update the items directly, because this listener may be fired many times in one
    // user request (because many menus change one or more properties). Therefore, we just invalidate
    // the MenuBarLayout. It will be updated automatically after the user request has finished,
    // because the layout calls rebuildItemsInternal().
    if (event.changedProperties.length > 0) {
      if (event.changedProperties.length === 1 && event.changedProperties[0] === 'enabled') {
        this.updateDefaultMenu();
      } else if (event.changedProperties.indexOf('visible') > -1) {
        this.updateVisibility();
        // Mainly necessary for menus currently not rendered (e.g. in ellipsis menu).
        // If the menu is rendered, the menu itself triggers invalidateLayoutTree (see Menu.js#_renderVisible)
        this.invalidateLayoutTree();
      }
    }
  }.bind(this);
};
scout.inherits(scout.MenuBar, scout.Widget);

scout.MenuBar.prototype._init = function(options) {
  scout.MenuBar.parent.prototype._init.call(this, options);

  this.menuSorter = options.menuOrder;
  this.menuSorter.menuBar = this;
  this.menuFilter = options.menuFilter;
  this.updateVisibility();
};

/**
 * @override
 */
scout.MenuBar.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.MenuBar.prototype._initKeyStrokeContext = function() {
  scout.MenuBar.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([
    new scout.MenuBarLeftKeyStroke(this),
    new scout.MenuBarRightKeyStroke(this)
  ]);
};

/**
 * @override Widget.js
 */
scout.MenuBar.prototype._render = function($parent) {
  this.$container = $parent.makeDiv('menubar')
    .toggleClass('main-menubar', this.size === 'large');

  this.$left = this.$container.appendDiv('menubox left');
  scout.HtmlComponent.install(this.$left, this.session);
  this.$right = this.$container.appendDiv('menubox right');
  scout.HtmlComponent.install(this.$right, this.session);

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.MenuBarLayout(this));

  if (this.position === 'top') {
    $parent.prepend(this.$container);
  } else {
    this.$container.addClass('bottom');
    $parent.append(this.$container);
  }
  this.rebuildItemsInternal();
};

scout.MenuBar.prototype._remove = function() {
  scout.MenuBar.parent.prototype._remove.call(this);
  this._removeMenuItems();
  this.visibleMenuItems = [];
  this.visible = false;
};

/**
 * @override
 */
scout.MenuBar.prototype._renderVisible = function() {
  this.$container.setVisible(this.visible);
  this.invalidateLayoutTree();
};

scout.MenuBar.prototype.bottom = function() {
  this.position = 'bottom';
};

scout.MenuBar.prototype.top = function() {
  this.position = 'top';
};

scout.MenuBar.prototype.large = function() {
  this.size = 'large';
};

scout.MenuBar.prototype._destroyMenuSorterSeparators = function() {
  this.menuItems.forEach(function(item) {
    if (item.createdBy === this.menuSorter) {
      item.destroy();
    }
  }, this);
};

/**
 * Forces the MenuBarLayout to be revalidated, which includes rebuilding the menu items.
 */
scout.MenuBar.prototype.rebuildItems = function(revalidateLayoutTree) {
  this.htmlComp.revalidateLayout(); // this will trigger rebuildItemsInternal()
};

/**
 * Rebuilds the menu items without relayouting the menubar.
 * Do not call this internal method from outside (except from the MenuBarLayout).
 */
scout.MenuBar.prototype.rebuildItemsInternal = function() {
  this._updateItems();
};

scout.MenuBar.prototype.setMenuItems = function(menuItems) {
  menuItems = scout.arrays.ensure(menuItems);
  // Only update if list of menus changed. Don't compare this.menuItems, because that list
  // may contain additional UI separators, and may not be in the same order
  var sameMenuItems = scout.arrays.equals(this._internalMenuItems, menuItems);

  if (!sameMenuItems) {
    if (this.rendered) {
      this._removeMenuItems();
    }

    // The menuSorter may add separators to the list of items -> destroy the old ones first
    this._destroyMenuSorterSeparators();
    this._internalMenuItems = menuItems;
    this._orderedMenuItems = this.menuSorter.order(menuItems, this);
    this.menuItems = this._orderedMenuItems.left.concat(this._orderedMenuItems.right);
    this.link(menuItems);
  }

  if (this.rendered) {
    var hasUnrenderedMenuItems = this.menuItems.some(function(elem) {
      return !elem.rendered;
    });
    if (!sameMenuItems || hasUnrenderedMenuItems) {
      this.rebuildItems(); // Re-layout menubar
    } else {
      // Don't rebuild menubar, but update "markers"
      this.updateVisibility();
      this.updateDefaultMenu();
      this.updateLastItemMarker();
      this.updateLeftOfButtonMarker();
    }
  }
};

scout.MenuBar.prototype._updateItems = function() {
  this._removeMenuItems();

  this.visibleMenuItems = this.menuItems;

  // Make sure menubar is visible before the items get rendered
  // especially important for menu items with open popups to position them correctly
  this.updateVisibility();

  this._renderMenuItems(this._orderedMenuItems.left, false);
  this._renderMenuItems(this._orderedMenuItems.right, true);
  this.updateDefaultMenu();
  this.updateLastItemMarker();
  this.updateLeftOfButtonMarker();

  // Make first valid MenuItem tabbable so that it can be focused. All other items
  // are not tabbable. But they can be selected with the arrow keys.
  if ((!this.defaultMenu || !this.defaultMenu.enabled) && this.tabbable) {
    this.menuItems.some(function(item) {
      if (item.isTabTarget()) {
        this.setTabbableMenu(item);
        return true;
      } else {
        return false;
      }
    }.bind(this));
  }
};

scout.MenuBar.prototype.setTabbableMenu = function(menu) {
  if (!this.tabbable || menu === this.tabbableMenu) {
    return;
  }
  if (this.tabbableMenu) {
    this.tabbableMenu.setTabbable(false);
  }
  menu.setTabbable(true);
  this.tabbableMenu = menu;
};

/**
 * Ensures that the last visible menu item (no matter if it is in the left or the right menu box)
 * has the class 'last' (to remove the margin-right). Call this method whenever the visibility of
 * single items change.
 */
scout.MenuBar.prototype.updateLastItemMarker = function() {
  // Remove the 'last' class from the current last visible item
  if (this._lastVisibleItem && this._lastVisibleItem.rendered) {
    this._lastVisibleItem.$container.removeClass('last');
  }
  this._lastVisibleItem = null;

  // Find the new last visible item (from left to right)
  var setLastVisibleItemFn = function(item) {
    if (item.visible) {
      this._lastVisibleItem = item;
    }
  }.bind(this);
  this._orderedMenuItems.left.forEach(setLastVisibleItemFn);
  this._orderedMenuItems.right.forEach(setLastVisibleItemFn);

  // Assign the class to the found item
  if (this._lastVisibleItem && this._lastVisibleItem.rendered) {
    this._lastVisibleItem.$container.addClass('last');
  }
};

scout.MenuBar.prototype.updateVisibility = function() {
  this.setVisible(!this.hiddenByUi && this.menuItems.some(function(m) {
    return m.visible;
  }));
};

/**
 * First rendered item that is enabled and reacts to ENTER keystroke shall be marked as 'defaultMenu'
 */
scout.MenuBar.prototype.updateDefaultMenu = function() {
  this.setDefaultMenu(null);
  if (this._orderedMenuItems) {
    var found = this._updateDefaultMenuInItems(this._orderedMenuItems.right);
    if (!found) {
      this._updateDefaultMenuInItems(this._orderedMenuItems.left);
    }
  }
};

scout.MenuBar.prototype._updateDefaultMenuInItems = function(items) {
  var found = false;
  items.some(function(item) {
    if (item.visible && item.enabled && this._isDefaultKeyStroke(item.actionKeyStroke)) {
      this.setDefaultMenu(item);
      this.setTabbableMenu(item);
      found = true;
      return true;
    }
  }.bind(this));
  return found;
};

scout.MenuBar.prototype.setDefaultMenu = function(defaultMenu) {
  if (this.defaultMenu === defaultMenu) {
    return;
  }
  if (this.defaultMenu && this.defaultMenu.rendered) {
    this.defaultMenu.$container.removeClass('default-menu');
  }
  this._setProperty('defaultMenu', defaultMenu);
  if (this.defaultMenu && this.defaultMenu.rendered) {
    this.defaultMenu.$container.addClass('default-menu');
  }
};

/**
 * Add class 'left-of-button' to every menu item which is on the left of a button
 */
scout.MenuBar.prototype.updateLeftOfButtonMarker = function() {
  this._updateLeftOfButtonMarker(this._orderedMenuItems.left);
  this._updateLeftOfButtonMarker(this._orderedMenuItems.right);
};

scout.MenuBar.prototype._updateLeftOfButtonMarker = function(items) {
  var item, previousItem;

  items = items.filter(function(item) {
    return item.visible && item.rendered;
  });

  for (var i = 0; i < items.length; i++) {
    item = items[i];
    item.$container.removeClass('left-of-button');
    if (i > 0 && item.isButton()) {
      previousItem = items[i - 1];
      previousItem.$container.addClass('left-of-button');
    }
  }
};

scout.MenuBar.prototype._isDefaultKeyStroke = function(keyStroke) {
  return scout.isOneOf(scout.keys.ENTER, keyStroke.which) &&
    !keyStroke.ctrl &&
    !keyStroke.alt &&
    !keyStroke.shift;
};

scout.MenuBar.prototype._renderMenuItems = function(menuItems, right) {
  var tooltipPosition = (this.position === 'top' ? 'bottom' : 'top');
  menuItems.forEach(function(item) {
    // Ensure all all items are non-tabbable by default. One of the items will get a tabindex
    // assigned again later in updateItems().
    item.setTabbable(false);
    if (this.tabbableMenu === item) {
      this.tabbableMenu = undefined;
    }
    item.tooltipPosition = tooltipPosition;
    item.render(right ? this.$right : this.$left);
    item.$container.addClass('menubar-item');
    if (right) {
      // Mark as right-aligned
      item.rightAligned = true;
    }

    // Attach a propertyChange listener to the item, so the menubar can be updated when one of
    // its items changes (e.g. visible, keystroke etc.)
    item.on('propertyChange', this._menuItemPropertyChangeListener);
  }.bind(this));
};

scout.MenuBar.prototype._removeMenuItems = function() {
  this.menuItems.forEach(function(item) {
    item.off('propertyChange', this._menuItemPropertyChangeListener);
    item.overflow = false;
    item.remove();
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuBarLayout = function(menuBar) {
  scout.MenuBarLayout.parent.call(this);
  this._menuBar = menuBar;
};
scout.inherits(scout.MenuBarLayout, scout.AbstractLayout);

/**
 * @override AbstractLayout.js
 */
scout.MenuBarLayout.prototype.layout = function($container) {
  // check if all menu items have enough room to be displayed without ellipsis
  this._destroyEllipsis();
  this._menuBar.rebuildItemsInternal();

  // Temporarily add "overflow: hidden" to measure the available size. (The overflow
  // is not hidden in the CSS, otherwise the focus border could get cut off.)
  var oldStyle = $container.attr('style');
  $container.css('overflow', 'hidden');
  $container.css('display', 'inline-block'); // override "display: table"
  var availableWidth = $container.width();
  $container.attrOrRemove('style', oldStyle);

  var leftWidth = this._menuBar.$left.width();
  var rightWidth = this._menuBar.$right.width();

  // use availableWidth + 1 because of rounding problems in JQuery
  if (leftWidth + rightWidth <= availableWidth + 1) {
    // ok, no ellisis required
    this._menuBar.visibleMenuItems = this._menuBar.menuItems;
  } else {
    // create ellipsis menu
    this._createAndRenderEllipsis(this._menuBar.$left, rightWidth === 0);
    var ellipsisSize = scout.graphics.getSize(this._menuBar.ellipsis.$container, true);

    var remainingLeftWidth = Math.min(availableWidth - rightWidth, leftWidth);

    // right-aligned menus are never put into the overflow ellipsis-menu
    // or in other words: they're not responsive.
    // for left-aligned menus: once we notice a menu-item that does not
    // fit into the available space, all following items must also be
    // put into the overflow ellipsis-menu. Otherwise you would put
    // an item with a long text into the ellipsis-menu, but the next
    // icon, with a short text would still be in the menu-bar. Which would
    // be confusing, as it would look like we've changed the order of the
    // menu-items.
    var menuItemsCopy = [];
    var overflown = false;
    var previousMenuItem = null;
    this._menuBar.menuItems.forEach(function(menuItem) {
      if (!menuItem.visible) {
        return;
      }
      if (menuItem.rightAligned) {
        // Always add right-aligned menus
        menuItemsCopy.push(menuItem);
      } else {
        var itemSize = scout.graphics.getSize(menuItem.$container, true);
        remainingLeftWidth -= itemSize.width;
        if (overflown || remainingLeftWidth < 0) {
          // Menu does not fit -> add to ellipsis menu
          if (!overflown) {
            overflown = true;
            // Check if ellipsis menu fits, otherwise the previous menu has to be removed as well
            if (previousMenuItem && remainingLeftWidth + itemSize.width - ellipsisSize.width < 0) {
              this._removeMenuItem(previousMenuItem);
            }
          }
          this._removeMenuItem(menuItem);
        } else {
          // Menu fits, add to normal menu list
          menuItemsCopy.push(menuItem);
        }
        previousMenuItem = menuItem;
      }
    }, this);

    this._addEllipsisToMenuItems(menuItemsCopy);
    this._menuBar.visibleMenuItems = menuItemsCopy;
  }

  this._menuBar.visibleMenuItems.forEach(function(menuItem) {
    // Make sure open popups are at the correct position after layouting
    if (menuItem.popup) {
      menuItem.popup.position();
    }
  });
};

scout.MenuBarLayout.prototype._removeMenuItem = function(menuItem) {
  menuItem.remove();
  menuItem.overflow = true;
  this._menuBar.ellipsis.childActions.push(menuItem);
};

scout.MenuBarLayout.prototype._addEllipsisToMenuItems = function(menuItems) {
  // Add the ellipsis menu to the menu-items list. Order matters because we do not sort
  // menu-items again.
  var insertItemAt = 0;
  menuItems.some(function(menuItem, i) {
    if (menuItem.rightAligned) {
      return true; // break
    }
    insertItemAt = i + 1;
    return false; // keep looking
  });
  scout.arrays.insert(menuItems, this._menuBar.ellipsis, insertItemAt);
};

scout.MenuBarLayout.prototype._createAndRenderEllipsis = function($container, lastMenuInBar) {
  var ellipsis = scout.create('Menu', {
    parent: this._menuBar,
    horizontalAlignment: 1,
    iconId: scout.icons.ELLIPSIS_V,
    tabbable: false
  });
  ellipsis.render($container);
  if (lastMenuInBar) {
    ellipsis.$container.addClass('last');
  }
  this._menuBar.ellipsis = ellipsis;
};

scout.MenuBarLayout.prototype._destroyEllipsis = function() {
  if (this._menuBar.ellipsis) {
    this._menuBar.ellipsis.destroy();
    this._menuBar.ellipsis = null;
  }
};

scout.MenuBarLayout.prototype.preferredLayoutSize = function($container) {
  // Menubar has an absolute css height set -> useCssSize = true
  return scout.graphics.prefSize($container, {
    useCssSize: true
  });
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * @memberOf scout.MenuBarLayout
 */
scout.MenuBarLayout.size = function(htmlMenuBar, containerSize) {
  var menuBarSize = htmlMenuBar.getPreferredSize();
  menuBarSize.width = containerSize.width;
  menuBarSize = menuBarSize.subtract(htmlMenuBar.getMargins());
  return menuBarSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuBarLeftKeyStroke = function(menuBar) {
  scout.MenuBarLeftKeyStroke.parent.call(this);
  this.field = menuBar;
  this.which = [scout.keys.LEFT];
  this.renderingHints.render = false;
  this.stopPropagation = true;
  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
};
scout.inherits(scout.MenuBarLeftKeyStroke, scout.KeyStroke);

scout.MenuBarLeftKeyStroke.prototype.handle = function(event) {
  var menuItems = this.field.visibleMenuItems,
    $menuItemFocused = this.field.$container.find(':focus'),
    i, menuItem, lastValidItem;

  for (i = 0; i < menuItems.length; i++) {
    menuItem = menuItems[i];
    if ($menuItemFocused[0] === menuItem.$container[0]) {
      if (lastValidItem) {
        this.field.setTabbableMenu(lastValidItem);
        this.field.session.focusManager.requestFocus(lastValidItem.$container);
      }
      break;
    }
    if (menuItem.isTabTarget()) {
      lastValidItem = menuItem;
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MenuBarRightKeyStroke = function(menuBar) {
  scout.MenuBarRightKeyStroke.parent.call(this);
  this.field = menuBar;
  this.which = [scout.keys.RIGHT];
  this.renderingHints.render = false;
  this.stopPropagation = true;
  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
};
scout.inherits(scout.MenuBarRightKeyStroke, scout.KeyStroke);

scout.MenuBarRightKeyStroke.prototype.handle = function(event) {
  var menuItems = this.field.visibleMenuItems,
    $menuItemFocused = this.field.$container.find(':focus'),
    i, menuItem, focusNext = false;

  for (i = 0; i < menuItems.length; i++) {
    menuItem = menuItems[i];
    if (focusNext && menuItem.isTabTarget()) {
      this.field.setTabbableMenu(menuItem);
      this.field.session.focusManager.requestFocus(menuItem.$container);
      break;
    }
    if ($menuItemFocused[0] === menuItem.$container[0]) {
      focusNext = true;
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * The MenuBarPopup is a special Popup that is used in the menu-bar. It is tightly coupled with a menu-item and shows a header
 * which has a different size than the popup-body.
 */
scout.MenuBarPopup = function() {
  scout.MenuBarPopup.parent.call(this);
  this.menu;
  this.$headBlueprint;
  this.ignoreEvent;
  this._headVisible = true;
};
scout.inherits(scout.MenuBarPopup, scout.ContextMenuPopup);

scout.MenuBarPopup.prototype._init = function(options) {
  options.$anchor = options.menu.$container;
  scout.MenuBarPopup.parent.prototype._init.call(this, options);

  this.menu = options.menu;
  this.$headBlueprint = this.menu.$container;
  this.ignoreEvent = options.ignoreEvent;
};

/**
 * @override ContextMenuPopup.js
 */
scout.MenuBarPopup.prototype._getMenuItems = function() {
  return this.menu.childActions || this.menu.menus;
};

/**
 * @override Popup.js
 */
scout.MenuBarPopup.prototype.close = function(event) {
  if (!event || !this.ignoreEvent || event.originalEvent !== this.ignoreEvent.originalEvent) {
    scout.MenuBarPopup.parent.prototype.close.call(this, event);
  }
};

/**
 * @override PopupWithHead.js
 */
scout.MenuBarPopup.prototype._renderHead = function() {
  scout.MenuBarPopup.parent.prototype._renderHead.call(this);

  // FIXME awe: throws exception if this.menu is a button because button is not rendered (MenuButtonAdapter is)
  if (this.menu.$container.parent().hasClass('main-menubar')) {
    this.$head.addClass('in-main-menubar');
  }

  if (this.menu.uiCssClass) {
    this._copyCssClassToHead(this.menu.uiCssClass);
  }
  this._copyCssClassToHead('unfocusable');
  this._copyCssClassToHead('button');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
// FIXME awe: (calendar) check bug reported from Michael: switch month when items are still loading (async)
scout.Calendar = function() {
  scout.Calendar.parent.call(this);

  // main elements
  this.$container;
  this.$header;
  this.$range;
  this.$modes;
  this.$grid;
  this.$list;
  this.$progress;

  // additional modes; should be stored in model
  this._showYearPanel = false;
  this._showListPanel = false;

  /**
   * The narrow view range is different from the regular view range.
   * It contains only dates that exactly match the requested dates,
   * the regular view range contains also dates from the first and
   * next month. The exact range is not sent to the server.
   */
  this._exactRange;

  /**
   * When the list panel is shown, this list contains the scout.CalenderListComponent
   * items visible on the list.
   */
  this._listComponents = [];

  this._addAdapterProperties(['components', 'menus', 'selectedComponent']);
};
scout.inherits(scout.Calendar, scout.Widget);

scout.Calendar.prototype.init = function(model, session, register) {
  scout.Calendar.parent.prototype.init.call(this, model, session, register);

  this._tooltipSupport = new scout.TooltipSupport({
    parent: this,
    htmlEnabled: true
  });
};

/**
 * Enum providing display-modes for calender-like components like calendar and planner.
 * @see ICalendarDisplayMode.java
 */
scout.Calendar.DisplayMode = {
  DAY: 1,
  WEEK: 2,
  MONTH: 3,
  WORK_WEEK: 4
};

/**
 * Used as a multiplier in date calculations back- and forward (in time).
 */
scout.Calendar.Direction = {
  BACKWARD: -1,
  FORWARD: 1
};

scout.Calendar.prototype._isDay = function() {
  return this.displayMode === scout.Calendar.DisplayMode.DAY;
};

scout.Calendar.prototype._isWeek = function() {
  return this.displayMode === scout.Calendar.DisplayMode.WEEK;
};

scout.Calendar.prototype._isMonth = function() {
  return this.displayMode === scout.Calendar.DisplayMode.MONTH;
};

scout.Calendar.prototype._isWorkWeek = function() {
  return this.displayMode === scout.Calendar.DisplayMode.WORK_WEEK;
};

/**
 * @override
 */
scout.Calendar.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

scout.Calendar.prototype._init = function(model) {
  scout.Calendar.parent.prototype._init.call(this, model);
  this._yearPanel = scout.create('YearPanel', {
    parent: this
  });
  this._yearPanel.on('dateSelect', this._onYearPanelDateSelect.bind(this));
  this._syncSelectedDate(model.selectedDate);
  this._syncDisplayMode(model.displayMode);
  this._exactRange = this._calcExactRange();
  this._yearPanel.setViewRange(this._exactRange);
  this.viewRange = this._calcViewRange();
};

scout.Calendar.prototype._syncSelectedDate = function(date) {
  date = scout.dates.ensure(date);
  this._setProperty('selectedDate', date);
  this._yearPanel.selectDate(this.selectedDate);
};

scout.Calendar.prototype._syncDisplayMode = function(displayMode) {
  this._setProperty('displayMode', displayMode);
  this._yearPanel.setDisplayMode(this.displayMode);
};

scout.Calendar.prototype._syncViewRange = function(viewRange) {
  viewRange = scout.DateRange.ensure(viewRange);
  this._setProperty('viewRange', viewRange);
};

scout.Calendar.prototype._syncMenus = function(menus) {
  this._setProperty('menus', menus);
  // FIXME awe: (calendar) here we should update the menu-bar (see Table.js)
  $.log.debug('(Calendar#_syncMenus) impl.');
};

scout.Calendar.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('calendar');

  var layout = new scout.CalendarLayout(this);
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(layout);
  this.htmlComp.pixelBasedSizing = false;

  // main elements
  this.$header = this.$container.appendDiv('calendar-header');
  this._yearPanel.render(this.$container);

  this.$grid = this.$container.appendDiv('calendar-grid');
  this.$list = this.$container.appendDiv('calendar-list-container').appendDiv('calendar-list');
  this.$listTitle = this.$list.appendDiv('calendar-list-title');

  // header contains all controls
  this.$range = this.$header.appendDiv('calendar-range');
  this.$range.appendDiv('calendar-previous').click(this._onClickPrevious.bind(this));
  this.$range.appendDiv('calendar-today', this.session.text('ui.CalendarToday')).click(this._onClickToday.bind(this));
  this.$range.appendDiv('calendar-next').click(this._onClickNext.bind(this));
  this.$range.appendDiv('calendar-select');

  this.$progress = this.$header.appendDiv('busyindicator-label');

  // ... and modes
  this.$commands = this.$header.appendDiv('calendar-commands');
  this.$commands.appendDiv('calendar-mode first', this.session.text('ui.CalendarDay')).attr('data-mode', scout.Calendar.DisplayMode.DAY).click(this._onClickDisplayMode.bind(this));
  this.$commands.appendDiv('calendar-mode', this.session.text('ui.CalendarWorkWeek')).attr('data-mode', scout.Calendar.DisplayMode.WORK_WEEK).click(this._onClickDisplayMode.bind(this));
  this.$commands.appendDiv('calendar-mode', this.session.text('ui.CalendarWeek')).attr('data-mode', scout.Calendar.DisplayMode.WEEK).click(this._onClickDisplayMode.bind(this));
  this.$commands.appendDiv('calendar-mode last', this.session.text('ui.CalendarMonth')).attr('data-mode', scout.Calendar.DisplayMode.MONTH).click(this._onClickDisplayMode.bind(this));
  this.$commands.appendDiv('calendar-toggle-year').click(this._onClickYear.bind(this));
  this.$commands.appendDiv('calendar-toggle-list').click(this._onClickList.bind(this));

  // append the main grid
  for (var w = 0; w < 7; w++) {
    var $w = this.$grid.appendDiv();
    if (w === 0) {
      $w.addClass('calendar-week-header');
    } else {
      $w.addClass('calendar-week');
    }

    for (var d = 0; d < 8; d++) {
      var $d = $w.appendDiv();
      if (w === 0 && d === 0) {
        $d.addClass('calendar-week-name');
      } else if (w === 0 && d > 0) {
        $d.addClass('calendar-day-name');
      } else if (w > 0 && d === 0) {
        $d.addClass('calendar-week-name');
      } else if (w > 0 && d > 0) {
        // FIXME awe: (calendar) we must also select the clicked day and update the model
        $d.addClass('calendar-day')
          .data('day', d)
          .data('week', w)
          .on('contextmenu', this._onDayContextMenu.bind(this));
      }
    }
  }

  // click event on all day and children elements
  $('.calendar-day', this.$grid).mousedown(this._onMousedownDay.bind(this));
  this._updateScreen(false);
};

scout.Calendar.prototype._renderProperties = function() {
  scout.Calendar.parent.prototype._renderProperties.call(this);
  this._renderComponents();
  this._renderSelectedComponent();
  this._renderLoadInProgress();
  this._renderDisplayMode();
  this._renderSelectedDate();
  this._renderViewRange();
};

scout.Calendar.prototype._renderComponents = function() {
  this.components.sort(this._sortFromTo);
  this.components.forEach(function(component) {
    component.remove();
    component.render(this.$container);
  });

  this._arrangeComponents();
  this._updateListPanel();
};

scout.Calendar.prototype._renderSelectedComponent = function() {
  $.log.debug('(Calendar#_renderSelectedComponent)');
  if (this.selectedComponent) {
    this.selectedComponent.setSelected(true);
  }
};

scout.Calendar.prototype._renderLoadInProgress = function() {
  this.$progress.setVisible(this.loadInProgress);
};

scout.Calendar.prototype._renderViewRange = function() {
  $.log.debug('(Calendar#_renderViewRange) impl.');
};

scout.Calendar.prototype._renderDisplayMode = function() {
  $.log.debug('(Calendar#_renderDisplayMode) impl.');
};

scout.Calendar.prototype._renderSelectedDate = function() {
  $.log.debug('(Calendar#_renderSelectedDate) impl.');
};

scout.Calendar.prototype._removeMenus = function() {
  // menubar takes care about removal
};

/* -- basics, events -------------------------------------------- */

scout.Calendar.prototype._onClickPrevious = function(event) {
  this._navigateDate(scout.Calendar.Direction.BACKWARD);
};

scout.Calendar.prototype._onClickNext = function(event) {
  this._navigateDate(scout.Calendar.Direction.FORWARD);
};

scout.Calendar.prototype._dateParts = function(date, modulo) {
  var parts = {
    year: date.getFullYear(),
    month: date.getMonth(),
    date: date.getDate(),
    day: date.getDay()
  };
  if (modulo) {
    parts.day = (date.getDay() + 6) % 7;
  }
  return parts;
};

scout.Calendar.prototype._navigateDate = function(direction) {
  this.selectedDate = this._calcSelectedDate(direction);
  this._updateModel(false);
};

scout.Calendar.prototype._calcSelectedDate = function(direction) {
  var p = this._dateParts(this.selectedDate),
    dayOperand = direction,
    weekOperand = direction * 7,
    monthOperand = direction;

  if (this._isDay()) {
    return new Date(p.year, p.month, p.date + dayOperand);
  } else if (this._isWeek() || this._isWorkWeek()) {
    return new Date(p.year, p.month, p.date + weekOperand);
  } else if (this._isMonth()) {
    return scout.dates.shift(this.selectedDate, 0, monthOperand, 0);
  }
};

scout.Calendar.prototype._updateModel = function(animate) {
  this._exactRange = this._calcExactRange();
  this._yearPanel.setViewRange(this._exactRange);
  this.viewRange = this._calcViewRange();
  this.trigger('modelChanged');
  this._updateScreen(animate);
};

/**
 * Calculates exact date range of displayed components based on selected-date.
 */
scout.Calendar.prototype._calcExactRange = function() {
  var from, to,
    p = this._dateParts(this.selectedDate, true);

  if (this._isDay()) {
    from = new Date(p.year, p.month, p.date);
    to = new Date(p.year, p.month, p.date + 1);
  } else if (this._isWeek()) {
    from = new Date(p.year, p.month, p.date - p.day);
    to = new Date(p.year, p.month, p.date - p.day + 6);
  } else if (this._isMonth()) {
    from = new Date(p.year, p.month, 1);
    to = new Date(p.year, p.month + 1, 0);
  } else if (this._isWorkWeek()) {
    from = new Date(p.year, p.month, p.date - p.day);
    to = new Date(p.year, p.month, p.date - p.day + 4);
  } else {
    throw new Error('invalid value for displayMode');
  }

  return new scout.DateRange(from, to);
};

/**
 * Calculates the view-range, which is what the user sees in the UI.
 * The view-range is wider than the exact-range in the monthly mode,
 * as it contains also dates from the previous and next month.
 */
scout.Calendar.prototype._calcViewRange = function() {
  var viewFrom = calcViewFromDate(this._exactRange.from),
    viewTo = calcViewToDate(viewFrom);
  return new scout.DateRange(viewFrom, viewTo);

  function calcViewFromDate(fromDate) {
    var i, tmpDate = new Date(fromDate.valueOf());
    for (i = 0; i < 42; i++) {
      tmpDate.setDate(tmpDate.getDate() - 1);
      if ((tmpDate.getDay() === 1) && tmpDate.getMonth() !== fromDate.getMonth()) {
        return tmpDate;
      }
    }
    throw new Error('failed to calc viewFrom date');
  }

  function calcViewToDate(fromDate) {
    var i, tmpDate = new Date(fromDate.valueOf());
    for (i = 0; i < 42; i++) {
      tmpDate.setDate(tmpDate.getDate() + 1);
    }
    return tmpDate;
  }
};

scout.Calendar.prototype._onClickToday = function(event) {
  this.selectedDate = new Date();
  this._updateModel(false);
};

scout.Calendar.prototype._onClickDisplayMode = function(event) {
  var p, displayMode,
    oldDisplayMode = this.displayMode;

  displayMode = $(event.target).data('mode');
  if (oldDisplayMode !== displayMode) {
    this.displayMode = displayMode;
    this._yearPanel.setDisplayMode(displayMode);
    if (this._isWorkWeek()) {
      // change date if selectedDate is on a weekend
      p = this._dateParts(this.selectedDate, true);
      if (p.day > 4) {
        this.selectedDate = new Date(p.year, p.month, p.date - p.day + 4);
      }
    }
    this._updateModel(true);

    // only render if components has other layout
    if (oldDisplayMode === scout.Calendar.DisplayMode.MONTH || this.displayMode === scout.Calendar.DisplayMode.MONTH) {
      this._renderComponents();
    }
  }
};

scout.Calendar.prototype._onClickYear = function(event) {
  this._showYearPanel = !this._showYearPanel;
  this._updateScreen(true);
};
scout.Calendar.prototype._onClickList = function(event) {
  this._showListPanel = !this._showListPanel;
  this._updateScreen(true);
};

scout.Calendar.prototype._onMousedownDay = function(event) {
  // we cannot use event.stopPropagation() in CalendarComponent.js because this would
  // prevent context-menus from being closed. With this awkward if-statement we only
  // process the event, when it is not bubbling up from somewhere else (= from mousedown
  // event on component).
  if (event.eventPhase === Event.AT_TARGET) {
    var selectedDate = $(event.delegateTarget).data('date');
    this._setSelection(selectedDate, null);
  }
};

/**
 * @param selectedDate
 * @param selectedComponent may be null when a day is selected
 */
scout.Calendar.prototype._setSelection = function(selectedDate, selectedComponent) {
  var changed = false;

  // selected date
  if (scout.dates.compare(this.selectedDate, selectedDate) !== 0) {
    changed = true;
    $('.calendar-day', this.$container).each(function(index, element) {
      var $day = $(element),
        date = $day.data('date');
      if (scout.dates.compare(date, this.selectedDate) === 0) {
        $day.select(false); // de-select old date
      } else if (scout.dates.compare(date, selectedDate) === 0) {
        $day.select(true); // select new date
      }
    }.bind(this));
    this.selectedDate = selectedDate;
  }

  // selected component / part (may be null)
  if (this.selectedComponent !== selectedComponent) {
    changed = true;
    if (this.selectedComponent) {
      this.selectedComponent.setSelected(false);
    }
    if (selectedComponent) {
      selectedComponent.setSelected(true);
    }
    this.selectedComponent = selectedComponent;
  }

  if (changed) {
    this.trigger('selectionChanged');
    this._updateListPanel();
  }

  if (this._showYearPanel) {
    this._yearPanel.selectDate(this.selectedDate);
  }
};

/* --  set display mode and range ------------------------------------- */

scout.Calendar.prototype._updateScreen = function(animate) {
  $.log.info('(Calendar#_updateScreen)');

  // select mode
  $('.calendar-mode', this.$commands).select(false);
  $('[data-mode="' + this.displayMode + '"]', this.$modes).select(true);

  // remove selected day
  $('.selected', this.$grid).select(false);

  // layout grid
  this.layoutLabel();
  this.layoutSize(animate);
  this.layoutAxis();

  if (this._showYearPanel) {
    this._yearPanel.selectDate(this.selectedDate);
  }

  this._updateListPanel();
};

scout.Calendar.prototype.layoutSize = function(animate) {
  // reset animation sizes
  $('div', this.$container).removeData(['new-width', 'new-height']);

  // init vars
  var $selected = $('.selected', this.$grid),
    headerH = this.$header.height(),
    gridH = this.$grid.height(),
    gridW = this.$container.width();

  // show or hide year
  $('.calendar-toggle-year', this.$modes).select(this._showYearPanel);
  if (this._showYearPanel) {
    this._yearPanel.$container.data('new-width', 215);
    gridW -= 215;
  } else {
    this._yearPanel.$container.data('new-width', 0);
  }

  // show or hide work list
  $('.calendar-toggle-list', this.$modes).select(this._showListPanel);
  if (this._showListPanel) {
    this.$list.parent().data('new-width', 270);
    gridW -= 270;
  } else {
    this.$list.parent().data('new-width', 0);
  }

  // basic grid width
  this.$grid.data('new-width', gridW);

  // layout week
  if (this._isDay() || this._isWeek() || this._isWorkWeek()) {
    $('.calendar-week', this.$grid).data('new-height', 0);
    $selected.parent().data('new-height', gridH - headerH);
  } else {
    $('.calendar-week', this.$grid).data('new-height', parseInt((gridH - headerH) / 6, 10));
  }

  // layout days
  if (this._isDay()) {
    $('.calendar-day-name, .calendar-day', this.$grid)
      .data('new-width', 0);
    $('.calendar-day-name:nth-child(' + ($selected.index() + 1) + '), .calendar-day:nth-child(' + ($selected.index() + 1) + ')', this.$grid)
      .data('new-width', gridW - headerH);
  } else if (this._isWorkWeek()) {
    $('.calendar-day-name, .calendar-day', this.$grid)
      .data('new-width', 0);
    $('.calendar-day-name:nth-child(-n+6), .calendar-day:nth-child(-n+6)', this.$grid)
      .data('new-width', parseInt((gridW - headerH) / 5, 10));
  } else if (this._isMonth() || this._isWeek()) {
    $('.calendar-day-name, .calendar-day', this.$grid)
      .data('new-width', parseInt((gridW - headerH) / 7, 10));
  }

  // set day-name (based on width of shown column)
  var width = this.$container.width(),
    weekdays;

  if (this._isDay()) {
    width /= 1;
  } else if (this._isWorkWeek()) {
    width /= 5;
  } else if (this._isWeek()) {
    width /= 7;
  } else if (this._isMonth()) {
    width /= 7;
  }

  if (width > 100) {
    weekdays = this.session.locale.dateFormat.symbols.weekdaysOrdered;
  } else {
    weekdays = this.session.locale.dateFormat.symbols.weekdaysShortOrdered;
  }

  $('.calendar-day-name', this.$grid).each(function(index) {
    $(this).attr('data-day-name', weekdays[index]);
  });

  // animate old to new sizes
  $('div', this.$container).each(function() {
    var $e = $(this),
      w = $e.data('new-width'),
      h = $e.data('new-height');

    if (w !== undefined && w !== $e.outerWidth()) {
      if (animate) {
        $e.animateAVCSD('width', w);
      } else {
        $e.css('width', w);
      }
    }
    if (h !== undefined && h !== $e.outerHeight()) {
      if (animate) {
        $e.animateAVCSD('height', h);
      } else {
        $e.css('height', h);
      }
    }
  });
};

scout.Calendar.prototype.layoutYearPanel = function() {
  if (this._showYearPanel) {
    scout.scrollbars.update(this._yearPanel.$yearList);
    this._yearPanel._scrollYear();
  }
};

scout.Calendar.prototype.layoutLabel = function() {
  var text, $dates,
    exFrom = this._exactRange.from,
    exTo = this._exactRange.to;

  // set range text
  if (this._isDay()) {
    text = this._format(exFrom, 'd. MMMM yyyy');
  } else if (this._isWorkWeek() || this._isWeek()) {
    var toText = this.session.text('ui.to');
    if (exFrom.getMonth() === exTo.getMonth()) {
      text = scout.strings.join(' ', this._format(exFrom, 'd.'), toText, this._format(exTo, 'd. MMMM yyyy'));
    } else if (exFrom.getFullYear() === exTo.getFullYear()) {
      text = scout.strings.join(' ', this._format(exFrom, 'd. MMMM'), toText, this._format(exTo, 'd. MMMM yyyy'));
    } else {
      text = scout.strings.join(' ', this._format(exFrom, 'd. MMMM yyyy'), toText, this._format(exTo, 'd. MMMM yyyy'));
    }

  } else if (this._isMonth()) {
    text = this._format(exFrom, 'MMMM yyyy');
  }
  $('.calendar-select', this.$range).text(text);

  // prepare to set all day date and mark selected one
  $dates = $('.calendar-day', this.$grid);

  var w, d, cssClass,
    currentMonth = this._exactRange.from.getMonth(),
    date = new Date(this.viewRange.from.valueOf());

  // loop all days and set value and class
  for (w = 0; w < 6; w++) {
    for (d = 0; d < 7; d++) {
      cssClass = '';
      if ((date.getDay() === 6) || (date.getDay() === 0)) {
        cssClass = date.getMonth() !== currentMonth ? ' weekend-out' : ' weekend';
      } else {
        cssClass = date.getMonth() !== currentMonth ? ' out' : '';
      }
      if (scout.dates.isSameDay(date, new Date())) {
        cssClass += ' now';
      }
      if (scout.dates.isSameDay(date, this.selectedDate)) {
        cssClass += ' selected';
      }

      // adjust position for days between 10 and 19 (because "1" is narrower than "0" or "2")
      if (date.getDate() > 9 && date.getDate() < 20) {
        cssClass += ' center-nice';
      }

      text = this._format(date, 'dd');
      $dates.eq(w * 7 + d)
        .removeClass('weekend-out weekend out selected now')
        .addClass(cssClass)
        .attr('data-day-name', text)
        .data('date', new Date(date.valueOf()));
      date.setDate(date.getDate() + 1);
    }
  }
};

scout.Calendar.prototype.layoutAxis = function() {
  var $e, $selected = $('.selected', this.$grid);

  // remove old axis
  $('.calendar-week-axis, .calendar-week-task', this.$grid).remove();

  // set weekname
  var session = this.session;
  $('.calendar-week-name', this.$container).each(function(index) {
    if (index > 0) {
      $e = $(this);
      $e.text(session.text('ui.CW', scout.dates.weekInYear($e.next().data('date'))));
    }
  });

  // day schedule
  if (!this._isMonth()) {
    var $parent = $selected.parent();
    $parent.appendDiv('calendar-week-axis').attr('data-axis-name', '08:00').css('top', this._dayPosition(8) + '%');
    $parent.appendDiv('calendar-week-axis').attr('data-axis-name', '12:00').css('top', this._dayPosition(12) + '%');
    $parent.appendDiv('calendar-week-axis').attr('data-axis-name', '13:00').css('top', this._dayPosition(13) + '%');
    $parent.appendDiv('calendar-week-axis').attr('data-axis-name', '17:00').css('top', this._dayPosition(17) + '%');
    $parent.appendDiv('calendar-week-task').attr('data-axis-name', session.text('ui.CalendarDay')).css('top', this._dayPosition(-1) + '%');
  }
};

/* -- year events ---------------------------------------- */

scout.Calendar.prototype._onYearPanelDateSelect = function(event) {
  this.selectedDate = event.date;
  this._updateModel(false);
};

scout.Calendar.prototype._updateListPanel = function() {
  if (this._showListPanel) {

    // remove old list-components
    this._listComponents.forEach(function(listComponent) {
      listComponent.remove();
    });

    this._listComponents = [];
    this._renderListPanel();
  }
};

/**
 * Renders the panel on the left, showing all components of the selected date.
 */
scout.Calendar.prototype._renderListPanel = function() {
  var listComponent, components = [];

  // set title
  this.$listTitle.text(this._format(this.selectedDate, 'd. MMMM yyyy'));

  // find components to display on the list panel
  this.components.forEach(function(component) {
    if (belongsToSelectedDate.call(this, component)) {
      components.push(component);
    }
  }.bind(this));

  // work with for-loop instead of forEach because of return statement
  function belongsToSelectedDate(component) {
    var i, date;
    for (i = 0; i < component.coveredDays.length; i++) {
      date = scout.dates.parseJsonDate(component.coveredDays[i]);
      if (scout.dates.isSameDay(this.selectedDate, date)) {
        return true;
      }
    }
    return false;
  }

  components.forEach(function(component) {
    listComponent = new scout.CalendarListComponent(this.selectedDate, component);
    listComponent.render(this.$list);
    this._listComponents.push(listComponent);
  }.bind(this));
};

/* -- components, events-------------------------------------------- */

scout.Calendar.prototype._selectedComponentChanged = function(component, partDay) {
  this._setSelection(partDay, component);
};

scout.Calendar.prototype._onDayContextMenu = function(event) {
  this._showContextMenu(event, 'Calendar.EmptySpace');
};

scout.Calendar.prototype._showContextMenu = function(event, allowedType) {
  event.preventDefault();
  event.stopPropagation();

  var func = function func(event, allowedType) {
    var filteredMenus = scout.menus.filter(this.menus, [allowedType], true),
      $part = $(event.currentTarget);
    if (filteredMenus.length === 0) {
      return;
    }
    var popup = scout.create('ContextMenuPopup', {
      parent: this,
      menuItems: filteredMenus,
      location: {
        x: event.pageX,
        y: event.pageY
      },
      $anchor: $part
    });
    popup.open();
  }.bind(this);

  scout.menus.showContextMenuWithWait(this.session, func, event, allowedType);
};

/* -- components, arrangement------------------------------------ */

// TODO awe, cru: (calendar) arrange methods should work on the model, not on the DOM
scout.Calendar.prototype._arrangeComponents = function() {
  var k, $day, $children, dayComponents, day,
    $days = $('.calendar-day', this.$grid);

  for (k = 0; k < $days.length; k++) {
    $day = $days.eq(k);
    $children = $day.children('.calendar-component:not(.component-task)');
    day = $day.data('date');

    if (this._isMonth() && $children.length > 2) {
      $day.addClass('many-items');
    } else if (!this._isMonth() && $children.length > 1) {
      // logical placement
      dayComponents = this._getComponents($children);
      this._arrange(dayComponents, day);

      // screen placement
      this._arrangeComponentSetPlacement($children, day);
    }
  }
};

scout.Calendar.prototype._getComponents = function($children) {
  var i, $child;
  var components = [];
  for (i = 0; i < $children.length; i++) {
    $child = $children.eq(i);
    components.push($child.data('component'));
  }
  return components;
};

scout.Calendar.prototype._sort = function(components) {
  components.sort(this._sortFromTo);
};

/**
 * Arrange components (stack width, stack index) per day
 * */
scout.Calendar.prototype._arrange = function(components, day) {
  var i, j, c, r, k,
    rows = [];

  //ordered by from, to
  this._sort(components);

  //clear existing placement
  for (i = 0; i < components.length; i++) {
    c = components[i];
    if (!c.stack) {
      c.stack = {};
    }
    c.stack[day] = {};
  }

  for (i = 0; i < components.length; i++) {
    c = components[i];
    r = c.getPartDayPosition(day);

    //reduce number of rows, if all components end before this one
    if (rows.length > 0 && this._allEndBefore(rows, r.from, day)) {
      rows = [];
    }

    //replace an component that ends before and can be replaced
    k = this._findReplacableRow(rows, r.from, day);

    //insert
    if (k >= 0) {
      rows[k] = c;
      c.stack[day].x = k;
    } else {
      rows.push(c);
      c.stack[day].x = rows.length - 1;
    }

    //update stackW
    for (j = 0; j < rows.length; j++) {
      rows[j].stack[day].w = rows.length;
    }
  }
};

scout.Calendar.prototype._allEndBefore = function(rows, pos, day) {
  var i;
  for (i = 0; i < rows.length; i++) {
    if (!this._endsBefore(rows[i], pos, day)) {
      return false;
    }
  }
  return true;
};

scout.Calendar.prototype._findReplacableRow = function(rows, pos, day) {
  var j;
  for (j = 0; j < rows.length; j++) {
    if (this._endsBefore(rows[j], pos, day)) {
      return j;
    }
  }
  return -1;
};

scout.Calendar.prototype._endsBefore = function(component, pos, day) {
  return component.getPartDayPosition(day).to <= pos;
};

scout.Calendar.prototype._arrangeComponentSetPlacement = function($children, day) {
  var i, $child, stack;

  // loop and place based on data
  for (i = 0; i < $children.length; i++) {
    $child = $children.eq(i);
    stack = $child.data('component').stack[day];

    // make last element smaller
    $child
      .css('width', 100 / stack.w + '%')
      .css('left', stack.x * 100 / stack.w + '%');
  }
};

/* -- helper ---------------------------------------------------- */

scout.Calendar.prototype._dayPosition = function(hour) {
  var pos;
  if (hour < 0) {
    pos = 85;
  } else if (hour < 8) {
    pos = hour / 8 * 10 + 5;
  } else if (hour < 12) {
    pos = (hour - 8) / 4 * 25 + 15;
  } else if (hour < 13) {
    pos = (hour - 12) / 1 * 5 + 40;
  } else if (hour < 17) {
    pos = (hour - 13) / 4 * 25 + 45;
  } else if (hour <= 24) {
    pos = (hour - 17) / 7 * 10 + 70;
  }
  return Math.round(pos * 100) / 100;
};

scout.Calendar.prototype._hourToNumber = function(hour) {
  var splits = hour.split(':');
  return parseFloat(splits[0]) + parseFloat(splits[1]) / 60;
};

scout.Calendar.prototype._format = function(date, pattern) {
  return scout.dates.format(date, this.session.locale, pattern);
};

scout.Calendar.prototype._sortFromTo = function(c1, c2) {
  var from1 = scout.dates.parseJsonDate(c1.fromDate);
  var from2 = scout.dates.parseJsonDate(c2.fromDate);
  var dFrom = scout.dates.compare(from1, from2);
  if (dFrom !== 0) {
    return dFrom;
  }
  var to1 = scout.dates.parseJsonDate(c1.toDate);
  var to2 = scout.dates.parseJsonDate(c2.toDate);
  return scout.dates.compare(to1, to2);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CalendarAdapter = function() {
  scout.CalendarAdapter.parent.call(this);
};
scout.inherits(scout.CalendarAdapter, scout.ModelAdapter);

/**
 * We must send the view-range to the client-model on the server. The view-range is determined by the UI.
 * Thus the calendar cannot be completely initialized without the view-range from the UI.
 * @override ModelAdapter.js
 */
scout.CalendarAdapter.prototype._postCreateWidget = function() {
  this._sendViewRangeChanged();
};

/**
 * @override ModelAdapter.js
 */
scout.CalendarAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'viewRangeChanged') {
    this._sendViewRangeChanged();
  } else if (event.type === 'modelChanged') {
    this._sendModelChanged();
  } else if (event.type === 'selectionChanged') {
    this._sendSelectionChanged();
  } else {
    scout.CalendarAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

scout.CalendarAdapter.prototype._jsonViewRange = function() {
  return scout.dates.toJsonDateRange(this.widget.viewRange);
};

scout.CalendarAdapter.prototype._jsonSelectedDate = function() {
  return scout.dates.toJsonDate(this.widget.selectedDate);
};

scout.CalendarAdapter.prototype._sendViewRangeChanged = function() {
  this._send('viewRangeChanged', {
    viewRange: this._jsonViewRange()
  });
};

scout.CalendarAdapter.prototype._sendModelChanged = function() {
  var data = {
    viewRange: this._jsonViewRange(),
    selectedDate: this._jsonSelectedDate(),
    displayMode: this.widget.displayMode
  };
  this._send('modelChanged', data);
};

scout.CalendarAdapter.prototype._sendSelectionChanged = function() {
  var selectedComponentId = this.widget.selectedComponent ? this.widget.selectedComponent.id : null;
  this._send('selectionChanged', {
    date: this._jsonSelectedDate(),
    componentId: selectedComponentId
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CalendarComponent = function() {
  scout.CalendarComponent.parent.call(this);

  /**
   * Selected is a GUI only property (the model doesn't have it)
   */
  this.selected = false;
  this._$parts = [];
};
scout.inherits(scout.CalendarComponent, scout.Widget);

/**
 * @override ModelAdapter.js
 */
scout.CalendarComponent.prototype._remove = function() {
  // remove $parts because they're not children of this.$container
  var tooltipSupport = this.parent._tooltipSupport;
  this._$parts.forEach(function($part) {
    tooltipSupport.uninstall($part);
    $part.remove();
  });
  scout.CalendarComponent.parent.prototype._remove.call(this);
};

scout.CalendarComponent.prototype._render = function($parent) {
  $.log.debug('(CalendarComponent#_render)');
  var i, partDay, $day, $part;

  for (i = 0; i < this.coveredDays.length; i++) {
    // check if day is in visible view range
    partDay = scout.dates.parseJsonDate(this.coveredDays[i]);
    $day = this._findDayInGrid(partDay);
    if ($day === undefined) {
      continue;
    }

    $part = $day
      .appendDiv('calendar-component', this.item.subject)
      .addClass(this.item.cssClass)
      .data('component', this)
      .data('partDay', partDay)
      .data('tooltipText', this._description.bind(this))
      .mousedown(this._onMousedown.bind(this))
      .on('contextmenu', this._onContextMenu.bind(this));
    this.parent._tooltipSupport.install($part);
    this._$parts.push($part);

    if (!this.parent._isMonth()) {
      if (this.fullDay) {
        var count = $('.component-task', $day).length;
        this._arrangeTask(1 + 26 * count);
        $part.addClass('component-task');
      } else {
        var
          fromDate = scout.dates.parseJsonDate(this.fromDate),
          toDate = scout.dates.parseJsonDate(this.toDate),
          partFrom = this._getHours(this.fromDate),
          partTo = this._getHours(this.toDate);

        // position and height depending on start and end date
        $part.addClass('component-day');
        if (this.coveredDays.length === 1) {
          this._partPosition($part, partFrom, partTo);
        } else if (scout.dates.isSameDay(partDay, fromDate)) {
          this._partPosition($part, partFrom, 24)
            .addClass('component-open-bottom');
        } else if (scout.dates.isSameDay(partDay, toDate)) {
          this._partPosition($part, 0, partTo)
            .addClass('component-open-top');
        } else {
          this._partPosition($part, 1, 24)
            .addClass('component-open-top')
            .addClass('component-open-bottom');
        }
      }
    }
  }
};

// FIXME awe: (calendar) tuning
scout.CalendarComponent.prototype._getHours = function(date){
  var d = scout.dates.parseJsonDate(date);
  return d.getHours() + d.getMinutes() / 60;
};

scout.CalendarComponent.prototype._findDayInGrid = function(date) {
  var $day;
  $('.calendar-day', this.parent.$grid)
    .each(function() {
      if (scout.dates.isSameDay($(this).data('date'), date)) {
        $day = $(this);
        return;
      }
    });
  return $day;
};

scout.CalendarComponent.prototype._isTask = function() {
  return !this.parent._isMonth() && this.fullDay;
};

scout.CalendarComponent.prototype._arrangeTask = function(taskOffset) {
  this._$parts.forEach(function($part) {
    $part.css('top', 'calc(85% + ' + taskOffset + 'px)');
  });
};

scout.CalendarComponent.prototype._isDayPart = function() {
  return !this.parent._isMonth() && !this.fullDay;
};

scout.CalendarComponent.prototype._getHourRange = function(day){
  var hourRange = new scout.Range(this._getHours(this.fromDate), this._getHours(this.toDate));
  var dateRange = new scout.Range(scout.dates.parseJsonDate(this.fromDate), scout.dates.parseJsonDate(this.toDate));

  if (scout.dates.isSameDay(day, dateRange.from) && scout.dates.isSameDay(day, dateRange.to)) {
    return new scout.Range(hourRange.from, hourRange.to);
  } else if (scout.dates.isSameDay(day, dateRange.from)) {
    return new scout.Range(hourRange.from, 24);
  } else if (scout.dates.isSameDay(day, dateRange.to)) {
    return new scout.Range(0, hourRange.to);
  }
  return new scout.Range(0, 24);
};

scout.CalendarComponent.prototype.getPartDayPosition = function(day){
  return this._getDisplayDayPosition(this._getHourRange(day));
};

scout.CalendarComponent.prototype._getDisplayDayPosition = function(range){
  var preferredRange = new scout.Range(this.parent._dayPosition(range.from), this.parent._dayPosition(range.to));
  var minRangeSize = 2.5;
  if(preferredRange.size() < minRangeSize){
    return new scout.Range(preferredRange.from, preferredRange.from + minRangeSize);
  }
  return preferredRange;
};

scout.CalendarComponent.prototype._partPosition = function($part, y1, y2) {
  var range = new scout.Range(y1, y2);
  var r = this._getDisplayDayPosition(range);

  return $part
    .css('top', r.from + '%')
    .css('height', r.to - r.from  + '%');
};

scout.CalendarComponent.prototype._renderProperties = function() {
  scout.CalendarComponent.parent.prototype._renderProperties.call(this);
  this._renderSelected();
};

scout.CalendarComponent.prototype._renderSelected = function() {
  this._$parts.forEach(function($part) {
    $part.toggleClass('comp-selected', this.selected);
  }, this);
};

scout.CalendarComponent.prototype.setSelected = function(selected) {
  this.setProperty('selected', selected);
};

scout.CalendarComponent.prototype._onMousedown = function(event) {
  var $part = $(event.delegateTarget);
  this.parent._selectedComponentChanged(this, $part.data('partDay'));
};

scout.CalendarComponent.prototype._onContextMenu = function(event) {
  this.parent._showContextMenu(event, 'Calendar.CalendarComponent');
};

scout.CalendarComponent.prototype._format = function(date, pattern) {
  return scout.dates.format(date, this.session.locale, pattern);
};

scout.CalendarComponent.prototype._description = function() {
  var descParts = [],
    range = null,
    text = '',
    fromDate = scout.dates.parseJsonDate(this.fromDate),
    toDate = scout.dates.parseJsonDate(this.toDate);

  // subject
  if (scout.strings.hasText(this.item.subject)) {
    descParts.push({
      text: scout.strings.encode(this.item.subject),
      cssClass: 'calendar-component-title'
    });
  }

  // time-range
  if (this.fullDay) {
    // NOP
  } else if (scout.dates.isSameDay(fromDate, toDate)) {
    range = this.session.text('ui.FromXToY', this._format(fromDate, 'HH:mm'), this._format(toDate, 'HH:mm'));
  } else {
    range = this.session.text('ui.FromXToY', this._format(fromDate, 'EEEE HH:mm '), this._format(toDate, 'EEEE HH:mm'));
  }

  if (scout.strings.hasText(range)) {
    descParts.push({
      text: range,
      cssClass: 'calendar-component-intro'
    });
  }

  // description
  if (scout.strings.hasText(this.item.description)) {
    descParts.push({
      text: scout.strings.nl2br(this.item.description)
    });
  }

  // build text
  descParts.forEach(function(part) {
    text += (part.cssClass ? '<span class="' + part.cssClass + '">' + part.text + '</span>' : part.text) + '<br/>';
  });

  return text;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CalendarComponentAdapter = function() {
  scout.CalendarComponentAdapter.parent.call(this);
};
scout.inherits(scout.CalendarComponentAdapter, scout.ModelAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Calendar component as used in the list panel of the calendar.
 * Delegates most functions to the scout.CalendarComponent instance used as source.
 * It's important we clean-up the registered listeners on the model-adapter, since
 * new instances of CalendarListComponent are created every time we click on a date
 * in the calendar, but the CalendarComponent instance is always the same.
 */
scout.CalendarListComponent = function(partDay, source) {
  this.partDay = partDay;
  this.source = source;
  this.$container;
  this._selectedListener = source.on('selected', function(event) {
    this.$container.toggleClass('comp-selected', event.selected);
  }.bind(this));
  this._removeListener = source.on('remove', this.remove.bind(this));
};

scout.CalendarListComponent.prototype.render = function($parent) {
  var source = this.source;
  this.$container = $parent
    .appendDiv('calendar-component')
    .data('partDay', this.partDay)
    .addClass(source.item.cssClass)
    .toggleClass('comp-selected', source._selected)
    .mousedown(source._onMousedown.bind(source))
    .on('contextmenu', source._onContextMenu.bind(source))
    .html(source._description());
};

scout.CalendarListComponent.prototype.remove = function() {
  this.source.removeListener(this._selectedListener);
  this.source.removeListener(this._removeListener);
  this.$container.remove();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CalendarLayout = function(calendar) {
  scout.CalendarLayout.parent.call(this);
  this.calendar = calendar;
};
scout.inherits(scout.CalendarLayout, scout.AbstractLayout);

scout.CalendarLayout.prototype.layout = function($container) {
  var height = 0, headerHeight = 0,
    $yearContainer = this.calendar._yearPanel.$container,
    $grid = this.calendar.$grid,
    $header = this.calendar.$header;

  height += $container.cssMarginTop() + $container.cssMarginBottom();
  $container.css('height', 'calc(100% - ' + height + 'px)');

  headerHeight = $header.outerHeight(true);
  $yearContainer.css('height', 'calc(100% - ' + (headerHeight + $yearContainer.cssMarginY()) + 'px)');
  $grid.css('height', 'calc(100% - ' + (headerHeight + $grid.cssMarginY()) + 'px)');

  this.calendar.layoutSize();
  this.calendar.layoutYearPanel();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DateRange = function(from, to) {
  this.from = from;
  this.to = to;
};

scout.DateRange.prototype.equals = function(other) {
  if (!other) {
    return false;
  }
  return scout.dates.equals(this.from, other.from) &&
    scout.dates.equals(this.to, other.to);
};

scout.DateRange.prototype.toString = function() {
  return 'scout.DateRange[' +
    'from=' + (this.from === null ? 'null' : this.from.toUTCString()) +
    ' to=' + (this.to === null ? 'null' : this.to.toUTCString()) + ']';
};

scout.DateRange.ensure = function(dateRange) {
  if (!dateRange) {
    return dateRange;
  }
  if (dateRange instanceof scout.DateRange) {
    return dateRange;
  }
  return new scout.DateRange(
    scout.dates.ensure(dateRange.from),
    scout.dates.ensure(dateRange.to));
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.YearPanel = function() {
  scout.YearPanel.parent.call(this);

  this.$container;
  this.$yearTitle;
  this.$yearList;
  this.selectedDate;
  this.displayMode;
  this.alwaysSelectFirstDay;
};
scout.inherits(scout.YearPanel, scout.Widget);

scout.YearPanel.prototype._init = function(model) {
  scout.YearPanel.parent.prototype._init.call(this, model);

  // If true, it is only possible to select the first day of a range, depending of the selected mode
  // day mode: every day may be selected
  // week, work week, calendar week mode: only first day of week may be selected
  // year, month mode: only first day of month may be selected
  this.alwaysSelectFirstDay = model.alwaysSelectFirstDay;
};

scout.YearPanel.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('year-panel-container');
  this.$yearTitle = this.$container.appendDiv('year-panel-title');
  this.$yearList = this.$container.appendDiv('year-panel-list');
};

scout.YearPanel.prototype.renderContent = function() {
  this.removeContent();
  this._drawYear();
  scout.scrollbars.install(this.$yearList, {
    parent: this,
    axis: 'y'
  });
  this.yearRendered = true;
  this._colorYear();
};

scout.YearPanel.prototype.removeContent = function() {
  scout.scrollbars.uninstall(this.$yearList, this.session);
  this.$yearList.empty();
  this.yearRendered = false;
};

scout.YearPanel.prototype._remove = function() {
  this.removeContent();
  scout.YearPanel.parent.prototype._remove.call(this);
};

scout.YearPanel.prototype._drawYear = function() {
  var first, month, $month, d, day, $day,
    year = this.selectedDate.getFullYear();

  // append 3 years
  this.$yearTitle
    .data('year', year)
    .empty();

  this.$yearTitle.appendDiv('year-title-item', year - 1)
    .data('year-diff', -1)
    .click(this._onYearClick.bind(this));

  this.$yearTitle.appendDiv('year-title-item selected', year);

  this.$yearTitle.appendDiv('year-title-item', year + 1)
    .data('year-diff', +1)
    .click(this._onYearClick.bind(this));

  // add months and days
  for (month = 0; month < 12; month++) {
    first = new Date(year, month, 1);
    $month = this.$yearList.appendDiv('year-month').attr('data-title', this._format(first, 'MMMM'));
    for (d = 1; d <= 31; d++) {
      day = new Date(year, month, d);

      // stop if day is already out of range
      if (day.getMonth() !== month) {
        break;
      }

      // add div per day
      $day = $month.appendDiv('year-day', d).data('date', day);

      if (day.getDay() === 0 || day.getDay() === 6) {
        $day.addClass('weekend');
      }

      // first day has margin depending on weekday
      if (d === 1) {
        $day.css('margin-left', ((day.getDay() + 6) % 7) * $day.outerWidth());
      }
    }
  }

  // bind events for days divs
  $('.year-day', this.$yearList)
    .click(this._onYearDayClick.bind(this))
    .hover(this._onYearHoverIn.bind(this), this._onYearHoverOut.bind(this));

  // update scrollbar
  scout.scrollbars.update(this.$yearList);
};

scout.YearPanel.prototype._colorYear = function() {
  if (!this.yearRendered) {
    return;
  }

  // remove color information
  $('.year-day.year-range, .year-day.year-range-day', this.$yearList).removeClass('year-range year-range-day');

  // loop all days and colorize based on range and selected
  var that = this,
    $day, date;

  $('.year-day', this.$yearList).each(function() {
    $day = $(this);
    date = $day.data('date');
    if (that.displayMode !== scout.Calendar.DisplayMode.DAY &&
        date >= that.viewRange.from && date < that.viewRange.to) {
      $day.addClass('year-range');
    }
    if (scout.dates.isSameDay(date, that.selectedDate)) {
      $day.addClass('year-range-day');
    }
  });

  // selected has to be visible day
  this._scrollYear();
};

scout.YearPanel.prototype._scrollYear = function() {
  var top, halfMonth, halfYear,
    $day = $('.year-range-day', this.$yearList),
    $month = $day.parent(),
    $year = $day.parent().parent();

  if (!$month[0]) {
    return;
  }
  top = $month[0].offsetTop;
  halfMonth = $month.outerHeight() / 2;
  halfYear = $year.outerHeight() / 2;

  this.$yearList.animateAVCSD('scrollTop', top + halfMonth - halfYear);
};

scout.YearPanel.prototype._format = function(date, pattern) {
  return scout.dates.format(date, this.session.locale, pattern);
};

scout.YearPanel.prototype.selectDate = function(date) {
  this.selectedDate = date;

  if (this.rendered) {
    // If year shown and changed, redraw year
    if (!date || date.getFullYear() !== this.$yearTitle.data('year')) {
      this.renderContent();
    }
    this._colorYear();
  }
};

scout.YearPanel.prototype.setDisplayMode = function(displayMode) {
  if (displayMode === this.displayMode) {
    return;
  }
  this._setProperty('displayMode', displayMode);
  if (this.rendered) {
    this._colorYear();
  }
};

scout.YearPanel.prototype.setViewRange = function(viewRange) {
  if (viewRange === this.viewRange) {
    return;
  }
  this._setProperty('viewRange', viewRange);
  if (this.rendered) {
    this._colorYear();
  }
};

/* -- events ---------------------------------------- */

scout.YearPanel.prototype._onYearClick = function(event) {
  var
    // we must use Planner.DisplayMode (extends Calendar.DisplayMode) here
    // because YearPanel must work for calendar and planner.
    displayMode = scout.Planner.DisplayMode,
    diff = $(event.target).data('year-diff'),
    year = this.selectedDate.getFullYear(),
    month = this.selectedDate.getMonth(),
    date = this.selectedDate.getDate(),
    newDate = new Date(year + diff, month, date),
    oldWeek,
    newWeek,
    weekDiff;

  if (this.alwaysSelectFirstDay) {
    // find date based on mode
    if (scout.isOneOf(this.displayMode, displayMode.WEEK, displayMode.WORK_WEEK, displayMode.CALENDAR_WEEK)) {
      oldWeek = scout.dates.weekInYear(this.selectedDate);
      newWeek = scout.dates.weekInYear(newDate);
      weekDiff = oldWeek - newWeek;
      // shift new selection that week in year does not change and the new selection is a monday.
      newDate = scout.dates.shift(newDate, 0, 0, weekDiff * 7);
      newDate = scout.dates.shiftToNextOrPrevMonday(newDate, 0);
    } else if (scout.isOneOf(this.displayMode, displayMode.MONTH, displayMode.YEAR)) {
      // set to first day of month
      newDate = new Date(year + diff, month, 1);
    }
  }

  this.selectedDate = newDate;
  this.trigger('dateSelect', {
    date: this.selectedDate
  });
};

scout.YearPanel.prototype._onYearDayClick = function(event) {
  this.selectedDate = $('.year-hover-day', this.$yearList).data('date');
  if (this.selectedDate) {
    this.trigger('dateSelect', {
      date: this.selectedDate
    });
  }
};

scout.YearPanel.prototype._onYearHoverIn = function(event) {
  var $day = $(event.target),
    date1 = $day.data('date'),
    year = date1.getFullYear(),
    month = date1.getMonth(),
    date = date1.getDate(),
    day = (date1.getDay() + 6) % 7,
    startHover,
    endHover,
    $day2, date2;

  // find hover based on mode
  if (this.displayMode === scout.Calendar.DisplayMode.DAY) {
    startHover = new Date(year, month, date);
    endHover = new Date(year, month, date);
  } else if (this.displayMode === scout.Calendar.DisplayMode.WEEK) {
    startHover = new Date(year, month, date - day);
    endHover = new Date(year, month, date - day + 6);
  } else if (this.displayMode === scout.Calendar.DisplayMode.WORK_WEEK) {
    startHover = new Date(year, month, date - day);
    endHover = new Date(year, month, date - day + 4);

    // don't allow selecting a weekend day
    if (date1 > endHover) {
      date1 = endHover;
    }
  } else if (this.displayMode === scout.Calendar.DisplayMode.MONTH) {
    startHover = new Date(year, month, 1);
    endHover = new Date(year, month + 1, 0);
  } else if (this.displayMode === scout.Planner.DisplayMode.YEAR) {
    startHover = new Date(year, month, 1);
    endHover = startHover;
  } else {
    startHover = new Date(year, month, date - day);
    endHover = startHover;
  }

  if (this.alwaysSelectFirstDay) {
    date1 = startHover;
  }

  // loop days and colorize based on hover start and hover end
  $('.year-day', this.$yearList).each(function() {
    $day2 = $(this);
    date2 = $day2.data('date');
    if (date2 >= startHover && date2 <= endHover) {
      $day2.addClass('year-hover');
    } else {
      $day2.removeClass('year-hover');
    }
    if (scout.dates.isSameDay(date1, date2)) {
      $day2.addClass('year-hover-day');
    }
  });
};

// remove all hover effects
scout.YearPanel.prototype._onYearHoverOut = function(event) {
  $('.year-day.year-hover, .year-day.year-hover-day', this.$yearList).removeClass('year-hover year-hover-day');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Planner = function() {
  scout.Planner.parent.call(this);

  this.resourceMap = [];
  this.activityMap = [];
  this.availableDisplayModes = [];
  this.resources = [];
  this.viewRange = {};
  this.selectionRange = new scout.DateRange();
  this.selectedResources = [];

  // visual
  this._resourceTitleWidth = 20;

  // main elements
  this.$container;
  this.$range;
  this.$modes;
  this.$grid;

  // scale calculator
  this.transformLeft = function(t) {
    return t;
  };
  this.transformWidth = function(t0, t1) {
    return (t1 - t0);
  };

  this.yearPanelVisible = false;
  this._addAdapterProperties(['menus']);
};
scout.inherits(scout.Planner, scout.Widget);

scout.Planner.Direction = {
  BACKWARD: -1,
  FORWARD: 1
};

/**
 * Enum providing display-modes for planner (extends calendar).
 * @see IPlannerDisplayMode.java
 */
scout.Planner.DisplayMode = $.extend({
  CALENDAR_WEEK: 5,
  YEAR: 6
}, scout.Calendar.DisplayMode);

scout.Planner.SelectionMode = {
  NONE: 0,
  SINGLE_RANGE: 1,
  MULTI_RANGE: 2
};

/**
 * @override
 */
scout.Planner.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

scout.Planner.prototype._init = function(model) {
  scout.Planner.parent.prototype._init.call(this, model);
  this._yearPanel = scout.create('YearPanel', {
    parent: this,
    alwaysSelectFirstDay: true
  });
  this._yearPanel.on('dateSelect', this._onYearPanelDateSelect.bind(this));
  this._header = scout.create('PlannerHeader', {
    parent: this
  });
  this._header.on('todayClick', this._onTodayClick.bind(this));
  this._header.on('yearClick', this._onYearClick.bind(this));
  this._header.on('previousClick', this._onPreviousClick.bind(this));
  this._header.on('nextClick', this._onNextClick.bind(this));
  this._header.on('displayModeClick', this._onDisplayModeClick.bind(this));
  this.menuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.PlannerMenuItemsOrder(this.session, 'Planner')
  });
  this.menuBar.bottom();
  for (var i = 0; i < this.resources.length; i++) {
    this._initResource(this.resources[i]);
  }
  this._syncDisplayMode(this.displayMode);
  this._syncAvailableDisplayModes(this.availableDisplayModes);
  this._syncViewRange(this.viewRange);
  this._syncSelectedResources(this.selectedResources);
  this._syncSelectedActivity(this.selectedActivity);
  this._syncSelectionRange(this.selectionRange);
  this._syncMenus(this.menus);

  this._tooltipSupport = new scout.TooltipSupport({
    parent: this,
    arrowPosition: 50
  });

};

scout.Planner.prototype._initResource = function(resource) {
  scout.defaultValues.applyTo(resource, 'Resource');
  resource.activities.forEach(function(activity) {
    this._initActivity(activity);
  }, this);
  this.resourceMap[resource.id] = resource;
};

scout.Planner.prototype._initActivity = function(activity) {
  activity.beginTime = scout.dates.parseJsonDate(activity.beginTime);
  activity.endTime = scout.dates.parseJsonDate(activity.endTime);
  scout.defaultValues.applyTo(activity, 'Activity');
  this.activityMap[activity.id] = activity;
};

scout.Planner.prototype._render = function($parent) {
  // basics, layout etc.
  this.$container = $parent.appendDiv('planner');
  var layout = new scout.PlannerLayout(this);
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(layout);
  this.htmlComp.pixelBasedSizing = false;

  // main elements
  this._header.render(this.$container);
  this._yearPanel.render(this.$container);
  this.$grid = this.$container.appendDiv('planner-grid')
    .on('mousedown', '.resource-cells', this._onCellMousedown.bind(this))
    .on('mousedown', '.resource-title', this._onResourceTitleMousedown.bind(this))
    .on('contextmenu', '.resource-title', this._onResourceTitleContextMenu.bind(this))
    .on('contextmenu', '.planner-activity', this._onActivityContextMenu.bind(this));
  this.$scale = this.$container.appendDiv('planner-scale');
  this.menuBar.render(this.$container);

  scout.tooltips.install(this.$grid, {
    parent: this,
    selector: '.planner-activity',
    text: function($comp) {
      if (this._activityById($comp.attr('data-id'))) {
        return this._activityById($comp.attr('data-id')).tooltipText;
      } else {
        return undefined;
      }
    }.bind(this)
  });

  scout.scrollbars.install(this.$grid, {
    parent: this
  });
  this._gridScrollHandler = this._onGridScroll.bind(this);
  this.$grid.on('scroll', this._gridScrollHandler);
};

scout.Planner.prototype._renderProperties = function() {
  scout.Planner.parent.prototype._renderProperties.call(this);

  this._renderViewRange();
  this._renderHeaderVisible();
  this._renderYearPanelVisible(false);
  this._renderResources();
  this._renderSelectedActivity();
  this._renderSelectedResources();
  // render with setTimeout because the planner needs to be layouted first
  setTimeout(this._renderSelectionRange.bind(this));
};

scout.Planner.prototype._remove = function() {
  scout.scrollbars.uninstall(this.$grid, this.session);
  scout.Planner.parent.prototype._remove.call(this);
};

/* -- basics, events -------------------------------------------- */

scout.Planner.prototype._onPreviousClick = function(event) {
  this._navigateDate(scout.Planner.Direction.BACKWARD);
};

scout.Planner.prototype._onNextClick = function(event) {
  this._navigateDate(scout.Planner.Direction.FORWARD);
};

scout.Planner.prototype._navigateDate = function(direction) {
  var viewRange = new scout.DateRange(this.viewRange.from, this.viewRange.to),
    displayMode = scout.Planner.DisplayMode;

  if (this.displayMode === displayMode.DAY) {
    viewRange.from = scout.dates.shift(this.viewRange.from, 0, 0, direction);
    viewRange.to = scout.dates.shift(this.viewRange.to, 0, 0, direction);
  } else if (scout.isOneOf(this.displayMode, displayMode.WEEK, displayMode.WORK_WEEK)) {
    viewRange.from = scout.dates.shift(this.viewRange.from, 0, 0, direction * 7);
    viewRange.from = scout.dates.ensureMonday(viewRange.from, -1 * direction);
    viewRange.to = scout.dates.shift(this.viewRange.to, 0, 0, direction * 7);
  } else if (this.displayMode === displayMode.MONTH) {
    viewRange.from = scout.dates.shift(this.viewRange.from, 0, direction, 0);
    viewRange.from = scout.dates.ensureMonday(viewRange.from, -1 * direction);
    viewRange.to = scout.dates.shift(this.viewRange.to, 0, direction, 0);
  } else if (this.displayMode === displayMode.CALENDAR_WEEK) {
    viewRange.from = scout.dates.shift(this.viewRange.from, 0, direction, 0);
    viewRange.from = scout.dates.ensureMonday(viewRange.from, -1 * direction);
    viewRange.to = scout.dates.shift(this.viewRange.to, 0, direction, 0);
  } else if (this.displayMode === displayMode.YEAR) {
    viewRange.from = scout.dates.shift(this.viewRange.from, 0, 3 * direction, 0);
    viewRange.to = scout.dates.shift(this.viewRange.to, 0, 3 * direction, 0);
  }

  this.setViewRange(viewRange);
};

scout.Planner.prototype._onTodayClick = function(event) {
  var today = new Date(),
    year = today.getFullYear(),
    month = today.getMonth(),
    date = today.getDate(),
    day = (today.getDay() + 6) % 7,
    displayMode = scout.Planner.DisplayMode;

  if (this.displayMode === displayMode.DAY) {
    today = new Date(year, month, date);
  } else if (this.displayMode === displayMode.YEAR) {
    today = new Date(year, month, 1);
  } else {
    today = new Date(year, month, date - day);
  }

  this.setViewRangeFrom(today);
};

scout.Planner.prototype._onDisplayModeClick = function(event) {
  var displayMode = event.displayMode;
  this.setDisplayMode(displayMode);
};

scout.Planner.prototype._onYearClick = function(event) {
  this.setYearPanelVisible(!this.yearPanelVisible);
};

scout.Planner.prototype._onYearPanelDateSelect = function(event) {
  this.setViewRangeFrom(event.date);
};

scout.Planner.prototype._onResourceTitleMousedown = function(event) {
  var $resource = $(event.target).parent();
  if ($resource.isSelected()) {
    if (event.which === 3 || event.which === 1 && event.ctrlKey) {
      // Right click on an already selected resource must not clear the selection -> context menu will be opened
      return;
    }
  }
  this.startRow = $resource.data('resource');
  this.lastRow = this.startRow;
  this._select();
};

scout.Planner.prototype._onResourceTitleContextMenu = function(event) {
  this._showContextMenu(event, 'Planner.Resource');
};

scout.Planner.prototype._onRangeSelectorContextMenu = function(event) {
  this._showContextMenu(event, 'Planner.Range');
};

scout.Planner.prototype._onActivityContextMenu = function(event) {
  this._showContextMenu(event, 'Planner.Activity');
};

scout.Planner.prototype._showContextMenu = function(event, allowedType) {
  event.preventDefault();
  event.stopPropagation();
  var func = function func(event, allowedType) {
    var filteredMenus = this._filterMenus([allowedType]),
      $part = $(event.currentTarget);
    if (filteredMenus.length === 0) {
      return; // at least one menu item must be visible
    }
    var popup = scout.create('ContextMenuPopup', {
      parent: this,
      menuItems: filteredMenus,
      location: {
        x: event.pageX,
        y: event.pageY
      },
      $anchor: $part
    });
    popup.open();
  }.bind(this);

  scout.menus.showContextMenuWithWait(this.session, func, event, allowedType);
};

scout.Planner.prototype._onGridScroll = function() {
  this._reconcileScrollPos();
};

scout.Planner.prototype._reconcileScrollPos = function() {
  // When scrolling horizontally scroll scale as well
  var scrollLeft = this.$grid.scrollLeft();
  this.$scale.scrollLeft(scrollLeft);
};

scout.Planner.prototype._renderRange = function() {
  if (!this.viewRange.from || !this.viewRange.to) {
    return;
  }
  var text,
    toDate = new Date(this.viewRange.to.valueOf() - 1),
    toText = this.session.text('ui.to'),
    displayMode = scout.Planner.DisplayMode;

  // find range text
  if (scout.dates.isSameDay(this.viewRange.from, toDate)) {
    text = this._dateFormat(this.viewRange.from, 'd. MMMM yyyy');
  } else if (this.viewRange.from.getMonth() === toDate.getMonth() && this.viewRange.from.getFullYear() === toDate.getFullYear()) {
    text = scout.strings.join(' ', this._dateFormat(this.viewRange.from, 'd.'), toText, this._dateFormat(toDate, 'd. MMMM yyyy'));
  } else if (this.viewRange.from.getFullYear() === toDate.getFullYear()) {
    if (this.displayMode === displayMode.YEAR) {
      text = scout.strings.join(' ', this._dateFormat(this.viewRange.from, 'MMMM'), toText, this._dateFormat(toDate, 'MMMM yyyy'));
    } else {
      text = scout.strings.join(' ', this._dateFormat(this.viewRange.from, 'd.  MMMM'), toText, this._dateFormat(toDate, 'd. MMMM yyyy'));
    }
  } else {
    if (this.displayMode === displayMode.YEAR) {
      text = scout.strings.join(' ', this._dateFormat(this.viewRange.from, 'MMMM yyyy'), toText, this._dateFormat(toDate, 'MMMM yyyy'));
    } else {
      text = scout.strings.join(' ', this._dateFormat(this.viewRange.from, 'd.  MMMM yyyy'), toText, this._dateFormat(toDate, 'd. MMMM yyyy'));
    }
  }

  // set text
  $('.planner-select', this._header.$range).text(text);
};

scout.Planner.prototype._renderScale = function() {
  if (!this.viewRange.from || !this.viewRange.to) {
    return;
  }
  var width,
    that = this,
    displayMode = scout.Planner.DisplayMode;

  // empty scale
  this.$scale.empty();
  this.$grid.children('.planner-small-scale-item-line').remove();
  this.$grid.children('.planner-large-scale-item-line').remove();

  // append main elements
  this.$scaleTitle = this.$scale.appendDiv('planner-scale-title');
  this._renderLabel();
  this.$timeline = this.$scale.appendDiv('timeline');
  this.$timelineLarge = this.$timeline.appendDiv('timeline-large');
  this.$timelineSmall = this.$timeline.appendDiv('timeline-small');

  // fill timeline large depending on mode
  if (this.displayMode === displayMode.DAY) {
    this._renderDayScale();
  } else if (scout.isOneOf(this.displayMode, displayMode.WORK_WEEK, displayMode.WEEK)) {
    this._renderWeekScale();
  } else if (this.displayMode === displayMode.MONTH) {
    this._renderMonthScale();
  } else if (this.displayMode === displayMode.CALENDAR_WEEK) {
    this._renderCalendarWeekScale();
  } else if (this.displayMode === displayMode.YEAR) {
    this._renderYearScale();
  }

  // set sizes and append scale lines
  var $smallScaleItems = this.$timelineSmall.children('.scale-item');
  var $largeScaleItems = this.$timelineLarge.children('.scale-item');
  width = 100 / $smallScaleItems.length;
  $largeScaleItems.each(function() {
    var $scaleItem = $(this);
    $scaleItem.css('width', $scaleItem.data('count') * width + '%')
      .data('scale-item-line', that.$grid.appendDiv('planner-large-scale-item-line'));
    $scaleItem.appendDiv('planner-large-scale-item-line')
      .css('left', 0);
  });
  $smallScaleItems.each(function(index) {
    var $scaleItem = $(this);
    $scaleItem.css('width', width + '%');
    if (!$scaleItem.data('first')) {
      var $lineGrid = that.$grid.appendDiv('planner-small-scale-item-line');
      $scaleItem.data('scale-item-line', $lineGrid);
      var $lineScale = $scaleItem.appendDiv('planner-small-scale-item-line').css('left', 0);
      if ($scaleItem.hasClass('label-invisible')) {
        $lineGrid.addClass('first-in-range');
        $lineScale.addClass('first-in-range');
      }
    }
  });

  // find transfer function
  this.beginScale = this.$timelineSmall.children().first().data('date-from').valueOf();
  this.endScale = this.$timelineSmall.children().last().data('date-to').valueOf();

  if (scout.isOneOf(this.displayMode, displayMode.WORK_WEEK, displayMode.WEEK)) {
    var options = this.displayModeOptions[this.displayMode];
    var interval = options.interval;
    var firstHourOfDay = options.firstHourOfDay;
    var lastHourOfDay = options.lastHourOfDay;

    this.transformLeft = function(begin, end, firstHour, lastHour, interval) {
      return function(t) {
        t = new Date(t);
        begin = new Date(begin);
        end = new Date(end);
        var fullRangeMillis = end - begin;
        // remove day component from range for scaling
        var dayDiffTBegin = scout.dates.compareDays(t, begin);
        var dayDIffEndBegin = scout.dates.compareDays(end, begin);
        var dayComponentMillis = dayDiffTBegin * 3600000 * 24;
        var rangeScaling = (24 / (lastHour - firstHour + 1));
        // re-add day component
        var dayOffset = dayDiffTBegin / dayDIffEndBegin;
        return ((t.valueOf() - (begin.valueOf() + firstHour * 3600000) - dayComponentMillis) * rangeScaling / fullRangeMillis + dayOffset) * 100;
      };
    }(this.viewRange.from, this.viewRange.to, firstHourOfDay, lastHourOfDay, interval);

    this.transformWidth = function(begin, end, firstHour, lastHour, interval) {
      return function(t0, t1) {
        t0 = new Date(t0);
        t1 = new Date(t1);
        var fullRangeMillis = end - begin;
        var selectedRangeMillis = t1 - t0;
        var dayDiffT1T0 = scout.dates.compareDays(t1, t0);
        var hiddenRangeMillis = (dayDiffT1T0 * (24 - (lastHour + 1) + firstHour) * 3600000);
        var rangeScaling = (24 / (lastHour - firstHour + 1));
        return ((selectedRangeMillis - hiddenRangeMillis) * rangeScaling) / fullRangeMillis * 100;
      };
    }(this.viewRange.from, this.viewRange.to, firstHourOfDay, lastHourOfDay, interval);
  } else {
    this.transformLeft = function(begin, end) {
      return function(t) {
        return (t - begin) / (end - begin) * 100;
      };
    }(this.beginScale, this.endScale);

    this.transformWidth = function(begin, end) {
      return function(t0, t1) {
        return (t1 - t0) / (end - begin) * 100;
      };
    }(this.beginScale, this.endScale);
  }
};

scout.Planner.prototype._renderDayScale = function() {
  var newLargeGroup, $divLarge, $divSmall,
    first = true;
  var loop = new Date(this.viewRange.from.valueOf());

  var options = this.displayModeOptions[this.displayMode];
  var interval = options.interval;
  var labelPeriod = options.labelPeriod;
  var firstHourOfDay = options.firstHourOfDay;
  var lastHourOfDay = options.lastHourOfDay;

  // cap interval to day range
  interval = Math.min(interval, 60 * (lastHourOfDay - firstHourOfDay + 1));

  // from start to end
  while (loop < this.viewRange.to) {
    if (loop.getHours() >= firstHourOfDay && loop.getHours() <= lastHourOfDay) {
      newLargeGroup = false;
      if (loop.getMinutes() === 0 || first) {
        $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'HH')).data('count', 0);
        newLargeGroup = true;
      }

      $divSmall = this.$timelineSmall
        .appendDiv('scale-item', this._dateFormat(loop, ':mm'))
        .data('date-from', new Date(loop.valueOf()));

      // hide label
      if ((loop.getMinutes() % (interval * labelPeriod)) !== 0) {
        $divSmall.addClass('label-invisible');
      }

      // increase variables
      loop = scout.dates.shiftTime(loop, 0, interval, 0);
      this._incrementTimelineScaleItems($divLarge, $divSmall, loop, newLargeGroup);
      first = false;
    } else {
      loop = scout.dates.shiftTime(loop, 0, interval, 0);
    }
  }
};

scout.Planner.prototype._renderWeekScale = function() {
  var newLargeGroup, $divLarge, $divSmall,
    first = true;
  var loop = new Date(this.viewRange.from.valueOf());

  var options = this.displayModeOptions[this.displayMode];
  var interval = options.interval;
  var labelPeriod = options.labelPeriod;
  var firstHourOfDay = options.firstHourOfDay;
  var lastHourOfDay = options.lastHourOfDay;

  // cap interval to day range
  interval = Math.min(interval, 60 * (lastHourOfDay - firstHourOfDay + 1));

  // from start to end
  while (loop < this.viewRange.to) {
    newLargeGroup = false;
    if (loop.getHours() < firstHourOfDay) {
      loop.setHours(firstHourOfDay);
    }

    if (loop.getHours() === firstHourOfDay && loop.getMinutes() === 0 || first) {
      if (loop.getMonth() === 0 || first) {
        $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'd. MMMM yyyy')).data('count', 0);
      } else if (loop.getDate() === 1) {
        $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'd. MMMM')).data('count', 0);
      } else {
        $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'd.')).data('count', 0);
      }
      newLargeGroup = true;
    }

    $divSmall = this.$timelineSmall
      .appendDiv('scale-item', this._dateFormat(loop, 'HH:mm'))
      .data('date-from', new Date(loop.valueOf()));

    // hide label
    if (((loop.getHours() - firstHourOfDay) * 60 + loop.getMinutes()) % (interval * labelPeriod) !== 0) {
      $divSmall.addClass('label-invisible');
    }

    // increase variables
    loop = scout.dates.shiftTime(loop, 0, interval, 0, 0);
    this._incrementTimelineScaleItems($divLarge, $divSmall, loop, newLargeGroup);
    first = false;

    if (loop.getHours() > lastHourOfDay) {
      // jump to next day
      loop.setHours(0);
      loop.setMinutes(0);
      loop.setDate(loop.getDate() + 1);
    }
  }
};

scout.Planner.prototype._renderMonthScale = function() {
  var newLargeGroup, $divLarge, $divSmall,
    first = true;
  var loop = new Date(this.viewRange.from.valueOf());

  var options = this.displayModeOptions[this.displayMode];
  var labelPeriod = options.labelPeriod;

  // from start to end
  while (loop < this.viewRange.to) {
    newLargeGroup = false;
    if (loop.getDate() === 1 || first) {
      if (loop.getMonth() === 0 || first) {
        $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'MMMM yyyy')).data('count', 0);
      } else {
        $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'MMMM')).data('count', 0);
      }
      newLargeGroup = true;
    }

    $divSmall = this.$timelineSmall
      .appendDiv('scale-item', this._dateFormat(loop, 'dd'))
      .data('date-from', new Date(loop.valueOf()));

    // hide label
    if (loop.getDate() % labelPeriod !== 0) {
      $divSmall.addClass('label-invisible');
    }

    loop = scout.dates.shift(loop, 0, 0, 1);
    this._incrementTimelineScaleItems($divLarge, $divSmall, loop, newLargeGroup);
    first = false;
  }

};

scout.Planner.prototype._renderCalendarWeekScale = function() {
  var newLargeGroup, $divLarge, $divSmall,
    first = true;
  var loop = new Date(this.viewRange.from.valueOf());

  var options = this.displayModeOptions[this.displayMode];
  var labelPeriod = options.labelPeriod;

  // from start to end
  while (loop < this.viewRange.to) {
    newLargeGroup = false;
    if (loop.getDate() < 8 || first === true) {
      if (loop.getMonth() === 0 || first === true) {
        if (loop.getDate() > 11) {
          $divLarge = this.$timelineLarge.appendDiv('scale-item').html('&nbsp;').data('count', 0);
          first = 2;
        } else {
          $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'MMMM yyyy')).data('count', 0);
          first = false;
        }
      } else {
        if (first === 2) {
          $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'MMMM yyyy')).data('count', 0);
          first = false;
        } else {
          $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'MMMM')).data('count', 0);
        }
      }
      newLargeGroup = true;
    }

    $divSmall = this.$timelineSmall
      .appendDiv('scale-item', scout.dates.weekInYear(loop))
      .data('date-from', new Date(loop.valueOf()))
      .data('tooltipText', this._scaleTooltipText.bind(this));
    this._tooltipSupport.install($divSmall);

    // hide label
    if (scout.dates.weekInYear(loop) % labelPeriod !== 0) {
      $divSmall.addClass('label-invisible');
    }

    loop.setDate(loop.getDate() + 7);
    this._incrementTimelineScaleItems($divLarge, $divSmall, loop, newLargeGroup);
  }
};

scout.Planner.prototype._renderYearScale = function() {
  var newLargeGroup, $divLarge, $divSmall,
    first = true;
  var loop = new Date(this.viewRange.from.valueOf());

  var options = this.displayModeOptions[this.displayMode];
  var labelPeriod = options.labelPeriod;

  // from start to end
  while (loop < this.viewRange.to) {
    newLargeGroup = false;
    if (loop.getMonth() === 0 || first) {
      $divLarge = this.$timelineLarge.appendDiv('scale-item', this._dateFormat(loop, 'yyyy')).data('count', 0);
      newLargeGroup = true;
    }

    $divSmall = this.$timelineSmall
      .appendDiv('scale-item', this._dateFormat(loop, 'MMMM'))
      .data('date-from', new Date(loop.valueOf()));

    // hide label
    if (loop.getMonth() % labelPeriod !== 0) {
      $divSmall.addClass('label-invisible');
    }

    loop = scout.dates.shift(loop, 0, 1, 0);
    this._incrementTimelineScaleItems($divLarge, $divSmall, loop, newLargeGroup);
    first = false;
  }
};

scout.Planner.prototype._incrementTimelineScaleItems = function($largeComp, $smallComp, newDate, newLargeGroup) {
  $largeComp.data('count', $largeComp.data('count') + 1);

  $smallComp.data('date-to', new Date(newDate.valueOf()))
    .data('first', newLargeGroup);
};

/* -- scale events --------------------------------------------------- */

scout.Planner.prototype._scaleTooltipText = function($scale) {
  var toText = ' ' + this.session.text('ui.to') + ' ',
    from = new Date($scale.data('date-from').valueOf()),
    to = new Date($scale.data('date-to').valueOf() - 1);

  if (from.getMonth() === to.getMonth()) {
    return this._dateFormat(from, 'd.') + toText + this._dateFormat(to, 'd. MMMM yyyy');
  } else if (from.getFullYear() === to.getFullYear()) {
    return this._dateFormat(from, 'd. MMMM') + toText + this._dateFormat(to, 'd. MMMM yyyy');
  } else {
    return this._dateFormat(from, 'd. MMMM yyyy') + toText + this._dateFormat(to, 'd. MMMM yyyy');
  }
};

/* --  render resources, activities --------------------------------- */

scout.Planner.prototype._removeAllResources = function() {
  this.resources.forEach(function(resource) {
    resource.$resource.remove();
  });
};

scout.Planner.prototype._renderResources = function(resources) {
  var i, resource,
    resourcesHtml = '';

  resources = resources || this.resources;
  for (i = 0; i < resources.length; i++) {
    resource = resources[i];
    resourcesHtml += this._buildResourceHtml(resource, this.$grid);
  }

  // Append resources to grid
  $(resourcesHtml).appendTo(this.$grid);

  // Match resources
  this.$grid.children('.planner-resource').each(function(index, element) {
    var $element = $(element);
    resource = this._resourceById($element.attr('data-id'));
    this._linkResource($element, resource);
    this._linkActivitiesForResource(resource);
  }.bind(this));
};

scout.Planner.prototype._linkResource = function($resource, resource) {
  $resource.data('resource', resource);
  resource.$resource = $resource;
  resource.$cells = $resource.children('.resource-cells');
};

scout.Planner.prototype._linkActivity = function($activity, activity) {
  $activity.data('activity', activity);
  activity.$activity = $activity;
};

scout.Planner.prototype._rerenderActivities = function(resources) {
  resources = resources || this.resources;
  resources.forEach(function(resource) {
    this._removeActivititesForResource(resource);
    this._renderActivititesForResource(resource);
  }, this);
};

scout.Planner.prototype._buildResourceHtml = function(resource) {
  var resourceHtml = '<div class="planner-resource" data-id="' + resource.id + '">';
  resourceHtml += '<div class="resource-title">' + scout.strings.encode(resource.resourceCell.text || '') + '</div>';
  resourceHtml += '<div class="resource-cells">' + this._buildActivitiesHtml(resource) + '</div>';
  resourceHtml += '</div>';
  return resourceHtml;
};

scout.Planner.prototype._renderActivititesForResource = function(resource) {
  resource.$cells.html(this._buildActivitiesHtml(resource));
  this._linkActivitiesForResource(resource);
};

scout.Planner.prototype._linkActivitiesForResource = function(resource) {
  resource.$cells.children('.planner-activity').each(function(index, element) {
    var $element = $(element);
    var activity = this._activityById($element.attr('data-id'));
    this._linkActivity($element, activity);
  }.bind(this));
};

scout.Planner.prototype._buildActivitiesHtml = function(resource) {
  var activitiesHtml = '';
  resource.activities.forEach(function(activity) {
    if (activity.beginTime.valueOf() >= this.endScale ||
      activity.endTime.valueOf() <= this.beginScale) {
      // don't add activities which are not in the view range
      return;
    }
    activitiesHtml += this._buildActivityHtml(activity);
  }, this);
  return activitiesHtml;
};

scout.Planner.prototype._removeActivititesForResource = function(resource) {
  resource.activities.forEach(function(activity) {
    if (activity.$activity) {
      activity.$activity.remove();
      activity.$activity = null;
    }
  }, this);
};

scout.Planner.prototype._buildActivityHtml = function(activity) {
  var level = 100 - Math.min(activity.level * 100, 100),
    backgroundColor = scout.styles.modelToCssColor(activity.backgroundColor),
    foregroundColor = scout.styles.modelToCssColor(activity.foregroundColor),
    levelColor = scout.styles.modelToCssColor(activity.levelColor),
    begin = activity.beginTime.valueOf(),
    end = activity.endTime.valueOf();

  // Make sure activity fits into scale
  begin = Math.max(begin, this.beginScale);
  end = Math.min(end, this.endScale);

  var activityCssClass = 'planner-activity' + (activity.cssClass ? (' ' + activity.cssClass) : '');
  var activityStyle = 'left: ' + 'calc(' + this.transformLeft(begin) + '% + 2px);';
  activityStyle += ' width: ' + 'calc(' + this.transformWidth(begin, end) + '% - 4px);';

  if (levelColor) {
    activityStyle += ' background-color: ' + levelColor + ';';
    activityStyle += ' border-color: ' + levelColor + ';';
  }
  if (!levelColor && backgroundColor) {
    activityStyle += ' background-color: ' + backgroundColor + ';';
    activityStyle += ' border-color: ' + backgroundColor + ';';
  }
  if (foregroundColor) {
    activityStyle += ' foreground-color: ' + foregroundColor + ';';
  }

  // the background-color represents the fill level and not the image. This makes it easier to change the color using a css class
  activityStyle += ' background-image: ' + 'linear-gradient(to bottom, #fff 0%, #fff ' + level + '%, transparent ' + level + '%, transparent 100% );';

  var activityHtml = '<div';
  activityHtml += ' class="' + activityCssClass + '"';
  activityHtml += ' style="' + activityStyle + '"';
  activityHtml += ' data-id="' + activity.id + '"';
  activityHtml += '>' + scout.strings.encode(activity.text || '') + '</div>';
  return activityHtml;
};

/* -- selector -------------------------------------------------- */

scout.Planner.prototype._onCellMousedown = function(event) {
  var $activity,
    $resource,
    $target = $(event.target),
    selectionMode = scout.Planner.SelectionMode;

  if (this.activitySelectable) {
    $activity = this._$elementFromPoint(event.pageX, event.pageY);
    if ($activity.hasClass('planner-activity')) {
      $resource = $activity.parent().parent();
      this.selectResources([$resource.data('resource')]);
      this.selectActivity($activity.data('activity'));
      this.selectRange(new scout.DateRange());
      return;
    }
  }

  if (this.selectionMode === selectionMode.NONE) {
    return;
  }

  if ($target.hasClass('selector') && (event.which === 3 || event.which === 1 && event.ctrlKey)) {
    // Right click on the selector must not clear the selection -> context menu will be opened
    return;
  }

  // init selector
  this.startRow = this._findRow(event.pageY);
  this.lastRow = this.startRow;

  // find range on scale
  this.startRange = this._findScale(event.pageX);
  this.lastRange = this.startRange;

  // draw
  this._select(true);

  // event
  this._cellMousemoveHandler = this._onCellMousemove.bind(this);
  $target.document()
    .on('mousemove', this._cellMousemoveHandler)
    .one('mouseup', this._onDocumentMouseup.bind(this));
};

scout.Planner.prototype._onResizeMousedown = function(event) {
  var swap,
    $target = $(event.target);

  // find range on scale
  if (($target.hasClass('selector-resize-right') && this.startRange.to > this.lastRange.to) ||
    ($target.hasClass('selector-resize-left') && this.startRange.to < this.lastRange.to)) {
    swap = this.startRange;
    this.startRange = this.lastRange;
    this.lastRange = swap;
  }

  $target.body().addClass('col-resize');

  this._resizeMousemoveHandler = this._onResizeMousemove.bind(this);
  $target.document()
    .on('mousemove', this._resizeMousemoveHandler)
    .one('mouseup', this._onDocumentMouseup.bind(this));

  return false;
};

scout.Planner.prototype._onCellMousemove = function(event) {
  var lastRow = this._findRow(event.pageY);
  if (lastRow) {
    this.lastRow = lastRow;
  }
  var lastRange = this._findScale(event.pageX);
  if (lastRange) {
    this.lastRange = lastRange;
  }

  this._select(true);
};

scout.Planner.prototype._onResizeMousemove = function(event) {
  if (!this.rendered) {
    // planner may be removed in the meantime
    return;
  }
  var lastRange = this._findScale(event.pageX);
  if (lastRange) {
    this.lastRange = lastRange;
  }

  this._select(true);
};

scout.Planner.prototype._onDocumentMouseup = function(event) {
  var $target = $(event.target);
  $target.body().removeClass('col-resize');
  if (this._cellMousemoveHandler) {
    $target.document().off('mousemove', this._documentMousemoveHandler);
    this._cellMousemoveHandler = null;
  }
  if (this._resizeMousemoveHandler) {
    $target.document().off('mousemove', this._resizeMousemoveHandler);
    this._resizeMousemoveHandler = null;
  }
  if (this.rendered) {
    this._select();
  }
};

scout.Planner.prototype._select = function(whileSelecting) {
  if (!this.startRow || !this.lastRow) {
    return;
  }
  // If startRange or lastRange are not given, use the existing range selection
  // Happens if the user clicks a resource instead of making a range selection
  if (!this.startRange && !this.lastRange) {
    if (this.selectionRange.from) {
      this.startRange = {};
      this.startRange.from = this.selectionRange.from.getTime();
      this.startRange.to = this.startRange.from;
    }
    if (this.selectionRange.to) {
      this.lastRange = {};
      this.lastRange.from = this.selectionRange.to.getTime();
      this.lastRange.to = this.lastRange.from;
    }
  }
  var rangeSelected = !!(this.startRange && this.lastRange);
  var $startRow = this.startRow.$resource,
    $lastRow = this.lastRow.$resource;

  // in case of single selection
  if (this.selectionMode === scout.Planner.SelectionMode.SINGLE_RANGE) {
    this.lastRow = this.startRow;
    $lastRow = this.startRow.$resource;
  }

  // select rows
  var $upperRow = ($startRow[0].offsetTop <= $lastRow[0].offsetTop) ? $startRow : $lastRow,
    $lowerRow = ($startRow[0].offsetTop > $lastRow[0].offsetTop) ? $startRow : $lastRow,
    resources = $('.planner-resource', this.$grid).toArray(),
    top = $upperRow[0].offsetTop,
    low = $lowerRow[0].offsetTop;

  for (var r = resources.length - 1; r >= 0; r--) {
    var row = resources[r];
    if ((row.offsetTop < top && row.offsetTop < low) || (row.offsetTop > top && row.offsetTop > low)) {
      resources.splice(r, 1);
    }
  }

  this.selectResources(resources.map(function(i) {
    return $(i).data('resource');
  }), !whileSelecting);
  this.selectActivity(null);

  if (rangeSelected) {
    // left and width
    var from = Math.min(this.lastRange.from, this.startRange.from),
      to = Math.max(this.lastRange.to, this.startRange.to);

    var selectionRange = new scout.DateRange(new Date(from), new Date(to));
    this.selectRange(selectionRange, !whileSelecting);
  }
};

scout.Planner.prototype._findRow = function(y) {
  var x = this.$grid.offset().left + 10,
    $row = this._$elementFromPoint(x, y).parent();

  if ($row.hasClass('planner-resource')) {
    return $row.data('resource');
  } else {
    return null;
  }
};

scout.Planner.prototype._findScale = function(x) {
  var y = this.$scale.offset().top + this.$scale.height() * 0.75,
    $scale = this._$elementFromPoint(x, y);

  if ($scale.data('date-from') !== undefined) {
    return new scout.DateRange($scale.data('date-from').valueOf(), $scale.data('date-to').valueOf());
  } else {
    return null;
  }
};

/* -- helper ---------------------------------------------------- */

scout.Planner.prototype._$elementFromPoint = function(x, y) {
  return $(this.$container.document(true).elementFromPoint(x, y));
};

scout.Planner.prototype._dateFormat = function(date, pattern) {
  var d = new Date(date.valueOf()),
    dateFormat = new scout.DateFormat(this.session.locale, pattern);

  return dateFormat.format(d);
};

scout.Planner.prototype._renderViewRange = function() {
  this._renderRange();
  this._renderScale();
  this.invalidateLayoutTree();
};

scout.Planner.prototype._renderHeaderVisible = function() {
  this._header.setVisible(this.headerVisible);
  this.invalidateLayoutTree();
};

scout.Planner.prototype._renderYearPanelVisible = function(animated) {
  var yearPanelWidth;
  if (this.yearPanelVisible) {
    this._yearPanel.renderContent();
  }

  // show or hide year panel
  $('.calendar-toggle-year', this.$modes).select(this.yearPanelVisible);
  if (this.yearPanelVisible) {
    yearPanelWidth = 210;
  } else {
    yearPanelWidth = 0;
  }
  this._yearPanel.$container.animate({
    width: yearPanelWidth
  }, {
    duration: animated ? 500 : 0,
    progress: this._onYearPanelWidthChange.bind(this),
    complete: this._afterYearPanelWidthChange.bind(this)
  });
};

scout.Planner.prototype._onYearPanelWidthChange = function() {
  if (!this._yearPanel.$container) {
    // If container has been removed in the meantime (e.g. user navigates away while animation is in progress)
    return;
  }
  var yearPanelWidth = this._yearPanel.$container.outerWidth();
  this.$grid.css('width', 'calc(100% - ' + yearPanelWidth + 'px)');
  this.$scale.css('width', 'calc(100% - ' + yearPanelWidth + 'px)');
  this.revalidateLayout();
};

scout.Planner.prototype._afterYearPanelWidthChange = function() {
  if (!this.yearPanelVisible) {
    this._yearPanel.removeContent();
  }
};

scout.Planner.prototype._syncMenus = function(menus) {
  this.updateKeyStrokes(menus, this.menus);
  this._setProperty('menus', menus);
  this._updateMenuBar();
};

scout.Planner.prototype._updateMenuBar = function() {
  var menuItems = this._filterMenus(['Planner.EmptySpace', 'Planner.Resource', 'Planner.Activity', 'Planner.Range'], true);
  this.menuBar.setMenuItems(menuItems);
};

scout.Planner.prototype._removeMenus = function() {
  // menubar takes care about removal
};

scout.Planner.prototype._filterMenus = function(allowedTypes, enableDisableKeyStroke) {
  allowedTypes = allowedTypes || [];
  if (allowedTypes.indexOf('Planner.Resource') > -1 && this.selectedResources.length === 0) {
    scout.arrays.remove(allowedTypes, 'Planner.Resource');
  }
  if (allowedTypes.indexOf('Planner.Activity') > -1 && !this.selectedActivity) {
    scout.arrays.remove(allowedTypes, 'Planner.Activity');
  }
  if (allowedTypes.indexOf('Planner.Range') > -1 && !this.selectionRange.from && !this.selectionRange.to) {
    scout.arrays.remove(allowedTypes, 'Planner.Range');
  }
  return scout.menus.filter(this.menus, allowedTypes, true, enableDisableKeyStroke);
};

scout.Planner.prototype._renderWorkDayCount = function() {};

scout.Planner.prototype._renderWorkDaysOnly = function() {};

scout.Planner.prototype._renderDisplayModeOptions = function() {
  this._renderRange();
  this._renderScale();
  this.invalidateLayoutTree();
};

scout.Planner.prototype._renderAvailableDisplayModes = function() {
  // done by PlannerHeader.js
};

scout.Planner.prototype._renderDisplayMode = function() {
  // done by PlannerHeader.js
};

scout.Planner.prototype._syncViewRange = function(viewRange) {
  viewRange = scout.DateRange.ensure(viewRange);
  this._setProperty('viewRange', viewRange);
  this._yearPanel.setViewRange(this.viewRange);
  this._yearPanel.selectDate(this.viewRange.from);
};

scout.Planner.prototype._syncDisplayMode = function(displayMode) {
  this._setProperty('displayMode', displayMode);
  this._yearPanel.setDisplayMode(this.displayMode);
  this._header.setDisplayMode(this.displayMode);
};

scout.Planner.prototype._syncAvailableDisplayModes = function(availableDisplayModes) {
  this._setProperty('availableDisplayModes', availableDisplayModes);
  this._header.setAvailableDisplayModes(this.availableDisplayModes);
};

scout.Planner.prototype._syncSelectionRange = function(selectionRange) {
  selectionRange = scout.DateRange.ensure(selectionRange);
  this._setProperty('selectionRange', selectionRange);
  this._updateMenuBar();
};

scout.Planner.prototype._syncSelectedResources = function(selectedResources) {
  if (typeof selectedResources[0] === 'string') {
    selectedResources = this._resourcesByIds(selectedResources);
  }
  if (this.rendered) {
    this._removeSelectedResources();
  }
  this._setProperty('selectedResources', selectedResources);
  this._updateMenuBar();
};

scout.Planner.prototype._removeSelectedResources = function() {
  this.selectedResources.forEach(function(resource) {
    resource.$resource.select(false);
  });
};

scout.Planner.prototype._renderSelectedResources = function() {
  this.selectedResources.forEach(function(resource) {
    resource.$resource.select(true);
  });
};

scout.Planner.prototype._renderActivitySelectable = function() {
  if (this.selectedActivity && this.selectedActivity.$activity) {
    this.selectedActivity.$activity.toggleClass('selected', this.activitySelectable);
  }
};

scout.Planner.prototype._renderSelectionMode = function() {
  if (this.selectionMode === scout.Planner.SelectionMode.NONE) {
    if (this.$selector) {
      this.$selector.remove();
      this.$highlight.remove();
    }
  } else {
    this._renderSelectionRange();
  }
};

scout.Planner.prototype._renderSelectionRange = function() {
  var $startRow, $lastRow,
    from = this.selectionRange.from,
    to = this.selectionRange.to,
    startRow = this.selectedResources[0],
    lastRow = this.selectedResources[this.selectedResources.length - 1];

  // remove old selector
  if (this.$selector) {
    this.$selector.remove();
    this.$highlight.remove();
  }

  if (!startRow || !lastRow || !this.selectionRange.from || !this.selectionRange.to) {
    return;
  }
  $startRow = startRow.$resource;
  $lastRow = lastRow.$resource;

  // top and height
  var $parent = ($startRow[0].offsetTop <= $lastRow[0].offsetTop) ? $startRow : $lastRow;
  this.$selector = $parent.children('.resource-cells').appendDiv('selector');
  this.$selector.cssHeight($startRow.outerHeight() + Math.abs($lastRow[0].offsetTop - $startRow[0].offsetTop));
  var $selectorResizeLeft = this.$selector.appendDiv('selector-resize-left').mousedown(this._onResizeMousedown.bind(this));
  var $selectorResizeRight = this.$selector.appendDiv('selector-resize-right').mousedown(this._onResizeMousedown.bind(this));
  this.$selector
    .css('left', 'calc(' + this.transformLeft(from) + '% - ' + $selectorResizeLeft.cssWidth() + 'px)')
    .css('width', 'calc(' + this.transformWidth(from, to) + '% + ' + ($selectorResizeLeft.cssWidth() + $selectorResizeRight.cssWidth()) + 'px)')
    .on('contextmenu', this._onRangeSelectorContextMenu.bind(this));

  // colorize scale
  this.$highlight = this.$timelineSmall.prependDiv('highlight');

  var left = this.$selector.cssLeft() + $selectorResizeLeft.cssWidth() + this.$scaleTitle.cssWidth();
  var width = this.$selector.cssWidth() - ($selectorResizeLeft.cssWidth() + $selectorResizeRight.cssWidth());
  this.$highlight
    .cssLeft(left)
    .cssWidth(width);
};

scout.Planner.prototype._syncSelectedActivity = function(selectedActivity) {
  if (typeof selectedActivity === 'string') {
    selectedActivity = this._activityById(selectedActivity);
  }
  if (this.rendered) {
    this._removeSelectedActivity();
  }
  this._setProperty('selectedActivity', selectedActivity);
  this._updateMenuBar();
};

scout.Planner.prototype._removeSelectedActivity = function() {
  if (this.selectedActivity && this.selectedActivity.$activity) {
    this.selectedActivity.$activity.removeClass('selected');
  }
};

scout.Planner.prototype._renderSelectedActivity = function() {
  if (this.selectedActivity && this.selectedActivity.$activity) {
    this.selectedActivity.$activity.addClass('selected');
  }
};

scout.Planner.prototype._renderLabel = function() {
  var label = this.label || '';
  if (this.$scaleTitle) {
    this.$scaleTitle.text(label);
  }
};

scout.Planner.prototype._resourcesByIds = function(ids) {
  return ids.map(this._resourceById.bind(this));
};

scout.Planner.prototype._activityById = function(id) {
  return this.activityMap[id];
};

scout.Planner.prototype._resourceById = function(id) {
  return this.resourceMap[id];
};

scout.Planner.prototype.setDisplayMode = function(displayMode) {
  this.setProperty('displayMode', displayMode);
  this.startRange = null;
  this.lastRange = null;
};

scout.Planner.prototype.layoutYearPanel = function() {
  if (this.yearPanelVisible) {
    scout.scrollbars.update(this._yearPanel.$yearList);
    this._yearPanel._scrollYear();
  }
};

scout.Planner.prototype.setYearPanelVisible = function(visible) {
  if (this.yearPanelVisible === visible) {
    return;
  }
  this._setProperty('yearPanelVisible', visible);
  if (this.rendered) {
    this._renderYearPanelVisible(true);
  }
};

scout.Planner.prototype.setViewRangeFrom = function(date) {
  var diff = this.viewRange.to.getTime() - this.viewRange.from.getTime(),
    viewRange = new scout.DateRange(this.viewRange.from, this.viewRange.to);

  viewRange.from = date;
  viewRange.to = new Date(date.getTime() + diff);
  this.setViewRange(viewRange);
};

scout.Planner.prototype.setViewRange = function(viewRange) {
  if (this.viewRange === viewRange) {
    return;
  }
  this._syncViewRange(viewRange);

  if (this.rendered) {
    this._renderViewRange();
    this._rerenderActivities();
    this._renderSelectedActivity();
    this.validateLayoutTree();
  }
};

scout.Planner.prototype.selectRange = function(range) {
  if (range && range.equals(this.selectionRange)) {
    return;
  }
  this.setProperty('selectionRange', range);
  this._updateMenuBar();
};

scout.Planner.prototype.selectActivity = function(activity) {
  this.setProperty('selectedActivity', activity);
  this._updateMenuBar();
};

scout.Planner.prototype.selectResources = function(resources) {
  if (scout.arrays.equals(resources, this.selectedResources)) {
    return;
  }

  resources = scout.arrays.ensure(resources);
  // Make a copy so that original array stays untouched
  resources = resources.slice();
  this.setProperty('selectedResources', resources);
  this.trigger('resourcesSelected', {
    resources: resources
  });
  this._updateMenuBar();

  if (this.rendered) {
    // Render selection range as well for the case if selectedRange does not change but selected resources do
    this._renderSelectionRange();
  }
};

/**
 * Returns true if a deselection happened. False if the given resources were not selected at all.
 */
scout.Planner.prototype.deselectResources = function(resources) {
  var deselected = false;
  resources = scout.arrays.ensure(resources);
  var selectedResources = this.selectedResources.slice(); // copy
  if (scout.arrays.removeAll(selectedResources, resources)) {
    this.selectResources(selectedResources);
    deselected = true;
  }
  return deselected;
};

scout.Planner.prototype.insertResources = function(resources) {
  // Update model
  resources.forEach(function(resource) {
    this._initResource(resource);
    // Always insert new rows at the end, if the order is wrong a rowOrderChange event will follow
    this.resources.push(resource);
  }.bind(this));

  // Update HTML
  if (this.rendered) {
    this._renderResources(resources);
    this.invalidateLayoutTree();
  }
};

scout.Planner.prototype.deleteResources = function(resources) {
  if (this.deselectResources(resources)) {
    this.selectRange(new scout.DateRange());
  }
  resources.forEach(function(resource) {
    // Update model
    scout.arrays.remove(this.resources, resource);
    delete this.resourceMap[resource.id];

    resource.activities.forEach(function(activity) {
      delete this.activityMap[activity.id];
    }.bind(this));

    // Update HTML
    if (this.rendered) {
      resource.$resource.remove();
      delete resource.$resource;
    }
  }.bind(this));

  this.invalidateLayoutTree();
};

scout.Planner.prototype.deleteAllResources = function() {
  // Update HTML
  if (this.rendered) {
    this._removeAllResources();
    this.invalidateLayoutTree();
  }

  // Update model
  this.resources = [];
  this.resourceMap = {};
  this.activityMap = {};
  this.selectResources([]);
  this.selectRange(new scout.DateRange());
};

scout.Planner.prototype._updateResources = function(resources) {
  resources.forEach(function(updatedResource) {
    var oldResource = this.resourceMap[updatedResource.id];
    if (!oldResource) {
      throw new Error('Update event received for non existing resource. ResourceId: ' + updatedResource.id);
    }

    // Replace old resource
    this._initResource(updatedResource);
    scout.arrays.replace(this.resources, oldResource, updatedResource);
    scout.arrays.replace(this.selectedResources, oldResource, updatedResource);

    // Replace old $resource
    if (this.rendered && oldResource.$resource) {
      var $updatedResource = $(this._buildResourceHtml(updatedResource));
      oldResource.$resource.replaceWith($updatedResource);
      $updatedResource.css('min-width', oldResource.$resource.css('min-width'));
      this._linkResource($updatedResource, updatedResource);
    }
  }.bind(this));
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlannerAdapter = function() {
  scout.PlannerAdapter.parent.call(this);
  this._addRemoteProperties(['displayMode', 'viewRange', 'selectionRange', 'selectedActivity']);
};
scout.inherits(scout.PlannerAdapter, scout.ModelAdapter);

scout.PlannerAdapter.prototype._sendViewRange = function(viewRange) {
  this._send('property', {
    viewRange: scout.dates.toJsonDateRange(viewRange)
  });
};

scout.PlannerAdapter.prototype._sendSelectedActivity = function() {
  var activityId = null;
  if (this.widget.selectedActivity) {
    activityId = this.widget.selectedActivity.id;
  }
  this._send('property', {
    selectedActivity: activityId
  });
};

scout.PlannerAdapter.prototype._sendSelectionRange = function() {
  var selectionRange = scout.dates.toJsonDateRange(this.widget.selectionRange);
  this._send('property', {
    selectionRange: selectionRange
  });
};

scout.PlannerAdapter.prototype._onWidgetResourcesSelected = function(event) {
  this._sendResourcesSelected();
};

scout.PlannerAdapter.prototype._sendResourcesSelected = function() {
  var resourceIds = this.widget.selectedResources.map(function(r) {
    return r.id;
  });
  this._send('resourcesSelected', {
    resourceIds: resourceIds
  });
};

scout.PlannerAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'resourcesSelected') {
    this._onWidgetResourcesSelected(event);
  } else {
    scout.PlannerAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

scout.PlannerAdapter.prototype._onResourcesInserted = function(resources) {
  this.widget.insertResources(resources);
};

scout.PlannerAdapter.prototype._onResourcesDeleted = function(resourceIds) {
  var resources = this.widget._resourcesByIds(resourceIds);
  this.addFilterForWidgetEventType('resourcesSelected');
  this.addFilterForProperties({
    selectionRange: new scout.DateRange()
  });
  this.widget.deleteResources(resources);
};

scout.PlannerAdapter.prototype._onAllResourcesDeleted = function() {
  this.addFilterForWidgetEventType('resourcesSelected');
  this.addFilterForProperties({
    selectionRange: new scout.DateRange()
  });
  this.widget.deleteAllResources();
};

scout.PlannerAdapter.prototype._onResourcesSelected = function(resourceIds) {
  var resources = this.widget._resourcesByIds(resourceIds);
  this.addFilterForWidgetEventType('resourcesSelected');
  this.widget.selectResources(resources, false);
};

scout.PlannerAdapter.prototype._onResourcesUpdated = function(resources) {
  this.widget._updateResources(resources);
};

scout.PlannerAdapter.prototype.onModelAction = function(event) {
  if (event.type === 'resourcesInserted') {
    this._onResourcesInserted(event.resources);
  } else if (event.type === 'resourcesDeleted') {
    this._onResourcesDeleted(event.resourceIds);
  } else if (event.type === 'allResourcesDeleted') {
    this._onAllResourcesDeleted();
  } else if (event.type === 'resourcesSelected') {
    this._onResourcesSelected(event.resourceIds);
  } else if (event.type === 'resourcesUpdated') {
    this._onResourcesUpdated(event.resources);
  } else {
    scout.PlannerAdapter.parent.prototype.onModelAction.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlannerHeader = function() {
  scout.PlannerHeader.parent.call(this);

  this.availableDisplayModes = [];
};
scout.inherits(scout.PlannerHeader, scout.Widget);

scout.PlannerHeader.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('planner-header');
  this.$range = this.$container.appendDiv('planner-range');
  this.$range.appendDiv('planner-previous').on('click', this._onPreviousClick.bind(this));
  this.$range.appendDiv('planner-today', this.session.text('ui.CalendarToday')).on('click', this._onTodayClick.bind(this));
  this.$range.appendDiv('planner-next').on('click', this._onNextClick.bind(this));
  this.$range.appendDiv('planner-select');
  this.$commands = this.$container.appendDiv('planner-commands');
  this._renderAvailableDisplayModes();
  this._renderDisplayMode();
};

scout.PlannerHeader.prototype.setAvailableDisplayModes = function(displayModes) {
  this.setProperty('availableDisplayModes', displayModes);
};

scout.PlannerHeader.prototype._renderAvailableDisplayModes = function() {
  var displayMode = scout.Planner.DisplayMode;
  this.$commands.empty();

  if (this.availableDisplayModes.length > 1) {
    if (this.availableDisplayModes.indexOf(displayMode.DAY) > -1) {
      this.$commands.appendDiv('planner-mode', this.session.text('ui.CalendarDay'))
        .attr('data-mode', displayMode.DAY)
        .on('click', this._onDisplayModeClick.bind(this));
    }
    if (this.availableDisplayModes.indexOf(displayMode.WORK_WEEK) > -1) {
      this.$commands.appendDiv('planner-mode', this.session.text('ui.CalendarWorkWeek'))
        .attr('data-mode', displayMode.WORK_WEEK)
        .on('click', this._onDisplayModeClick.bind(this));
    }
    if (this.availableDisplayModes.indexOf(displayMode.WEEK) > -1) {
      this.$commands.appendDiv('planner-mode', this.session.text('ui.CalendarWeek'))
        .attr('data-mode', displayMode.WEEK)
        .on('click', this._onDisplayModeClick.bind(this));
    }
    if (this.availableDisplayModes.indexOf(displayMode.MONTH) > -1) {
      this.$commands.appendDiv('planner-mode', this.session.text('ui.CalendarMonth'))
        .attr('data-mode', displayMode.MONTH)
        .on('click', this._onDisplayModeClick.bind(this));
    }
    if (this.availableDisplayModes.indexOf(displayMode.CALENDAR_WEEK) > -1) {
      this.$commands.appendDiv('planner-mode', this.session.text('ui.CalendarCalendarWeek'))
        .attr('data-mode', displayMode.CALENDAR_WEEK)
        .on('click', this._onDisplayModeClick.bind(this));
    }
    if (this.availableDisplayModes.indexOf(displayMode.YEAR) > -1) {
      this.$commands.appendDiv('planner-mode', this.session.text('ui.CalendarYear'))
        .attr('data-mode', displayMode.YEAR)
        .on('click', this._onDisplayModeClick.bind(this));
    }
  }

  var $modes = this.$commands.children('.planner-mode');
  $modes.first().addClass('first');
  $modes.last().addClass('last');
  this.$commands.appendDiv('planner-toggle-year').on('click', this._onYearClick.bind(this));
};

scout.PlannerHeader.prototype.setDisplayMode = function(displayMode) {
  this.setProperty('displayMode', displayMode);
};

scout.PlannerHeader.prototype._renderDisplayMode = function() {
  $('.planner-mode', this.$commands).select(false);
  $('[data-mode="' + this.displayMode + '"]', this.$commands).select(true);
};

scout.PlannerHeader.prototype._onTodayClick = function(event) {
  this.trigger('todayClick');
};

scout.PlannerHeader.prototype._onNextClick = function(event) {
  this.trigger('nextClick');
};

scout.PlannerHeader.prototype._onPreviousClick = function(event) {
  this.trigger('previousClick');
};

scout.PlannerHeader.prototype._onYearClick = function(event) {
  this.trigger('yearClick');
};

scout.PlannerHeader.prototype._onDisplayModeClick = function(event) {
  var displayMode = $(event.target).data('mode');
  this.setDisplayMode(displayMode);
  this.trigger('displayModeClick', {
    displayMode: this.displayMode
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlannerLayout = function(planner) {
  scout.PlannerLayout.parent.call(this);
  this.planner = planner;
};
scout.inherits(scout.PlannerLayout, scout.AbstractLayout);

scout.PlannerLayout.prototype.layout = function($container) {
  var menuBarSize,
    $header = this.planner._header.$container,
    $scale = this.planner.$scale,
    $grid = this.planner.$grid,
    menuBar = this.planner.menuBar,
    $yearContainer = this.planner._yearPanel.$container,
    menuBarHeight = 0,
    gridHeight = 0,
    yearContainerHeight = 0,
    gridTop = 0,
    scaleTop = 0,
    htmlMenuBar = scout.HtmlComponent.get(menuBar.$container),
    htmlContainer = this.planner.htmlComp,
    containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  if (menuBar.$container.isVisible()) {
    menuBarSize = scout.MenuBarLayout.size(htmlMenuBar, containerSize);
    htmlMenuBar.setSize(menuBarSize);
    menuBarHeight = menuBarSize.height;
    if (menuBar.position === 'top') {
      scaleTop += menuBarHeight;
    }
  }

  if ($header.isVisible()) {
    scaleTop += scout.graphics.getSize($header).height;
  }
  $scale.css('top', scaleTop);
  gridTop += scaleTop + scout.graphics.getSize($scale).height;
  $grid.css('top', gridTop);

  yearContainerHeight = scaleTop + $yearContainer.cssMarginY();
  gridHeight = gridTop + $grid.cssMarginY();

  if (menuBar.$container.isVisible() && menuBar.position === 'bottom') {
    yearContainerHeight += menuBarHeight;
    gridHeight += menuBarHeight;
  }

  $yearContainer.css('height', 'calc(100% - ' + yearContainerHeight + 'px)');
  $grid.css('height', 'calc(100% - ' + gridHeight + 'px)');

  this._updateMinWidth();
  this._layoutScaleLines();
  // immediate update to prevent flickering, due to reset in layoutScaleLines
  scout.scrollbars.update(this.planner.$grid, true);
  this.planner.layoutYearPanel();
};

/**
 * Min width is necessary for horizontal scrollbar
 */
scout.PlannerLayout.prototype._updateMinWidth = function() {
  var minWidth = this._minWidth(),
    $scaleTitle = this.planner.$scaleTitle,
    $timeline = this.planner.$timeline;

  if (!$timeline) {
    // May be null if no view range is rendered
    return;
  }

  $timeline.css('min-width', minWidth);
  minWidth += $scaleTitle.outerWidth(true);
  this.planner.resources.forEach(function(resource) {
    resource.$resource.css('min-width', minWidth);
  });
};

/**
 * Positions the scale lines and set to correct height
 */
scout.PlannerLayout.prototype._layoutScaleLines = function() {
  var height, $smallScaleItems, $largeScaleItems, scrollLeft,
    $timelineSmall = this.planner.$timelineSmall,
    $timelineLarge = this.planner.$timelineLarge;

  if (!$timelineSmall) {
    // May be null if no view range is rendered
    return;
  }

  $smallScaleItems = $timelineSmall.children('.scale-item');
  $largeScaleItems = $timelineLarge.children('.scale-item');

  // First loop through every item and set height to 0 in order to get the correct scrollHeight
  $largeScaleItems.each(function() {
    var $scaleItemLine = $(this).data('scale-item-line');
    $scaleItemLine.cssHeight(0);
  });
  $smallScaleItems.each(function() {
    var $scaleItemLine = $(this).data('scale-item-line');
    if ($scaleItemLine) {
      $scaleItemLine.cssHeight(0);
    }
  });
  // also make sure there is no scrollbar anymore which could influence scrollHeight
  scout.scrollbars.reset(this.planner.$grid);

  // Loop again and update height and left
  height = this.planner.$grid[0].scrollHeight;
  scrollLeft = this.planner.$scale[0].scrollLeft;
  $largeScaleItems.each(function() {
    var $scaleItem = $(this),
      $scaleItemLine = $scaleItem.data('scale-item-line');
    $scaleItemLine.cssLeft(scrollLeft + $scaleItem.position().left)
      .cssHeight(height);
  });
  $smallScaleItems.each(function() {
    var $scaleItem = $(this),
      $scaleItemLine = $scaleItem.data('scale-item-line');
    if ($scaleItemLine) {
      $scaleItemLine.cssLeft(scrollLeft + $scaleItem.position().left)
        .cssHeight(height);
    }
  });
};

scout.PlannerLayout.prototype._minWidth = function() {
  var $scaleItemsLarge = this.planner.$timelineLarge.children('.scale-item'),
    $scaleItemsSmall = this.planner.$timelineSmall.children('.scale-item'),
    numScaleItemsLarge = $scaleItemsLarge.length,
    numScaleItemsSmall = $scaleItemsSmall.length,
    displayMode = scout.Planner.DisplayMode,
    cellInsets = scout.graphics.getInsets($scaleItemsSmall, {includeBorder: false}),
    minWidth = numScaleItemsSmall*cellInsets.horizontal(); //no matter what, this width must never be deceeded

  if (this.planner.displayMode === displayMode.DAY) {
    return Math.max(minWidth, numScaleItemsLarge * 52);
  } if (scout.isOneOf(this.planner.displayMode, displayMode.WORK_WEEK, displayMode.WEEK)) {
    return Math.max(minWidth, numScaleItemsLarge * 160);
  } if (this.planner.displayMode === displayMode.MONTH) {
    return Math.max(minWidth, numScaleItemsSmall * 23);
  } if (this.planner.displayMode === displayMode.CALENDAR_WEEK) {
    return Math.max(minWidth, numScaleItemsSmall * 23);
  } if (this.planner.displayMode === displayMode.YEAR) {
    return Math.max(minWidth, numScaleItemsSmall * 90);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlannerMenuItemsOrder = function(session, objectType) {
  scout.PlannerMenuItemsOrder.parent.call(this, session, objectType);
  this.selectionTypes = ['Resource', 'Activity', 'Range'];
};
scout.inherits(scout.PlannerMenuItemsOrder, scout.MenuItemsOrder);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FileChooser = function() {
  scout.FileChooser.parent.call(this);
  this._files = [];
  this._glassPaneRenderer;
};
scout.inherits(scout.FileChooser, scout.Widget);

scout.FileChooser.prototype._init = function(model) {
  scout.FileChooser.parent.prototype._init.call(this, model);
  this._glassPaneRenderer = new scout.GlassPaneRenderer(this.session, this, true);
};

/**
 * @override
 */
scout.FileChooser.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.FileChooser.prototype._initKeyStrokeContext = function() {
  scout.FileChooser.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([
    new scout.FocusAdjacentElementKeyStroke(this.session, this),
    new scout.ClickActiveElementKeyStroke(this, [
      scout.keys.SPACE, scout.keys.ENTER
    ]),
    new scout.CloseKeyStroke(this, function() {
      return this.$cancelButton;
    }.bind(this))
  ]);
};

scout.FileChooser.prototype._render = function($parent) {
  // Render modality glasspanes (must precede adding the file chooser to the DOM)
  this._glassPaneRenderer.renderGlassPanes();
  this.$container = $parent.appendDiv('file-chooser');
  var $handle = this.$container.appendDiv('drag-handle');
  this.$container.makeDraggable($handle);

  this.$container.appendDiv('closable')
    .on('click', function() {
      this._doCancel();
    }.bind(this));

  this.$content = this.$container.appendDiv('file-chooser-content');
  this.$title = this.$content.appendDiv('file-chooser-title')
    .text(this.session.text(this.multiSelect ? 'ui.ChooseFiles' : 'ui.ChooseFile'));

  this.$fileInputField = $parent.makeElement('<input>')
    .attr('type', 'file')
    .prop('multiple', this.multiSelect)
    .attr('accept', this.acceptTypes)
    .on('change', this._onFileChange.bind(this));

  if (scout.device.supportsFile()) {
    this.$fileInputField.appendTo(this.$container);

    // Install DnD support
    this.$container.on('dragenter', this._onDragEnterOrOver.bind(this))
      .on('dragover', this._onDragEnterOrOver.bind(this))
      .on('drop', this._onDrop.bind(this));

    // explanation for file chooser
    this.$content.appendDiv('file-chooser-label')
      .text(this.session.text('ui.FileChooserHint'));

    // List of files
    this.$files = this.$content.appendElement('<ul>', 'file-chooser-files');
    scout.scrollbars.install(this.$files, {
      parent: this
    });

  } else {
    // legacy iframe code
    this.$legacyFormTarget = this.$fileInputField.appendElement('<iframe>')
      .attr('name', 'legacyFileUpload' + this.id)
      .on('load', function() {
        // Manually handle JSON response from iframe
        try {
          // "onAjaxDone"
          var text = this.$legacyFormTarget.contents().text();
          if (scout.strings.hasText(text)) {
            // Manually handle JSON response
            var json = $.parseJSON(text);
            this.session.responseQueue.process(json);
          }
        } finally {
          // "onAjaxAlways"
          this.session.setBusy(false);
        }
      }.bind(this));
    this.$fileInputField
      .attr('name', 'file')
      .addClass('legacy-upload-file-input');
    this.$legacyForm = this.$content.appendElement('<form>', 'legacy-upload-form')
      .attr('action', 'upload/' + this.session.uiSessionId + '/' + this.id)
      .attr('enctype', 'multipart/form-data')
      .attr('method', 'post')
      .attr('target', 'legacyFileUpload' + this.id)
      .append(this.$fileInputField);
    this.$legacyForm.appendElement('<input>')
      .attr('name', 'legacyFormTextPlainAnswer')
      .attr('type', 'hidden');
  }

  // Buttons
  this.$buttons = this.$container.appendDiv('file-chooser-buttons');
  var boxButons = new scout.BoxButtons(this.$buttons);
  if (scout.device.supportsFile()) {
    this.$addFileButton = boxButons.addButton({
      text: this.session.text('ui.Browse'),
      onClick: this._onAddFileButtonClicked.bind(this)
    });
  }
  this.$uploadButton = boxButons.addButton({
    text: this.session.text('ui.Upload'),
    onClick: this._onUploadButtonClicked.bind(this),
    enabled: false
  });
  this.$cancelButton = boxButons.addButton({
    text: this.session.text('Cancel'),
    onClick: this._onCancelButtonClicked.bind(this)
  });

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.FormLayout(this));
  this.htmlComp.pixelBasedSizing = false;

  this.$container.addClassForAnimation('animate-open');
  // Prevent resizing when file chooser is dragged off the viewport
  this.$container.addClass('calc-helper');
  this.$container.css('min-width', this.$container.width());
  this.$container.removeClass('calc-helper');
  boxButons.updateButtonWidths(this.$container.width());
  // Now that all texts, paddings, widths etc. are set, we can calculate the position
  this._position();
};

scout.FileChooser.prototype._postRender = function() {
  scout.FileChooser.parent.prototype._postRender.call(this);
  this.session.focusManager.installFocusContext(this.$container, scout.focusRule.AUTO);
};

scout.FileChooser.prototype._remove = function() {
  this._glassPaneRenderer.removeGlassPanes();
  this.session.focusManager.uninstallFocusContext(this.$container);
  scout.FileChooser.parent.prototype._remove.call(this);
};

scout.FileChooser.prototype._position = function() {
  this.$container.cssMarginLeft(-this.$container.outerWidth() / 2);
};

scout.FileChooser.prototype._doUpload = function() {
  if (scout.device.supportsFile()) {
    if (this._files.length === 0) {
      this._doCancel();
      return;
    }
    this.session.uploadFiles(this, this._files, undefined, this.maximumUploadSize);
  } else if (this.$fileInputField[0].value) {
    // legacy iframe code
    this.session.setBusy(true);
    this.$legacyForm[0].submit();
  }
};

scout.FileChooser.prototype._doCancel = function() {
  // FIXME CGU [6.1] offline case?
  this.trigger('cancel');
};

scout.FileChooser.prototype._doAddFile = function() {
  // Trigger browser's file chooser
  this.$fileInputField.click();
};

scout.FileChooser.prototype._onUploadButtonClicked = function(event) {
  this.$uploadButton.setEnabled(false);
  this._doUpload();
  this.session.listen().done(function() {
    this.$uploadButton.setEnabled(true);
  }.bind(this));

};

scout.FileChooser.prototype._onCancelButtonClicked = function(event) {
  this._doCancel();
};

scout.FileChooser.prototype._onAddFileButtonClicked = function(event) {
  this._doAddFile();
};

scout.FileChooser.prototype._onFileChange = function(event) {
  if (scout.device.supportsFile()) {
    this.addFiles(this.$fileInputField[0].files);
  } else {
    this.$uploadButton.setEnabled(this.$fileInputField[0].value);
  }
};

/**
 * Add files using java script files api.
 */
scout.FileChooser.prototype.addFiles = function(files) {
  for (var i = 0; i < files.length; i++) {
    var file = files[i];
    if (this.multiSelect) {
      this._files.push(file);
    } else {
      this._files = [file];
      this.$files.empty();
    }
    var $file = this.$files.appendElement('<li>', 'file', file.name);
    // Append a space to allow the browser to break the line here when it gets too long
    $file.append(" ");
    var $remove = $file
      .appendSpan('remove menu-item')
      .on('click', this.removeFile.bind(this, file, $file));
    var $removeLink = $file.makeElement('<a>', 'remove-link', this.session.text('Remove'));
    $remove.appendTextNode('(');
    $remove.append($removeLink);
    $remove.appendTextNode(')');
  }
  this.$uploadButton.setEnabled(this._files.length > 0);
  scout.scrollbars.update(this.$files);
};

scout.FileChooser.prototype.removeFile = function(file, $file) {
  var index = this._files.indexOf(file);
  if (index > -1) {
    this._files.splice(index, 1);
  }
  if ($file) {
    $file.remove();
  }
  this.$uploadButton.setEnabled(this._files.length > 0);
  scout.scrollbars.update(this.$files);
};

scout.FileChooser.prototype._onDragEnterOrOver = function(event) {
  scout.dragAndDrop.verifyDataTransferTypesScoutTypes(event, scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER);
};

scout.FileChooser.prototype._onDrop = function(event) {
  if (scout.dragAndDrop.dataTransferTypesContainsScoutTypes(event.originalEvent.dataTransfer, scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER)) {
    $.suppressEvent(event);
    this.addFiles(event.originalEvent.dataTransfer.files);
  }
};

/**
 * @override Widget.js
 */
scout.FileChooser.prototype._attach = function() {
  this.$parent.append(this.$container);
  this.session.detachHelper.afterAttach(this.$container);
  scout.FileChooser.parent.prototype._attach.call(this);
};

/**
 * @override Widget.js
 */
scout.FileChooser.prototype._detach = function() {
  this.session.detachHelper.beforeDetach(this.$container);
  this.$container.detach();
  scout.FileChooser.parent.prototype._detach.call(this);
};

/**
 * Used by CloseKeyStroke.js
 */
scout.FileChooser.prototype.close = function() {
  if (this.$cancelButton && this.session.focusManager.requestFocus(this.$cancelButton)) {
    this.$cancelButton.click();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FileChooserAdapter = function() {
  scout.FileChooserAdapter.parent.call(this);
};
scout.inherits(scout.FileChooserAdapter, scout.ModelAdapter);

scout.FileChooserAdapter.prototype._onWidgetCancel = function(event) {
  this._send('cancel');
};

scout.FileChooserAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'cancel') {
    this._onWidgetCancel(event);
  } else {
    scout.FileChooserAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Controller with functionality to register and render file choosers.
 *
 * The file choosers are put into the list fileChoosers contained in 'displayParent'.
 */
scout.FileChooserController = function(displayParent, session) {
  this.displayParent = displayParent;
  this.session = session;
};

/**
 * Adds the given file chooser to this controller and renders it.
 */
scout.FileChooserController.prototype.registerAndRender = function(fileChooser) {
  fileChooser._setProperty('displayParent', this.displayParent);
  this.displayParent.fileChoosers.push(fileChooser);
  this._render(fileChooser);
};

/**
 * Removes the given file chooser from this controller and DOM. However, the file chooser's adapter is not destroyed. That only happens once the file chooser is closed.
 */
scout.FileChooserController.prototype.unregisterAndRemove = function(fileChooser) {
  if (fileChooser) {
    scout.arrays.remove(this.displayParent.fileChoosers, fileChooser);
    this._remove(fileChooser);
  }
};

/**
 * Removes all file choosers registered with this controller from DOM.
 */
scout.FileChooserController.prototype.remove = function() {
  this.displayParent.fileChoosers.forEach(this._remove.bind(this));
};

/**
 * Renders all file choosers registered with this controller.
 */
scout.FileChooserController.prototype.render = function() {
  this.displayParent.fileChoosers.forEach(this._render.bind(this));
};

scout.FileChooserController.prototype._render = function(fileChooser) {
  // Only render file chooser if 'displayParent' is rendered yet; if not, the file chooser will be rendered once 'displayParent' is rendered.
  if (!this.displayParent.rendered) {
    return;
  }
  // Prevent "Already rendered" errors / FIXME bsh, dwi: Remove this hack! Fix in on model if possible. See #162954.
  if (fileChooser.rendered) {
    return;
  }

  fileChooser.render(this.session.desktop.$container);

  // Only display the file chooser if its 'displayParent' is visible to the user.
  if (!this.displayParent.inFront()) {
    fileChooser.detach();
  }
};

scout.FileChooserController.prototype._remove = function(fileChooser) {
  fileChooser.remove();
};

/**
 * Attaches all file choosers to their original DOM parents.
 * In contrast to 'render', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.
 *
 * This method has no effect if already attached.
 */
scout.FileChooserController.prototype.attach = function() {
  this.displayParent.fileChoosers.forEach(function(fileChooser) {
    fileChooser.attach();
  }, this);
};

/**
 * Detaches all file choosers from their DOM parents. Thereby, modality glassPanes are not detached.
 * In contrast to 'remove', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.
 *
 * This method has no effect if already detached.
 */
scout.FileChooserController.prototype.detach = function() {
  this.displayParent.fileChoosers.forEach(function(fileChooser) {
    fileChooser.detach();
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Slider = function() {
  scout.Slider.parent.call(this);

  this.value;
  this.minValue;
  this.maxValue;
  this.step;
};
scout.inherits(scout.Slider, scout.Widget);

scout.Slider.prototype._init = function(options) {
  scout.Slider.parent.prototype._init.call(this, options);
  this.value = options.value;
  this.minValue = options.minValue;
  this.maxValue = options.maxValue;
  this.step = options.step;
};

scout.Slider.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('slider');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.SliderLayout(this));
  this.$sliderInput = this.$container.appendElement('<input>', 'slider-input')
    .attr('type', 'range')
    .on('change', this._onValueChange.bind(this));

  this.$sliderValue = this.$container
    .appendSpan('slider-value', this.value);
};

scout.Slider.prototype._renderProperties = function() {
  scout.Slider.parent.prototype._renderProperties.call(this);
  this._renderValue();
  this._renderMinValue();
  this._renderMaxValue();
  this._renderStep();
};

scout.Slider.prototype._renderValue = function() {
  var value = scout.nvl(this.value, 0);
  this.$sliderInput.val(value);
  this.$sliderValue.text(value);
};

scout.Slider.prototype._renderMinValue = function() {
  if (this.minValue) {
    this.$sliderInput.attr('min', this.minValue);
  } else {
    this.$sliderInput.removeAttr('min');
  }
};

scout.Slider.prototype._renderMaxValue = function() {
  if (this.maxValue) {
    this.$sliderInput.attr('max', this.maxValue);
  } else {
    this.$sliderInput.removeAttr('max');
  }
};

scout.Slider.prototype._renderStep = function() {
  if (this.step) {
    this.$sliderInput.attr('step', this.step);
  } else {
    this.$sliderInput.removeAttr('step');
  }
};

scout.Slider.prototype._onValueChange = function(event) {
  this.setValue(this.$sliderInput.val());
};

scout.Slider.prototype.setValue = function(value) {
  this.setProperty('value', value);
};


/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SliderAdapter = function() {
  scout.SliderAdapter.parent.call(this);
  this._addRemoteProperties(['value']);
};
scout.inherits(scout.SliderAdapter, scout.ModelAdapter);

scout.SliderLayout = function(slider) {
  scout.SliderLayout.parent.call(this);
  this.slider = slider;
};
scout.inherits(scout.SliderLayout, scout.AbstractLayout);

scout.SliderLayout.prototype.layout = function($container) {
  var size = scout.graphics.getSize($container);
  this.slider.$sliderInput.css('height', size.height);
  this.slider.$sliderValue.css('height', size.height);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Form = function() {
  scout.Form.parent.call(this);
  this._addAdapterProperties(['rootGroupBox', 'views', 'dialogs', 'initialFocus', 'messageBoxes', 'fileChoosers']);

  this.displayHint = scout.Form.DisplayHint.DIALOG;
  this.maximizeEnabled = true;
  this.maximized = false;
  this.minimizeEnabled = true;
  this.minimized = false;
  this.modal = true;
  this.dialogs = [];
  this.views = [];
  this.messageBoxes = [];
  this.fileChoosers = [];
  this.closable = true;
  this.cacheBounds = false;
  this.resizable = true;
  this.rootGroupBox;
  this._locked;
  this.formController;
  this.messageBoxController;
  this.fileChooserController;
  this._glassPaneRenderer;
  /**
   * Whether this form should render its initial focus
   */
  this.renderInitialFocusEnabled = true;
};
scout.inherits(scout.Form, scout.Widget);

scout.Form.DisplayHint = {
  DIALOG: 'dialog',
  POPUP_WINDOW: 'popupWindow',
  VIEW: 'view'
};

scout.Form.prototype._init = function(model) {
  scout.Form.parent.prototype._init.call(this, model);

  this.formController = new scout.FormController(this, this.session);
  this.messageBoxController = new scout.MessageBoxController(this, this.session);
  this.fileChooserController = new scout.FileChooserController(this, this.session);

  this._syncRootGroupBox(this.rootGroupBox);

  // Only render glassPanes if modal and not being a wrapped Form.
  var renderGlassPanes = (this.modal && !(this.parent instanceof scout.WrappedFormField));
  this._glassPaneRenderer = new scout.GlassPaneRenderer(this.session, this, renderGlassPanes);
  var glasspaneRendererHandler = function(event) {
    //render glasspanes on parents after initialized
    if (event.newProperties.displayParent) {
      this._glassPaneRenderer.renderGlassPanes();
    }
  }.bind(this);
  this.on('propertyChange', glasspaneRendererHandler);
  this.one('destroy', function() {
    this.off('propertyChange', glasspaneRendererHandler);
  }.bind(this));
};

scout.Form.prototype._syncRootGroupBox = function(rootGroupBox) {
  this._setProperty('rootGroupBox', rootGroupBox);
  if (this.rootGroupBox &&
    (this.isDialog() || this.searchForm || this.parent instanceof scout.WrappedFormField)) {
    this.rootGroupBox.menuBar.bottom();
  }
};

/**
 * @override Widget.js
 */
scout.Form.prototype._renderProperties = function() {
  scout.Form.parent.prototype._renderProperties.call(this);
  this._updateTitle();
};

scout.Form.prototype._render = function($parent) {
  this._renderForm($parent);
};

scout.Form.prototype._renderForm = function($parent) {
  var layout, $handle;

  this.$container = $parent.appendDiv()
    .addClass(this.isDialog() ? 'dialog' : 'form')
    .data('model', this);

  if (this.uiCssClass) {
    this.$container.addClass(this.uiCssClass);
  }

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.pixelBasedSizing = false;
  if (this.isDialog()) {
    layout = new scout.DialogLayout(this);
    this.htmlComp.validateRoot = true;
    $handle = this.$container.appendDiv('drag-handle');
    this.$container.makeDraggable($handle, $.throttle(this.onMove.bind(this), 1000 / 60)); // 60fps

    if (this.closable) {
      this.$container
        .appendDiv('closer')
        .on('click', this.close.bind(this));
    }
    if (this.resizable) {
      var $myWindow = this.$container.window();
      this.$container.resizable({
        start: function(event, ui) {
          this.$container.resizable('option', 'maxHeight', $myWindow.height() - event.target.offsetTop);
          this.$container.resizable('option', 'maxWidth', $myWindow.width() - event.target.offsetLeft);
        }.bind(this)
      });
      this.$container.on('resize', function(e) {
        var autoSizeOld = this.htmlComp.layout.autoSize;
        this.htmlComp.layout.autoSize = false;
        this.htmlComp.revalidateLayout();
        this.htmlComp.layout.autoSize = autoSizeOld;
        return false;
      }.bind(this));
    }
    this._updateTitle();
  } else {
    layout = new scout.FormLayout(this);
  }

  this.htmlComp.setLayout(layout);
  this.rootGroupBox.render(this.$container);

  if (this._locked) {
    this.disable();
  }

  if (this.isDialog()) {
    this.$container.addClassForAnimation('animate-open');
  }
};

scout.Form.prototype.close = function() {
  // FIXME [6.1] cgu/awe: this is confusing, close sends a formClosing? May it be rejected? I would expect the form to be closed in offline mode too.
  // Is it only used for popup windows? Suggestion: Rename close to kill, destroy the form and send a kill event (trigger('kill')).
  this._send('formClosing');
};

scout.Form.prototype._postRender = function() {
  scout.Form.parent.prototype._postRender.call(this);

  this._installFocusContext();
  if (this.renderInitialFocusEnabled) {
    this.renderInitialFocus();
  }

  // Render attached forms, message boxes and file choosers.
  this.formController.render();
  this.messageBoxController.render();
  this.fileChooserController.render();
};

scout.Form.prototype._updateTitle = function() {
  if (this.isPopupWindow()) {
    this._updateTitleForWindow();
  } else if (this.isDialog()) {
    this._updateTitleForDom();
  }
};

scout.Form.prototype._updateTitleForWindow = function() {
  var formTitle = scout.strings.join(' - ', this.title, this.subTitle),
    applicationTitle = this.session.desktop.title;
  this.popupWindow.title(formTitle || applicationTitle);
};

scout.Form.prototype._updateTitleForDom = function() {
  var titleText = this.title;
  if (!titleText && this.closable) {
    // Add '&nbsp;' to prevent title-box of a closable form from collapsing if title is empty
    titleText = scout.strings.plainText('&nbsp;');
  }
  if (titleText || this.subTitle) {
    var $titles = getOrAppendChildDiv(this.$container, 'title-box');
    // Render title
    if (titleText) {
      getOrAppendChildDiv($titles, 'title')
        .text(titleText)
        .icon(this.iconId);
    } else {
      removeChildDiv($titles, 'title');
    }
    // Render subTitle
    if (scout.strings.hasText(titleText)) {
      getOrAppendChildDiv($titles, 'sub-title').text(this.subTitle);
    } else {
      removeChildDiv($titles, 'sub-title');
    }
  } else {
    removeChildDiv(this.$container, 'title-box');
  }

  // Layout could have been changed, e.g. if subtitle becomes visible
  this.invalidateLayoutTree();

  // ----- Helper functions -----

  function getOrAppendChildDiv($parent, cssClass) {
    var $div = $parent.children('.' + cssClass);
    if ($div.length === 0) {
      $div = $parent.appendDiv(cssClass);
    }
    return $div;
  }

  function removeChildDiv($parent, cssClass) {
    $parent.children('.' + cssClass).remove();
  }
};

scout.Form.prototype.isDialog = function() {
  return this.displayHint === scout.Form.DisplayHint.DIALOG;
};

scout.Form.prototype.isPopupWindow = function() {
  return this.displayHint === scout.Form.DisplayHint.POPUP_WINDOW;
};

scout.Form.prototype.isView = function() {
  return this.displayHint === scout.Form.DisplayHint.VIEW;
};

scout.Form.prototype._isClosable = function() {
  var i, btn,
    systemButtons = this.rootGroupBox.systemButtons;
  for (i = 0; i < systemButtons.length; i++) {
    btn = systemButtons[i];
    if (btn.visible &&
      btn.systemType === scout.Button.SystemType.CANCEL ||
      btn.systemType === scout.Button.SystemType.CLOSE) {
      return true;
    }
  }
  return false;
};

scout.Form.prototype.onMove = function(newOffset) {
  this.trigger('move', newOffset);
};

scout.Form.prototype.appendTo = function($parent) {
  this.$container.appendTo($parent);
};

scout.Form.prototype._remove = function() {
  this.formController.remove();
  this.messageBoxController.remove();
  this.fileChooserController.remove();
  this._glassPaneRenderer.removeGlassPanes();
  this._uninstallFocusContext();
  scout.Form.parent.prototype._remove.call(this);
};

scout.Form.prototype._renderTitle = function() {
  this._updateTitle();
};

scout.Form.prototype._renderSubTitle = function() {
  this._updateTitle();
};

scout.Form.prototype._renderIconId = function() {
  this._updateTitle();
};

/**
 * Disables the form and calls setEnabled on the root group-box of the form.
 *
 * @param updateChildren
 *          (optional) If true the enabled property of all child form fields (recursive) are updated to same value as well.
 *
 * @override Widget.js
 */
scout.Form.prototype.setEnabled = function(enabled, updateChildren) {
  scout.Form.parent.prototype.setEnabled.call(this, enabled);
  this.rootGroupBox.setEnabled(enabled, undefined, updateChildren);
};

/**
 * @override Widget.js
 */
scout.Form.prototype.setDisabledStyle = function(disabledStyle) {
  this.rootGroupBox.setDisabledStyle(disabledStyle);
};

/**
 * Method invoked when:
 *  - this is a 'detailForm' and the outline content is displayed;
 *  - this is a 'view' and the view tab is selected;
 *  - this is a child 'dialog' or 'view' and its 'displayParent' is attached;
 * @override Widget.js
 */
scout.Form.prototype._attach = function() {
  this.$parent.append(this.$container);

  // If the parent was resized while this view was detached, the view has a wrong size.
  if (this.isView()) {
    this.invalidateLayoutTree(false);
  }

  this.session.detachHelper.afterAttach(this.$container);

  // form is attached even if children are not yet
  if ((this.isView() || this.isDialog()) && !this.detailForm) {
    //notify model this form is active
    this.session.desktop._setFormActivated(this);
  }

  // Attach child dialogs, message boxes and file choosers.
  this.formController.attachDialogs();
  this.messageBoxController.attach();
  this.fileChooserController.attach();
  scout.Form.parent.prototype._attach.call(this);
};

/**
 * Method invoked when:
 *  - this is a 'detailForm' and the outline content is hidden;
 *  - this is a 'view' and the view tab is deselected;
 *  - this is a child 'dialog' or 'view' and its 'displayParent' is detached;
 * @override Widget.js
 */
scout.Form.prototype._detach = function() {
  // Detach child dialogs, message boxes and file choosers, not views.
  this.formController.detachDialogs();
  this.messageBoxController.detach();
  this.fileChooserController.detach();

  this.session.detachHelper.beforeDetach(this.$container);
  this.$container.detach();
  scout.Form.parent.prototype._detach.call(this);
};

scout.Form.prototype.renderInitialFocus = function() {
  if (this.rendered) {
    this.session.focusManager.requestFocus(this._initialFocusElement());
  }
};

/**
 * This method returns the HtmlElement (DOM node) which is used by FocusManager/FocusContext/Popup
 * to focus the initial element. The impl. of these classes relies on HtmlElements, so we can not
 * easily use the focus() method of scout.FormField here. Furthermore, some classes like scout.Button
 * are sometimes 'adapted' by a ButtonAdapterMenu, which means the Button itself is not rendered, but
 * we must know the $container of the adapter menu to focus the correct element. That's why we call
 * the getFocusableElement() method.
 */
scout.Form.prototype._initialFocusElement = function() {
  var focusElement,
    initialFocusField = this.initialFocus;

  if (initialFocusField) {
    focusElement = initialFocusField.getFocusableElement();
  }
  if (!focusElement) {
    focusElement = this.session.focusManager.findFirstFocusableElement(this.$container);
  }
  return focusElement;
};

scout.Form.prototype._installFocusContext = function() {
  if (this.isDialog() || this.isPopupWindow()) {
    this.session.focusManager.installFocusContext(this.$container, scout.focusRule.NONE);
  }
};

scout.Form.prototype._uninstallFocusContext = function() {
  if (this.isDialog() || this.isPopupWindow()) {
    this.session.focusManager.uninstallFocusContext(this.$container);
  }
};

/**
 * === Method required for objects that act as 'displayParent' ===
 *
 * Returns 'true' if this Form is currently accessible to the user.
 */
scout.Form.prototype.inFront = function() {
  return this.rendered && this.attached;
};

scout.Form.prototype.requestFocus = function(formField) {
  if (!formField) {
    return;
  }
  formField.focus();
};

scout.Form.prototype.visitFields = function(visitor) {
  this.rootGroupBox.visit(visitor);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormAdapter = function() {
  scout.FormAdapter.parent.call(this);
  this._addAdapterProperties(['rootGroupBox', 'views', 'dialogs', 'initialFocus', 'messageBoxes', 'fileChoosers']);
};
scout.inherits(scout.FormAdapter, scout.ModelAdapter);

scout.FormAdapter.prototype.onModelAction = function(event) {
  if (event.type === 'requestFocus') {
    this._onRequestFocus(event.formField);
  } else {
    scout.FormAdapter.parent.prototype.onModelAction.call(this, event);
  }
};

scout.FormAdapter.prototype._onRequestFocus = function(formFieldId) {
  var formFieldWidget = this.session.getOrCreateWidget(formFieldId, this.widget);
  this.widget.requestFocus(formFieldWidget);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormLayout = function(form) {
  scout.FormLayout.parent.call(this);
  this._form = form;
};
scout.inherits(scout.FormLayout, scout.AbstractLayout);

scout.FormLayout.prototype.layout = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    htmlRootGb = this._htmlRootGroupBox(),
    rootGbSize;

  rootGbSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets())
    .subtract(htmlRootGb.getMargins());

  if (this._form.isDialog()) {
    rootGbSize.height -= this._titleHeight();
  }

  $.log.trace('(FormLayout#layout) rootGbSize=' + rootGbSize);
  htmlRootGb.setSize(rootGbSize);
};

scout.FormLayout.prototype.preferredLayoutSize = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    htmlRootGb = this._htmlRootGroupBox(),
    prefSize;

  prefSize = htmlRootGb.getPreferredSize()
    .add(htmlContainer.getInsets())
    .add(htmlRootGb.getMargins());
  prefSize.height += this._titleHeight();

  return prefSize;
};

scout.FormLayout.prototype._htmlRootGroupBox = function() {
  var $rootGroupBox = this._form.$container.children('.root-group-box');
  return scout.HtmlComponent.get($rootGroupBox);
};

scout.FormLayout.prototype._titleHeight = function() {
  var $titleBox = this._form.$container.children('.title-box');
  return scout.graphics.prefSize($titleBox, {
    includeMargin: true
  }).height;
};

scout.FormLifecycle = function() {
  this.askSaveChanges = true;
  this.askSaveChangesText; // Java: cancelVerificationText
  this.events = new scout.EventSupport();
  this.handlers = {
    'save': this._defaultSave.bind(this)
  };

  // FIXME CGU awe: why not always add lifecycle? remove case may remove it or empty method
  // FIXME CGU awe: on ui we should use destroy, not dispose. Event name should not contain 'form'.
  // FIXME CGU awe: Form lifecycle methods should be available on form delegating to lifecycle
  // FIXME CGU awe: do we need the 'do' prefix?
  // FIXME CGU awe: form.close() currently only works for remote case, delegate to lifecycle in js case
};

// Info: doExportXml, doImportXml, doSaveWithoutMarkerChange is not supported in Html UI

scout.FormLifecycle.prototype.init = function(form) {
  scout.assertParameter('form', form, scout.Form);
  this.form = form;
  this.askSaveChangesText = this.session().text('FormSaveChangesQuestion');
  this.markAsSaved();
};

scout.FormLifecycle.prototype.doCancel = function() {
  var showMessageBox = this.requiresSave() && this.askSaveChanges;
  if (showMessageBox) {
    this._showYesNoCancelMessageBox(
      this.askSaveChangesText,
      this.doOk.bind(this),
      this.doClose.bind(this));
  } else {
    this.doFinally();
    this.disposeForm();
  }
};

scout.FormLifecycle.prototype.disposeForm = function() {
  // FIXME [awe] 6.1 default impl. sollte form vom desktop entfernen
  this.events.trigger('disposeForm');
};

scout.FormLifecycle.prototype.doReset = function() {
  throw new Error('doReset not implemented yet');
};

/**
 * Helper function to deal with functions that return a Status object.
 * Makes it easier to return early when that function returns an invalid status (= less code to write).
 */
scout.FormLifecycle.prototype._whenInvalid = function(func) {
  var status = func.call(this);
  if (!(status instanceof scout.Status)) {
    throw new Error('Expected function to return a scout.Status object');
  }
  if (status.isValid()) {
    return false;
  }
  this._showStatusMessageBox(status);
  return true;
};

scout.FormLifecycle.prototype.doOk = function() {
  if (this._whenInvalid(this._validateForm)) {
    return;
  }

  if (this.requiresSave()) {
    if (this._whenInvalid(this._save)) {
      return;
    }
    this.markAsSaved();
  }

  this.doFinally();
  this.disposeForm();
};

scout.FormLifecycle.prototype._showYesNoCancelMessageBox = function(message, yesAction, noAction) {
  var session = this.session();
  var model = {
    parent: this.form,
    severity: scout.MessageBox.SEVERITY.WARNING,
    header: message,
    yesButtonText: session.text('Yes'),
    noButtonText: session.text('No'),
    cancelButtonText: session.text('Cancel')
  };
  var mbController = this.form.messageBoxController;
  var messageBox = scout.create('MessageBox', model);
  messageBox.on('action', function(event) {
    mbController.unregisterAndRemove(messageBox);
    if (event.option === 'yes') {
      yesAction();
    } else if (event.option === 'no') {
      noAction();
    }
  });
  mbController.registerAndRender(messageBox);
};

scout.FormLifecycle.prototype._showStatusMessageBox = function(status) {
  // FIXME [awe] 6.1 - make MessageBox easier to use in JS only case (like MessageBoxes in Java)
  var model = {
    parent: this.form,
    severity: scout.MessageBox.SEVERITY.ERROR,
    html: status.message,
    yesButtonText: this.session().text('Ok')
  };
  var mbController = this.form.messageBoxController;
  var messageBox = scout.create('MessageBox', model);
  messageBox.on('action', mbController.unregisterAndRemove.bind(mbController, messageBox));
  mbController.registerAndRender(messageBox);
};

scout.FormLifecycle.prototype._validateForm = function() {
  var missingFields = [];
  var invalidFields = [];

  this.form.visitFields(function(field) {
    var result = field.validate();
    if (result.valid) {
      return;
    }
    // when mandatory is not fullfilled, do not add to invalid fields
    if (!result.validByMandatory) {
      missingFields.push(field);
      return;
    }
    if (!result.validByErrorStatus) {
      invalidFields.push(field);
      return;
    }
  });

  var status = new scout.Status();
  if (missingFields.length === 0 && invalidFields.length === 0) {
    status.severity = scout.Status.Severity.OK;
  } else {
    status.severity = scout.Status.Severity.ERROR;
    status.message = this._createInvalidFieldsMessageHtml(missingFields, invalidFields);
  }

  return status;
};

/**
 * Creates a HTML message used to display missing and invalid fields in a message box.
 */
scout.FormLifecycle.prototype._createInvalidFieldsMessageHtml = function(missingFields, invalidFields) {
  var $div = $('<div>'), // cannot use $.makeDiv here because this needs to work without any rendered elements at all
    hasMissingFields = missingFields.length > 0,
    hasInvalidFields = invalidFields.length > 0;
  if (hasMissingFields) {
    appendTitleAndList.call(this, $div, 'FormEmptyMandatoryFieldsMessage', missingFields);
  }
  if (hasMissingFields && hasInvalidFields) {
    $div.appendElement('<br>');
  }
  if (hasInvalidFields) {
    appendTitleAndList.call(this, $div, 'FormInvalidFieldsMessage', invalidFields);
  }
  return $div.html();

  function appendTitleAndList($div, titleKey, fields) {
    $div
      .appendElement('<strong>')
      .text(this.session().text(titleKey));
    var $ul = $div.appendElement('<ul>');
    fields.forEach(function(field) {
      $ul.appendElement('<li>').text(field.label);
    });
  }
};

scout.FormLifecycle.prototype._defaultSave = function() {
  return scout.Status.ok();
};

scout.FormLifecycle.prototype._save = function() {
  var status = this.handlers.save();
  this.events.trigger('save');
  return status;
};

scout.FormLifecycle.prototype.doSave = function() {
  throw new Error('doSave not implemented yet');
};

scout.FormLifecycle.prototype.doClose = function() {
  this.doFinally();
  this.disposeForm();
};

scout.FormLifecycle.prototype.doFinally = function() {
  this.events.trigger('finally');
};

scout.FormLifecycle.prototype.markAsSaved = function() {
  this.form.visitFields(function(field) {
    field.markAsSaved();
  });
};

/**
 * Visits all form fields and calls the updateRequiresSave() function. If any
 * field has the requiresSave flag set to true, this function returns true,
 * false otherwise.
 *
 * @see (Java) AbstractFormField #checkSaveNeeded, #isSaveNeeded
 */
scout.FormLifecycle.prototype.requiresSave = function() {
  var requiresSave = false;
  this.form.visitFields(function(field) {
    field.updateRequiresSave();
    if (field.requiresSave) {
      requiresSave = true;
    }
  });
  return requiresSave;
};

scout.FormLifecycle.prototype.session = function() {
  return this.form.session;
};

/**
 * Register a handler function for save actions.
 * All handler functions must return a scout.Status. In case of an error a Status object with severity error must be returned.
 * Note: in contrast to events, handlers can control the flow of the lifecycle. They also have a return value where events have none.
 *   Only one handler can be registered for each type.
 */
scout.FormLifecycle.prototype.handle = function(type, func) {
  var supportedTypes = ['save'];
  if (supportedTypes.indexOf(type) === -1) {
    throw new Error('Cannot register handler for unsupported type \'' + type + '\'');
  }
  this.handlers[type] = func;
};

/**
 * Register an event handler for the given type.
 * Event handlers don't have a return value. They do not have any influence on the lifecycle flow. There can be multiple event
 * handler for each type.
 */
scout.FormLifecycle.prototype.on = function(type, func) {
  return this.events.on(type, func);
};

scout.FormLifecycle.prototype.off = function(type, func) {
  return this.events.off(type, func);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormMenu = function() {
  scout.FormMenu.parent.call(this);
  this.form;
  this.toggleAction = true;
  this._addAdapterProperties('form');
};
scout.inherits(scout.FormMenu, scout.Menu);

scout.FormMenu.PopupStyle = {
  DEFAULT: 'default',
  MOBILE: 'mobile'
};

scout.FormMenu.prototype._init = function(model) {
  scout.FormMenu.parent.prototype._init.call(this, model);

  if (!this.popupStyle) {
    if (this.session.userAgent.deviceType === scout.Device.Type.MOBILE) {
      this.popupStyle = scout.FormMenu.PopupStyle.MOBILE;
    } else {
      this.popupStyle = scout.FormMenu.PopupStyle.DEFAULT;
    }
  }
};

scout.FormMenu.prototype._renderForm = function() {
  if (!this.rendered) {
    // Don't execute initially since _renderSelected will be executed
    return;
  }
  this._renderSelected();
};

/**
 * @override
 */
scout.FormMenu.prototype.clone = function(modelOverride) {
  modelOverride = modelOverride || {};
  // If the FormMenu is put into a context menu it will be cloned.
  // Cloning a form is not possible because it may non clonable components (Table, TabBox, etc.) -> exclude
  // Luckily, it is not necessary to clone it since the form is never shown multiple times at once -> Just use the same instance
  modelOverride.form = this.form;
  return scout.FormMenu.parent.prototype.clone.call(this, modelOverride);
};

/**
 * @override
 */
scout.FormMenu.prototype._createPopup = function() {
  // Menu bar should always be on the bottom
  this.form.rootGroupBox.menuBar.bottom();

  if (this.popupStyle === scout.FormMenu.PopupStyle.MOBILE) {
    return scout.create('MobilePopup', {
      parent: this.session.desktop, // use desktop to make _handleSelectedInEllipsis work (if parent is this and this were not rendered, popup.entryPoint would not work)
      widget: this.form,
      title: this.form.title
    });
  }

  return scout.create('FormMenuPopup', {
    parent: this,
    formMenu: this,
    openingDirectionX: this.popupOpeningDirectionX,
    openingDirectionY: this.popupOpeningDirectionY
  });
};

/**
 * @override
 */
scout.FormMenu.prototype._doActionTogglesPopup = function() {
  return !!this.form;
};

scout.FormMenu.prototype._handleSelectedInEllipsis = function() {
  if (this.popupStyle !== scout.FormMenu.PopupStyle.MOBILE) {
    scout.FormMenu.parent.prototype._handleSelectedInEllipsis.call(this);
    return;
  }
  if (!this._doActionTogglesPopup()) {
    return;
  }
  // The mobile popup is not atached to a header -> no need to open the parent menu, just show the poupup
  if (this.selected) {
    this._openPopup();
  } else {
    this._closePopup();
  }
};

/**
 * @override
 */
scout.FormMenu.prototype._createActionKeyStroke = function() {
  return new scout.FormMenuActionKeyStroke(this);
};

/**
 * FormMenuActionKeyStroke
 */
scout.FormMenuActionKeyStroke = function(action) {
  scout.FormMenuActionKeyStroke.parent.call(this, action);
};
scout.inherits(scout.FormMenuActionKeyStroke, scout.ActionKeyStroke);

scout.FormMenuActionKeyStroke.prototype.handle = function(event) {
  this.field.toggle();
};

scout.FormMenuActionKeyStroke.prototype._postRenderKeyBox = function($drawingArea) {
  if (this.field.iconId) {
    var wIcon = $drawingArea.find('.icon').width();
    var wKeybox = $drawingArea.find('.key-box').outerWidth();
    var containerPadding = Number($drawingArea.css('padding-left').replace('px', ''));
    var leftKeyBox = wIcon / 2 - wKeybox / 2 + containerPadding;
    $drawingArea.find('.key-box').css('left', leftKeyBox + 'px');
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormMenuAdapter = function() {
  scout.FormMenuAdapter.parent.call(this);
  this._addAdapterProperties('form');
};
scout.inherits(scout.FormMenuAdapter, scout.MenuAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormMenuPopup = function() {
  scout.FormMenuPopup.parent.call(this);
  this.formMenu;
  this.formMenuPropertyChangeHandler = this._onFormMenuPropertyChange.bind(this);
  this._addAdapterProperties('form');
};
scout.inherits(scout.FormMenuPopup, scout.PopupWithHead);

scout.FormMenuPopup.prototype._init = function(options) {
  options.form = options.formMenu.form;
  options.initialFocus = options.formMenu.form._initialFocusElement.bind(options.formMenu.form);
  scout.FormMenuPopup.parent.prototype._init.call(this, options);

  this.$formMenu = this.formMenu.$container;
  this.$headBlueprint = this.$formMenu;
};

scout.FormMenuPopup.prototype._createLayout = function() {
  return new scout.FormMenuPopupLayout(this);
};

scout.FormMenuPopup.prototype._render = function($parent) {
  scout.FormMenuPopup.parent.prototype._render.call(this, $parent);
  this.$container.addClass('form-menu-popup');

  this.form.renderInitialFocusEnabled = false;
  this.form.render(this.$body);
  this.form.htmlComp.pixelBasedSizing = true;

  // We add this here for symmetry reasons (because _removeHead is not called on remove())
  if (this._headVisible) {
    this.formMenu.on('propertyChange', this.formMenuPropertyChangeHandler);
  }
};

scout.FormMenuPopup.prototype._remove = function() {
  scout.FormMenuPopup.parent.prototype._remove.call(this);

  if (this._headVisible) {
    this.formMenu.off('propertyChange', this.formMenuPropertyChangeHandler);
  }
};

scout.FormMenuPopup.prototype._renderHead = function() {
  scout.FormMenuPopup.parent.prototype._renderHead.call(this);
  if (this.formMenu.uiCssClass) {
    this._copyCssClassToHead(this.formMenu.uiCssClass);
  }
  if (this.formMenu.cssClass) {
    this._copyCssClassToHead(this.formMenu.cssClass);
  }
  this._copyCssClassToHead('unfocusable');
};

scout.FormMenuPopup.prototype._onFormMenuPropertyChange = function(event) {
  this.session.layoutValidator.schedulePostValidateFunction(function() {
    // Because this post layout validation function is executed asynchronously,
    // we have to check again if the popup is still rendered.
    if (!this.rendered) {
      return;
    }
    this.rerenderHead();
    this.position();
  }.bind(this));
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormMenuPopupLayout = function(popup) {
  scout.FormMenuPopupLayout.parent.call(this, popup);
  this.popup = popup;
};
scout.inherits(scout.FormMenuPopupLayout, scout.PopupWithHeadLayout);

scout.FormMenuPopupLayout.prototype.layout = function($container) {
  var popupSize,
    htmlForm = this.popup.form.htmlComp;

  scout.FormMenuPopupLayout.parent.prototype.layout.call(this, $container);

  popupSize = scout.graphics.getSize(this.popup.$body);

  // set size of form
  popupSize = popupSize.subtract(scout.graphics.getInsets(this.popup.$body));
  htmlForm.setSize(popupSize);
};

scout.FormMenuPopupLayout.prototype.preferredLayoutSize = function($container) {
  var htmlComp = this.popup.htmlComp,
    htmlForm = this.popup.form.htmlComp,
    prefSize;

  prefSize = htmlForm.getPreferredSize()
    .add(htmlComp.getInsets())
    .add(scout.graphics.getInsets(this.popup.$body, {
      includeMargin: true
    }))
    .add(htmlForm.getMargins());

  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DialogLayout = function(form) {
  scout.DialogLayout.parent.call(this, form);
  this.autoSize = true;
};
scout.inherits(scout.DialogLayout, scout.FormLayout);

scout.DialogLayout.prototype.layout = function($container) {
  if (!this.autoSize) {
    scout.DialogLayout.parent.prototype.layout.call(this, $container);
    return;
  }

  var htmlComp = this._form.htmlComp,
    $window = this._form.$container.window(),
    dialogMargins = htmlComp.getMargins(),
    windowSize = new scout.Dimension($window.width(), $window.height()),
    dialogSize = new scout.Dimension(),
    currentBounds = htmlComp.getBounds(),
    prefSize = this.preferredLayoutSize($container);

  // Because prefSize does not include the dialog margins, we have to subtract them from the current size as well.
  // Because currentBounds.subtract() would also alter the x/y values, we subtract the dimensions manually.
  currentBounds.width -= dialogMargins.horizontal();
  currentBounds.height -= dialogMargins.vertical();

  // class .dialog may specify a margin
  // currentBounds.y and x are 0 initially, but if size changes while dialog is open they are greater than 0
  // This guarantees the dialog size may not exceed the document size
  var maxWidth = (windowSize.width - dialogMargins.horizontal() - currentBounds.x);
  var maxHeight = (windowSize.height - dialogMargins.vertical() - currentBounds.y);

  // Calculate new dialog size:
  // 1. Ensure the dialog is not larger than viewport
  dialogSize.width = Math.min(maxWidth, prefSize.width);
  dialogSize.height = Math.min(maxHeight, prefSize.height);

  // 2. Ensure the dialog can only get larger, not smaller.
  //    This prevents 'snapping' the dialog back to the calculated size when a field changes its visibility, but
  //    the user previously enlarged the dialog.
  //    This must not happen when the dialog is layouted the first time (-> when it is opened, because it has not the right size yet and may get too big)
  if (htmlComp.layouted) {
    dialogSize.width = Math.max(dialogSize.width, currentBounds.width);
    dialogSize.height = Math.max(dialogSize.height, currentBounds.height);
  }

  scout.graphics.setSize(htmlComp.$comp, dialogSize);
  scout.DialogLayout.parent.prototype.layout.call(this, $container);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Table = function() {
  scout.Table.parent.call(this);

  this.rowIconVisible = false;
  this.autoResizeColumns = false;
  this.columnAddable = false;
  this.checkable = false;
  this.enabled = true;
  this.headerEnabled = true;
  this.headerVisible = true;
  this.hasReloadHandler = false;
  this.keyStrokes = [];
  this.keyboardNavigation = true;
  this.menus = [];
  this.contextMenu;
  this.multiCheck = true;
  this.multiSelect = true;
  this.multilineText = false;
  this.rows = [];
  this.scrollToSelection = false;
  this.scrollTop = 0;
  this.selectedRows = [];
  this.sortEnabled = true;
  this.tableControls = [];
  this.tableStatusVisible = false;
  this.footerVisible = false;
  this.filters = [];
  this.columns = [];
  this.rowsMap = {}; // rows by id
  this.rowWidth = 0;
  this.rowBorderWidth; // read-only, set by _calculateRowBorderWidth(), also used in TableLayout.js
  this.rowBorderLeftWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableHeader.js
  this.rowBorderRightWidth = 0; // read-only, set by _calculateRowBorderWidth(), also used in TableHeader.js
  this.staticMenus = [];
  this.selectionHandler = new scout.TableSelectionHandler(this);
  this.header;
  this.footer;
  this._filterMap = {};
  this._filteredRows = [];
  this._filteredRowsDirty = true;
  this.tooltips = [];
  this._aggregateRows = [];
  this._animationRowLimit = 25;
  this._blockLoadThreshold = 25;
  this.menuBar;
  this._doubleClickSupport = new scout.DoubleClickSupport();
  this.checkableStyle = scout.Table.CheckableStyle.CHECKBOX;
  this.$container;
  this.$data;
  this._addAdapterProperties(['tableControls', 'menus', 'keyStrokes']);

  this._permanentHeadSortColumns = [];
  this._permanentTailSortColumns = [];
  // Initial value must be > 0 to make prefSize work (if it is 0, no filler will be generated).
  // If rows have a variable height, prefSize is only correct for 10 rows.
  // Layout will adjust this value depending on the view port size.
  this.viewRangeSize = 10;
  this.viewRangeRendered = new scout.Range(0, 0);
  this._filterMenusHandler = this._filterMenus.bind(this);
  this.virtual = true;
  this.contextColumn;
};
scout.inherits(scout.Table, scout.Widget);

//FIXME CGU [6.1] create StringColumn.js incl. defaultValues from defaultValues.json

scout.Table.CheckableStyle = {
  /**
   * When row is checked a boolean column with a checkbox is inserted into the table.
   */
  CHECKBOX: 'checkbox',
  /**
   * When a row is checked the table-row is marked as checked. By default a background
   * color is set on the table-row when the row is checked.
   */
  TABLE_ROW: 'tableRow'
};
scout.Table.SELECTION_CLASSES = 'select-middle select-top select-bottom select-single selected';

scout.Table.prototype._init = function(model) {
  scout.Table.parent.prototype._init.call(this, model);
  this._initColumns();

  this.rows.forEach(function(row, i) {
    this.rows[i] = this._initRow(row);
  }, this);

  this.menuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.MenuItemsOrder(this.session, 'Table'),
    menuFilter: this._filterMenusHandler
  });
  this.menuBar.bottom();

  this._syncSelectedRows(this.selectedRows);
  this.setFilters(this.filters);
  this._syncKeyStrokes(this.keyStrokes);
  this._syncMenus(this.menus);
  this._syncTableControls(this.tableControls);
  this._syncTableStatus(this.tableStatus);
  this._applyFilters(this.rows);
  this._calculateValuesForBackgroundEffect();
  this._group();
};

scout.Table.prototype._initRow = function(row) {
  if (!(row instanceof scout.TableRow)) {
    row.parent = this;
    row = scout.create('TableRow', row);
  }
  this.rowsMap[row.id] = row;
  this.trigger('rowInitialized', {
    row: row
  });
  return row;
};

scout.Table.prototype._initColumns = function() {
  var column, i;
  for (i = 0; i < this.columns.length; i++) {
    this.columns[i].session = this.session;
    column = scout.create(this.columns[i]);
    column.table = this;
    this.columns[i] = column;

    if (column.checkable) {
      // set checkable column if this column is the checkable one
      this.checkableColumn = column;
    }
  }

  // Add gui only checkbox column at the beginning
  if (this.rowIconVisible) {
    this._insertRowIconColumn();
  }
  this._syncCheckable(this.checkable);

  // Sync head and tail sort columns
  this._syncHeadAndTailSortColumns();
};

/**
 * @override
 */
scout.Table.prototype._createLoadingSupport = function() {
  return new scout.LoadingSupport({
    widget: this
  });
};

/**
 * @override
 */
scout.Table.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.Table.prototype._initKeyStrokeContext = function() {
  scout.Table.parent.prototype._initKeyStrokeContext.call(this);

  this._initTableKeyStrokeContext();
};

scout.Table.prototype._initTableKeyStrokeContext = function() {
  this.keyStrokeContext.registerKeyStroke([
    new scout.TableNavigationUpKeyStroke(this),
    new scout.TableNavigationDownKeyStroke(this),
    new scout.TableNavigationPageUpKeyStroke(this),
    new scout.TableNavigationPageDownKeyStroke(this),
    new scout.TableNavigationHomeKeyStroke(this),
    new scout.TableNavigationEndKeyStroke(this),

    new scout.TableFocusFilterFieldKeyStroke(this),
    new scout.TableStartCellEditKeyStroke(this),
    new scout.TableSelectAllKeyStroke(this),
    new scout.TableRefreshKeyStroke(this),
    new scout.TableToggleRowKeyStroke(this),
    new scout.TableCopyKeyStroke(this),
    new scout.ContextMenuKeyStroke(this, this.onContextMenu, this),
    new scout.AppLinkKeyStroke(this, this.handleAppLinkAction)
  ]);

  // Prevent default action and do not propagate  or  keys if ctrl- or alt-modifier is not pressed.
  // Otherwise, an '-event' on the first row, or an '-event' on the last row will bubble up (because not consumed by table navigation keystrokes) and cause a superior table to move its selection.
  // Use case: - outline page table with search form that contains a table field;
  //           - shift + '-event'/'-event' are not consumed by a single selection table, and would propagate otherwise;
  //           - preventDefault because of smartfield, so that the cursor is not moved on first or last row;
  this.keyStrokeContext.registerStopPropagationInterceptor(function(event) {
    if (!event.ctrlKey && !event.altKey && scout.isOneOf(event.which, scout.keys.UP, scout.keys.DOWN)) {
      event.stopPropagation();
      event.preventDefault();
    }
  });
};

scout.Table.prototype._insertBooleanColumn = function() {
  // don't add checkbox column when we're in checkableStyle mode
  if (this.checkableStyle === scout.Table.CheckableStyle.TABLE_ROW) {
    return;
  }
  var column = scout.create('BooleanColumn', {
    session: this.session,
    fixedWidth: true,
    fixedPosition: true,
    guiOnly: true,
    disallowHeaderMenu: true,
    showSeparator: false,
    width: scout.Column.NARROW_MIN_WIDTH,
    table: this
  });

  scout.arrays.insert(this.columns, column, 0);
  this.checkableColumn = column;
};

scout.Table.prototype._insertRowIconColumn = function() {
  var position = 0,
    column = scout.create('IconColumn', {
      session: this.session,
      fixedWidth: true,
      fixedPosition: true,
      guiOnly: true,
      disallowHeaderMenu: true,
      showSeparator: false,
      width: scout.Column.NARROW_MIN_WIDTH,
      table: this
    });
  if (this.columns[0] === this.checkableColumn) {
    position = 1;
  }
  scout.arrays.insert(this.columns, column, position);
  this.rowIconColumn = column;
};

scout.Table.prototype.handleAppLinkAction = function(event) {
  var $appLink = $(event.target);
  var column = this._columnAtX($appLink.offset().left);
  this._triggerAppLinkAction(column, $appLink.data('ref'));
};

scout.Table.prototype._render = function($parent) {
  this.$container = this.$parent.appendDiv('table');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.TableLayout(this));
  this.htmlComp.pixelBasedSizing = false;

  if (this.uiCssClass) {
    this.$container.addClass(this.uiCssClass);
  }

  this.$data = this.$container.appendDiv('table-data');
  this.$data.on('mousedown', '.table-row', this._onRowMouseDown.bind(this))
    .on('mouseup', '.table-row', this._onRowMouseUp.bind(this))
    .on('dblclick', '.table-row', this._onRowDoubleClick.bind(this))
    .on('scroll', this._onDataScroll.bind(this))
    .on('contextmenu', '.table-row', function(event) {
      event.preventDefault();
      event.stopPropagation();
      return false;
    });
  scout.scrollbars.install(this.$data, {
    parent: this,
    axis: 'both'
  });
  this._installImageListeners();
  this._installCellTooltipSupport();
  this.menuBar.render(this.$container);

  // layout bugfix for IE9 (and maybe other browsers)
  if (scout.device.tableAdditionalDivRequired) {
    // determine @table-cell-padding-left and @table-cell-padding-right (actually the sum)
    var test = this.$data.appendDiv('table-cell');
    test.text('&nbsp;');
    this.cellHorizontalPadding = test.cssPxValue('padding-left') + test.cssPxValue('padding-right');
    test.remove();
  }

  this._calculateRowBorderWidth();
  this._updateRowWidth();
  this._updateRowHeight();
  this._renderViewport();
  if (this.scrollToSelection) {
    this.revealSelection();
  }
};

scout.Table.prototype._renderProperties = function() {
  scout.Table.parent.prototype._renderProperties.call(this);
  this._renderTableHeader();
  this._renderFooterVisible();
  this._renderDropType();
  this._renderCheckableStyle();
};

scout.Table.prototype._remove = function() {
  scout.scrollbars.uninstall(this.$data, this.session);
  this._uninstallDragAndDropHandler();
  // FIXME CGU do not delete header, implement according to footer
  this.header = null;
  this._removeAggregateRows();
  this._uninstallImageListeners();
  this._uninstallCellTooltipSupport();
  this._removeRows();
  this.$fillBefore = null;
  this.$fillAfter = null;
  this.$data = null;
  this.$emptyData = null;
  scout.Table.parent.prototype._remove.call(this);
};

scout.Table.prototype.setTableControls = function(controls) {
  this.setProperty('tableControls', controls);
};

scout.Table.prototype._renderTableControls = function() {
  if (this.footer) {
    this.footer._renderControls();
  }
};

scout.Table.prototype._syncTableControls = function(controls) {
  var i;
  for (i = 0; i < this.tableControls.length; i++) {
    this.keyStrokeContext.unregisterKeyStroke(this.tableControls[i]);
  }
  this._setProperty('tableControls', controls);
  for (i = 0; i < this.tableControls.length; i++) {
    this.keyStrokeContext.registerKeyStroke(this.tableControls[i]);
  }
  this._updateFooterVisibility();
  this.tableControls.forEach(function(control) {
    control.tableFooter = this.footer;
  }, this);
};

/**
 * When an IMG has been loaded we must update the stored height in the model-row.
 * Note: we don't change the width of the row or table.
 */
scout.Table.prototype._onImageLoadOrError = function(event) {
  var
    $row = $(event.target).closest('.table-row'),
    row = $row.data('row');
  row.height = $row.outerHeight(true);
  this.invalidateLayoutTree();
};

scout.Table.prototype._onRowMouseDown = function(event) {
  this._doubleClickSupport.mousedown(event);
  this._$mouseDownRow = $(event.currentTarget);
  this._mouseDownColumn = this._columnAtX(event.pageX);
  this._$mouseDownRow.window().one('mouseup', function() {
    this._$mouseDownRow = null;
  }.bind(this));
  this.selectionHandler.onMouseDown(event);

  if (this.checkableStyle === scout.Table.CheckableStyle.TABLE_ROW) {
    var row = this._$mouseDownRow.data('row');
    this.checkRow(row, !row.checked);
  }
  this.setContextColumn(this._columnAtX(event.pageX));
};

scout.Table.prototype._onRowMouseUp = function(event) {
  var $row, $mouseUpRow, column, $appLink, row,
    mouseButton = event.which;

  if (this._doubleClickSupport.doubleClicked()) {
    // Don't execute on double click events
    return;
  }

  $mouseUpRow = $(event.currentTarget);
  this.selectionHandler.onMouseUp(event, $mouseUpRow);

  if (!this._$mouseDownRow || this._$mouseDownRow[0] !== $mouseUpRow[0]) {
    // Don't accept if mouse up happens on another row than mouse down, or mousedown didn't happen on a row at all
    return;
  }

  $row = $mouseUpRow;
  column = this._columnAtX(event.pageX);
  if (column !== this._mouseDownColumn) {
    // Don't execute click / appLinks when the mouse gets pressed and moved outside of a cell
    return;
  }
  if (mouseButton === 1) {
    column.onMouseUp(event, $row);
    $appLink = this._find$AppLink(event);
  }
  row = $row.data('row');
  if ($appLink) {
    this._triggerAppLinkAction(column, $appLink.data('ref'));
  } else {
    this._triggerRowClicked(row, mouseButton);
  }
};

scout.Table.prototype._onRowDoubleClick = function(event) {
  var $row = $(event.currentTarget),
    column = this._columnAtX(event.pageX);

  this.doRowAction($row.data('row'), column);
};

scout.Table.prototype.onContextMenu = function(event) {
  var func = function(event) {
    event.preventDefault();

    var menuItems;
    if (this.selectedRows.length > 0) {
      menuItems = this._filterMenus(this.menus, scout.MenuDestinations.CONTEXT_MENU, true, false, ['Header']);
      if (!event.pageX && !event.pageY) {
        var $rowToDisplay = this.selectionHandler.lastActionRow ? this.selectionHandler.lastActionRow.$row : this.selectedRows[this.selectedRows.length - 1].$row;
        var offset = $rowToDisplay.offset();
        event.pageX = offset.left + 10;
        event.pageY = offset.top + $rowToDisplay.outerHeight() / 2;
      }
      if (menuItems.length > 0) {
        this.contextMenu = scout.create('ContextMenuPopup', {
          parent: this,
          menuItems: menuItems,
          location: {
            x: event.pageX,
            y: event.pageY
          },
          $anchor: this.$data,
          menuFilter: this._filterMenusHandler
        });
        this.contextMenu.open();

        // Set table style to focused, so that it looks as it still has the focus.
        // Must be called after open(), because opening the popup might cause another
        // popup to close first (which will remove the 'focused' class).
        if (this.enabled) {
          this.$container.addClass('focused');
          this.contextMenu.on('close', function(event) {
            this.$container.removeClass('focused');
            this.contextMenu = null;
          }.bind(this));
        }
      }
    }
  };

  scout.menus.showContextMenuWithWait(this.session, func.bind(this), event);
};

scout.Table.prototype._onDataScroll = function() {
  var scrollTop = this.$data[0].scrollTop;
  if (this.scrollTop === scrollTop) {
    return;
  }
  this._renderViewport();
  this.scrollTop = scrollTop;
};

scout.Table.prototype._renderTableStatus = function() {
  this.trigger('statusChanged');
};

scout.Table.prototype.setContextColumn = function(contextColumn) {
  this.setProperty('contextColumn', contextColumn);
};

scout.Table.prototype._hasVisibleTableControls = function() {
  return this.tableControls.some(function(control) {
    if (control.visible) {
      return true;
    }
    return false;
  });
};

scout.Table.prototype.hasAggregateTableControl = function() {
  return this.tableControls.some(function(control) {
    if (control instanceof scout.AggregateTableControl) {
      return true;
    }
    return false;
  });
};

scout.Table.prototype._createHeader = function() {
  return scout.create('TableHeader', {
    parent: this,
    table: this,
    enabled: this.headerEnabled
  });
};

scout.Table.prototype._createFooter = function() {
  return scout.create('TableFooter', {
    parent: this,
    table: this
  });
};

scout.Table.prototype._installCellTooltipSupport = function() {
  scout.tooltips.install(this.$data, {
    parent: this,
    selector: '.table-cell',
    text: this._cellTooltipText.bind(this),
    arrowPosition: 50,
    arrowPositionUnit: '%',
    nativeTooltip: !scout.device.isCustomEllipsisTooltipPossible()
  });
};

scout.Table.prototype._uninstallCellTooltipSupport = function() {
  scout.tooltips.uninstall(this.$data);
};

scout.Table.prototype._cellTooltipText = function($cell) {
  var cell, tooltipText,
    $row = $cell.parent(),
    cellIndex = this.$cellsForRow($row).index($cell),
    column = this.columns[cellIndex],
    row = $row.data('row');

  if (row) {
    cell = this.cell(column, row);
    tooltipText = cell.tooltipText;
  }

  if (tooltipText) {
    return tooltipText;
  } else if (this._isTruncatedCellTooltipEnabled(column) && $cell.isContentTruncated()) {
    return $cell.text();
  }
};

/**
 * Show cell tooltip only if it is not possible to resize the column
 */
scout.Table.prototype._isTruncatedCellTooltipEnabled = function(column) {
  return !this.headerVisible || column.fixedWidth;
};

scout.Table.prototype.reload = function() {
  if (!this.hasReloadHandler) {
    return;
  }
  this._removeRows();
  this._renderFiller();
  this._triggerReload();
};

scout.Table.prototype.exportToClipboard = function() {
  this._triggerExportToClipboard();
};

scout.Table.prototype.toggleSelection = function() {
  if (this.selectedRows.length === this.filteredRows().length) {
    this.deselectAll();
  } else {
    this.selectAll();
  }
};

scout.Table.prototype.selectAll = function() {
  this.selectRows(this.filteredRows());
};

scout.Table.prototype.deselectAll = function() {
  this.selectRows([]);
};

scout.Table.prototype.checkAll = function(checked) {
  this.checkRows(this.filteredRows(), {
    checked: checked
  });
};

scout.Table.prototype.uncheckAll = function() {
  this.checkAll(false);
};

scout.Table.prototype.updateScrollbars = function() {
  scout.scrollbars.update(this.$data);
};


scout.Table.prototype._sort = function(animateAggregateRows) {
  var sortColumns = this._sortColumns();

  // Initialize comparators
  if (!this._isUiSortPossible(sortColumns)) {
    return false;
  }
  this.clearAggregateRows(animateAggregateRows);
  if (!sortColumns.length) {
    // no sort column defined.
    return true;
  }

  // add all visible columns as fallback sorting to guarantee same sorting as in Java.
  sortColumns = scout.arrays.union(sortColumns, this.columns);

  this._sortImpl(sortColumns);
  this._filteredRowsDirty = true; // order has been changed
  this._triggerRowOrderChanged();
  if (this.rendered) {
    this._renderRowOrderChanges();
  }

  // Do it after row order has been rendered, because renderRowOrderChanges rerenders the whole viewport which would destroy the animation
  this._group(animateAggregateRows);

  // Sort was possible -> return true
  return true;
};

/**
 * In a JS only app the flag 'uiSortPossible' is never set and thus defaults to true. Additionally we check if each column can install
 * its comparator used to sort. If installation failed for some reason, sorting is not possible. In a remote app the server sets the
 * 'uiSortPossible' flag, which decides if the column must be sorted by the server or can be sorted by the client.
 * @see RemoteApp.js
 */
scout.Table.prototype._isUiSortPossible = function(sortColumns) {
  var uiSortPossible = scout.nvl(this.uiSortPossible, true);
  return uiSortPossible && this._isColumnsUiSortPossible(sortColumns);
};

scout.Table.prototype._sortColumns = function() {
  var sortColumns = [];
  for (var c = 0; c < this.columns.length; c++) {
    var column = this.columns[c];
    var sortIndex = column.sortIndex;
    if (sortIndex >= 0) {
      sortColumns[sortIndex] = column;
    }
  }
  return sortColumns;
};

scout.Table.prototype._sortImpl = function(sortColumns) {
  // compare rows
  function compare(row1, row2) {
    for (var s = 0; s < sortColumns.length; s++) {
      var column = sortColumns[s];
      var result = column.compare(row1, row2);
      if (column.sortActive && !column.sortAscending) {
        // only consider sortAscending flag when sort is active
        // columns with !sortActive are always sorted ascending (sortAscending represents last state for those, thus not considered)
        result = -result;
      }
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  }
  this.rows.sort(compare.bind(this));
};

/**
 * @returns whether or not the column can be sorted (as a side effect a comparator is installed on each column)
 */
scout.Table.prototype._isColumnsUiSortPossible = function(sortColumns) {
  return sortColumns.every(function(column) {
    return column.isUiSortPossible();
  });
};

scout.Table.prototype._renderRowOrderChanges = function() {
  var animate,
    $rows = this.$rows(),
    oldRowPositions = {};

  // store old position
  // animate only if every row is rendered, otherwise some rows would be animated and some not
  if ($rows.length === this.filteredRows().length) {
    $rows.each(function(index, elem) {
      var rowWasInserted = false,
        $row = $(elem),
        row = $row.data('row');

      // Prevent the order animation for newly inserted rows (to not confuse the user)
      if (this._insertedRows) {
        for (var i = 0; i < this._insertedRows.length; i++) {
          if (this._insertedRows[i].id === row.id) {
            rowWasInserted = true;
            break;
          }
        }
      }

      if (!rowWasInserted) {
        animate = true;
        oldRowPositions[row.id] = $row.offset().top;
      }
    }.bind(this));
  }

  this._rerenderViewport();
  // If aggregate rows are being removed by animation, rerenderViewport does not delete them -> reorder
  // This may happen if grouping gets deactivated and another column will get the new first sort column
  this._order$AggregateRows();

  // for less than animationRowLimit rows: move to old position and then animate
  if (animate) {
    $rows = this.$rows();
    $rows.each(function(index, elem) {
      var $row = $(elem),
        row = $row.data('row'),
        oldTop = oldRowPositions[row.id];

      if (oldTop !== undefined) {
        $row.css('top', oldTop - $row.offset().top).animate({
          top: 0
        }, {
          progress: this._triggerRowOrderChanged.bind(this, row, true)
        });
      }
    }.bind(this));
  }
};

/**
 * @param multiSort true to add the column to list of sorted columns. False to use this column exclusively as sort column (reset other columns)
 * @param remove true to remove the column from the sort columns
 */
scout.Table.prototype.sort = function(column, direction, multiSort, remove) {
  var data, sorted, animateAggregateRows;
  multiSort = scout.nvl(multiSort, false);
  remove = scout.nvl(remove, false);
  // Animate if sort removes aggregate rows
  animateAggregateRows = !multiSort;
  if (remove) {
    this._removeSortColumn(column);
  } else {
    this._addSortColumn(column, direction, multiSort);
  }
  if (this.header) {
    this.header.onSortingChanged();
  }
  sorted = this._sort(animateAggregateRows);

  data = {
    columnId: column.id,
    sortAscending: column.sortAscending
  };
  if (remove) {
    data.sortingRemoved = true;
  }
  if (multiSort) {
    data.multiSort = true;
  }
  if (sorted) {
    this._send('rowsSorted', data);
  } else {
    // Delegate sorting to server when it is not possible on client side
    this._send('sortRows', data);
    // hint to animate the aggregate after the row order changed event
    this._animateAggregateRows = animateAggregateRows;
  }
};

scout.Table.prototype._addSortColumn = function(column, direction, multiSort) {
  var groupColCount, sortColCount;
  direction = scout.nvl(direction, column.sortAscending ? 'asc' : 'desc');
  multiSort = scout.nvl(multiSort, true);

  this._updateSortIndexForColumn(column, multiSort);

  // Reset grouped flag if column should be sorted exclusively
  if (!multiSort) {
    groupColCount = this._groupedColumns().length;
    sortColCount = this._sortColumns().length;
    if (sortColCount === 1 && groupColCount === 1) {
      // special case: if it is the only sort column and also grouped, do not remove grouped property.
    } else {
      column.grouped = false;
    }
  }

  column.sortAscending = direction === 'asc' ? true : false;
  column.sortActive = true;
};

/**
 * Intended to be called for new sort columns.
 * Sets the sortIndex of the given column and its siblings.
 */
scout.Table.prototype._updateSortIndexForColumn = function(column, multiSort) {
  var deviation,
    sortIndex = -1;

  if (multiSort) {
    // if not already sorted set the appropriate sort index (check for sortIndex necessary if called by _onColumnHeadersUpdated)
    if (!column.sortActive || column.sortIndex === -1) {
      sortIndex = Math.max(-1, scout.arrays.max(this.columns.map(function(c) {
        return (c.sortIndex === undefined || c.initialAlwaysIncludeSortAtEnd) ? -1 : c.sortIndex;
      })));
      column.sortIndex = sortIndex + 1;

      // increase sortIndex for all permanent tail columns (a column has been added in front of them)
      this._permanentTailSortColumns.forEach(function(c) {
        c.sortIndex++;
      });
    }
  } else {
    // do not update sort index for permanent head/tail sort columns, their order is fixed (see ColumnSet.java)
    if (!(column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd)) {
      column.sortIndex = this._permanentHeadSortColumns.length;
    }

    // remove sort index for siblings (ignore permanent head/tail columns, only if not multi sort)
    scout.arrays.eachSibling(this.columns, column, function(siblingColumn) {
      if (siblingColumn.sortActive) {
        this._removeSortColumnInternal(siblingColumn);
      }
    }.bind(this));

    // set correct sort index for all permanent tail sort columns
    deviation = (column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd) ? 0 : 1;
    this._permanentTailSortColumns.forEach(function(c, index) {
      c.sortIndex = this._permanentHeadSortColumns.length + deviation + index;
    }, this);
  }
};

scout.Table.prototype._removeSortColumn = function(column) {
  if (column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd) {
    return;
  }
  // Adjust sibling columns with higher index
  scout.arrays.eachSibling(this.columns, column, function(siblingColumn) {
    if (siblingColumn.sortIndex > column.sortIndex) {
      siblingColumn.sortIndex = siblingColumn.sortIndex - 1;
    }
  });
  this._removeSortColumnInternal(column);
};

scout.Table.prototype._removeSortColumnInternal = function(column) {
  if (column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd) {
    return;
  }
  column.sortActive = false;
  column.grouped = false;
  column.sortIndex = -1;
};

scout.Table.prototype.isGroupingPossible = function(column) {
  var possible = true;

  if (!this.sortEnabled) {
    // grouping without sorting is not possible
    return false;
  }

  if (this._permanentHeadSortColumns && this._permanentHeadSortColumns.length === 0) {
    // no permanent head sort columns. grouping ok.
    return true;
  }

  if (column.initialAlwaysIncludeSortAtBegin) {
    possible = true;
    scout.arrays.eachSibling(this._permanentHeadSortColumns, column, function(c) {
      if (c.sortIndex < column.sortIndex) {
        possible = possible && c.grouped;
      }
    });
    return possible;
  }

  if (column.initialAlwaysIncludeSortAtEnd) {
    // it is a tail sort column. Grouping does not make sense.
    return false;
  }

  // column itself is not a head or tail sort column. Therefore, all head sort columns must be grouped.
  this._permanentHeadSortColumns.forEach(function(c) {
    possible = possible && c.grouped;
  });
  return possible;
};

scout.Table.prototype.isAggregationPossible = function(column) {
  if (!(column instanceof scout.NumberColumn)) {
    return false;
  }

  if (column.grouped) {
    // Aggregation is not possible if column is grouped
    return false;
  }

  // Aggregation is possible if it is grouped by another column or aggregation control is available
  return this.isGrouped() || this.hasAggregateTableControl();
};

scout.Table.prototype.changeAggregation = function(column, func) {
  this.changeAggregations([column], [func]);
};

scout.Table.prototype.changeAggregations = function(columns, functions) {
  columns.forEach(function(column, i) {
    var func = functions[i];
    column.setAggregationFunction(func);

    this._triggerAggregationFunctionChanged(column);
  }, this);

  this._group();
};

scout.Table.prototype._addGroupColumn = function(column, direction, multiGroup) {
  var sortIndex = -1;

  if (!this.isGroupingPossible(column)) {
    return;
  }

  direction = scout.nvl(direction, column.sortAscending ? 'asc' : 'desc');
  multiGroup = scout.nvl(multiGroup, true);
  if (!(column.initialAlwaysIncludeSortAtBegin || column.initialAlwaysIncludeSortAtEnd)) {
    // do not update sort index for permanent head/tail sort columns, their order is fixed (see ColumnSet.java)
    if (multiGroup) {

      sortIndex = Math.max(-1, scout.arrays.max(this.columns.map(function(c) {
        return (c.sortIndex === undefined || c.initialAlwaysIncludeSortAtEnd || !c.grouped) ? -1 : c.sortIndex;
      })));

      if (!column.sortActive) {
        // column was not yet present: insert at determined position
        // and move all subsequent nodes by one.
        // add just after all other grouping columns in column set.
        column.sortIndex = sortIndex + 1;
        scout.arrays.eachSibling(this.columns, column, function(siblingColumn) {
          if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex > sortIndex) {
            siblingColumn.sortIndex++;
          }
        });

        // increase sortIndex for all permanent tail columns (a column has been added in front of them)
        this._permanentTailSortColumns.forEach(function(c) {
          c.sortIndex++;
        });
      } else {
        // column already sorted, update position:
        // move all sort columns between the newly determined sortindex and the old sortindex by one.
        scout.arrays.eachSibling(this.columns, column, function(siblingColumn) {
          if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) &&
            (siblingColumn.sortIndex > sortIndex) &&
            (siblingColumn.sortIndex < column.sortIndex)) {
            siblingColumn.sortIndex++;
          }
        });
        column.sortIndex = sortIndex + 1;
      }
    } else {
      // no multigroup:
      sortIndex = this._permanentHeadSortColumns.length;

      if (column.sortActive) {
        // column already sorted, update position:
        // move all sort columns between the newly determined sortindex and the old sortindex by one.
        scout.arrays.eachSibling(this.columns, column, function(siblingColumn) {
          if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) &&
            (siblingColumn.sortIndex >= sortIndex) &&
            (siblingColumn.sortIndex < column.sortIndex)) {
            siblingColumn.sortIndex++;
          }
        });
        column.sortIndex = sortIndex;
      } else { //not sorted yet
        scout.arrays.eachSibling(this.columns, column, function(siblingColumn) {
          if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex >= sortIndex) {
            siblingColumn.sortIndex++;
          }
        });

        column.sortIndex = sortIndex;

        // increase sortIndex for all permanent tail columns (a column has been added in front of them)
        this._permanentTailSortColumns.forEach(function(c) {
          c.sortIndex++;
        });
      }

      // remove all other grouped properties:
      scout.arrays.eachSibling(this.columns, column, function(siblingColumn) {
        if (siblingColumn.sortActive && !(siblingColumn.initialAlwaysIncludeSortAtBegin || siblingColumn.initialAlwaysIncludeSortAtEnd) && siblingColumn.sortIndex >= sortIndex) {
          siblingColumn.grouped = false;
        }
      });

    }

    column.sortAscending = direction === 'asc' ? true : false;
    column.sortActive = true;

  } else {

    if (column.initialAlwaysIncludeSortAtBegin) {
      // do not change order or direction. just set grouped to true.
      column.grouped = true;
    }

  }

  column.grouped = true;
};

scout.Table.prototype._removeGroupColumn = function(column) {
  column.grouped = false;

  if (column.initialAlwaysIncludeSortAtBegin) {
    // head sort case: remove all groupings after this column.
    this.columns.forEach(function(c) {
      if (c.sortIndex >= column.sortIndex) {
        c.grouped = false;
      }
    });
  }

  this._removeSortColumn(column);
};

scout.Table.prototype._buildRowDiv = function(row) {
  var rowWidth = this.rowWidth;
  var rowClass = 'table-row';
  if(row.cssClass){
    rowClass += ' '+row.cssClass;
  }
  if (!row.enabled) {
    rowClass += ' disabled';
  }
  if (row.checked && this.checkableStyle === scout.Table.CheckableStyle.TABLE_ROW) {
    rowClass += ' checked';
  }
  var rowDiv = '<div class="' + rowClass + '" style="width: ' + rowWidth + 'px"' + scout.device.unselectableAttribute.string + '>';
  for (var c = 0; c < this.columns.length; c++) {
    rowDiv += this.columns[c].buildCellForRow(row);
  }
  rowDiv += '</div>';

  return rowDiv;
};

scout.Table.prototype._calculateRowBorderWidth = function() {
  var $tableRowDummy = this.$data.appendDiv('table-row');
  this.rowBorderLeftWidth = $tableRowDummy.cssBorderLeftWidth();
  this.rowBorderRightWidth = $tableRowDummy.cssBorderRightWidth();
  this.rowBorderWidth = this.rowBorderLeftWidth + this.rowBorderRightWidth;
  $tableRowDummy.remove();
};

scout.Table.prototype._updateRowWidth = function() {
  this.rowWidth = this.rowBorderWidth;
  for (var i = 0; i < this.columns.length; i++) {
    this.rowWidth += this.columns[i].width;
  }
};

scout.Table.prototype._updateRowHeight = function() {
  var $emptyRow = this.$data.appendDiv('table-row');
  var $emptyAggrRow = this.$data.appendDiv('table-aggregate-row');

  $emptyRow.appendDiv('table-cell').html('&nbsp;');
  $emptyAggrRow.appendDiv('table-cell').html('&nbsp;');
  this.rowHeight = $emptyRow.outerHeight(true);
  this.aggregateRowHeight = $emptyAggrRow.outerHeight(true);
  $emptyRow.remove();
  $emptyAggrRow.remove();
};

/**
 * Updates the row heights for every visible row and aggregate row and clears the height of the others
 */
scout.Table.prototype._updateRowHeights = function() {
  this.rows.forEach(function(row) {
    if (!row.$row) {
      row.height = null;
    } else {
      row.height = row.$row.outerHeight(true);
    }
  });
  this._aggregateRows.forEach(function(aggregateRow) {
    if (!aggregateRow.$row) {
      aggregateRow.height = null;
    } else {
      aggregateRow.height = aggregateRow.$row.outerHeight(true);
    }
  });
};

/**
 * @param new rows to append at the end of this.$data. If undefined this.rows is used.
 */
scout.Table.prototype._renderRowsInRange = function(range) {
  var $rows,
    rowString = '',
    numRowsRendered = 0,
    prepend = false;

  var rows = this.filteredRows();
  if (rows.length === 0) {
    return;
  }

  var maxRange = new scout.Range(0, this.rows.length);
  range = maxRange.intersect(range);
  if (!range.intersect(this.viewRangeRendered).equals(new scout.Range(0, 0))) {
    throw new Error('New range must not intersect with existing.');
  }
  if (range.to <= this.viewRangeRendered.from) {
    prepend = true;
  }
  var newRange = this.viewRangeRendered.union(range);
  if (newRange.length === 2) {
    throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);
  }
  this.viewRangeRendered = newRange[0];
  this._removeEmptyData();

  // Build $rows (as string instead of jQuery objects due to efficiency reasons)
  for (var r = range.from; r < range.to; r++) {
    var row = rows[r];
    rowString += this._buildRowDiv(row);
    numRowsRendered++;
  }

  // append block of rows
  $rows = this.$data.makeElement(rowString);
  if (prepend) {
    if (this.$fillBefore) {
      $rows = $rows.insertAfter(this.$fillBefore);
    } else {
      $rows = $rows.prependTo(this.$data);
    }
  } else {
    if (this.$fillAfter) {
      $rows = $rows.insertBefore(this.$fillAfter);
    } else {
      $rows = $rows.appendTo(this.$data);
    }
  }

  $rows.each(function(index, rowObject) {
    var $row = $(rowObject);
    var row = rows[range.from + index];
    scout.Table.linkRowToDiv(row, $row);
    this._installRow(row);
  }.bind(this));

  if ($.log.isTraceEnabled()) {
    $.log.trace(numRowsRendered + ' new rows rendered from ' + range);
    $.log.trace(this._rowsRenderedInfo());
  }
};

scout.Table.prototype._rowsRenderedInfo = function() {
  var numRenderedRows = this.$rows().length,
    renderedRowsRange = '(' + this.viewRangeRendered + ')',
    text = numRenderedRows + ' rows rendered ' + renderedRowsRange;
  return text;
};

scout.Table.prototype._removeRowsInRange = function(range) {
  var fromRow, toRow, row, i,
    numRowsRemoved = 0,
    rows = this.filteredRows();

  var maxRange = new scout.Range(0, rows.length);
  range = maxRange.intersect(range);
  fromRow = rows[range.from];
  toRow = rows[range.to];

  var newRange = this.viewRangeRendered.subtract(range);
  if (newRange.length === 2) {
    throw new Error('Can only remove rows at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);
  }
  this.viewRangeRendered = newRange[0];
  this._removeEmptyData();

  for (i = range.from; i < range.to; i++) {
    row = rows[i];
    this._removeRow(row);
    numRowsRemoved++;
  }

  if ($.log.isTraceEnabled()) {
    $.log.trace(numRowsRemoved + ' rows removed from ' + range + '.');
    $.log.trace(this._rowsRenderedInfo());
  }
};

scout.Table.prototype._removeAllRows = function() {
  this.$rows().each(function(i, elem) {
    var $row = $(elem),
      row = $row.data('row');
    if ($row.hasClass('hiding')) {
      // Do not remove rows which are removed using an animation
      // row.$row may already point to a new row -> don't call removeRow to not accidentally remove the new row
      return;
    }
    this._removeRow(row);
  }.bind(this));
  this.viewRangeRendered = new scout.Range(0, 0);
};

/**
 *
 * @param rows if undefined, all rows are removed
 */
scout.Table.prototype._removeRows = function(rows) {
  if (!rows) {
    rows = scout.arrays.ensure(rows);
    this._removeAllRows();
    return;
  }
  rows = scout.arrays.ensure(rows);
  rows.forEach(function(row) {
    var rowIndex = this.filteredRows().indexOf(row);

    if (rowIndex === -1) {
      throw new Error('Row not found, cannot remove $row');
    }
    // if row is not rendered but its rowindex is inside the view range -> inconsistency
    if (!row.$row && this.viewRangeRendered.contains(rowIndex) && !row.$row) {
      throw new Error('Inconsistency found while removing row. Row is not but inside rendered view range. RowIndex: ' + rowIndex);
    }
    // if row is rendered but its rowindex is not inside the view range -> inconsistency
    if (row.$row && !this.viewRangeRendered.contains(rowIndex)) {
      throw new Error('Inconsistency found while removing row. Row is rendered but not inside rendered view range. RowIndex: ' + rowIndex);
    }

    this._removeRow(row);

    // Adjust view range if row is inside or before range
    if (this.viewRangeRendered.contains(rowIndex) || rowIndex < this.viewRangeRendered.from) {
      if (rowIndex < this.viewRangeRendered.from) {
        this.viewRangeRendered.from--;
        this.viewRangeRendered.to--;
      } else if (rowIndex <= this.viewRangeRendered.to) {
        this.viewRangeRendered.to--;
      }
    }
  }.bind(this));
};

/**
 * Just removes the row, does NOT adjust this.viewRangeRendered
 */
scout.Table.prototype._removeRow = function(row) {
  var $row = row.$row;
  if (!$row) {
    return;
  }

  this._destroyTooltipsForRow(row);
  this._removeCellEditorForRow(row);

  // Do not remove rows which are removed using an animation
  if (!$row.hasClass('hiding')) {
    $row.remove();
    row.$row = null;
  }
};

/**
 * Animates the rendering of a row by setting it to invisible before doing a slideDown animation. The row needs to already be rendered.
 */
scout.Table.prototype._showRow = function(row) {
  var $row = row.$row;
  if (!$row) {
    return;
  }
  if ($row.is('.showing')) {
    return;
  }

  $row.setVisible(false);
  $row.addClass('showing');
  $row.removeClass('hiding');
  $row.stop().slideDown({
    duration: 250,
    complete: function() {
      $row.removeClass('showing');
      this.updateScrollbars();
    }.bind(this)
  });
};

/**
 * Animates the removal of a row by doing a slideUp animation. The row will be removed after the animation finishes.
 */
scout.Table.prototype._hideRow = function(row) {
  var $row = row.$row;
  if (!$row) {
    return;
  }
  if ($row.is('.hiding')) {
    return;
  }

  $row.addClass('hiding');
  $row.removeClass('showing');
  $row.stop().slideUp({
    duration: 250,
    complete: function() {
      if (!row.$row) {
        // ignore already removed rows
        return;
      }
      $row.remove();
      if ($row[0] === row.$row[0]) {
        // Only set to null if row still is linked to to original $row
        // If row got rendered again while the animation is still running, row.$row points to the new $row
        row.$row = null;
      }
      this.updateScrollbars();
    }.bind(this)
  });
};

/**
 * This method should be used after a row is added to the DOM (new rows, updated rows). The 'row'
 * is expected to be linked with the corresponding '$row' (row.$row and $row.data('row')).
 */
scout.Table.prototype._installRow = function(row) {
  row.height = row.$row.outerHeight(true);

  if (row.hasError) {
    this._showCellErrorForRow(row);
  }
  // Reopen editor popup (closed when row was removed)
  if (this.cellEditorPopup && !this.cellEditorPopup.rendered && this.cellEditorPopup.row.id === row.id) {
    var editorField = this.cellEditorPopup.cell.field;
    this.startCellEdit(this.cellEditorPopup.column, row, editorField);
  }
};

scout.Table.prototype._showCellErrorForRow = function(row) {
  var $cells = this.$cellsForRow(row.$row),
    that = this;

  $cells.each(function(index) {
    var $cell = $(this);
    var cell = that.cellByCellIndex(index, row);
    if (cell.errorStatus) {
      that._showCellError(row, $cell, cell.errorStatus);
    }
  });
};

scout.Table.prototype._showCellError = function(row, $cell, errorStatus) {
  var tooltip, opts,
    text = errorStatus.message;

  opts = {
    parent: this,
    text: text,
    autoRemove: false,
    $anchor: $cell,
    table: this
  };
  tooltip = scout.create('TableTooltip', opts);
  tooltip.render();
  // link to be able to remove it when row gets deleted
  tooltip.row = row;
  this.tooltips.push(tooltip);
};

/**
 * @returns the column at position x (e.g. from event.pageX)
 */
scout.Table.prototype._columnAtX = function(x) {
  var columnOffsetRight = 0,
    columnOffsetLeft = this.$data.offset().left + this.rowBorderLeftWidth,
    scrollLeft = this.$data.scrollLeft();

  if (x < columnOffsetLeft) {
    // Clicked left of first column (on selection border) --> return first column
    return this.columns[0];
  }

  columnOffsetLeft -= scrollLeft;
  var column = scout.arrays.find(this.columns, function(column) {
    columnOffsetRight = columnOffsetLeft + column.width;
    if (x >= columnOffsetLeft && x < columnOffsetRight) {
      return true;
    }
    columnOffsetLeft = columnOffsetRight;
  });
  if (!column) {
    // No column found (clicked right of last column, on selection border) --> return last column
    column = this.columns[this.columns.length - 1];
  }
  return column;
};

scout.Table.prototype._find$AppLink = function(event) {
  // bubble up from target to delegateTarget
  var $elem = $(event.target);
  var $stop = $(event.delegateTarget);
  while ($elem.length > 0) {
    if ($elem.hasClass('app-link')) {
      return $elem;
    }
    if ($elem[0] === $stop[0]) {
      return null;
    }
    $elem = $elem.parent();
  }
  return null;
};

scout.Table.prototype._filterMenus = function(menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes) {
  return scout.menus.filterAccordingToSelection('Table', this.selectedRows.length, menus, destination, onlyVisible, enableDisableKeyStroke, notAllowedTypes);
};

scout.Table.prototype.setStaticMenus = function(staticMenus) {
  this._setProperty('staticMenus', staticMenus);
  this._updateMenuBar();
};

scout.Table.prototype._removeMenus = function() {
  // menubar takes care about removal
};

scout.Table.prototype.notifyRowSelectionFinished = function() {
  if (this._triggerRowsSelectedPending) {
    this._triggerRowsSelected();
    this._triggerRowsSelectedPending = false;
  }
  this._updateMenuBar();
};

scout.Table.prototype._triggerRowClicked = function(row, mouseButton, column) {
  var event = {
    row: row,
    mouseButton: mouseButton
  };
  this.trigger('rowClicked', event);
};

scout.Table.prototype._triggerRowAction = function(row, column) {
  this.trigger('rowAction', {
    row: row,
    column: column
  });
};

/**
 * @param openFieldPopupOnCellEdit when this parameter is set to true, the CellEditorPopup sets an
 *    additional property 'cellEditor' on the editor-field. The field instance may use this property
 *    to decide whether or not it should open a popup immediately after it is rendered. This is used
 *    for Smart- and DateFields.
 */
scout.Table.prototype.prepareCellEdit = function(column, row, openFieldPopupOnCellEdit) {
  this.openFieldPopupOnCellEdit = scout.nvl(openFieldPopupOnCellEdit, false);
  var field = column.createDefaultEditor(row);
  this.startCellEdit(column, row, field);
};

/**
 * @returns returns a cell for the given column and row. Row Icon column and cell icon column don't not have cells --> generate one.
 */
scout.Table.prototype.cell = function(column, row) {
  if (column === this.rowIconColumn) {
    return scout.create('Cell', {
      iconId: row.iconId,
      cssClass: scout.strings.join(' ', 'row-icon-cell', row.cssClass)
    });
  }

  if (column === this.checkableColumn) {
    return scout.create('Cell', {
      value: row.checked,
      editable: true,
      cssClass: row.cssClass
    });
  }

  return row.cells[column.index];
};

scout.Table.prototype.cellByCellIndex = function(cellIndex, row) {
  return this.cell(this.columns[cellIndex], row);
};

scout.Table.prototype.cellValue = function(column, row) {
  var cell = this.cell(column, row);
  if (!cell) {
    return cell;
  }
  if (cell.value !== undefined) {
    return cell.value;
  }
  return cell.text || '';
};

scout.Table.prototype.cellText = function(column, row) {
  var cell = this.cell(column, row);
  if (!cell) {
    return '';
  }
  return cell.text || '';
};

/**
 *
 * @returns the next editable position in the table, starting from the cell at (currentColumn / currentRow).
 * A position is an object containing row and column (cell has no reference to a row or column due to memory reasons).
 */
scout.Table.prototype.nextEditableCellPos = function(currentColumn, currentRow, backwards) {
  var pos, startColumnIndex, rowIndex, startRowIndex, predicate,
    colIndex = this.columns.indexOf(currentColumn);

  startColumnIndex = colIndex + 1;
  if (backwards) {
    startColumnIndex = colIndex - 1;
  }
  pos = this.nextEditableCellPosForRow(startColumnIndex, currentRow, backwards);
  if (pos) {
    return pos;
  }

  predicate = function(row) {
    if (!row.$row) {
      return false;
    }

    startColumnIndex = 0;
    if (backwards) {
      startColumnIndex = this.columns.length - 1;
    }
    pos = this.nextEditableCellPosForRow(startColumnIndex, row, backwards);
    if (pos) {
      return true;
    }
  }.bind(this);

  rowIndex = this.rows.indexOf(currentRow);
  startRowIndex = rowIndex + 1;
  if (backwards) {
    startRowIndex = rowIndex - 1;
  }
  scout.arrays.findFrom(this.rows, startRowIndex, predicate, backwards);

  return pos;
};

scout.Table.prototype.nextEditableCellPosForRow = function(startColumnIndex, row, backwards) {
  var cell, column, predicate;

  predicate = function(column) {
    if (column.guiOnly) {
      // does not support tabbing
      return false;
    }
    cell = this.cell(column, row);
    return this.enabled && row.enabled && cell.editable;
  }.bind(this);

  column = scout.arrays.findFrom(this.columns, startColumnIndex, predicate, backwards);
  if (column) {
    return {
      column: column,
      row: row
    };
  }
};

scout.Table.prototype.clearAggregateRows = function(animate) {
  // Remove "hasAggregateRow" markers from real rows
  this._aggregateRows.forEach(function(aggregateRow) {
    if (aggregateRow.prevRow) {
      aggregateRow.prevRow.aggregateRowAfter = null;
    }
    if (aggregateRow.nextRow) {
      aggregateRow.nextRow.aggregateRowBefore = null;
    }
  }, this);

  if (this.rendered) {
    this._removeAggregateRows(animate);
    this._renderSelection(); // fix selection borders
  }
  this._aggregateRows = [];
};

/**
 * Executes the aggregate function with the given funcName for each column, but only if the Column
 * has that function, which is currently only the case for NumberColumns.
 *
 * @param states is a reference to an Array containig the results for each column.
 * @param row (optional) if set, an additional cell-value parameter is passed to the aggregate function
 */
scout.Table.prototype._forEachColumn = function(funcName, states, row) {
  var value;
  this.columns.forEach(function(column, i) {
    if (column[funcName]) {
      if (row) {
        value = column.cellValueForGrouping(row);
      }
      states[i] = column[funcName](states[i], value);
    }
  });
};

scout.Table.prototype._group = function(animate) {
  var rows, nextRow, newGroup,
    groupColumns = this._groupedColumns(),
    states = [];

  this.clearAggregateRows();
  if (!groupColumns.length) {
    return;
  }

  rows = this.filteredRows();
  this._forEachColumn('aggrStart', states);
  rows.forEach(function(row, r) {
    this._forEachColumn('aggrStep', states, row);
    // test if sum should be shown, if yes: reset sum-array
    nextRow = rows[r + 1];
    // test if group is finished
    newGroup = (r === rows.length - 1) || this._isNewGroup(groupColumns, row, nextRow);
    // if group is finished: add group row
    if (newGroup) {
      //finish aggregation
      this._forEachColumn('aggrFinish', states);
      //append sum row
      this._addAggregateRow(states, row, nextRow);
      //reset after group
      this._forEachColumn('aggrStart', states);
    }
  }.bind(this));

  if (this.rendered) {
    this._renderAggregateRows(animate);
    this._renderSelection(); // fix selection borders
  }
};

scout.Table.prototype._isNewGroup = function(groupedColumns, row, nextRow) {
  var i, col, newRow = false,
    hasCellTextForGroupingFunction;

  if (!nextRow) {
    return true; //row is last row
  }

  for (i = 0; i < groupedColumns.length; i++) {
    col = groupedColumns[i];
    hasCellTextForGroupingFunction = col && col.cellTextForGrouping && typeof col.cellTextForGrouping === 'function';
    newRow = newRow || (hasCellTextForGroupingFunction && col.cellTextForGrouping(row) !== col.cellTextForGrouping(nextRow)); // NOSONAR
    newRow = newRow || (!hasCellTextForGroupingFunction && this.cellText(col, row) !== this.cellText(col, nextRow));
    if (newRow) {
      return true;
    }
  }
  return false;
};

scout.Table.prototype._groupedColumns = function() {
  return this.columns.filter(function(col) {
    return col.grouped;
  });
};

/**
 * Inserts a new aggregation row between 'prevRow' and 'nextRow'.
 *
 * @param contents cells of the new aggregate row
 * @param prevRow row _before_ the new aggregate row
 * @param nextRow row _after_ the new aggregate row
 */
scout.Table.prototype._addAggregateRow = function(contents, prevRow, nextRow) {
  var aggregateRow = {
    contents: contents.slice(),
    prevRow: prevRow,
    nextRow: nextRow
  };
  this._aggregateRows.push(aggregateRow);
  if (prevRow) {
    prevRow.aggregateRowAfter = aggregateRow;
  }
  if (nextRow) {
    nextRow.aggregateRowBefore = aggregateRow;
  }
};

scout.Table.prototype._removeAggregateRows = function(animate) {
  if (this._aggregateRows.length === 0) {
    return;
  }
  animate = scout.nvl(animate, false);
  if (!animate) {
    this._aggregateRows.forEach(function(aggregateRow) {
      this._removeRow(aggregateRow);
    }, this);
    this.updateScrollbars();
  } else {
    this._aggregateRows.forEach(function(aggregateRow, i) {
      this._hideRow(aggregateRow);
    }, this);
  }
};

scout.Table.prototype._renderAggregateRows = function(animate) {
  var c, cell, column, row, contents, $cell, $aggregateRow;
  animate = scout.nvl(animate, false);

  this._aggregateRows.forEach(function(aggregateRow, r) {
    if (aggregateRow.$row) {
      // already rendered, no need to update again (necessary for subsequent renderAggregateRows calls (eg. in insertRows -> renderRows)
      return;
    }
    row = aggregateRow.prevRow;
    if (!row || !row.$row) {
      return;
    }

    $aggregateRow = this.$container.makeDiv('table-aggregate-row')
      .data('aggregateRow', aggregateRow);
    contents = aggregateRow.contents;

    for (c = 0; c < this.columns.length; c++) {
      column = this.columns[c];
      if (column.grouped) {
        cell = column.createAggrGroupCell(row);
      } else if (column instanceof scout.NumberColumn) {
        cell = column.createAggrValueCell(contents[c]);
      } else {
        cell = column.createAggrEmptyCell(row);
      }
      $cell = $(column.buildCell(cell, {}));
      $cell.appendTo($aggregateRow);
    }

    $aggregateRow.insertAfter(row.$row).width(this.rowWidth);
    aggregateRow.height = $aggregateRow.outerHeight(true);
    aggregateRow.$row = $aggregateRow;
    if (animate) {
      this._showRow(aggregateRow);
    }
  }, this);
};

scout.Table.prototype.groupColumn = function(column, multiGroup, direction, remove) {
  var data, sorted;
  multiGroup = scout.nvl(multiGroup, false);
  remove = scout.nvl(remove, false);
  if (remove) {
    this._removeGroupColumn(column);
  }
  if (!this.isGroupingPossible(column)) {
    return;
  }
  if (!remove) {
    this._addGroupColumn(column, direction, multiGroup);
  }

  if (this.header) {
    this.header.onSortingChanged();
  }
  sorted = this._sort(true);

  data = {
    columnId: column.id,
    groupAscending: column.sortAscending
  };
  if (remove) {
    data.groupingRemoved = true;
  }
  if (multiGroup) {
    data.multiGroup = true;
  }
  this._triggerGroupingChanged();
  if (sorted) {
    this._send('rowsGrouped', data);
  } else {
    // Delegate sorting to server when it is not possible on client side
    this._send('groupRows', data);

    // hint to animate the aggregate after the row order changed event
    this._animateAggregateRows = true;
  }
};

scout.Table.prototype.removeColumnGrouping = function(column) {
  if (column) {
    this.groupColumn(column, false, 'asc', true);
  }
};

/**
 * @returns true if at least one column has grouped=true
 */
scout.Table.prototype.isGrouped = function() {
  return this.columns.some(function(column) {
    if (column.grouped) {
      return true;
    }
    return false;
  });
};

scout.Table.prototype.setColumnBackgroundEffect = function(column, effect) {
  column.setBackgroundEffect(effect);
};

/**
 * Updates the background effect of every column, if column.backgroundEffect is set.
 * Meaning: Recalculates the min / max values and renders the background effect again.
 */
scout.Table.prototype._updateBackgroundEffect = function() {
  this.columns.forEach(function(column) {
    if (!column.backgroundEffect) {
      return;
    }
    column.updateBackgroundEffect();
  }, this);
};

/**
 * Recalculates the values necessary for the background effect of every column, if column.backgroundEffect is set
 */
scout.Table.prototype._calculateValuesForBackgroundEffect = function() {
  this.columns.forEach(function(column) {
    if (!column.backgroundEffect) {
      return;
    }
    column.calculateMinMaxValues();
  }, this);
};

scout.Table.prototype.checkRow = function(row, checked) {
  this.checkRows([row], {
    checked: checked
  });
};

scout.Table.prototype.checkRows = function(rows, options) {
  var opts = $.extend({
      checked: true,
      checkOnlyEnabled: true
    }, options);
  var checkedRows = [];
  if (!this.checkable || (!this.enabled && opts.checkOnlyEnabled)) {
    return;
  }
  rows = scout.arrays.ensure(rows);
  rows.forEach(function(row) {
    if ((!row.enabled && opts.checkOnlyEnabled) || row.checked === opts.checked) {
      return;
    }
    if (!this.multiCheck && opts.checked) {
      for (var i = 0; i < this.rows.length; i++) {
        if (this.rows[i].checked) {
          this.rows[i].checked = false;
          checkedRows.push(this.rows[i]);
        }
      }
    }
    row.checked = opts.checked;
    checkedRows.push(row);
  }, this);

  if (this.rendered) {
    checkedRows.forEach(function(row) {
      this._renderRowChecked(row);
    }, this);
  }
  this._triggerRowsChecked(checkedRows);
};

scout.Table.prototype.uncheckRow = function(row) {
  this.uncheckRows([row]);
};

scout.Table.prototype.uncheckRows = function(rows, options) {
  var opts = $.extend({
      checked: false
    }, options);
  this.checkRows(rows, opts);
};

scout.Table.prototype.doRowAction = function(row, column) {
  if (this.selectedRows.length !== 1 || this.selectedRows[0] !== row) {
    // Only allow row action if the selected row was double clicked because the handler of the event expects a selected row.
    // This may happen if the user modifies the selection using ctrl or shift while double clicking.
    return;
  }

  column = column || this.columns[0];
  if (column && column.guiOnly) {
    column = scout.arrays.find(this.columns, function(col) {
      return !col.guiOnly;
    });
  }
  if (!row || !column) {
    return;
  }
  this._triggerRowAction(row, column);
};

scout.Table.prototype.insertRow = function(row) {
  this.insertRows([row]);
};

scout.Table.prototype.insertRows = function(rows, fromServer) {
  var wasEmpty = this.rows.length === 0;

  // Update model
  rows.forEach(function(row, i) {
    row = this._initRow(row);
    rows[i] = row;
    // Always insert new rows at the end, if the order is wrong a rowOrderChange event will follow
    this.rows.push(row);
  }, this);
  // this event should be triggered before the rowOrderChanged event (triggered by the _sort function).
  this._triggerRowsInserted(rows);

  this._applyFilters(rows);
  this._calculateValuesForBackgroundEffect();
  fromServer = scout.nvl(fromServer, false);
  if (!fromServer) {
    // If event comes from server, there will be a row order changed event as well -> no sorting necessary
    this._sort();
  } else {
    // There will only be a row order changed event if table was not empty.
    // If it was empty, there will be NO row order changed event (tableEventBuffer) -> inserted rows are already in correct order -> no sort necessary but group is
    if (wasEmpty) {
      this._group();
    }
  }
  this._rebuildingTable = false;

  // Update HTML
  if (this.rendered) {
    // Remember inserted rows for future events like rowOrderChanged
    if (!this._insertedRows) {
      this._insertedRows = rows;
      setTimeout(function() {
        this._insertedRows = null;
      }.bind(this), 0);
    } else {
      scout.arrays.pushAll(this._insertedRows, rows);
    }

    this.viewRangeDirty = true;
    this._renderViewport();
    this.invalidateLayoutTree();
  }
};

scout.Table.prototype.deleteRow = function(row) {
  this.deleteRows([row]);
};

scout.Table.prototype.deleteRows = function(rows) {
  var invalidate, filterChanged;

  rows.forEach(function(row) {
    // Update HTML
    if (this.rendered) {
      // Cancel cell editing if cell editor belongs to a cell of the deleted row
      if (this.cellEditorPopup && this.cellEditorPopup.row.id === row.id) {
        this.cellEditorPopup.cancelEdit();
      }

      this._removeRows(row);
      invalidate = true;
    }

    // Update model
    scout.arrays.remove(this.rows, row);
    if (this._filterCount() > 0 && scout.arrays.remove(this._filteredRows, row)) {
      filterChanged = true;
    }
    delete this.rowsMap[row.id];

    if (this.selectionHandler.lastActionRow === row) {
      this.selectionHandler.clearLastSelectedRowMarker();
    }
  }.bind(this));

  this.deselectRows(rows);
  if (filterChanged) {
    this._rowsFiltered();
  }
  this._group();
  this._updateBackgroundEffect();
  this._triggerRowsDeleted(rows);

  if (invalidate) {
    this._renderViewport();
    // Update markers and filler because row may be removed by removeRows. RenderViewport doesn't do it if view range is already correctly rendered.
    this._renderRangeMarkers();
    this._renderFiller();
    this.invalidateLayoutTree();
  }
};

scout.Table.prototype.deleteAllRows = function() {
  var filterChanged = this._filterCount() > 0 && this._filteredRows.length > 0,
    rows = this.rows;

  // Update HTML
  if (this.rendered) {
    // Cancel cell editing
    if (this.cellEditorPopup) {
      this.cellEditorPopup.cancelEdit();
    }

    this.selectionHandler.clearLastSelectedRowMarker();
    this._removeRows();
  }

  // Update model
  this.rows = [];
  this.rowsMap = {};
  this.deselectAll();
  this._filteredRows = [];

  if (filterChanged) {
    this._rowsFiltered();
  }
  this._group();
  this._updateBackgroundEffect();
  this._triggerAllRowsDeleted(rows);

  // Update HTML
  if (this.rendered) {
    this._renderFiller();
    this._renderViewport();
    this.invalidateLayoutTree();
  }
};

scout.Table.prototype.updateRow = function(row) {
  this.updateRows([row]);
};

scout.Table.prototype.updateRows = function(rows) {
  var filterChanged, newHiddenRows = [];

  // Update model
  rows.forEach(function(updatedRow) {
    var oldRow = this.rowsMap[updatedRow.id];
    if (!oldRow) {
      throw new Error('Update event received for non existing row. RowId: ' + updatedRow.id);
    }

    // Replace old row
    updatedRow = this._initRow(updatedRow);
    if (this.selectionHandler.lastActionRow === oldRow) {
      this.selectionHandler.lastActionRow = updatedRow;
    }
    // TODO CGU remove this replace functions, they are slow due to indexOf. Either create maps (rowId/rowIndex) before the loop or even store rowIndex for each row
    scout.arrays.replace(this.rows, oldRow, updatedRow);
    scout.arrays.replace(this.selectedRows, oldRow, updatedRow);

    // Apply row filter
    updatedRow.filterAccepted = oldRow.filterAccepted;
    if (this._filterCount() > 0) {
      if (this._applyFiltersForRow(updatedRow)) {
        filterChanged = true;
        if (!updatedRow.filterAccepted) {
          newHiddenRows.push(updatedRow);
        }
      } else {
        // If filter state has not changed, just make sure filteredRows will be recalculated the next time its used
        this._filteredRowsDirty = true;
      }
    }

    // Replace old $row
    if (this.rendered && oldRow.$row) {
      // render row and replace div in DOM
      var $updatedRow = $(this._buildRowDiv(updatedRow));
      $updatedRow.copyCssClasses(oldRow.$row, scout.Table.SELECTION_CLASSES + ' first last');
      oldRow.$row.replaceWith($updatedRow);
      scout.Table.linkRowToDiv(updatedRow, $updatedRow);
      this._destroyTooltipsForRow(updatedRow);
      this._removeCellEditorForRow(updatedRow);
      this._installRow(updatedRow);
    }
  }, this);

  this._triggerRowsUpdated(rows);

  if (filterChanged) {
    this._rowsFiltered(newHiddenRows);
    if (this.rendered) {
      // Make sure filtered rows get removed and viewport is completely rendered
      this._rerenderViewport();
    }
  }
  this._group();
  this._updateBackgroundEffect();
};

scout.Table.prototype.updateRowOrder = function(rows) {
  rows = scout.arrays.ensure(rows);
  if (rows.length !== this.rows.length) {
    throw new Error('Row order may not be updated because lengths of the arrays differ.');
  }

  // update model (make a copy so that original array stays untouched)
  this.rows = rows.slice();
  this._filteredRowsDirty = true; // order has changed

  this.clearAggregateRows(this._animateAggregateRows);
  if (this.rendered) {
    this._renderRowOrderChanges();
  }
  this._triggerRowOrderChanged();

  this._group(this._animateAggregateRows);
  this._animateAggregateRows = false;
};

scout.Table.prototype._destroyTooltipsForRow = function(row) {
  for (var i = this.tooltips.length - 1; i >= 0; i--) {
    if (this.tooltips[i].row.id === row.id) {
      this.tooltips[i].destroy();
      this.tooltips.splice(i, 1);
    }
  }
};

scout.Table.prototype._removeCellEditorForRow = function(row) {
  if (this.cellEditorPopup && this.cellEditorPopup.rendered && this.cellEditorPopup.row.id === row.id) {
    this.cellEditorPopup.remove();
  }
};

scout.Table.prototype.startCellEdit = function(column, row, field) {
  if (!this.rendered) {
    this._postRenderActions.push(this.startCellEdit.bind(this, column, row, field));
    return;
  }

  this.ensureRowRendered(row);
  var popup = column.startCellEdit(row, field);
  this.cellEditorPopup = popup;
  return popup;
};

/**
 * In a remote app this function is overridden by RemoteApp.js, the default implementation is the local case.
 * @param saveEditorValue when this parameter is set to true, the value of the editor field is set as
 *    new value on the edited cell. In remote case this parameter is always false, because the cell
 *    value is updated by an updateRow event instead.
 * @see RemoteApp.js
 */
scout.Table.prototype.endCellEdit = function(field, saveEditorValue) {
  if (!this.rendered) {
    this._postRenderActions.push(this.endCellEdit.bind(this, field, saveEditorValue));
    return;
  }

  // the cellEditorPopup could already be removed by scrolling (out of view range) or be removed by update rows
  if (this.cellEditorPopup) {
    var context = this.cellEditorPopup;

    // Remove the cell-editor popup prior destroying the field, so that the 'cell-editor-popup's focus context is
    // uninstalled first and the focus can be restored onto the last focused element of the surrounding focus context.
    // Otherwise, if the currently focused field is removed from DOM, the $entryPoint would be focused first, which can
    // be avoided if removing the popup first.
    this.cellEditorPopup.destroy();
    this.cellEditorPopup = null;

    // Must store context in a local variable and call setCellValue _after_ cellEditorPopup is set to null
    // because in updateRows we check if the popup is still there and start cell editing mode again.
    saveEditorValue = scout.nvl(saveEditorValue, false);
    if (saveEditorValue) {
      this.setCellValue(context.column, context.row, field.value);
    }
  }

  field.destroy();
};

/**
 * In a remote app this function is overridden by RemoteApp.js, the default implementation is the local case.
 * @see RemoteApp.js
 */
scout.Table.prototype.completeCellEdit = function(field) {
  this.endCellEdit(field, true);
};

/**
 * In a remote app this function is overridden by RemoteApp.js, the default implementation is the local case.
 * @see RemoteApp.js
 */
scout.Table.prototype.cancelCellEdit = function(field) {
  this.endCellEdit(field);
};

scout.Table.prototype.scrollTo = function(row) {
  if (this.viewRangeRendered.size() === 0) {
    // Cannot scroll to a row no row is rendered
    return;
  }
  this.ensureRowRendered(row);
  scout.scrollbars.scrollTo(this.$data, row.$row);
};

scout.Table.prototype.scrollPageUp = function() {
  var newScrollTop = Math.max(0, this.$data[0].scrollTop - this.$data.height());
  this.setScrollTop(newScrollTop);
};

scout.Table.prototype.scrollPageDown = function() {
  var newScrollTop = Math.min(this.$data[0].scrollHeight, this.$data[0].scrollTop + this.$data.height());
  this.setScrollTop(newScrollTop);
};

scout.Table.prototype.setScrollTop = function(scrollTop) {
  this.setProperty('scrollTop', scrollTop);
  // call _renderViewport to make sure rows are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed
  if(this.rendered){
    this._renderViewport();
  }
};

scout.Table.prototype._renderScrollTop = function() {
  scout.scrollbars.scrollTop(this.$data, this.scrollTop);
};

scout.Table.prototype.revealSelection = function() {
  if (!this.rendered) {
    // Execute delayed because table may be not layouted yet
    this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));
    return;
  }

  if (this.selectedRows.length > 0) {
    this.scrollTo(this.selectedRows[0]);
  }
};

scout.Table.prototype.revealChecked = function() {
  var firstCheckedRow = scout.arrays.find(this.rows, function(row) {
    return row.checked === true;
  });
  if (firstCheckedRow) {
    this.scrollTo(firstCheckedRow);
  }
};

scout.Table.prototype._rowById = function(id) {
  return this.rowsMap[id];
};

scout.Table.prototype._rowsByIds = function(ids) {
  return ids.map(this._rowById.bind(this));
};

scout.Table.prototype._rowsToIds = function(rows) {
  return rows.map(function(row) {
    return row.id;
  });
};

/**
 * render borders and selection of row. default select if no argument or false is passed in deselect
 * model has to be updated before calling this method.
 */
scout.Table.prototype._renderSelection = function(rows) {
  rows = scout.arrays.ensure(rows || this.selectedRows);

  // helper function adds/removes a class for a row only if necessary, return true if classes have been changed
  var addOrRemoveClassIfNeededFunc = function($row, condition, classname) {
    var hasClass = $row.hasClass(classname);
    if (condition && !hasClass) {
      $row.addClass(classname);
      return true;
    } else if (!condition && hasClass) {
      $row.removeClass(classname);
      return true;
    }
    return false;
  };

  for (var i = 0; i < rows.length; i++) { // traditional for loop, elements might be added during loop
    var row = rows[i];
    if (!row.$row) {
      continue;
    }

    var thisRowSelected = this.selectedRows.indexOf(row) !== -1,
      filteredRows = this.filteredRows(),
      previousIndex = filteredRows.indexOf(row) - 1,
      previousRowSelected = previousIndex >= 0 && this.selectedRows.indexOf(filteredRows[previousIndex]) !== -1,
      followingIndex = filteredRows.indexOf(row) + 1,
      followingRowSelected = followingIndex < filteredRows.length && this.selectedRows.indexOf(filteredRows[followingIndex]) !== -1;

    // Don't collapse selection borders if two consecutively selected (real) rows are separated by an aggregation row
    if (thisRowSelected && previousRowSelected && row.aggregateRowBefore) {
      previousRowSelected = false;
    }
    if (thisRowSelected && followingRowSelected && row.aggregateRowAfter) {
      followingRowSelected = false;
    }

    // Note: We deliberately use the '+' operator on booleans here! That way, _all_ methods are executed (boolean
    // operators might stop in between) and the variable classChanged contains a number > 1 (which is truthy) when
    // at least one method call returned true.
    var classChanged = 0 +
      addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected, 'selected') +
      addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && !previousRowSelected && followingRowSelected, 'select-top') +
      addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && previousRowSelected && !followingRowSelected, 'select-bottom') +
      addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && !previousRowSelected && !followingRowSelected, 'select-single') +
      addOrRemoveClassIfNeededFunc(row.$row, thisRowSelected && previousRowSelected && followingRowSelected, 'select-middle');

    if (classChanged && previousRowSelected && rows.indexOf(filteredRows[previousIndex]) === -1) {
      rows.push(filteredRows[previousIndex]);
    }
    if (classChanged && followingRowSelected && rows.indexOf(filteredRows[followingIndex]) === -1) {
      rows.push(filteredRows[followingIndex]);
    }
  }

  // Make sure the cell editor popup is correctly layouted because selection changes the cell bounds
  if (this.cellEditorPopup && this.cellEditorPopup.rendered && this.selectedRows.indexOf(this.cellEditorPopup.row) > -1) {
    this.cellEditorPopup.position();
    this.cellEditorPopup.pack();
  }
};

scout.Table.prototype._removeSelection = function() {
  this.selectedRows.forEach(function(row) {
    if (!row.$row) {
      return;
    }
    row.$row.select(false);
    row.$row.toggleClass(scout.Table.SELECTION_CLASSES, false);
  }, this);
};

scout.Table.prototype.addRowToSelection = function(row, ongoingSelection) {
  if (this.selectedRows.indexOf(row) > -1) {
    return;
  }
  ongoingSelection = ongoingSelection !== undefined ? ongoingSelection : true;
  this.selectedRows.push(row);

  if (row.$row && this.rendered) {
    row.$row.select(true);
    this._renderSelection(row);
    if (this.scrollToSelection) {
      this.revealSelection();
    }
  }

  this._triggerRowsSelectedPending = true;
  if (!ongoingSelection) {
    this.notifyRowSelectionFinished();
  }
};

scout.Table.prototype.removeRowFromSelection = function(row, ongoingSelection) {
  ongoingSelection = ongoingSelection !== undefined ? ongoingSelection : true;
  if (scout.arrays.remove(this.selectedRows, row)) {
    if (this.rendered) {
      this._renderSelection(row);
    }
    if (!ongoingSelection) {
      this._triggerRowsSelected();
    } else {
      this._triggerRowsSelectedPending = true;
    }
  }
};

scout.Table.prototype.selectRows = function(rows, debounceSend) {
  rows = scout.arrays.ensure(rows);
  var selectedEqualRows = scout.arrays.equalsIgnoreOrder(rows, this.selectedRows);
  // TODO CGU maybe make sure selectedRows are in correct order, this would make logic in AbstractTableNavigationKeyStroke or renderSelection easier
  // but requires some effort (remember rowIndex, keep array in order after sort, ... see java Table)
  if (selectedEqualRows) {
    return;
  }

  if (this.rendered) {
    this._removeSelection();
  }

  if (!this.multiSelect && rows.length > 1) {
    rows = [rows[0]];
  }

  // Make a copy so that original array stays untouched
  this.selectedRows = rows.slice();
  this._triggerRowsSelected(debounceSend);

  this._updateMenuBar();
  if (this.rendered) {
    this._renderSelection();
    if (this.scrollToSelection) {
      this.revealSelection();
    }
  }
};

scout.Table.prototype.deselectRows = function(rows) {
  rows = scout.arrays.ensure(rows);
  var selectedRows = this.selectedRows.slice(); // copy
  if (scout.arrays.removeAll(selectedRows, rows)) {
    this.selectRows(selectedRows);
  }
};

scout.Table.prototype.isRowSelected = function(row) {
  return this.selectedRows.indexOf(row) > -1;
};

scout.Table.prototype._filterCount = function() {
  return Object.keys(this._filterMap).length;
};

scout.Table.prototype.filteredRows = function() {
  // filtered rows are cached to avoid unnecessary loops
  if (this._filteredRowsDirty) {
    if (this._filterCount() === 0) {
      this._filteredRows = this.rows;
    } else {
      this._filteredRows = [];
      this.rows.forEach(function(row) {
        if (row.filterAccepted) {
          this._filteredRows.push(row);
        }
      }, this);
    }
    this._filteredRowsDirty = false;
  }
  return this._filteredRows;
};

scout.Table.prototype.$rows = function(includeAggrRows) {
  var selector = '.table-row';
  if (includeAggrRows) {
    selector += ', .table-aggregate-row';
  }
  return this.$data.find(selector);
};

scout.Table.prototype.$aggregateRows = function() {
  return this.$data.find('.table-aggregate-row');
};

/**
 * @returns {scout.TableRow} the first selected row of this table or null when no row is selected
 */
scout.Table.prototype.selectedRow = function() {
  if (this.selectedRows.length > 0) {
    return this.selectedRows[0];
  }
  return null;
};

scout.Table.prototype.$selectedRows = function() {
  if (!this.$data) {
    return $();
  }
  return this.$data.find('.selected');
};

scout.Table.prototype.$cellsForColIndex = function(colIndex, includeAggrRows) {
  var selector = '.table-row > div:nth-of-type(' + colIndex + ')';
  if (includeAggrRows) {
    selector += ', .table-aggregate-row > div:nth-of-type(' + colIndex + ')';
  }
  return this.$data.find(selector);
};

scout.Table.prototype.$cellsForColIndexWidthFix = function(colIndex, includeAggrRows) {
  var selector = '.table-row > div:nth-of-type(' + colIndex + ') > .width-fix ';
  if (includeAggrRows) {
    selector += ', .table-aggregate-row > div:nth-of-type(' + colIndex + ') > .width-fix';
  }
  return this.$data.find(selector);
};

scout.Table.prototype.$cellsForRow = function($row) {
  return $row.children('.table-cell');
};

scout.Table.prototype.$cell = function(column, $row) {
  var columnIndex = this.columns.indexOf(column);
  return $row.children().eq(columnIndex);
};

scout.Table.prototype._columnById = function(columnId) { // FIXME [awe] 6.1 make this public
  return scout.arrays.find(this.columns, function(column) {
    return column.id === columnId;
  });
};

scout.Table.prototype._columnsByIds = function(columnIds) {
  return columnIds.map(this._columnById.bind(this));
};

scout.Table.prototype.filter = function() {
  var animate = true,
    numChangedRows = 0,
    newHiddenRows = [],
    newShownRows = [];

  // Filter rows
  this.rows.forEach(function(row) {
    var changed = this._applyFiltersForRow(row);
    if (changed) {
      if (!row.filterAccepted) {
        newHiddenRows.push(row);
      } else {
        newShownRows.push(row);
      }
    }
  }, this);

  numChangedRows = newHiddenRows.length + newShownRows.length;
  if (numChangedRows === 0) {
    return;
  }

  this._rowsFiltered(newHiddenRows);
  this._group(animate);

  if (this.rendered) {
    animate = numChangedRows <= this._animationRowLimit;
    if (!animate) {
      this._rerenderViewport();
    } else {
      newHiddenRows.forEach(function(row) {
        this._hideRow(row);
      }.bind(this));

      this._rerenderViewport();
      // Rows removed by an animation are still there, new rows were appended -> reset correct row order
      this._order$Rows().insertAfter(this.$fillBefore);
      // Also make sure aggregate rows are at the correct position (_renderAggregateRows does nothing because they are already rendered)
      this._order$AggregateRows();
      newShownRows.forEach(function(row) {
        this._showRow(row);
      }, this);
    }
    this._renderEmptyData();
  }
};

/**
 * Sorts the given $rows according to the row index
 */
scout.Table.prototype._order$Rows = function($rows) {
  // Find rows using jquery because
  // this.filteredRows() may be empty but there may be $rows which are getting removed by animation
  $rows = $rows || this.$rows();
  return $rows.sort(function(elem1, elem2) {
    var $row1 = $(elem1),
      $row2 = $(elem2),
      row1 = $row1.data('row'),
      row2 = $row2.data('row');

    return this.rows.indexOf(row1) - this.rows.indexOf(row2);
  }.bind(this));
};

scout.Table.prototype._order$AggregateRows = function($rows) {
  // Find aggregate rows using jquery because
  // this._aggregateRows may be empty but there may be $aggregateRows which are getting removed by animation
  $rows = $rows || this.$aggregateRows();
  $rows.each(function(i, elem) {
    var $aggrRow = $(elem),
      aggregateRow = $aggrRow.data('aggregateRow');
    if (!aggregateRow || !aggregateRow.prevRow) {
      return;
    }
    $aggrRow.insertAfter(aggregateRow.prevRow.$row);
  });
};

scout.Table.prototype._rowsFiltered = function(hiddenRows) {
  // non visible rows must be deselected
  this.deselectRows(hiddenRows);
  // notify
  this._filteredRowsDirty = true;
  this._triggerRowsFiltered();
};

scout.Table.prototype._rowAcceptedByFilters = function(row) {
  for (var key in this._filterMap) { // NOSONAR
    var filter = this._filterMap[key];
    if (!filter.accept(row)) {
      return false;
    }
  }
  return true;
};

/**
 * @returns {Boolean} true if row state has changed, false if not
 */
scout.Table.prototype._applyFiltersForRow = function(row) {
  if (this._rowAcceptedByFilters(row)) {
    if (!row.filterAccepted) {
      row.filterAccepted = true;
      return true;
    }
  } else {
    if (row.filterAccepted) {
      row.filterAccepted = false;
      return true;
    }
  }
  return false;
};

/**
 * Applies the filters for the given rows.<p>
 * This function is intended to be used for new rows. That's why rowsFiltered event is only triggered if there are accepted rows in the given list.
 */
scout.Table.prototype._applyFilters = function(rows) {
  var filterChanged,
    newHiddenRows = [];

  if (this._filterCount() === 0) {
    this._filteredRowsDirty = true;
    return;
  }

  rows.forEach(function(row) {
    if (this._applyFiltersForRow(row)) {
      filterChanged = true;
      if (!row.filterAccepted) {
        newHiddenRows.push(row);
      }
    }
    // always notify if there are new rows which accept the filter
    if (row.filterAccepted) {
      filterChanged = true;
    }
  }, this);

  if (filterChanged) {
    this._rowsFiltered(newHiddenRows);
  }
};

/**
 *
 * @returns array of filter names which are currently active
 */
scout.Table.prototype.filteredBy = function() {
  var filteredBy = [];
  for (var key in this._filterMap) { // NOSONAR
    var filter = this._filterMap[key];
    filteredBy.push(filter.createLabel());
  }
  return filteredBy;
};

scout.Table.prototype.resetFilter = function() {
  // remove filters
  for (var key in this._filterMap) { // NOSONAR
    this.removeFilterByKey(key);
  }
  this._filterMap = {};

  // reset rows
  this.filter();
  this._triggerFilterResetted();
};

scout.Table.prototype.resizeToFit = function(column) {
  if (column.fixedWidth) {
    return;
  }
  var calculatedSize = column.calculateOptimalWidth();
  if (scout.device.browser === scout.Device.Browser.INTERNET_EXPLORER && calculatedSize !== column.minWidth) {
    calculatedSize++;
  }
  if (column.width !== calculatedSize) {
    this.resizeColumn(column, calculatedSize);
  }
};

/**
 * @param filter object with createKey() and accept()
 */
scout.Table.prototype.addFilter = function(filter) {
  var key = filter.createKey();
  if (!key) {
    throw new Error('key has to be defined');
  }
  this._filterMap[key] = filter;
  this.trigger('addFilter', {
    filter: filter
  });
};

scout.Table.prototype.removeFilter = function(filter) {
  this.removeFilterByKey(filter.createKey());
};

scout.Table.prototype.removeFilterByKey = function(key) {
  if (!key) {
    throw new Error('key has to be defined');
  }
  var filter = this._filterMap[key];
  if (!filter) {
    return;
  }
  delete this._filterMap[key];
  this.trigger('removeFilter', {
    filter: filter
  });
};

scout.Table.prototype.getFilter = function(key) {
  if (!key) {
    throw new Error('key has to be defined');
  }
  return this._filterMap[key];
};

/**
 * While resizing a column, this method is called for each change of the width. As long as the resizing is in
 * progress (e.g. the mouse button has not been released), the column is marked with the flag "resizingInProgress".
 * When the resizing has finished, this method has to be called again without the flag "resizingInProgress" to
 * correctly set the width of the "empty data" div.
 *
 * @param column
 *          (required) column to resize
 * @param width
 *          (required) new column size
 */
scout.Table.prototype.resizeColumn = function(column, width) {
  if (column.fixedWidth) {
    return;
  }
  var colNum = this.columns.indexOf(column) + 1;
  width = Math.floor(width);
  column.width = width;
  this._updateRowWidth();

  this.$cellsForColIndex(colNum, true)
    .css('min-width', width)
    .css('max-width', width);
  if (scout.device.tableAdditionalDivRequired) {
    this.$cellsForColIndexWidthFix(colNum, true)
      .css('max-width', (width - this.cellHorizontalPadding - 2 /* unknown IE9 extra space */ ));
    // same calculation in scout.Column.prototype.buildCellForRow;
  }
  this.$rows(true)
    .css('width', this.rowWidth);

  // If resized column contains cells with wrapped text, view port needs to be updated
  // Remove row height for non rendered rows because it may have changed due to resizing (wrap text)
  this._updateRowHeights();
  this._renderFiller();
  this._renderViewport();
  this.updateScrollbars();

  this._triggerColumnResized(column);

  if (column.resizingInProgress) {
    this._renderEmptyData();
  } else {
    this._renderEmptyData(this.rowWidth - this.rowBorderWidth);
  }
};

scout.Table.prototype.moveColumn = function(column, oldPos, newPos, dragged) {
  this.columns.forEach(function(iteratingColumn, i) {
    // Don't allow moving a column before the last column with a fixed position (checkbox col, row icon col ...)
    if (iteratingColumn.fixedPosition && newPos <= i) {
      newPos = i + 1;
    }
  });

  scout.arrays.remove(this.columns, column);
  scout.arrays.insert(this.columns, column, newPos);

  this._triggerColumnMoved(column, oldPos, newPos, dragged);

  // move aggregated rows
  this._aggregateRows.forEach(function(aggregateRow) {
    scout.arrays.move(aggregateRow.contents, oldPos, newPos);
  });

  // move cells
  this._rerenderViewport();
};

scout.Table.prototype._renderColumnOrderChanges = function(oldColumnOrder) {
  var column, i, j, $orderedCells, $cell, $cells, that = this,
    $row;

  if (this.header) {
    this.header.onOrderChanged(oldColumnOrder);
  }

  // move cells
  this.$rows(true).each(function() {
    $row = $(this);
    $orderedCells = $();
    $cells = $row.children();
    for (i = 0; i < that.columns.length; i++) {
      column = that.columns[i];

      //Find $cell for given column
      for (j = 0; j < oldColumnOrder.length; j++) {
        if (oldColumnOrder[j] === column) {
          $cell = $cells[j];
          break;
        }
      }
      $orderedCells.push($cell);
    }
    $row.prepend($orderedCells);
  });
};

scout.Table.prototype._triggerRowsInserted = function(rows) {
  this.trigger('rowsInserted', {
    rows: rows
  });
};

scout.Table.prototype._triggerRowsDeleted = function(rows) {
  this.trigger('rowsDeleted', {
    rows: rows
  });
};

scout.Table.prototype._triggerRowsUpdated = function(rows) {
  this.trigger('rowsUpdated', {
    rows: rows
  });
};

scout.Table.prototype._triggerAllRowsDeleted = function(rows) {
  this.trigger('allRowsDeleted', {
    rows: rows
  });
};

scout.Table.prototype._triggerRowsSelected = function(debounce) {
  this.trigger('rowsSelected', {
    debounce: debounce
  });
};

scout.Table.prototype._triggerRowsChecked = function(rows) {
  this.trigger('rowsChecked', {
    rows: rows
  });
};

scout.Table.prototype._triggerRowsFiltered = function() {
  this.trigger('rowsFiltered');
};

scout.Table.prototype._triggerFilterResetted = function() {
  this.trigger('filterResetted');
};

scout.Table.prototype._triggerAppLinkAction = function(column, ref) {
  this.trigger('appLinkAction', {
    column: column,
    ref: ref
  });
};

scout.Table.prototype._triggerReload = function() {
  this.trigger('reload');
};

scout.Table.prototype._triggerExportToClipboard = function() {
  this.trigger('exportToClipboard');
};

scout.Table.prototype._triggerRowOrderChanged = function(row, animating) {
  var event = {
    row: row,
    animating: animating
  };
  this.trigger('rowOrderChanged', event);
};

scout.Table.prototype._triggerColumnResized = function(column) {
  var event = {
    column: column
  };
  this.trigger('columnResized', event);
};

scout.Table.prototype._triggerColumnMoved = function(column, oldPos, newPos, dragged) {
  var event = {
    column: column,
    oldPos: oldPos,
    newPos: newPos,
    dragged: dragged
  };
  this.trigger('columnMoved', event);
};

scout.Table.prototype._triggerAggregationFunctionChanged = function(column) {
  var event = {
    column: column
  };
  this.trigger('aggregationFunctionChanged', event);
};

scout.Table.prototype._triggerGroupingChanged = function() {
  this.trigger('groupingChanged');
};

scout.Table.prototype._renderHeaderVisible = function() {
  this._renderTableHeader();
};

scout.Table.prototype._renderHeaderEnabled = function() {
  // Rebuild the table header when this property changes
  this._removeTableHeader();
  this._renderTableHeader();
};

scout.Table.prototype._syncCheckable = function(checkable) {
  this._setProperty('checkable', checkable);

  var column = this.checkableColumn;
  if (this.checkable && !column) {
    this._insertBooleanColumn();
  } else if (!this.checkable && column) {
    scout.arrays.remove(this.columns, column);
    this.checkableColumn = null;
  }
};

scout.Table.prototype.hasPermanentHeadOrTailSortColumns = function() {
  return this._permanentHeadSortColumns.length !== 0 || this._permanentTailSortColumns.length !== 0;
};

scout.Table.prototype._syncHeadAndTailSortColumns = function() {
  // find all sort columns (head and tail sort columns should always be included)
  var sortColumns = this.columns.filter(function(c) {
    return c.sortIndex >= 0;
  });
  sortColumns.sort(function(a, b) {
    return a.sortIndex - b.sortIndex;
  });

  this._permanentHeadSortColumns = [];
  this._permanentTailSortColumns = [];

  sortColumns.forEach(function(c) {
    if (c.initialAlwaysIncludeSortAtBegin) {
      this._permanentHeadSortColumns.push(c);
    } else if (c.initialAlwaysIncludeSortAtEnd) {
      this._permanentTailSortColumns.push(c);
    }
  }, this);
};

scout.Table.prototype._syncRowIconVisible = function(rowIconVisible) {
  this._setProperty('rowIconVisible', rowIconVisible);
  var column = this.rowIconColumn;
  if (this.rowIconVisible && !column) {
    this._insertRowIconColumn();
  } else if (!this.rowIconVisible && column) {
    scout.arrays.remove(this.columns, column);
    this.rowIconColumn = null;
  }
};

scout.Table.prototype._syncSelectedRows = function(selectedRows) {
  if (typeof selectedRows[0] === 'string') {
    selectedRows = this._rowsByIds(selectedRows);
  }
  this._setProperty('selectedRows', selectedRows);
};

scout.Table.prototype.setMenus = function(menus) {
  this.setProperty('menus', menus);
};

scout.Table.prototype._syncMenus = function(menus, oldMenus) {
  this.updateKeyStrokes(menus, oldMenus);
  this._setProperty('menus', menus);
  this._updateMenuBar();

  if (this.header) {
    this.header.updateMenuBar();
  }
};

scout.Table.prototype._updateMenuBar = function() {
  var notAllowedTypes = ['Header'];
  var menuItems = this._filterMenus(this.menus, scout.MenuDestinations.MENU_BAR, false, true, notAllowedTypes);
  menuItems = this.staticMenus.concat(menuItems);
  this.menuBar.setMenuItems(menuItems);
  if (this.contextMenu) {
    var contextMenuItems = this._filterMenus(this.menus, scout.MenuDestinations.CONTEXT_MENU, true, false, ['Header']);
    this.contextMenu.updateMenuItems(contextMenuItems);
  }
};

scout.Table.prototype._syncKeyStrokes = function(keyStrokes) {
  this.updateKeyStrokes(keyStrokes, this.keyStrokes);
  this._setProperty('keyStrokes', keyStrokes);
};

scout.Table.prototype.setFilters = function(filters) {
  for (var key in this._filterMap) { // NOSONAR
    this.removeFilterByKey(key);
  }
  if (filters) {
    filters.forEach(function(filter) {
      filter = this._ensureFilter(filter);
      this.addFilter(filter);
    }, this);
  }
};

scout.Table.prototype._ensureFilter = function(filter) {
  if (filter instanceof scout.TableUserFilter) {
    return filter;
  }
  if (filter.column) {
    filter.column = this._columnById(filter.column);
  }
  filter.table = this;
  filter.session = this.session;
  return scout.create(filter);
};

scout.Table.prototype._syncTableStatus = function(status) {
  status = scout.Status.ensure(status);
  this._setProperty('tableStatus', status);
};

scout.Table.prototype.setTableStatusVisible = function(visible) {
  this.setProperty('tableStatusVisible', visible);
  this._updateFooterVisibility();
};

scout.Table.prototype._updateFooterVisibility = function() {
  this.setFooterVisible(this.tableStatusVisible || this._hasVisibleTableControls());
};

scout.Table.prototype.setFooterVisible = function(visible) {
  this._setProperty('footerVisible', visible);
  if (visible && !this.footer) {
    this.footer = this._createFooter();
  }
  if (this.rendered) {
    this._renderFooterVisible();
  }
  if (!visible && this.footer) {
    this.footer.destroy();
    this.footer = null;
  }
};

scout.Table.prototype.setHeaderVisible = function(visible) {
  this.setProperty('headerVisible', visible);
};

/**
 * Renders the background effect of every column, if column.backgroundEffect is set
 */
scout.Table.prototype._renderBackgroundEffect = function() {
  this.columns.forEach(function(column) {
    if (!column.backgroundEffect) {
      return;
    }
    column._renderBackgroundEffect();
  }, this);
};

scout.Table.prototype._renderRowChecked = function(row) {
  if (!this.checkable) {
    return;
  }
  if (!row.$row) {
    return;
  }
  var $styleElem;
  if (this.checkableStyle === scout.Table.CheckableStyle.TABLE_ROW) {
    $styleElem = row.$row;
  } else {
    if (!this.checkableColumn) {
      throw new Error('checkableColumn not set');
    }
    $styleElem = this.checkableColumn.$checkBox(row.$row);
  }
  $styleElem.toggleClass('checked', row.checked);
};

scout.Table.prototype._renderCheckable = function() {
  this._redraw();
};

scout.Table.prototype._renderRowIconVisible = function() {
  this._redraw();
};

scout.Table.prototype._redraw = function() {
  this._rerenderHeaderColumns();
  this._rerenderViewport();
};

scout.Table.prototype._rerenderHeaderColumns = function() {
  if (this.header) {
    this.header.rerenderColumns();
    this.invalidateLayoutTree();
  }
};

scout.Table.prototype._renderTableHeader = function() {
  var changed = false;
  if (this.headerVisible && !this.header) {
    this.header = this._createHeader();
    this.header.render();
    this._renderEmptyData();
    changed = true;
  } else if (!this.headerVisible && this.header) {
    this._removeTableHeader();
    changed = true;
  }
  this.$container.toggleClass('header-invisible', !this.header);
  if (changed) {
    this.invalidateLayoutTree();
  }
};

scout.Table.prototype._removeTableHeader = function() {
  if (this.header) {
    this.header.destroy();
    this.header = null;
  }
};

/**
 * @param width optional width of emptyData, if omitted the width is set to the header's scrollWidth.
 */
scout.Table.prototype._renderEmptyData = function(width) {
  if (this.header && this.filteredRows().length === 0) {
    if (!this.$emptyData) {
      this.$emptyData = this.$data.appendDiv().html('&nbsp;');
    }
    // measure header-width and subtract insets from table-data
    var
      horizInsets = scout.graphics.getInsets(this.$data).horizontal(),
      headerWidth = scout.nvl(width, this.header.$container[0].scrollWidth) - horizInsets;
    this.$emptyData
      .css('min-width', headerWidth)
      .css('max-width', headerWidth);
  }
  this.updateScrollbars();
};

scout.Table.prototype._removeEmptyData = function() {
  if (this.filteredRows().length > 0 && this.$emptyData) {
    this.$emptyData.remove();
    this.$emptyData = undefined;
    this.updateScrollbars();
  }
};

scout.Table.prototype._renderFooterVisible = function() {
  if (!this.footer) {
    return;
  }
  if (this.footerVisible) {
    this._renderFooter();
  } else {
    this._removeFooter();
  }
  this.invalidateLayoutTree();
};

scout.Table.prototype._renderFooter = function() {
  if (this.footer.rendered) {
    return;
  }

  this.footer.render();
};

scout.Table.prototype._removeFooter = function() {
  if (!this.footer.rendered) {
    return;
  }
  this.footer.remove();
};

/**
 * @override Widget.js
 */
scout.Table.prototype._renderEnabled = function() {
  scout.Table.parent.prototype._renderEnabled.call(this);

  var enabled = this.enabled;
  this.$data.setEnabled(enabled);
  this.$container.setTabbable(enabled);

  if (this.rendered) {
    // Enable/disable all checkboxes
    this.$rows().each(function() {
      var $row = $(this),
        row = $row.data('row');
      $row.find('input').setEnabled(enabled && row.enabled);
    });
  }
};

/**
 * @override Widget.js
 */
scout.Table.prototype._renderDisabledStyle = function() {
  scout.Table.parent.prototype._renderDisabledStyle.call(this);
  this._renderDisabledStyleInternal(this.$data);
};

scout.Table.prototype._renderAutoResizeColumns = function() {
  if (this.autoResizeColumns) {
    this.invalidateLayoutTree();
  }
};

scout.Table.prototype._renderDropType = function() {
  if (this.dropType) {
    this._installDragAndDropHandler();
  } else {
    this._uninstallDragAndDropHandler();
  }
};

scout.Table.prototype._renderCheckableStyle = function() {
  this.$container.toggleClass('checkable', this.checkableStyle === scout.Table.CheckableStyle.TABLE_ROW);
};

scout.Table.prototype._installDragAndDropHandler = function(event) {
  if (this.dragAndDropHandler) {
    return;
  }
  this.dragAndDropHandler = scout.dragAndDrop.handler(this, {
    supportedScoutTypes: scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,
    dropType: function() {
      return this.dropType;
    }.bind(this),
    dropMaximumSize: function() {
      return this.dropMaximumSize;
    }.bind(this),
    additionalDropProperties: function(event) {
      var $target = $(event.currentTarget);
      var properties = {
        rowId: ''
      };
      if ($target.hasClass('table-row')) {
        var row = $target.data('row');
        properties.rowId = row.id;
      }
      return properties;
    }.bind(this)
  });
  this.dragAndDropHandler.install(this.$container, '.table-data,.table-row');
};

scout.Table.prototype._uninstallDragAndDropHandler = function(event) {
  if (!this.dragAndDropHandler) {
    return;
  }
  this.dragAndDropHandler.uninstall();
  this.dragAndDropHandler = null;
};

/**
 * This listener is used to invalidate table layout when an image icon has been loaded (which happens async in the browser).
 */
scout.Table.prototype._installImageListeners = function() {
  this._imageLoadListener = this._onImageLoadOrError.bind(this);
  this.$data[0].addEventListener('load', this._imageLoadListener, true);
  this.$data[0].addEventListener('error', this._imageLoadListener, true);
};

scout.Table.prototype._uninstallImageListeners = function() {
  this.$data[0].removeEventListener('load', this._imageLoadListener, true);
  this.$data[0].removeEventListener('error', this._imageLoadListener, true);
};

/**
 * Calculates the optimal view range size (number of rows to be rendered).
 * It uses the default row height to estimate how many rows fit in the view port.
 * The view range size is this value * 2.
 */
scout.Table.prototype.calculateViewRangeSize = function() {
  // Make sure row height is up to date (row height may be different after zooming)
  this._updateRowHeight();

  if (this.rowHeight === 0) {
    throw new Error('Cannot calculate view range with rowHeight = 0');
  }
  return Math.ceil(this.$data.outerHeight() / this.rowHeight) * 2;
};

scout.Table.prototype.setViewRangeSize = function(viewRangeSize) {
  if (this.viewRangeSize === viewRangeSize) {
    return;
  }
  this._setProperty('viewRangeSize', viewRangeSize);
  if (this.rendered) {
    this._renderViewport();
  }
};

scout.Table.prototype._calculateCurrentViewRange = function() {
  var rowIndex,
    scrollTop = this.$data[0].scrollTop,
    maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;

  if (maxScrollTop === 0) {
    // no scrollbars visible
    rowIndex = 0;
  } else {
    rowIndex = this._rowIndexAtScrollTop(scrollTop);
  }

  return this._calculateViewRangeForRowIndex(rowIndex);
};

/**
 * Returns the index of the row which is at position scrollTop.
 */
scout.Table.prototype._rowIndexAtScrollTop = function(scrollTop) {
  var height = 0,
    index = -1;
  this.filteredRows().some(function(row, i) {
    height += this._heightForRow(row);
    if (scrollTop < height) {
      index = i;
      return true;
    }
  }.bind(this));
  return index;
};

scout.Table.prototype._heightForRow = function(row) {
  var height = 0,
    aggregateRow = row.aggregateRowAfter;

  if (row.height) {
    height = row.height;
  } else {
    height = this.rowHeight;
  }

  // Add height of aggregate row as well
  if (aggregateRow) {
    if (aggregateRow.height) {
      height += aggregateRow.height;
    } else {
      height += this.aggregateRowHeight;
    }
  }

  return height;
};

/**
 * Returns a range of size this.viewRangeSize. Start of range is rowIndex - viewRangeSize / 4.
 * -> 1/4 of the rows are before the viewport 2/4 in the viewport 1/4 after the viewport,
 * assuming viewRangeSize is 2*number of possible rows in the viewport (see calculateViewRangeSize).
 */
scout.Table.prototype._calculateViewRangeForRowIndex = function(rowIndex) {
  // regular / non-virtual scrolling? -> all rows are already rendered in the DOM
  if (!this.virtual) {
    return new scout.Range(0, this.filteredRows().length);
  }

  var viewRange = new scout.Range(),
    quarterRange = Math.floor(this.viewRangeSize / 4),
    diff;

  viewRange.from = Math.max(rowIndex - quarterRange, 0);
  viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.filteredRows().length);

  // Try to use the whole viewRangeSize (extend from if necessary)
  diff = this.viewRangeSize - viewRange.size();
  if (diff > 0) {
    viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);
  }
  return viewRange;
};

/**
 * Calculates and renders the rows which should be visible in the current viewport based on scroll top.
 */
scout.Table.prototype._renderViewport = function() {
  var viewRange = this._calculateCurrentViewRange();
  this._renderViewRange(viewRange);
};

scout.Table.prototype._rerenderViewport = function() {
  this._removeRows();
  this._removeAggregateRows();
  this._renderFiller();
  this._renderViewport();
};

scout.Table.prototype._renderViewRangeForRowIndex = function(rowIndex) {
  var viewRange = this._calculateViewRangeForRowIndex(rowIndex);
  this._renderViewRange(viewRange);
};

/**
 * Renders the rows visible in the viewport and removes the other rows
 */
scout.Table.prototype._renderViewRange = function(viewRange) {
  if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {
    // Range already rendered -> do nothing
    return;
  }
  this._removeRangeMarkers();
  var rangesToRender = viewRange.subtract(this.viewRangeRendered);
  var rangesToRemove = this.viewRangeRendered.subtract(viewRange);
  rangesToRemove.forEach(function(range) {
    this._removeRowsInRange(range);
  }.bind(this));
  rangesToRender.forEach(function(range) {
    this._renderRowsInRange(range);
  }.bind(this));

  // check if at least last and first row in range got correctly rendered
  if (this.viewRangeRendered.size() > 0) {
    var rows = this.filteredRows();
    var firstRow = rows[this.viewRangeRendered.from];
    var lastRow = rows[this.viewRangeRendered.to - 1];
    if (!firstRow.$row || !lastRow.$row) {
      throw new Error('Rows not rendered as expected. ' + this.viewRangeRendered + '. First: ' + firstRow.$row + '. Last: ' + lastRow.$row);
    }
  }

  this._renderRangeMarkers();
  this._removeAggregateRows();
  this._renderAggregateRows();
  this._renderFiller();
  this._renderEmptyData();
  this._renderBackgroundEffect();
  this._renderSelection();
  this.viewRangeDirty = false;
};

scout.Table.prototype._removeRangeMarkers = function() {
  var firstRow, lastRow;
  if (this.viewRangeRendered.size() === 0) {
    return;
  }
  firstRow = this.filteredRows()[this.viewRangeRendered.from];
  lastRow = this.filteredRows()[this.viewRangeRendered.to - 1];
  firstRow.$row.removeClass('first');
  lastRow.$row.removeClass('last');
};

scout.Table.prototype._renderRangeMarkers = function() {
  var firstRow, lastRow;
  if (this.viewRangeRendered.size() === 0) {
    return;
  }
  firstRow = this.filteredRows()[this.viewRangeRendered.from];
  lastRow = this.filteredRows()[this.viewRangeRendered.to - 1];
  firstRow.$row.addClass('first');
  lastRow.$row.addClass('last');
};

scout.Table.prototype.ensureRowRendered = function(row) {
  if (!row.$row) {
    var rowIndex = this.filteredRows().indexOf(row);
    this._renderViewRangeForRowIndex(rowIndex);
  }
};

scout.Table.prototype._renderFiller = function() {
  if (!this.$fillBefore) {
    this.$fillBefore = this.$data.prependDiv('table-data-fill');
    this._applyFillerStyle(this.$fillBefore);
  }

  var fillBeforeHeight = this._calculateFillerHeight(new scout.Range(0, this.viewRangeRendered.from));
  this.$fillBefore.cssHeight(fillBeforeHeight);
  this.$fillBefore.cssWidth(this.rowWidth);
  $.log.trace('FillBefore height: ' + fillBeforeHeight);

  if (!this.$fillAfter) {
    this.$fillAfter = this.$data.appendDiv('table-data-fill');
    this._applyFillerStyle(this.$fillAfter);
  }

  var fillAfterHeight = this._calculateFillerHeight(new scout.Range(this.viewRangeRendered.to, this.filteredRows().length));
  this.$fillAfter.cssHeight(fillAfterHeight);
  this.$fillAfter.cssWidth(this.rowWidth);
  $.log.trace('FillAfter height: ' + fillAfterHeight);
};

scout.Table.prototype._applyFillerStyle = function($filler) {
  var lineColor = $filler.css('background-color');
  // In order to get a 1px border we need to get the right value in percentage for the linear gradient
  var lineWidth = ((1 - (1 / this.rowHeight)) * 100).toFixed(2) + '%';
  $filler.css({
    background: 'linear-gradient(to bottom, transparent, transparent ' + lineWidth + ', ' + lineColor + ' ' + lineWidth + ', ' + lineColor + ')',
    backgroundSize: '100% ' + this.rowHeight + 'px',
    backgroundColor: 'transparent'
  });
};

scout.Table.prototype._calculateFillerHeight = function(range) {
  var totalHeight = 0;
  for (var i = range.from; i < range.to; i++) {
    var row = this.filteredRows()[i];
    totalHeight += this._heightForRow(row);
  }
  return totalHeight;
};

scout.Table.prototype.containsNumberColumn = function() {
  return this.columns.some(function(column) {
    return column instanceof scout.NumberColumn;
  });
};

/**
 * Rebuilds the header.<br>
 * Does not modify the rows, it expects a deleteAll and insert operation to follow which will do the job.
 */
scout.Table.prototype.updateColumnStructure = function(columns) {
  this._rebuildingTable = true;

  this.columns = columns;
  this._initColumns();

  if (this.rendered) {
    this._updateRowWidth();
    this.$rows(true).css('width', this.rowWidth);

    this._rerenderHeaderColumns();
  }
  this.trigger('columnStructureChanged');
};

scout.Table.prototype.updateColumnOrder = function(columns) {
  var i, column, currentPosition, oldColumnOrder;
  if (columns.length !== this.columns.length) {
    throw new Error('Column order may not be updated because lengths of the arrays differ.');
  }

  oldColumnOrder = this.columns.slice();

  for (i = 0; i < columns.length; i++) {
    column = columns[i];
    currentPosition = this.columns.indexOf(column);
    if (currentPosition < 0) {
      throw new Error('Column with id ' + column.id + 'not found.');
    }

    if (currentPosition !== i) {
      // Update model
      scout.arrays.remove(this.columns, column);
      scout.arrays.insert(this.columns, column, i);
    }
  }

  if (this.rendered) {
    this._renderColumnOrderChanges(oldColumnOrder);
  }
};

/**
 * @param columns array of columns which were updated.
 */
scout.Table.prototype.updateColumnHeaders = function(columns) {
  var column, oldColumnState;

  // Update model columns
  for (var i = 0; i < columns.length; i++) {
    scout.defaultValues.applyTo(columns[i], 'Column');
    column = this._columnById(columns[i].id);
    oldColumnState = $.extend(oldColumnState, column);
    column.text = columns[i].text;
    column.tooltipText = columns[i].tooltipText;
    column.headerCssClass = columns[i].headerCssClass;
    column.headerBackgroundColor = columns[i].headerBackgroundColor;
    column.headerForegroundColor = columns[i].headerForegroundColor;
    column.headerFont = columns[i].headerFont;
    column.headerIconId = columns[i].headerIconId;
    column.sortActive = columns[i].sortActive;
    column.sortAscending = columns[i].sortAscending;
    if (!column.sortActive && column.sortIndex !== -1) {
      // Adjust indices of other sort columns (if a sort column in the middle got removed, there won't necessarily be an event for the other columns)
      this._removeSortColumn(column);
    } else if (column.sortActive && column.sortIndex === -1) {
      // Necessary if there is a tail sort column (there won't be an event for the tail sort column if another sort column was added before)
      this._addSortColumn(column);
    } else {
      column.sortIndex = columns[i].sortIndex;
    }

    if (this.rendered && this.header) {
      this.header.updateHeader(column, oldColumnState);
    }
  }
};

scout.Table.prototype.requestFocusInCell = function(column, row) {
  if (!this.rendered) {
    this._postRenderActions.push(this.requestFocusInCell.bind(this, column, row));
    return;
  }

  var cell = this.cell(column, row);
  if (this.enabled && row.enabled && cell.editable) {
    this.prepareCellEdit(column, row, true);
  }
};

/**
 * Method invoked when this is a 'detailTable' and the outline content is displayed.
 * @override Widget.js
 */
scout.Table.prototype._attach = function() {
  this.$parent.append(this.$container);
  var htmlParent = this.htmlComp.getParent();
  this.htmlComp.setSize(htmlParent.getSize());
  this.session.detachHelper.afterAttach(this.$container);
  scout.Table.parent.prototype._attach.call(this);
};

/**
 * Method invoked when this is a 'detailTable' and the outline content is not displayed anymore.
 * @override Widget.js
 */
scout.Table.prototype._detach = function() {
  this.session.detachHelper.beforeDetach(this.$container);
  this.$container.detach();
  // Detach helper stores the current scroll pos and restores in attach.
  // To make it work scrollTop needs to be reseted here otherwise viewport won't be rendered by _onDataScroll
  scout.Table.parent.prototype._detach.call(this);
};

scout.Table.prototype.setVirtual = function(virtual) {
  this._setProperty('virtual', virtual);
};

scout.Table.prototype.setCellValue = function(column, row, value) {
  column.setCellValue(row, value);
  this.updateRow(row);
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * @memberOf scout.Table
 */
scout.Table.parseHorizontalAlignment = function(alignment) {
  if (alignment > 0) {
    return 'right';
  }
  if (alignment === 0) {
    return 'center';
  }
  return 'left';
};

scout.Table.linkRowToDiv = function(row, $row) {
  if (row) {
    row.$row = $row;
  }
  if ($row) {
    $row.data('row', row);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableAdapter = function() {
  scout.TableAdapter.parent.call(this);
  this._addAdapterProperties(['tableControls', 'menus', 'keyStrokes']);
  this._addRemoteProperties(['contextColumn']);
};
scout.inherits(scout.TableAdapter, scout.ModelAdapter);

scout.TableAdapter.prototype._sendRowsSelected = function(rowIds, debounceSend) {
  var eventData = {
    rowIds: rowIds
  };

  // send delayed to avoid a lot of requests while selecting
  // coalesce: only send the latest selection changed event for a field
  this._send('rowsSelected', eventData, {
    delay: debounceSend ? 250 : 0,
    coalesce: function(previous) {
      return this.id === previous.id && this.type === previous.type;
    }
  });
};

scout.TableAdapter.prototype._sendRowClicked = function(rowId, mouseButton, columnId) {
  var data = {
    rowId: rowId,
    columnId: columnId,
    mouseButton: mouseButton
  };
  this._send('rowClicked', data);
};

scout.TableAdapter.prototype._onWidgetRowsSelected = function(event) {
  var rowIds = this.widget._rowsToIds(this.widget.selectedRows);
  this._sendRowsSelected(rowIds, event.debounce);
};

scout.TableAdapter.prototype._onWidgetRowClicked = function(event) {
  var columnId;
  if (event.column !== undefined) {
    columnId = event.column.id;
  }

  this._sendRowClicked(event.row.id, event.mouseButton, columnId);
};

scout.TableAdapter.prototype._onWidgetAddFilter = function(event) {
  var filter = event.filter;
  if (filter instanceof scout.TableUserFilter) {
    this._send('addFilter', filter.createAddFilterEventData());
  }
};

scout.TableAdapter.prototype._onWidgetRemoveFilter = function(event) {
  var filter = event.filter;
  if (filter instanceof scout.TableUserFilter) {
    this._send('removeFilter', filter.createRemoveFilterEventData());
  }
};

scout.TableAdapter.prototype._onWidgetColumnResized = function(event) {
  this._sendColumnResized(event.column);
};

scout.TableAdapter.prototype._sendColumnResized = function(column) {
  if (column.fixedWidth || this.widget.autoResizeColumns) {
    return;
  }

  var eventData = {
    columnId: column.id,
    width: column.width
  };

  // send delayed to avoid a lot of requests while resizing
  // coalesce: only send the latest resize event for a column
  this._send('columnResized', eventData, {
    delay: 750,
    coalesce: function(previous) {
      return this.id === previous.id && this.type === previous.type && this.columnId === previous.columnId;
    },
    showBusyIndicator: false
  });
};

scout.TableAdapter.prototype._onWidgetAggregationFunctionChanged = function(event) {
  this._sendAggregationFunctionChanged(event.column);
};

scout.TableAdapter.prototype._sendAggregationFunctionChanged = function(column) {
  var data = {
    columnId: column.id,
    aggregationFunction: column.aggregationFunction
  };
  this._send('aggregationFunctionChanged', data);
};

scout.TableAdapter.prototype._onWidgetColumnBackgroundEffectChanged = function(event) {
  this._sendColumnBackgroundEffectChanged(event.column);
};

scout.TableAdapter.prototype._sendColumnBackgroundEffectChanged = function(column) {
  var data = {
    columnId: column.id,
    backgroundEffect: column.backgroundEffect
  };
  this._send('columnBackgroundEffectChanged', data);
};

scout.TableAdapter.prototype._onWidgetColumnOrganizeAction = function(event) {
  this._send('columnOrganizeAction', {
    action: event.action,
    columnId: event.column.id
  });
};

scout.TableAdapter.prototype._onWidgetColumnMoved = function(event) {
  var index = event.newPos;
  this.widget.columns.forEach(function(iteratingColumn, i) {
    // Adjust index if column is only known on the gui
    if (iteratingColumn.guiOnly) {
      index--;
    }
  });
  this._sendColumnMoved(event.column, index);
};

scout.TableAdapter.prototype._sendColumnMoved = function(column, index) {
  var data = {
    columnId: column.id,
    index: index
  };
  this._send('columnMoved', data);
};

scout.TableAdapter.prototype._onWidgetPrepareCellEdit = function(event) {
  this._sendPrepareCellEdit(event.row, event.column);
};

scout.TableAdapter.prototype._sendPrepareCellEdit = function(row, column) {
  var data = {
    rowId: row.id,
    columnId: column.id
  };
  this._send('prepareCellEdit', data);
};

scout.TableAdapter.prototype._onWidgetCompleteCellEdit = function(event) {
  this._sendCompleteCellEdit(event.field);
};

scout.TableAdapter.prototype._sendCompleteCellEdit = function(field) {
  var data = {
    fieldId: field.id
  };
  this._send('completeCellEdit', data);
};

scout.TableAdapter.prototype._onWidgetCancelCellEdit = function(event) {
  this._sendCancelCellEdit(event.field);
};

scout.TableAdapter.prototype._sendCancelCellEdit = function(field) {
  var data = {
    fieldId: field.id
  };
  this._send('cancelCellEdit', data);
};

scout.TableAdapter.prototype._onWidgetRowsChecked = function(event) {
  this._sendRowsChecked(event.rows);
};

scout.TableAdapter.prototype._sendRowsChecked = function(rows) {
  var data = {
    rows: []
  };

  for (var i = 0; i < rows.length; i++) {
    data.rows.push({
      rowId: rows[i].id,
      checked: rows[i].checked
    });
  }

  this._send('rowsChecked', data);
};

scout.TableAdapter.prototype._onWidgetRowsFiltered = function(event) {
  var rowIds = this.widget._rowsToIds(this.widget.filteredRows());
  this._sendRowsFiltered(rowIds);
};

scout.TableAdapter.prototype._sendRowsFiltered = function(rowIds) {
  var eventData = {};
  if (rowIds.length === this.widget.rows.length) {
    eventData.remove = true;
  } else {
    eventData.rowIds = rowIds;
  }

  // send with timeout, mainly for incremental load of a large table
  // coalesce: only send last event (don't coalesce remove and 'add' events, the UI server needs both)
  this._send('rowsFiltered', eventData, {
    delay: 250,
    coalesce: function(previous) {
      return this.id === previous.id && this.type === previous.type && this.remove === previous.remove;
    },
    showBusyIndicator: false
  });
};

scout.TableAdapter.prototype._onWidgetRowAction = function(event) {
  this._sendRowAction(event.row, event.column);
};

scout.TableAdapter.prototype._sendRowAction = function(row, column) {
  this._send('rowAction', {
    rowId: row.id,
    columnId: column.id
  });
};

scout.TableAdapter.prototype._onWidgetAppLinkAction = function(event) {
  this._sendAppLinkAction(event.column, event.ref);
};

scout.TableAdapter.prototype._sendAppLinkAction = function(column, ref) {
  this._send('appLinkAction', {
    columnId: column.id,
    ref: ref
  });
};

scout.TableAdapter.prototype._sendContextColumn = function(contextColumn) {
  if (contextColumn.guiOnly) {
    contextColumn = null;
    this.widget.contextColumn = null;
  }
  var columnId = null;
  if (contextColumn) {
    columnId = contextColumn.id;
  }
  this._send('property', {
    contextColumn: columnId
  });
};

scout.TableAdapter.prototype._onWidgetReload = function(event) {
  this._send('reload');
};

scout.TableAdapter.prototype._onWidgetExportToClipbaord = function(event) {
  this._send('exportToClipboard');
};

scout.TableAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'rowsSelected') {
    this._onWidgetRowsSelected(event);
  } else if (event.type === 'rowsChecked') {
    this._onWidgetRowsChecked(event);
  } else if (event.type === 'rowsFiltered') {
    this._onWidgetRowsFiltered(event);
  } else if (event.type === 'rowClicked') {
    this._onWidgetRowClicked(event);
  } else if (event.type === 'rowAction') {
    this._onWidgetRowAction(event);
  } else if (event.type === 'prepareCellEdit') {
    this._onWidgetPrepareCellEdit(event);
  } else if (event.type === 'completeCellEdit') {
    this._onWidgetCompleteCellEdit(event);
  } else if (event.type === 'cancelCellEdit') {
    this._onWidgetCancelCellEdit(event);
  } else if (event.type === 'appLinkAction') {
    this._onWidgetAppLinkAction(event);
  } else if (event.type === 'exportToClipboard') {
    this._onWidgetExportToClipbaord(event);
  } else if (event.type === 'reload') {
    this._onWidgetReload(event);
  } else if (event.type === 'addFilter') {
    this._onWidgetAddFilter(event);
  } else if (event.type === 'removeFilter') {
    this._onWidgetRemoveFilter(event);
  } else if (event.type === 'columnResized') {
    this._onWidgetColumnResized(event);
  } else if (event.type === 'columnMoved') {
    this._onWidgetColumnMoved(event);
  } else if (event.type === 'columnBackgroundEffectChanged') {
    this._onWidgetColumnBackgroundEffectChanged(event);
  } else if (event.type === 'columnOrganizeAction') {
    this._onWidgetColumnOrganizeAction(event);
  } else if (event.type === 'aggregationFunctionChanged') {
    this._onWidgetAggregationFunctionChanged(event);
  } else {
    scout.TableAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

scout.TableAdapter.prototype._onRowsInserted = function(rows) {
  this.widget.insertRows(rows, true);
};

scout.TableAdapter.prototype._onRowsDeleted = function(rowIds) {
  var rows = this.widget._rowsByIds(rowIds);
  this.addFilterForWidgetEventType('rowsSelected');
  this.widget.deleteRows(rows);
};

scout.TableAdapter.prototype._onAllRowsDeleted = function() {
  this.addFilterForWidgetEventType('rowsSelected');
  this.widget.deleteAllRows();
};

scout.TableAdapter.prototype._onRowsUpdated = function(rows) {
  this.widget.updateRows(rows);
};

scout.TableAdapter.prototype._onRowsSelected = function(rowIds) {
  var rows = this.widget._rowsByIds(rowIds);
  this.addFilterForWidgetEventType('rowsSelected');
  this.widget.selectRows(rows);
  // FIXME [6.1] CGU what is this for? seems wrong here
  this.widget.selectionHandler.clearLastSelectedRowMarker();
};

scout.TableAdapter.prototype._onRowsChecked = function(rows) {
  var checkedRows = [],
    uncheckedRows = [];

  rows.forEach(function(rowData) {
    var row = this.widget._rowById(rowData.id);
    if (rowData.checked) {
      checkedRows.push(row);
    } else {
      uncheckedRows.push(row);
    }
  }, this);

  this.addFilterForWidgetEventType('rowsChecked');
  this.widget.checkRows(checkedRows, {
    checked: true,
    checkOnlyEnabled: false
  });
  this.widget.uncheckRows(uncheckedRows, {
    checkOnlyEnabled: false
  });
};

scout.TableAdapter.prototype._onRowOrderChanged = function(rowIds) {
  var rows = this.widget._rowsByIds(rowIds);
  this.widget.updateRowOrder(rows);
};

scout.TableAdapter.prototype._onColumnStructureChanged = function(columns) {
  this.widget.updateColumnStructure(columns);
};

scout.TableAdapter.prototype._onColumnOrderChanged = function(columnIds) {
  var columns = this.widget._columnsByIds(columnIds);
  this.widget.updateColumnOrder(columns);
};

scout.TableAdapter.prototype._onColumnHeadersUpdated = function(columns) {
  this.widget.updateColumnHeaders(columns);
};

scout.TableAdapter.prototype._onStartCellEdit = function(columnId, rowId, fieldId) {
  var column = this.widget._columnById(columnId),
    row = this.widget._rowById(rowId),
    field = this.session.getOrCreateWidget(fieldId, this.widget);

  this.widget.startCellEdit(column, row, field);
};

scout.TableAdapter.prototype._onEndCellEdit = function(fieldId) {
  var field = this.session.getModelAdapter(fieldId);
  this.widget.endCellEdit(field.widget);
};

scout.TableAdapter.prototype._onRequestFocus = function() {
  this.widget.requestFocus();
};

scout.TableAdapter.prototype._onScrollToSelection = function() {
  this.widget.revealSelection();
};

scout.TableAdapter.prototype._onColumnBackgroundEffectChanged = function(event) {
  event.eventParts.forEach(function(eventPart) {
    var column = this.widget._columnById(eventPart.columnId),
      backgroundEffect = eventPart.backgroundEffect;

    this.addFilterForWidgetEvent(function(widgetEvent) {
      return (widgetEvent.type === 'columnBackgroundEffectChanged' &&
        widgetEvent.column.id === column.id &&
        widgetEvent.column.backgroundEffect === backgroundEffect);
    });

    column.setBackgroundEffect(backgroundEffect);
  }, this);
};

scout.TableAdapter.prototype._onRequestFocusInCell = function(event) {
  var row = this.widget._rowById(event.rowId),
    column = this.widget._columnById(event.columnId);

  this.widget.requestFocusInCell(column, row);
};

scout.TableAdapter.prototype._onAggregationFunctionChanged = function(event) {
  var columns = [],
    functions = [];

  event.eventParts.forEach(function(eventPart) {
    var func = eventPart.aggregationFunction,
      column = this.widget._columnById(eventPart.columnId);

    this.addFilterForWidgetEvent(function(widgetEvent) {
      return (widgetEvent.type === 'aggregationFunctionChanged' &&
        widgetEvent.column.id === column.id &&
        widgetEvent.column.aggregationFunction === func);
    });

    columns.push(column);
    functions.push(func);
  }, this);

  this.widget.changeAggregations(columns, functions);
};

scout.TableAdapter.prototype._onFiltersChanged = function(filters) {
  this.addFilterForWidgetEventType('addFilter');
  this.addFilterForWidgetEventType('removeFilter');

  this.widget.setFilters(filters);
  // do not refilter while the table is being rebuilt (because column.index in filter and row.cells may be inconsistent)
  if (!this.widget._rebuildingTable) { //FIXME CGU [6.1] gehrt das nicht direkt in filter rein?
    this.widget.filter();
  }
};

scout.TableAdapter.prototype.onModelAction = function(event) {
  if (event.type === 'rowsInserted') {
    this._onRowsInserted(event.rows);
  } else if (event.type === 'rowsDeleted') {
    this._onRowsDeleted(event.rowIds);
  } else if (event.type === 'allRowsDeleted') {
    this._onAllRowsDeleted();
  } else if (event.type === 'rowsSelected') {
    this._onRowsSelected(event.rowIds);
  } else if (event.type === 'rowOrderChanged') {
    this._onRowOrderChanged(event.rowIds);
  } else if (event.type === 'rowsUpdated') {
    this._onRowsUpdated(event.rows);
  } else if (event.type === 'filtersChanged') {
    this._onFiltersChanged(event.filters);
  } else if (event.type === 'rowsChecked') {
    this._onRowsChecked(event.rows);
  } else if (event.type === 'columnStructureChanged') {
    this._onColumnStructureChanged(event.columns);
  } else if (event.type === 'columnOrderChanged') {
    this._onColumnOrderChanged(event.columnIds);
  } else if (event.type === 'columnHeadersUpdated') {
    this._onColumnHeadersUpdated(event.columns);
  } else if (event.type === 'startCellEdit') {
    this._onStartCellEdit(event.columnId, event.rowId, event.fieldId);
  } else if (event.type === 'endCellEdit') {
    this._onEndCellEdit(event.fieldId);
  } else if (event.type === 'requestFocus') {
    this._onRequestFocus();
  } else if (event.type === 'scrollToSelection') {
    this._onScrollToSelection();
  } else if (event.type === 'aggregationFunctionChanged') {
    this._onAggregationFunctionChanged(event);
  } else if (event.type === 'columnBackgroundEffectChanged') {
    this._onColumnBackgroundEffectChanged(event);
  } else if (event.type === 'requestFocusInCell') {
    this._onRequestFocusInCell(event);
  } else {
    scout.TableAdapter.parent.prototype.onModelAction.call(this, event);
  }
};

/**
 * @override ModelAdapter.js
 */
scout.TableAdapter.prototype.exportAdapterData = function(adapterData) {
  adapterData = scout.TableAdapter.parent.prototype.exportAdapterData.call(this, adapterData);
  delete adapterData.selectedRows;
  adapterData.rows = [];
  adapterData.columns.forEach(function(column) {
    delete column.classId;
    delete column.modelClass;
  });
  return adapterData;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableRow = function() {
  this.$row;
  this.aggregateRowAfter;
  this.cells = [];
  this.checked = false;
  this.enabled = true;
  this.filterAccepted = true;
  this.height;
  this.hasError = false;
  this.id;
};

scout.TableRow.prototype.init = function(model) {
  this._init(model);
};

scout.TableRow.prototype._init = function(model) {
  if (!model.parent) {
    throw new Error('missing property \'parent\'');
  }
  $.extend(this, model);
  scout.defaultValues.applyTo(this);
  this._initCells();
};

scout.TableRow.prototype._initCells = function() {
  this.getTable().columns.forEach(function(column) {
    if (!column.guiOnly) {
      var cell = this.cells[column.index];
      cell = column.initCell(cell, this);
      this.cells[column.index] = cell;
    }
  }, this);
};

scout.TableRow.prototype.getTable = function() {
  return this.parent;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableMatrix = function(table, session) {
  this.session = session;
  this.locale = session.locale;
  this._allData = [];
  this._allAxis = [];
  this._columns = table.columns;
  this._rows = table.rows;
  this._table = table;
};

scout.TableMatrix.DateGroup = {
  NONE: 0,
  YEAR: 256,
  MONTH: 257,
  WEEKDAY: 258
};

scout.TableMatrix.NumberGroup = {
  COUNT: -1,
  SUM: 1,
  AVG: 2
};

/**
 * add data axis
 */
scout.TableMatrix.prototype.addData = function(data, dataGroup) {
  var dataAxis = [],
    locale = this.locale;

  // collect all axis
  this._allData.push(dataAxis);

  // copy column for later access
  dataAxis.column = data;

  // data always is number
  dataAxis.format = function(n) {
    return locale.decimalFormat.format(n);
  };

  // count, sum, avg
  if (dataGroup === scout.TableMatrix.NumberGroup.COUNT) {
    dataAxis.norm = function(f) {
      return 1;
    };
    dataAxis.group = function(array) {
      return array.length;
    };
  } else if (dataGroup === scout.TableMatrix.NumberGroup.SUM) {
    dataAxis.norm = function(f) {
      if (isNaN(f) || f === null || f === '') {
        return null;
      } else {
        return parseFloat(f);
      }
    };
    dataAxis.group = function(array) {
      return array.reduce(function(a, b) {
        return a + b;
      });
    };
  } else if (dataGroup === scout.TableMatrix.NumberGroup.AVG) {
    dataAxis.norm = function(f) {
      if (isNaN(f) || f === null || f === '') {
        return null;
      } else {
        return parseFloat(f);
      }
    };
    dataAxis.group = function(array) {
      var sum = array.reduce(function(a, b) {
          return a + b;
        }),
        count = array.reduce(function(a, b) {
          return (b === null ? a : a + 1);
        }, 0);

      if (count === 0) {
        return null;
      } else {
        return sum / count;
      }
    };
  }

  return dataAxis;
};

//add x or y Axis
scout.TableMatrix.prototype.addAxis = function(axis, axisGroup) {
  var keyAxis = [],
    locale = this.locale,
    session = this.session,
    getText = this.session.text.bind(this.session),
    emptyCell = getText('ui.EmptyCell');

  // collect all axis
  this._allAxis.push(keyAxis);
  keyAxis.column = axis;

  // normalized string data
  keyAxis.normTable = [];

  // add a key to the axis
  keyAxis.add = function(k) {
    if (keyAxis.indexOf(k) === -1) {
      keyAxis.push(k);
    }
  };

  // default functions
  keyAxis.reorder = function() {
    keyAxis.sort(function(a, b) {
      // make sure -empty- is at the bottom
      if (a === null) {
        return 1;
      }
      if (b === null) {
        return -1;
      }
      // sort others
      return (a - b);
    });
  };
  keyAxis.norm = function(f) {
    if (f === null || f === '') {
      return null;
    } else {
      var index = keyAxis.normTable.indexOf(f);
      if (index === -1) {
        return keyAxis.normTable.push(f) - 1;
      } else {
        return index;
      }
    }
  };
  keyAxis.format = function(n) {
    if (n === null) {
      return emptyCell;
    } else {
      return keyAxis.normTable[n];
    }
  };

  // norm and format depends of datatype and group functionality
  if (axis instanceof scout.DateColumn) {
    if (axisGroup === scout.TableMatrix.DateGroup.NONE) {
      keyAxis.norm = function(f) {
        if (f === null || f === '') {
          return null;
        } else {
          return f.getTime();
        }
      };
      keyAxis.format = function(n) {
        if (n === null) {
          return null;
        } else {
          var format = axis.format;
          if (format) {
            format = new scout.DateFormat(locale, format);
          } else {
            format = locale.dateFormat;
          }
          return format.format(new Date(n));
        }
      };
    } else if (axisGroup === scout.TableMatrix.DateGroup.YEAR) {
      keyAxis.norm = function(f) {
        if (f === null || f === '') {
          return null;
        } else {
          return f.getFullYear();
        }
      };
      keyAxis.format = function(n) {
        if (n === null) {
          return emptyCell;
        } else {
          return String(n);
        }
      };
    } else if (axisGroup === scout.TableMatrix.DateGroup.MONTH) {
      keyAxis.norm = function(f) {
        if (f === null || f === '') {
          return null;
        } else {
          return f.getMonth();
        }
      };
      keyAxis.format = function(n) {
        if (n === null) {
          return emptyCell;
        } else {
          return locale.dateFormatSymbols.months[n];
        }
      };
    } else if (axisGroup === scout.TableMatrix.DateGroup.WEEKDAY) {
      keyAxis.norm = function(f) {
        if (f === null || f === '') {
          return null;
        } else {
          var b = (f.getDay() + 7 - locale.dateFormatSymbols.firstDayOfWeek) % 7;
          return b;
        }
      };
      keyAxis.format = function(n) {
        if (n === null) {
          return emptyCell;
        } else {
          return locale.dateFormatSymbols.weekdaysOrdered[n];
        }
      };
    }
  } else if (axis instanceof scout.NumberColumn) {
    keyAxis.norm = function(f) {
      if (isNaN(f) || f === null || f === '') {
        return null;
      } else {
        return parseFloat(f);
      }
    };
    keyAxis.format = function(n) {
      if (isNaN(n) || n === null) {
        return emptyCell;
      } else {
        return axis.decimalFormat.format(n);
      }
    };
  } else if (axis instanceof scout.BooleanColumn) {
    keyAxis.norm = function(f) {
      if (!f) {
        return 0;
      } else {
        return 1;
      }
    };
    keyAxis.format = function(n) {
      if (n === 0) {
        return getText('ui.BooleanColumnGroupingFalse');
      } else {
        return getText('ui.BooleanColumnGroupingTrue');
      }
    };
  } else if (axis instanceof scout.IconColumn) {
    keyAxis.textIsIcon = true;
  } else {
    keyAxis.reorder = function() {
      var comparator = scout.comparators.TEXT;
      comparator.install(session);

      keyAxis.sort(function(a, b) {
        // make sure -empty- is at the bottom
        if (a === null) {
          return 1;
        }
        if (b === null) {
          return -1;
        }
        // sort others
        return comparator.compare(keyAxis.format(a), keyAxis.format(b));
      });
    };
  }

  return keyAxis;
};

/**
 * @returns a cube containing the results
 */
scout.TableMatrix.prototype.calculate = function() {
  var cube = {},
    r, v, k, data, key, normData, normKey;

  // collect data from table
  for (r = 0; r < this._rows.length; r++) {
    var row = this._rows[r];
    // collect keys of x, y axis from row
    var keys = [];
    for (k = 0; k < this._allAxis.length; k++) {
      var column = this._allAxis[k].column;
      key = column.cellValueForGrouping(row);
      normKey = this._allAxis[k].norm(key);

      if (normKey !== undefined) {
        this._allAxis[k].add(normKey);
        keys.push(normKey);
      }
    }
    keys = JSON.stringify(keys);

    // collect values of data axis from row
    var values = [];
    for (v = 0; v < this._allData.length; v++) {
      data = this._table.cellValue(this._allData[v].column, row);
      normData = this._allData[v].norm(data);
      if (normData !== undefined) {
        values.push(normData);
      }
    }

    // build cube
    if (cube[keys]) {
      cube[keys].push(values);
    } else {
      cube[keys] = [values];
    }
  }

  // group values and find sum, min and max of data axis
  for (v = 0; v < this._allData.length; v++) {
    data = this._allData[v];

    data.total = 0;
    data.min = null;
    data.max = null;

    for (k in cube) {
      if (cube.hasOwnProperty(k)) {
        var allCell = cube[k],
          subCell = [];

        for (var i = 0; i < allCell.length; i++) {
          subCell.push(allCell[i][v]);
        }

        var newValue = this._allData[v].group(subCell);
        cube[k][v] = newValue;
        data.total += newValue;

        if (newValue === null) {
          continue;
        }

        if (newValue < data.min || data.min === null) {
          data.min = newValue;
        }
        if (newValue > data.max || data.min === null) {
          data.max = newValue;
        }
      }
    }

    //To calculate correct y axis scale data.max must not be 0. If data.max===0-> log(data.max)=-infinity
    if(scout.nvl(data.max, 0)===0){
      data.max = 0.1;
    }

      var f = Math.ceil(Math.log(data.max) / Math.LN10) - 1;

      data.max = Math.ceil(data.max / Math.pow(10, f)) * Math.pow(10, f);
      data.max = Math.ceil(data.max / 4) * 4;

  }

  // find dimensions and sort for x, y axis
  for (k = 0; k < this._allAxis.length; k++) {
    key = this._allAxis[k];

    key.min = Math.min.apply(null, key);
    key.max = Math.max.apply(null, key);

    // null value should be handeld as first value (in charts)
    if (key.indexOf(null) > -1) {
      key.max = key.max + 1;
    }

    key.reorder();
  }

  // access function used by chart
  cube.getValue = function(keys) {
    keys = JSON.stringify(keys);

    if (cube.hasOwnProperty(keys)) {
      return cube[keys];
    } else {
      return null;
    }
  };

  return cube;
};

scout.TableMatrix.prototype.columnCount = function() {
  var colCount = [];

  var count = 0;
  for (var c = 0; c < this._columns.length; c++) {
    var column = this._columns[c];
    if (column instanceof scout.NumberColumn){
      continue;
    }
    colCount.push([column, []]);

    for (var r = 0; r < this._rows.length; r++) {
      var row = this._rows[r];
      var v = this._table.cellValue(column, row);
      if (colCount[count][1].indexOf(v) === -1) {
        colCount[count][1].push(v);
      }
    }

    colCount[count][1] = colCount[count][1].length;
    count++;
  }
  return colCount;
};

scout.TableMatrix.prototype.isEmpty = function() {
  return this._rows.length === 0 || this._columns.length === 0;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableFooter = function() {
  scout.TableFooter.parent.call(this);

  this._tableRowsChangedHandler = this._onTableRowsChanged.bind(this);
  this._tableRowsFilteredHandler = this._onTableRowsFiltered.bind(this);
  this._tableAddFilterHandler = this._onTableAddFilter.bind(this);
  this._tableRemoveFilterHandler = this._onTableRemoveFilter.bind(this);
  this._tableRowsSelectedHandler = this._onTableRowsSelected.bind(this);
  this._tableStatusChangedHandler = this._onTableStatusChanged.bind(this);
  this._tableColumnStructureChangedHandler = this._onColumnStructureChanged.bind(this);
};
scout.inherits(scout.TableFooter, scout.Widget);

scout.TableFooter.prototype._init = function(options) {
  scout.TableFooter.parent.prototype._init.call(this, options);
  this.table = options.table;

  // Keystroke context for the search field.
  // TODO [5.2] dwi: migrate search-field to widget, so that this keystroke code is not in table footer class anymore.
  this.searchFieldKeyStrokeContext = new scout.InputFieldKeyStrokeContext();
  this.searchFieldKeyStrokeContext.$bindTarget = function() {
    return this._$textFilter;
  }.bind(this);
  this.searchFieldKeyStrokeContext.$scopeTarget = function() {
    return this._$textFilter;
  }.bind(this);
};

scout.TableFooter.prototype._render = function($parent) {
  var filter;
  $parent = $parent || this.table.$container;

  this.$container = $parent.appendDiv('table-footer');
  this._$window = $parent.window();
  this._$body = $parent.body();

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.TableFooterLayout(this));

  // --- container for an open control ---
  this.$controlContainer = this.$container.appendDiv('table-control-container').hide();
  this.$controlContent = this.$controlContainer.appendDiv('table-control-content');

  // --- table controls section ---
  this._$controls = this.$container.appendDiv('table-controls');

  // --- info section ---
  this._$info = this.$container.appendDiv('table-info');

  // text filter
  this._$textFilter = scout.fields.makeTextField($parent, 'table-text-filter')
    .appendTo(this._$info)
    .on('input', '', this._onFilterInput.bind(this))
    .on('input', '', $.debounce(this._onFilterInputDebounce.bind(this)))
    .placeholder(this.session.text('ui.FilterBy_'));
  filter = this.table.getFilter(scout.TableTextUserFilter.Type);
  if (filter) {
    this._$textFilter.val(filter.text);
  }

  // load info ("X rows loaded, click to reload")
  this._$infoLoad = this._$info
    .appendDiv('table-info-item table-info-load')
    .on('click', '', this._onInfoLoadClick.bind(this));

  // filter info ("X rows filtered by Y, click to remove filter")
  this._$infoFilter = this._$info
    .appendDiv('table-info-item table-info-filter')
    .on('click', '', this._onInfoFilterClick.bind(this));

  // selection info ("X rows selected, click to select all/none")
  this._$infoSelection = this._$info
    .appendDiv('table-info-item table-info-selection')
    .on('click', '', this._onInfoSelectionClick.bind(this));

  // table status
  this._$infoTableStatus = this._$info
    .appendDiv('table-info-item table-info-status')
    .on('mousedown', this._onStatusMousedown.bind(this));
  this._$infoTableStatusIcon = this._$infoTableStatus
    .appendSpan('font-icon icon');

  // ------

  this._renderControls();
  this._renderInfo();
  this._updateInfoVisibility();

  this.table.on('rowsInserted', this._tableRowsChangedHandler);
  this.table.on('rowsDeleted', this._tableRowsChangedHandler);
  this.table.on('allRowsDeleted', this._tableRowsChangedHandler);
  this.table.on('rowsFiltered', this._tableRowsFilteredHandler);
  this.table.on('addFilter', this._tableAddFilterHandler);
  this.table.on('removeFilter', this._tableRemoveFilterHandler);
  this.table.on('rowsSelected', this._tableRowsSelectedHandler);
  this.table.on('statusChanged', this._tableStatusChangedHandler);
  this.table.on('columnStructureChanged', this._tableColumnStructureChangedHandler);

  this.session.keyStrokeManager.installKeyStrokeContext(this.searchFieldKeyStrokeContext);
};

scout.TableFooter.prototype._remove = function() {
  this.session.keyStrokeManager.uninstallKeyStrokeContext(this.searchFieldKeyStrokeContext);
  this._hideTableStatusTooltip();
  this.$resizer = null;
  this.open = false;

  this.table.off('rowsInserted', this._tableRowsChangedHandler);
  this.table.off('rowsDeleted', this._tableRowsChangedHandler);
  this.table.off('allRowsDeleted', this._tableRowsChangedHandler);
  this.table.off('rowsFiltered', this._tableRowsFilteredHandler);
  this.table.off('addFilter', this._tableAddFilterHandler);
  this.table.off('removeFilter', this._tableRemoveFilterHandler);
  this.table.off('rowsSelected', this._tableRowsSelectedHandler);
  this.table.off('statusChanged', this._tableStatusChangedHandler);
  this.table.off('columnStructureChanged', this._tableColumnStructureChangedHandler);

  scout.TableFooter.parent.prototype._remove.call(this);
};

scout.TableFooter.prototype._renderResizerVisible = function() {
  if (this.selectedControl.resizerVisible) {
    this._renderResizer();
    this.$controlContainer.addClass('has-resizer');
  } else if (this.$resizer) {
    this.$resizer.remove();
    this.$resizer = null;
    this.$controlContainer.removeClass('has-resizer');
  }
};

scout.TableFooter.prototype._renderResizer = function() {
  if (this.$resizer) {
    return;
  }
  this.$resizer = this.$controlContainer.prependDiv('table-control-resize')
    .on('mousedown', '', resize.bind(this));

  function resize(event) {
    // Remember current height and start position
    var startHeight = this.$controlContainer.height(),
      startX = Math.floor(event.pageY);
    this._$window
      .on('mousemove.tablefooter', resizeMove.bind(this))
      .one('mouseup', resizeEnd.bind(this));
    this._$body.addClass('row-resize');

    function resizeMove(event) {
      if (!this.rendered) {
        // footer may be removed in the meantime
        return;
      }
      // Calculate position delta
      var x = Math.floor(event.pageY);
      var dx = x - startX;
      // Ensure control container does not get bigger than the table
      var maxHeight = this.table.$container.height() - this.table.footer.$container.height();
      // Calculate new height of table control container
      var newHeight = Math.min(startHeight - dx, maxHeight);

      this.$controlContainer.height(newHeight);
      this.$controlContent.outerHeight(newHeight);
      this._revalidateTableLayout();
    }

    function resizeEnd() {
      if (this.rendered && this.$controlContainer.height() < 100) {
        this.selectedControl.setSelected(false);
      }

      this._$window.off('mousemove.tablefooter');
      this._$body.removeClass('row-resize');
    }

    return false;
  }
};

scout.TableFooter.prototype._renderControls = function() {
  var controls = this.table.tableControls;
  if (controls) {
    controls.forEach(function(control) {
      control.setParent(this);
      control.render(this._$controls);
    }.bind(this));
  } else {
    this._$controls.empty();
  }
};

scout.TableFooter.prototype._renderInfo = function() {
  this._renderInfoLoad();
  this._renderInfoTableStatus();
  this._renderInfoFilter();
  this._renderInfoSelection();
};

scout.TableFooter.prototype._renderInfoLoad = function() {
  var $info = this._$infoLoad,
    numRows = this.table.rows.length;

  $info.empty();
  if (!this._compactStyle) {
    $info.appendSpan().text(this.session.text('ui.NumRowsLoaded', this.computeCountInfo(numRows)));
    if (this.table.hasReloadHandler) {
      $info.appendBr();
      $info.appendSpan('table-info-button').text(this.session.text('ui.ReloadData')).appendTo($info);
    }
  } else {
    $info.appendSpan().text(this.session.text('ui.NumRowsLoadedMin'));
    $info.appendBr();
    $info.appendSpan('table-info-button').text(this.computeCountInfo(numRows));
  }
  $info.setEnabled(this.table.hasReloadHandler);

  if (!this.htmlComp.layouting) {
    this.invalidateLayoutTree(false);
  }
};

scout.TableFooter.prototype._renderInfoFilter = function() {
  var $info = this._$infoFilter;
  var numRowsFiltered = this.table.filteredRows().length;
  var filteredBy = this.table.filteredBy().join(', '); // filteredBy() returns an array

  $info.empty();
  if (!this._compactStyle) {
    if (filteredBy) {
      $info.appendSpan().text(this.session.text('ui.NumRowsFilteredBy', this.computeCountInfo(numRowsFiltered), filteredBy));
    } else {
      $info.appendSpan().text(this.session.text('ui.NumRowsFiltered', this.computeCountInfo(numRowsFiltered)));
    }
    $info.appendBr();
    $info.appendSpan('table-info-button').text(this.session.text('ui.RemoveFilter')).appendTo($info);
  } else {
    $info.appendSpan().text(this.session.text('ui.NumRowsFilteredMin'));
    $info.appendBr();
    $info.appendSpan('table-info-button').text(this.computeCountInfo(numRowsFiltered));
  }

  if (!this.htmlComp.layouting) {
    this.invalidateLayoutTree(false);
  }
};

scout.TableFooter.prototype._renderInfoSelection = function() {
  var $info = this._$infoSelection,
    numRows = this.table.filteredRows().length,
    numRowsSelected = this.table.selectedRows.length,
    all = numRows > 0 && numRows === numRowsSelected;

  $info.empty();
  if (!this._compactStyle) {
    $info.appendSpan().text(this.session.text('ui.NumRowsSelected', this.computeCountInfo(numRowsSelected)));
    $info.appendBr();
    $info.appendSpan('table-info-button').text(this.session.text(all ? 'ui.SelectNone' : 'ui.SelectAll')).appendTo($info);
  } else {
    $info.appendSpan().text(this.session.text('ui.NumRowsSelectedMin'));
    $info.appendBr();
    $info.appendSpan('table-info-button').text(this.computeCountInfo(numRowsSelected));
  }

  if (!this.htmlComp.layouting) {
    this.invalidateLayoutTree(false);
  }
};

scout.TableFooter.prototype._renderInfoTableStatus = function() {
  var $info = this._$infoTableStatus;
  var tableStatus = this.table.tableStatus;
  $info.removeClass(scout.Status.cssClasses);
  if (tableStatus) {
    $info.addClass(tableStatus.cssClass());
  }

  if (!this.htmlComp.layouting) {
    this.invalidateLayoutTree(false);
  }
};

scout.TableFooter.prototype._updateInfoVisibility = function() {
  this._updateInfoFilterVisibility();
  this._updateInfoSelectionVisibility();
  this._updateInfoTableStatusVisibility();
};

scout.TableFooter.prototype._updateInfoFilterVisibility = function() {
  var visible = this.table.filteredBy().length > 0;
  this._setInfoVisible(this._$infoFilter, visible);
};

scout.TableFooter.prototype._updateInfoSelectionVisibility = function() {
  var visible = this.table.multiSelect;
  this._setInfoVisible(this._$infoSelection, visible);
};

scout.TableFooter.prototype._updateInfoTableStatusVisibility = function() {
  var visible = this.table.tableStatus;
  if (visible) {
    // If the uiState of the tableStatus was not set to hidden (either manually by the
    // user or automatically by a timeout or other event), show the tooltip when the
    // "info visible" animation has finished. Otherwise, we don't show the tooltip to
    // not disturb the user.
    var complete = null;
    if (!scout.isOneOf(this.table.tableStatus.uiState, 'user-hidden', 'auto-hidden')) {
      this._$infoTableStatus.addClass('tooltip-active'); // color icon before animation starts
      complete = function() {
        // Same check is required again, because this function is called asynchronously
        if (this.table.tableStatus && !scout.isOneOf(this.table.tableStatus.uiState, 'user-hidden', 'auto-hidden')) {
          this._showTableStatusTooltip();
        }
      }.bind(this);
    }
    this._setInfoVisible(this._$infoTableStatus, true, complete);
  } else {
    this._hideTableStatusTooltip();
    this._setInfoVisible(this._$infoTableStatus, false);
  }
};

scout.TableFooter.prototype._setInfoVisible = function($info, visible, complete) {
  if ($info.isVisible() === visible && !(visible && $info.data('hiding'))) {
    if (complete) {
      complete();
    }
    return;
  }
  var animate = this.rendered; // Animate only on a user interaction, no while the table gets rendered
  if (!animate) {
    $info.setVisible(visible);
    return;
  }
  if (visible) {
    var animationOpts = {
      progress: this.revalidateLayout.bind(this),
      complete: function() {
        if (complete) {
          complete();
        }
      }.bind(this)
    };
    // Save complete function so that layout may use it
    $info.data('animationComplete', animationOpts.complete);
    // If info is shown the first time, set the width to 0 to make animation work
    if ($info[0].style.width === '') {
      $info.cssWidth(0);
    }
    $info.show().stop().widthToContent(animationOpts);
  } else {
    // Mark element as hiding so that the layout does not try to resize it
    $info.data('hiding', true);
    $info.stop().animate({
      width: 0
    }, {
      progress: this.revalidateLayout.bind(this),
      complete: function() {
        $info.removeData('hiding');
        $info.hide();
      }
    });
  }
};

scout.TableFooter.prototype._toggleTableInfoTooltip = function($info, tooltipType) {
  if (this._tableInfoTooltip) {
    this._tableInfoTooltip.destroy();
  } else {
    this._tableInfoTooltip = scout.create(tooltipType, {
      parent: this,
      tableFooter: this,
      cssClass: 'table-info-tooltip',
      arrowPosition: 50,
      arrowPositionUnit: '%',
      $anchor: $info
    });
    this._tableInfoTooltip.one('destroy', function() {
      this._tableInfoTooltip = null;
    }.bind(this));
    this._tableInfoTooltip.render();
  }
};

scout.TableFooter.prototype.computeCountInfo = function(n) {
  if (scout.nvl(n, 0) === 0) {
    if (this._compactStyle) {
      return this.session.text('ui.TableRowCount', 0);
    } else {
      return this.session.text('ui.TableRowCount0');
    }
  } else if (n === 1) {
    return this.session.text('ui.TableRowCount1');
  } else {
    return this.session.text('ui.TableRowCount', n);
  }
};

/* open, close and resize of the container */

scout.TableFooter.prototype._revalidateTableLayout = function() {
  this.table.htmlComp.revalidateLayoutTree();
};

scout.TableFooter.prototype.openControlContainer = function(control) {
  if (this.open) {
    // Calling open again may resize the container -> don't return
  }
  this.opening = true;
  this.open = true;

  var insets = scout.graphics.getInsets(this.$controlContainer),
    contentHeight = control.height - insets.top - insets.bottom;

  this.$controlContent.outerHeight(contentHeight);

  // If container is opened the first time, set the height to 0 to make animation work
  if (this.$controlContainer[0].style.height === '') {
    this.$controlContainer.outerHeight(0);
  }

  if (this.$controlContainer.outerHeight() > control.height) {
    // Container gets smaller -> layout first to prevent having a white area
    this.table.invalidateLayoutTree();
  }

  // open container, stop existing (close) animations before
  // use delay to make sure form is rendered and layouted with new size
  this.$controlContainer.stop(true).show().delay(1).animate({
    height: control.height
  }, {
    duration: this.rendered ? control.animateDuration : 0,
    complete: function() {
      this.opening = false;
      control.onControlContainerOpened();
      this.table.invalidateLayoutTree();
    }.bind(this)
  });
};

scout.TableFooter.prototype.closeControlContainer = function(control) {
  if (!this.open) {
    return;
  }
  this.open = false;
  this.opening = false;
  this.table.invalidateLayoutTree();

  this.$controlContainer.stop(true).show().animate({
    height: 0
  }, {
    duration: control.animateDuration,
    done: function() {
      this.$controlContainer.hide();
      control.onControlContainerClosed();
    }.bind(this)
  });
};

scout.TableFooter.prototype._hideTableStatusTooltip = function() {
  clearTimeout(this._autoHideTableStatusTooltipTimeoutId);
  if (this._tableStatusTooltip) {
    this._tableStatusTooltip.destroy();
  }
};

scout.TableFooter.prototype._showTableStatusTooltip = function() {
  // Remove existing tooltip (might have the wrong css class)
  if (this._tableStatusTooltip) {
    this._tableStatusTooltip.destroy();
  }

  var tableStatus = this.table.tableStatus;
  var text = (tableStatus ? tableStatus.message : null);
  if (scout.strings.empty(text)) {
    return; // Refuse to show empty tooltip
  }

  // Create new tooltip
  var opts = {
    parent: this,
    text: text,
    severity: tableStatus.severity,
    autoRemove: !tableStatus.isError(),
    $anchor: this._$infoTableStatusIcon
  };
  this._tableStatusTooltip = scout.create('Tooltip', opts);
  this._tableStatusTooltip.one('destroy', function() {
    this._tableStatusTooltip = null;
  }.bind(this));
  this._tableStatusTooltip.render();

  // Adjust icon style
  this._$infoTableStatus.addClass('tooltip-active');
  this._tableStatusTooltip.on('remove', function() {
    this._$infoTableStatus.removeClass('tooltip-active');
    // When the tooltip is removed (e.g. because of the auto-remove timeout, or
    // The user clicked somewhere) set the uiStatus accordingly. Otherwise, it
    // might pop up again when the table layout is revalidated.
    clearTimeout(this._autoHideTableStatusTooltipTimeoutId);
    if (this.table.tableStatus && !this.table.tableStatus.isError()) {
      this.table.tableStatus.uiState = 'auto-hidden';
    }
  }.bind(this));

  // Auto-hide unimportant messages
  clearTimeout(this._autoHideTableStatusTooltipTimeoutId);
  if (!tableStatus.isError() && !this.table.tableStatus.uiState) {
    // Already set status to 'auto-hidden', in case the user changes outline before timeout elapses
    this.table.tableStatus.uiState = 'auto-hidden';
    this._autoHideTableStatusTooltipTimeoutId = setTimeout(function() {
      this._hideTableStatusTooltip();
    }.bind(this), 5000);
  }
};

scout.TableFooter.prototype.onControlSelected = function(control) {
  var previousControl = this.selectedControl;
  this.selectedControl = control;

  if (control) {
    this._renderResizerVisible();
    if (previousControl && previousControl.height !== control.height) {
      this.openControlContainer(control);
    }
  }
};

scout.TableFooter.prototype._onStatusMousedown = function(event) {
  // Toggle tooltip
  if (this._tableStatusTooltip) {
    this._hideTableStatusTooltip();
    this.table.tableStatus.uiState = 'user-hidden';
  } else {
    this._showTableStatusTooltip();
    if (this._tableStatusTooltip.rendered) {
      this.table.tableStatus.uiState = 'user-shown';
    }
  }
};

scout.TableFooter.prototype._onFilterInput = function(event) {
  var $input = $(event.currentTarget),
    filterText = $input.val();

  if (!filterText) {
    return;
  }
  $input.val(filterText.toLowerCase());
};

scout.TableFooter.prototype._onFilterInputDebounce = function(event) {
  var filter,
    $input = $(event.currentTarget),
    filterText = $input.val();

  if (filterText) {
    filter = scout.create('TableTextUserFilter', {
      session: this.session,
      table: this.table
    });

    filter.text = filterText;
    this.table.addFilter(filter);
  } else {
    this.table.removeFilterByKey(scout.TableTextUserFilter.Type);
  }

  this.table.filter();
  this.validateLayoutTree();
  event.stopPropagation();
};

scout.TableFooter.prototype._onInfoLoadClick = function() {
  if (!this._$infoLoad.isEnabled()) {
    return;
  }
  if (this._compactStyle) {
    this._toggleTableInfoTooltip(this._$infoLoad, 'TableInfoLoadTooltip');
  } else {
    this.table.reload();
  }
};

scout.TableFooter.prototype._onInfoFilterClick = function() {
  if (this._compactStyle) {
    this._toggleTableInfoTooltip(this._$infoFilter, 'TableInfoFilterTooltip');
  } else {
    this.table.resetFilter();
  }
};

scout.TableFooter.prototype._onInfoSelectionClick = function() {
  if (this._compactStyle) {
    this._toggleTableInfoTooltip(this._$infoSelection, 'TableInfoSelectionTooltip');
  } else {
    this.table.toggleSelection();
  }
};

scout.TableFooter.prototype._onTableRowsChanged = function(event) {
  this._renderInfoLoad();
};

scout.TableFooter.prototype._onTableRowsFiltered = function(event) {
  this._renderInfoFilter();
  this._renderInfoSelection();
};

scout.TableFooter.prototype._onTableAddFilter = function(event) {
  this._renderInfoFilter();
  this._updateInfoFilterVisibility();
  if (event.filter.filterType === scout.TableTextUserFilter.Type) {
    this._$textFilter.val(event.filter.text);
  }
};

scout.TableFooter.prototype._onTableRemoveFilter = function(event) {
  this._renderInfoFilter();
  this._updateInfoFilterVisibility();
  if (event.filter.filterType === scout.TableTextUserFilter.Type) {
    this._$textFilter.val('');
  }
};

scout.TableFooter.prototype._onTableRowsSelected = function(event) {
  this._renderInfoSelection();
};

scout.TableFooter.prototype._onTableStatusChanged = function(event) {
  this._renderInfoTableStatus();
  this._updateInfoTableStatusVisibility();
};

scout.TableFooter.prototype._onColumnStructureChanged = function(event) {
  var controls = this.table.tableControls;
  if (controls) {
    controls.forEach(function(control) {
      if (control.selected) {
        control.removeContent();
        control.renderContent();
      }
    }.bind(this));
  } else {
    this._$controls.empty();
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableFooterLayout = function(tableFooter) {
  scout.TableFooterLayout.parent.call(this);
  this._tableFooter = tableFooter;
};
scout.inherits(scout.TableFooterLayout, scout.AbstractLayout);

/**
 * @override
 */
scout.TableFooterLayout.prototype.layout = function($container) {
  var contentFits, controlsWidth, infoWidth,
    $controls = this._tableFooter._$controls,
    $info = this._tableFooter._$info,
    $infoItems = $info.find('.table-info-item'),
    containerWidth = scout.graphics.getSize($container).width;

  controlsWidth = scout.graphics.getSize($controls).width;
  infoWidth = scout.graphics.getSize($info).width;

  // Remove width to make sure elements are as width as they want to be
  $infoItems.each(function() {
    var $item = $(this);
    // Do not touch items which are being hidden to make sure they can properly animate width to 0
    if ($item.isVisible() && !$item.data('hiding')) {
      $item.data('oldWidth', $item.outerWidth());
      $item.css('width', 'auto');
    }
  });
  $info.css('max-width', '');

  // Always try to use max space first
  if (this._tableFooter._compactStyle) {
    this._tableFooter._compactStyle = false;
    this._tableFooter._renderInfo();
  }
  infoWidth = scout.graphics.getSize($info).width;
  if (controlsWidth + infoWidth <= containerWidth) {
    // Make sure table info tooltip is not shown anymore (only available in compact style)
    if (this._tableFooter._tableInfoTooltip) {
      this._tableFooter._tableInfoTooltip.destroy();
    }
    contentFits = true;
  }

  if (!contentFits) {
    // If elements don't fit, try to minimize table-info
    this._tableFooter._compactStyle = true;
    this._tableFooter._renderInfo();

    infoWidth = scout.graphics.getSize($info).width;
    if (controlsWidth + infoWidth <= containerWidth) {
      contentFits = true;
    }
    // Make sure info section does not overlap controls
    $info.css('max-width', Math.max(containerWidth - controlsWidth, 0));
  }

  // don't animate on the first layouting -> only animate on user interactions
  var animated = this._tableFooter.htmlComp.layouted;
  this._setInfoItemsSize($infoItems, animated);

  if (this._tableFooter._tableStatusTooltip && this._tableFooter._tableStatusTooltip.rendered) {
    this._tableFooter._tableStatusTooltip.position();
  }
  if (this._tableFooter._tableInfoTooltip && this._tableFooter._tableInfoTooltip.rendered) {
    this._tableFooter._tableInfoTooltip.position();
  }

  // Let table controls update their content according to the new footer size
  this._tableFooter.table.tableControls.forEach(function(control) {
    control.revalidateLayout();
  });
};

scout.TableFooterLayout.prototype._setInfoItemsSize = function($infoItems, animated) {
  $infoItems.each(function() {
    var $item = $(this);
    if ($item.isVisible() && !$item.data('hiding')) {
      // Make sure complete function of already scheduled animation will be executed
      var existingComplete = $item.data('animationComplete');
      if (animated) {
        $item.stop().cssWidthAnimated($item.data('oldWidth'), $item.outerWidth(), {
          complete: existingComplete
        });
        $item.removeData('oldWidth');
      } else {
        $item.cssWidth($item.outerWidth());
      }
    }
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableInfoFilterTooltip = function() {
  scout.TableInfoFilterTooltip.parent.call(this);
};
scout.inherits(scout.TableInfoFilterTooltip, scout.Tooltip);

scout.TableInfoFilterTooltip.prototype._init = function(options) {
  scout.TableInfoFilterTooltip.parent.prototype._init.call(this, options);

  this.tableFooter = options.tableFooter;
};

scout.TableInfoFilterTooltip.prototype._renderText = function() {
  var table = this.tableFooter.table,
    numRowsFiltered = table.filteredRows().length,
    filteredBy = table.filteredBy().join(', '); // filteredBy() returns an array

  this.$content.appendSpan()
    .text(this.session.text('ui.NumRowsFilteredBy', this.tableFooter.computeCountInfo(numRowsFiltered), filteredBy));
  this.$content.appendBr();
  this.$content.appendSpan('link')
    .text(this.session.text('ui.RemoveFilter'))
    .on('click', this._onRemoveFilterClick.bind(this));
};

scout.TableInfoFilterTooltip.prototype._onRemoveFilterClick = function() {
  this.tableFooter.table.resetFilter();
  this.destroy();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableInfoLoadTooltip = function() {
  scout.TableInfoLoadTooltip.parent.call(this);
};
scout.inherits(scout.TableInfoLoadTooltip, scout.Tooltip);

scout.TableInfoLoadTooltip.prototype._init = function(options) {
  scout.TableInfoLoadTooltip.parent.prototype._init.call(this, options);

  this.tableFooter = options.tableFooter;
};

scout.TableInfoLoadTooltip.prototype._renderText = function() {
  var table = this.tableFooter.table,
    numRows = table.rows.length;

  this.$content.appendSpan().text(this.session.text('ui.NumRowsLoaded', this.tableFooter.computeCountInfo(numRows)));
  this.$content.appendBr();
  this.$content.appendSpan('link')
    .text(this.session.text('ui.ReloadData'))
    .on('click', this._onReloadClick.bind(this));
};

scout.TableInfoLoadTooltip.prototype._onReloadClick = function() {
  this.tableFooter.table.reload();
  this.destroy();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableInfoSelectionTooltip = function() {
  scout.TableInfoSelectionTooltip.parent.call(this);
};
scout.inherits(scout.TableInfoSelectionTooltip, scout.Tooltip);

scout.TableInfoSelectionTooltip.prototype._init = function(options) {
  scout.TableInfoSelectionTooltip.parent.prototype._init.call(this, options);

  this.tableFooter = options.tableFooter;
};

scout.TableInfoSelectionTooltip.prototype._renderText = function() {
  var table = this.tableFooter.table,
    numRowsSelected = table.selectedRows.length;

  this.$content.appendSpan().text(this.session.text('ui.NumRowsSelected', this.tableFooter.computeCountInfo(numRowsSelected)));
  this.$content.appendBr();
  this.$content.appendSpan('link')
    .text(this.session.text('ui.SelectNone'))
    .on('click', this._onSelectNoneClick.bind(this));
  this.$content.appendBr();
  this.$content.appendSpan('link')
    .text(this.session.text('ui.SelectAll'))
    .on('click', this._onSelectAllClick.bind(this));
};

scout.TableInfoSelectionTooltip.prototype._onSelectNoneClick = function() {
  this.tableFooter.table.deselectAll();
  this.destroy();
};

scout.TableInfoSelectionTooltip.prototype._onSelectAllClick = function() {
  this.tableFooter.table.selectAll();
  this.destroy();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableHeader = function() {
  scout.TableHeader.parent.call(this);

  this._tableDataScrollHandler = this._onTableDataScroll.bind(this);
  this._tableAddRemoveFilterHandler = this._onTableAddRemoveFilter.bind(this);
  this._tableColumnResizedHandler = this._onTableColumnResized.bind(this);
  this._tableColumnMovedHandler = this._onTableColumnMoved.bind(this);
  this.dragging = false;
  this._renderedColumns = [];
};
scout.inherits(scout.TableHeader, scout.Widget);

scout.TableHeader.prototype._init = function(options) {
  scout.TableHeader.parent.prototype._init.call(this, options);

  this.table = options.table;
  this.enabled = options.enabled;
  this.menuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.GroupBoxMenuItemsOrder()
  });
  this.menuBar.tabbable = false;
  this.menuBar.bottom();
  this.menuBar.on('propertyChange', this._onMenuBarPropertyChange.bind(this));
  this.updateMenuBar();
};

scout.TableHeader.prototype._render = function($parent) {
  this.$container = this.table.$data.beforeDiv('table-header');

  // Filler is necessary to make sure the header is always as large as the table data, otherwise horizontal scrolling does not work correctly
  this.$filler = this.$container.appendDiv('table-header-item filler').css('visibility', 'hidden');

  if (!this.enabled) {
    this.menuBar.hiddenByUi = true;
  }
  // Required to make "height: 100%" rule work. menuBarContainer and menuBar itself must have the same visibility.
  // Otherwise they could cover the sorting/filter icons on the table-header of the column.
  this.$menuBarContainer = this.$container.appendDiv('menubar-container');
  this.$menuBarContainer.setVisible(this.menuBar.visible);
  this.menuBar.render(this.$menuBarContainer);
  this._$window = this.$container.window();
  this._$body = this.$container.body();

  this._renderColumns();

  this.table.$data.on('scroll', this._tableDataScrollHandler);
  this.table.on('addFilter', this._tableAddRemoveFilterHandler);
  this.table.on('removeFilter', this._tableAddRemoveFilterHandler);
  this.table.on('columnResized', this._tableColumnResizedHandler);
  this.table.on('columnMoved', this._tableColumnMovedHandler);
};

scout.TableHeader.prototype._remove = function() {
  this.table.$data.off('scroll', this._tableDataScrollHandler);
  this.table.off('addFilter', this._tableAddRemoveFilterHandler);
  this.table.off('removeFilter', this._tableAddRemoveFilterHandler);
  this.table.off('columnResized', this._tableColumnResizedHandler);
  this.table.off('columnMoved', this._tableColumnMovedHandler);

  this._removeColumns();

  scout.TableHeader.parent.prototype._remove.call(this);
};

scout.TableHeader.prototype.rerenderColumns = function() {
  this._removeColumns();
  this._renderColumns();
};

scout.TableHeader.prototype._renderColumns = function() {
  this.table.columns.forEach(this._renderColumn, this);
  if (this.table.columns.length === 0) {
    // If there are no columns, make the filler visible and make sure the header is as large as normally using nbsp
    this.$filler.css('visibility', 'visible').html('&nbsp;').addClass('empty');
  }
  this._reconcileScrollPos();
};

scout.TableHeader.prototype._renderColumn = function(column, index) {
  var columnWidth = column.width,
    marginLeft = '',
    marginRight = '',
    isFirstColumn = (index === 0),
    isLastColumn = (index === this.table.columns.length - 1);

  if (isFirstColumn) {
    marginLeft = this.table.rowBorderLeftWidth;
  } else if (isLastColumn) {
    marginRight = this.table.rowBorderRightWidth;
  }

  var $header = this.$filler.beforeDiv('table-header-item')
    .setEnabled(this.enabled)
    .data('column', column)
    .css('min-width', columnWidth + 'px')
    .css('max-width', columnWidth + 'px')
    .css('margin-left', marginLeft)
    .css('margin-right', marginRight);
  $header.appendSpan('table-header-item-text');
  if (this.enabled) {
    $header
      .on('click', this._onHeaderItemClick.bind(this))
      .on('mousedown', this._onHeaderItemMousedown.bind(this));
  }

  if (this.session.inspector) {
    scout.inspector.applyInfo(column, $header);
  }

  if (isFirstColumn) {
    $header.addClass('first');
  } else if (isLastColumn) {
    $header.addClass('last');
  }

  column.$header = $header;

  scout.tooltips.install($header, {
    parent: this,
    text: this._headerItemTooltipText.bind(this),
    arrowPosition: 50,
    arrowPositionUnit: '%',
    nativeTooltip: !scout.device.isCustomEllipsisTooltipPossible()
  });

  this._decorateHeader(column);
  $header.addClass('halign-' + scout.Table.parseHorizontalAlignment(column.horizontalAlignment));

  var showSeparator = column.showSeparator;
  if (isLastColumn && !this.enabled) {
    showSeparator = false;
  }
  if (showSeparator) {
    var $separator = this.$filler.beforeDiv('table-header-resize');
    if (column.fixedWidth || !this.enabled) {
      $separator.setEnabled(false);
    } else {
      $separator.on('mousedown', '', this._onSeparatorMousedown.bind(this)).
      on('dblclick', this._onSeparatorDblclick.bind(this));
    }
    column.$separator = $separator;
  }
  this._renderedColumns.push(column);
};

scout.TableHeader.prototype._removeColumns = function() {
  this._renderedColumns.slice().forEach(this._removeColumn, this);
};

scout.TableHeader.prototype._removeColumn = function(column) {
  if (column.$header) {
    column.$header.remove();
    column.$header = null;
  }
  if (column.$separator) {
    column.$separator.remove();
    column.$separator = null;
  }
  scout.arrays.remove(this._renderedColumns, column);
};

scout.TableHeader.prototype.resizeHeaderItem = function(column) {
  if (!column) {
    // May be undefined if there are no columns
    return;
  }
  if (!column.$header) {
    // May be undefined if called when header item is not rendered yet (may caused by _adjustColumnMinWidth)
    return;
  }

  var remainingHeaderSpace, adjustment,
    $header = column.$header,
    $headerResize,
    columnWidth = column.width,
    marginLeft = '',
    marginRight = '',
    menuBarWidth = (this.menuBar.visible ? this.$menuBarContainer.outerWidth(true) : 0),
    isFirstColumn = this.table.columns.indexOf(column) === 0,
    isLastColumn = this.table.columns.indexOf(column) === this.table.columns.length - 1;

  if (isFirstColumn) {
    marginLeft = this.table.rowBorderLeftWidth;
  } else if (isLastColumn) {
    marginRight = this.table.rowBorderRightWidth;
    remainingHeaderSpace = this.$container.width() - this.table.rowWidth + scout.graphics.getInsets(this.table.$data).right;
    $headerResize = $header.next('.table-header-resize');

    if (remainingHeaderSpace < menuBarWidth) {
      adjustment = menuBarWidth;
      adjustment += $headerResize.width();
      if (remainingHeaderSpace > 0) {
        adjustment -= remainingHeaderSpace;
      }

      var origColumnWidth = columnWidth;
      columnWidth = Math.max(columnWidth - adjustment, column.minWidth - adjustment);
      this.$filler.cssWidth(origColumnWidth - columnWidth);
    }
  }

  $header
    .css('min-width', columnWidth)
    .css('max-width', columnWidth)
    .css('margin-left', marginLeft)
    .css('margin-right', marginRight);

  if (this._tableHeaderMenu && this._tableHeaderMenu.rendered && this._tableHeaderMenu.column === column) {
    this._tableHeaderMenu.onColumnResized();
  }
};

scout.TableHeader.prototype._reconcileScrollPos = function() {
  // When scrolling horizontally scroll header as well
  var scrollLeft = this.table.$data.scrollLeft(),
    lastColumn = this.table.columns[this.table.columns.length - 1];

  this.resizeHeaderItem(lastColumn);
  this.$container.scrollLeft(scrollLeft);
  this.$menuBarContainer.cssRight(-1 * scrollLeft);
};

scout.TableHeader.prototype._arrangeHeaderItems = function($headers) {
  var that = this;
  $headers.each(function() {
    // move to old position and then animate
    $(this).css('left', $(this).data('old-pos') - $(this).offset().left)
      .animate({
        left: 0
      }, {
        progress: function(animation, progress, remainingMs) {
          var $headerItem = $(this);
          if (!$headerItem.isSelected()) {
            return;
          }
          // make sure selected header item is visible
          scout.scrollbars.scrollHorizontalTo(that.table.$data, $headerItem);

          // move menu
          if (that._tableHeaderMenu && that._tableHeaderMenu.rendered) {
            that._tableHeaderMenu.position();
          }
        }
      });
  });
};

scout.TableHeader.prototype._headerItemTooltipText = function($col) {
  var column = $col.data('column');
  if (column && scout.strings.hasText(column.headerTooltipText)) {
    return column.headerTooltipText;
  } else if ($col.isContentTruncated() || ($col.width() + $col.position().left) > $col.parent().width()) {
    $col = $col.clone();
    $col.children('.table-header-item-state').remove();
    return $col.text();
  }
};

scout.TableHeader.prototype.openTableHeaderMenu = function(column) {
  var $header = column.$header;
  this._tableHeaderMenu = scout.create('TableHeaderMenu', {
    parent: this,
    column: $header.data('column'),
    tableHeader: this,
    $anchor: $header,
    focusableContainer: true
  });
  this._tableHeaderMenu.open();
};

scout.TableHeader.prototype.closeTableHeaderMenu = function() {
  this._tableHeaderMenu.destroy();
  this._tableHeaderMenu = null;
};

scout.TableHeader.prototype.onColumnActionsChanged = function(event) {
  if (this._tableHeaderMenu) {
    this._tableHeaderMenu.onColumnActionsChanged(event);
  }
};

scout.TableHeader.prototype.findHeaderItems = function() {
  return this.$container.find('.table-header-item:not(.filler)');
};

/**
 * Updates the column headers visualization of the text, sorting and styling state
 */
scout.TableHeader.prototype.updateHeader = function(column, oldColumnState) {
  this._decorateHeader(column, oldColumnState);
};

scout.TableHeader.prototype._decorateHeader = function(column, oldColumnState) {
  var $header = column.$header;
  if (column.disallowHeaderMenu) {
    $header.addClass('disabled');
  }

  this._renderColumnCssClass(column, oldColumnState);
  this._renderColumnText(column);
  this._renderColumnIconId(column);
  this._renderColumnState(column);
  this._renderColumnLegacyStyle(column);
};

scout.TableHeader.prototype._renderColumnCssClass = function(column, oldColumnState) {
  var $header = column.$header;
  if (oldColumnState) {
    $header.removeClass(oldColumnState.headerCssClass);
  }
  $header.addClass(column.headerCssClass);
};

scout.TableHeader.prototype._renderColumnText = function(column) {
  var text = column.text,
    $header = column.$header,
    $headerText = $header.children('.table-header-item-text');

  // Make sure empty header is as height as the others to make it properly clickable
  $headerText.htmlOrNbsp(scout.strings.nl2br(text), 'empty');
  this._updateColumnIconAndTextStyle(column);
};

scout.TableHeader.prototype._renderColumnIconId = function(column) {
  column.$header.icon(column.headerIconId);
  this._updateColumnIconAndTextStyle(column);
};

scout.TableHeader.prototype._updateColumnIconAndTextStyle = function(column) {
  var $icon = column.$header.data('$icon'),
    $text = column.$header.children('.table-header-item-text');

  if ($icon) {
    $icon.toggleClass('with-text', !!column.text);
  }
  // Make text invisible if there is an icon but no text
  $text.setVisible(!($icon && $text.html() === '&nbsp;'));
};

scout.TableHeader.prototype._renderColumnLegacyStyle = function(column) {
  scout.styles.legacyStyle(column, column.$header, 'header');
};

scout.TableHeader.prototype._renderColumnState = function(column) {
  var sortDirection, $state,
    $header = column.$header,
    filtered = this.table.getFilter(column.id);

  $header.children('.table-header-item-state').remove();
  $state = $header.appendSpan('table-header-item-state');
  $state.empty();
  $header.removeClass('sort-asc sort-desc sorted group-asc group-desc grouped filtered');
  $state.removeClass('sort-asc sort-desc sorted group-asc group-desc grouped filtered');

  if (column.sortActive) {
    sortDirection = column.sortAscending ? 'asc' : 'desc';
    if (column.grouped) {
      $header.addClass('group-' + sortDirection);
    }
    $header.addClass('sorted sort-' + sortDirection);
    $state.addClass('sorted sort-' + sortDirection);
  }

  if (column.grouped || filtered) {
    // contains group and filter symbols
    var $left = $state.appendDiv('left');
    if (column.grouped) {
      $header.addClass('grouped');
      $state.addClass('grouped');
      $left.appendDiv().text('G');
    }
    if (filtered) {
      $header.addClass('filtered');
      $state.addClass('filtered');
      $left.appendDiv().text('F');
    }
  }
  // Contains sort arrow
  $state.appendDiv('right');

  this._adjustColumnMinWidth(column);
};

/**
 * Makes sure state is fully visible by adjusting width (happens if column.minWidth is < DEFAULT_MIN_WIDTH)
 */
scout.TableHeader.prototype._adjustColumnMinWidth = function(column) {
  var filtered = this.table.getFilter(column.id);
  if (column.sortActive || column.grouped || filtered) {
    if (column.minWidth < scout.Column.DEFAULT_MIN_WIDTH) {
      column.prefMinWidth = column.minWidth;
      column.minWidth = scout.Column.DEFAULT_MIN_WIDTH;
    }
    if (column.width < column.minWidth) {
      this.table.resizeColumn(column, column.minWidth);
    }
  } else {
    // Reset to preferred min width if no state is visible
    if (column.prefMinWidth) {
      column.minWidth = column.prefMinWidth;
      column.prefMinWidth = null;
      // Resize to old min width, assuming user has not manually changed the size because column is still as width as default_min_width
      if (column.width === scout.Column.DEFAULT_MIN_WIDTH) {
        this.table.resizeColumn(column, column.minWidth);
      }
    }
  }
};

scout.TableHeader.prototype.updateMenuBar = function() {
  var menuItems = this.table._filterMenus(this.table.menus, scout.MenuDestinations.HEADER);
  this.menuBar.setMenuItems(menuItems);
};

scout.TableHeader.prototype._onTableColumnResized = function(event) {
  var column = event.column,
    lastColumn = this.table.columns[this.table.columns.length - 1];
  this.resizeHeaderItem(column);
  if (lastColumn !== column) {
    this.resizeHeaderItem(lastColumn);
  }
};

scout.TableHeader.prototype.onSortingChanged = function() {
  for (var i = 0; i < this.table.columns.length; i++) {
    var column = this.table.columns[i];
    this._renderColumnState(column);
  }
};

scout.TableHeader.prototype._onTableColumnMoved = function(event) {
  var column = event.column,
    oldPos = event.oldPos,
    newPos = event.newPos,
    $header = column.$header,
    $headers = this.findHeaderItems(),
    $moveHeader = $headers.eq(oldPos),
    $moveResize = $moveHeader.next(),
    lastColumnPos = this.table.columns.length - 1;

  // store old position of header
  $headers.each(function() {
    $(this).data('old-pos', $(this).offset().left);
  });

  // change order in dom of header
  if (newPos < oldPos) {
    $headers.eq(newPos).before($moveHeader);
    $headers.eq(newPos).before($moveResize);
  } else {
    $headers.eq(newPos).after($moveHeader);
    $headers.eq(newPos).after($moveResize);
  }

  // Update first/last markers
  if ($headers.length > 0) {
    $headers.eq(0).removeClass('first');
    $headers.eq($headers.length - 1).removeClass('last');
  }
  if (this.table.columns.length > 0) {
    this.table.columns[0].$header.addClass('first');
    this.table.columns[this.table.columns.length - 1].$header.addClass('last');
  }

  // Update header size due to header menu items if moved from or to last position
  if (oldPos === lastColumnPos || newPos === lastColumnPos) {
    this.table.columns.forEach(function(column) {
      this.resizeHeaderItem(column);
    }.bind(this));
  }

  // move to old position and then animate
  if (event.dragged) {
    $header.css('left', parseInt($header.css('left'), 0) + $header.data('old-pos') - $header.offset().left)
      .animateAVCSD('left', 0);
  } else {
    this._arrangeHeaderItems($headers);
  }
};

scout.TableHeader.prototype.onOrderChanged = function(oldColumnOrder) {
  var column, i, $header, $headerResize;
  var $headers = this.findHeaderItems();

  // store old position of headers
  $headers.each(function() {
    $(this).data('old-pos', $(this).offset().left);
  });

  // change order in dom of header
  for (i = 0; i < this.table.columns.length; i++) {
    column = this.table.columns[i];
    $header = column.$header;
    $headerResize = $header.next('.table-header-resize');

    this.$container.append($header);
    this.$container.append($headerResize);
  }

  this._arrangeHeaderItems($headers);
};

scout.TableHeader.prototype._onHeaderItemClick = function(event) {
  var $headerItem = $(event.currentTarget),
    column = $headerItem.data('column');

  if (column.disallowHeaderMenu) {
    return;
  }

  if (this.dragging || this.columnMoved) {
    this.dragging = false;
    this.columnMoved = false;
  } else if (this.table.sortEnabled && (event.shiftKey || event.ctrlKey)) {
    this.table.removeColumnGrouping();
    this.table.sort(column, $headerItem.hasClass('sort-asc') ? 'desc' : 'asc', event.shiftKey);
  } else if (this._tableHeaderMenu && this._tableHeaderMenu.isOpenFor($headerItem)) {
    this.closeTableHeaderMenu();
  } else {
    this.openTableHeaderMenu(column);
  }

  return false;
};

scout.TableHeader.prototype._onHeaderItemMousedown = function(event) {
  var diff = 0,
    that = this,
    startX = Math.floor(event.pageX),
    $header = $(event.currentTarget),
    column = $header.data('column'),
    oldPos = this.table.columns.indexOf(column),
    newPos = oldPos,
    move = $header.outerWidth(),
    $otherHeaders = $header.siblings('.table-header-item:not(.filler)');

  if (column.fixedPosition) {
    // Don't allow moving a column with fixed position
    return;
  }

  this.dragging = false;
  // firefox fires a click action after a column has been droped at the new location, chrome doesn't -> we need a hint to avoid menu gets opened after drop
  this.columnMoved = false;

  // start drag & drop events
  this._$window
    .on('mousemove.tableheader', '', dragMove)
    .one('mouseup', '', dragEnd);

  function dragMove(event) {
    diff = Math.floor(event.pageX) - startX;
    if (diff === 0) {
      return;
    }

    that.dragging = true;

    // change css of dragged header
    $header.addClass('moving');
    that.$container.addClass('moving');

    // move dragged header
    $header.css('left', diff);

    // find other affected headers
    var middle = realMiddle($header);

    $otherHeaders.each(function(i) {
      var m = realMiddle($(this));

      if (middle < m && i < oldPos) {
        $(this).css('left', move);
      } else if (middle > m && i >= oldPos) {
        $(this).css('left', -move);
      } else {
        $(this).css('left', 0);
      }
    });

    if (that._tableHeaderMenu) {
      that._tableHeaderMenu.destroy();
      that._tableHeaderMenu = null;
    }
  }

  function realWidth($div) {
    var html = $div.html(),
      width = $div.html('<span>' + html + '</span>').find('span:first').width();

    $div.html(html);
    return width;
  }

  function realMiddle($div) {
    if ($div.hasClass('halign-right')) {
      return $div.offset().left + $div.outerWidth() - realWidth($div) / 2;
    } else {
      return $div.offset().left + realWidth($div) / 2;
    }
  }

  function dragEnd(event) {
    that._$window.off('mousemove.tableheader');

    // in case of no movement: return
    if (!that.dragging) {
      return true;
    }

    // find new position of dragged header
    var h = (diff < 0) ? $otherHeaders : $($otherHeaders.get().reverse());
    h.each(function(i) {
      if ($(this).css('left') !== '0px') {
        newPos = that.table.columns.indexOf(($(this).data('column')));
        return false;
      }
    });

    // move column
    if (newPos > -1 && oldPos !== newPos) {
      that.table.moveColumn($header.data('column'), oldPos, newPos, true);
      that.dragging = false;
      that.columnMoved = true;
    } else {
      $header.animateAVCSD('left', '', function() {
        that.dragging = false;
      });
    }

    // reset css of dragged header
    $otherHeaders.each(function() {
      $(this).css('left', '');
    });

    $header.removeClass('moving');
    that.$container.removeClass('moving');
  }
};

scout.TableHeader.prototype._onSeparatorDblclick = function(event) {
  var $header = $(event.target).prev(),
    column = $header.data('column');
  this.table.resizeToFit(column);
};

scout.TableHeader.prototype._onSeparatorMousedown = function(event) {
  var startX = Math.floor(event.pageX),
    $header = $(event.target).prev(),
    column = $header.data('column'),
    that = this,
    headerWidth = column.width;

  column.resizingInProgress = true;

  // Install resize helpers. Those helpers make sure the header and the data element keep their
  // current width until the resizing has finished. Otherwise, make a column smaller while the
  // table has been horizontally scrolled to the right would behave very strange.
  this.$headerColumnResizeHelper = this.$container
    .appendDiv('table-column-resize-helper')
    .css('width', this.table.rowWidth + this.table.rowBorderWidth);
  this.$dataColumnResizeHelper = this.table.$data
    .appendDiv('table-column-resize-helper')
    .css('width', this.table.rowWidth);

  this._$window
    .on('mousemove.tableheader', resizeMove)
    .one('mouseup', resizeEnd);
  this._$body.addClass('col-resize');

  // Prevent text selection in a form, don't stop propagation to allow others (e.g. cell editor) to react
  event.preventDefault();

  function resizeMove(event) {
    var diff = Math.floor(event.pageX) - startX,
      wHeader = headerWidth + diff;

    wHeader = Math.max(wHeader, column.minWidth);
    if (wHeader !== column.width) {
      that.table.resizeColumn(column, wHeader);
    }
  }

  function resizeEnd(event) {
    delete column.resizingInProgress;

    // Remove resize helpers
    that.$headerColumnResizeHelper.remove();
    that.$headerColumnResizeHelper = null;
    that.$dataColumnResizeHelper.remove();
    that.$dataColumnResizeHelper = null;

    that._$window.off('mousemove.tableheader');
    that._$body.removeClass('col-resize');

    that.table.resizeColumn(column, column.width);
  }
};

scout.TableHeader.prototype._onTableDataScroll = function() {
  scout.scrollbars.fix(this.$menuBarContainer);
  this._reconcileScrollPos();
  this._fixTimeout = scout.scrollbars.unfix(this.$menuBarContainer, this._fixTimeout);
};

scout.TableHeader.prototype._onMenuBarPropertyChange = function(event) {
  if (event.changedProperties.indexOf('visible') !== -1) {
    this.$menuBarContainer.setVisible(event.newProperties.visible);
  }
};

scout.TableHeader.prototype._onTableAddRemoveFilter = function(event) {
  var column = event.filter.column;
  // Check for column.$header because column may have been removed in the mean time due to a structure changed event -> don't try to render state
  if (event.filter.filterType === scout.ColumnUserFilter.Type && column.$header) {
    this._renderColumnState(column);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableHeaderMenu = function() {
  scout.TableHeaderMenu.parent.call(this);
  this.tableHeader;
  this.table;
  this.$headerItem;
  this.$columnActions;
  this.$columnFilters;
  this.filterCheckedMode = scout.TableHeaderMenu.CheckedMode.ALL;

  this._tableHeaderScrollHandler = this._onAnchorScroll.bind(this);
  this.on('locationChanged', this._onLocationChanged.bind(this));
};
scout.inherits(scout.TableHeaderMenu, scout.Popup);

scout.TableHeaderMenu.CheckedMode = {
  ALL: {
    checkAll: true,
    text: 'ui.SelectAllFilter'
  },
  NONE: {
    checkAll: false,
    text: 'ui.SelectNoneFilter'
  }
};

scout.TableHeaderMenu.prototype._init = function(options) {
  options.scrollType = options.scrollType || 'none';
  scout.TableHeaderMenu.parent.prototype._init.call(this, options);

  this.tableHeader = options.tableHeader;
  this.column = options.column;
  this.table = this.tableHeader.table;
  this.$headerItem = this.$anchor;

  // Filtering
  this.filter = this.table.getFilter(this.column.id);
  if (!this.filter) {
    this.filter = this.column.createFilter();
  }
  // always recalculate available values to make sure new/updated/deleted rows are considered
  this.filter.calculate();
  this.filter.on('filterFieldsChanged', this._updateFilterTable.bind(this)); // FIXME AWE: (filter) off handler?
  this._updateFilterTableCheckedMode();

  this.hasFilterTable = this.filter.availableValues.length > 0;
  this.hasFilterFields = this.filter.hasFilterFields;

  if (this.hasFilterTable) {
    this._tableFilterHandler = this._onFilterTableChanged.bind(this);
    this.table.on('addFilter', this._tableFilterHandler);
    this.table.on('removeFilter', this._tableFilterHandler);
    this._filterTableRowsCheckedHandler = this._onFilterTableRowsChecked.bind(this);
  }
};

scout.TableHeaderMenu.prototype._createLayout = function() {
  return new scout.TableHeaderMenuLayout(this);
};

scout.TableHeaderMenu.prototype._render = function($parent) {
  var leftGroups = [],
    $rightGroups = [];

  this.$headerItem.select(true);

  this.$container = $parent.appendDiv('table-header-menu');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(this._createLayout());
  this.$body = this.$container.appendDiv('table-header-menu-body');
  scout.HtmlComponent.install(this.$body, this.session);
  scout.scrollbars.install(this.$body, {
    parent: this,
    axis: 'y'
  });
  this.$columnActions = this.$body.appendDiv('table-header-menu-actions');

  // only add right column if filter has a filter-table or filter-fields
  if (this.hasFilterTable || this.hasFilterFields) {
    this.$columnFilters = this.$body.appendDiv('table-header-menu-filters');
    var htmlColumnFiltes = scout.HtmlComponent.install(this.$columnFilters, this.session);
    htmlColumnFiltes.setLayout(new scout.RowLayout());
  }

  this.tableHeader.$container.on('scroll', this._tableHeaderScrollHandler);
  this.$whiter = this.$container.appendDiv('table-header-menu-whiter');

  if (this.withFocusContext && this.focusableContainer) {
    this.$container.attr('tabindex', -1);
  }

  // -- Left column -- //
  // Moving
  var movableColumns = this.table.columns.filter(function(column) {
    return !column.fixedPosition;
  });
  if (movableColumns.length > 1 && !this.column.fixedPosition) {
    leftGroups.push(this._renderMovingGroup());
  }
  // Sorting
  if (this.table.sortEnabled) {
    leftGroups.push(this._renderSortingGroup());
  }
  // Add/remove/change columns
  leftGroups.push(this._renderColumnActionsGroup());
  // Grouping
  // column.grouped check necessary to make ungroup possible, even if grouping is not possible anymore
  if (this.table.isGroupingPossible(this.column) || this.column.grouped) {
    leftGroups.push(this._renderGroupingGroup());
  }
  // Aggregation
  if (this.table.isAggregationPossible(this.column)) {
    leftGroups.push(this._renderAggregationGroup());
  }
  // Coloring
  if (this.column instanceof scout.NumberColumn) {
    leftGroups.push(this._renderColoringGroup());
  }

  // -- Right column -- //
  // Filter table
  if (this.hasFilterTable) {
    $rightGroups.push(this._renderFilterTable());
  }
  // Filter fields
  if (this.hasFilterFields) {
    $rightGroups.push(this._renderFilterFields());
  }

  addFirstLastClass(leftGroups);
  addFirstLastClass($rightGroups);

  // Set table style to focused, so that it looks as it still has the focus.
  if (this.table.enabled) {
    this.table.$container.addClass('focused');
  }

  function addFirstLastClass(groups) {
    if (groups.length) {
      addCssClass(groups[0], 'first');
      addCssClass(groups[groups.length - 1], 'last');
    }
  }

  // Note: we should refactor code for filter-fields and filter-table so they could also
  // work with a model-class (like the button menu groups). Currently this would cause
  // to much work.
  function addCssClass(group, cssClass) {
    var $container = group instanceof scout.TableHeaderMenuGroup ? group.$container : group;
    $container.addClass(cssClass);
  }
};

scout.TableHeaderMenu.prototype._remove = function() {
  if (this.filterTable) {
    this.filterTable.off('rowsChecked', this._filterTableRowsCheckedHandler);
  }
  this.tableHeader.$container.off('scroll', this._tableHeaderScrollHandler);
  this.$headerItem.select(false);
  this.table.off('addFilter', this._tableFilterHandler);
  this.table.off('removeFilter', this._tableFilterHandler);
  scout.scrollbars.uninstall(this.$body, this.session);
  scout.TableHeaderMenu.parent.prototype._remove.call(this);

  // table may have been removed in the meantime
  if (this.table.rendered) {
    this.table.$container.removeClass('focused');
  }
};

scout.TableHeaderMenu.prototype._renderMovingGroup = function() {
  var table = this.table,
    column = this.column,
    pos = table.columns.indexOf(column);

  var group = scout.create('TableHeaderMenuGroup', {
    parent: this,
    textKey: 'ui.Move',
    cssClass: 'first'
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.toBegin',
    cssClass: 'move move-top',
    clickHandler: function() {
      table.moveColumn(column, pos, 0);
      pos = table.columns.indexOf(column);
    }
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.forward',
    cssClass: 'move move-up',
    clickHandler: function() {
      table.moveColumn(column, pos, Math.max(pos - 1, 0));
      pos = table.columns.indexOf(column);
    }
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.backward',
    cssClass: 'move move-down',
    clickHandler: function() {
      table.moveColumn(column, pos, Math.min(pos + 1, table.header.findHeaderItems().length - 1));
      pos = table.columns.indexOf(column);
    }
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.toEnd',
    cssClass: 'move move-bottom',
    clickHandler: function() {
      table.moveColumn(column, pos, table.header.findHeaderItems().length - 1);
      pos = table.columns.indexOf(column);
    }
  });

  group.render(this.$columnActions);
  return group;
};

scout.TableHeaderMenu.prototype._renderColumnActionsGroup = function() {
  var column = this.column,
    menuPopup = this;

  this.columnActionsGroup = scout.create('TableHeaderMenuGroup', {
    parent: this,
    textKey: 'ui.Column'
  });

  this.addColumnButton = scout.create('TableHeaderMenuButton', {
    parent: this.columnActionsGroup,
    textKey: 'ui.addColumn',
    cssClass: 'add-column',
    visible: this.table.columnAddable,
    clickHandler: onClick.bind(this, 'add')
  });
  this.removeColumnButton = scout.create('TableHeaderMenuButton', {
    parent: this.columnActionsGroup,
    textKey: 'ui.removeColumn',
    cssClass: 'remove-column',
    visible: this.column.removable,
    clickHandler: onClick.bind(this, 'remove')
  });
  this.modifyColumnButton = scout.create('TableHeaderMenuButton', {
    parent: this.columnActionsGroup,
    textKey: 'ui.changeColumn',
    cssClass: 'change-column',
    visible: this.column.modifiable,
    clickHandler: onClick.bind(this, 'modify')
  });

  this.columnActionsGroup.render(this.$columnActions);
  return this.columnActionsGroup;

  function onClick(action) {
    menuPopup.close();
    this.table.trigger('columnOrganizeAction', {
      action: action,
      column: column
    });
  }
};

scout.TableHeaderMenu.prototype.onColumnActionsChanged = function(event) {
  this.addColumnButton.setVisible(event.addVisible);
  this.removeColumnButton.setVisible(event.removeVisible);
  this.modifyColumnButton.setVisible(event.modifyVisible);
  var groupVisible = this.columnActionsGroup.children.some(function(button) {
    return button.visible;
  });
  this.columnActionsGroup.setVisible(groupVisible);
};

scout.TableHeaderMenu.prototype._renderSortingGroup = function() {
  var table = this.table,
    column = this.column,
    menuPopup = this;

  this.sortingGroup = scout.create('TableHeaderMenuGroup', {
    parent: this,
    textKey: 'ColumnSorting'
  });

  if (!table.hasPermanentHeadOrTailSortColumns()) {
    this.sortAscButton = scout.create('TableHeaderMenuButton', {
      parent: this.sortingGroup,
      textKey: 'ui.ascending',
      cssClass: 'sort sort-asc',
      direction: 'asc',
      togglable: true,
      clickHandler: onSortClick
    });
    this.sortDescButton = scout.create('TableHeaderMenuButton', {
      parent: this.sortingGroup,
      textKey: 'ui.descending',
      cssClass: 'sort sort-desc',
      direction: 'desc',
      togglable: true,
      clickHandler: onSortClick
    });
  }

  this.sortAscAddButton = scout.create('TableHeaderMenuButton', {
    parent: this.sortingGroup,
    textKey: 'ui.ascendingAdditionally',
    cssClass: 'sort sort-asc-add',
    direction: 'asc',
    togglable: true,
    clickHandler: onSortAdditionalClick
  });
  this.sortDescAddButton = scout.create('TableHeaderMenuButton', {
    parent: this.sortingGroup,
    textKey: 'ui.descendingAdditionally',
    cssClass: 'sort sort-desc-add',
    direction: 'desc',
    togglable: true,
    clickHandler: onSortAdditionalClick
  });

  this._updateSortingSelectedState();
  this.sortingGroup.render(this.$columnActions);
  return this.sortingGroup;

  function onSortClick() {
    menuPopup.close();
    sort(this.direction, false, this.selected);
  }

  function onSortAdditionalClick() {
    menuPopup.close();
    sort(this.direction, true, this.selected);
  }

  function sort(direction, multiSort, remove) {
    table.sort(column, direction, multiSort, remove);
    menuPopup._updateSortingSelectedState();
  }
};

scout.TableHeaderMenu.prototype._updateSortingSelectedState = function() {
  if (!this.table.sortEnabled) {
    return;
  }

  var addIcon,
    showAddCommands = false,
    sortCount = this._sortColumnCount();

  this.sortingGroup.children.forEach(function(button) {
    button.setSelected(false);
  });

  if (sortCount === 1 && !this.table.hasPermanentHeadOrTailSortColumns()) {
    if (this.column.sortActive) {
      if (this.column.sortAscending) {
        this.sortAscButton.setSelected(true);
      } else {
        this.sortDescButton.setSelected(true);
      }
    } else {
      showAddCommands = true;
    }
  } else if (sortCount > 1 || this.table.hasPermanentHeadOrTailSortColumns()) {
    showAddCommands = true;
    if (this.column.sortActive) {
      if (this.column.sortAscending) {
        this.sortAscAddButton.setSelected(true);
      } else {
        this.sortDescAddButton.setSelected(true);
      }
      addIcon = this.column.sortIndex + 1;
      this.sortAscAddButton.setIcon(addIcon);
      this.sortDescAddButton.setIcon(addIcon);
    }
  }

  this.sortAscAddButton.setVisible(showAddCommands);
  this.sortDescAddButton.setVisible(showAddCommands);
};

scout.TableHeaderMenu.prototype._renderGroupingGroup = function() {
  var menuPopup = this,
    table = this.table,
    column = this.column,
    groupCount = this._groupColumnCount();

  var group = scout.create('TableHeaderMenuGroup', {
    parent: this,
    textKey: 'ui.Grouping'
  });

  var groupButton = scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.groupingApply',
    cssClass: 'group',
    additional: false,
    togglable: true,
    clickHandler: groupColumn
  });
  var groupAddButton = scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.additionally',
    cssClass: 'group-add',
    additional: true,
    togglable: true,
    clickHandler: groupColumn
  });

  if (groupCount === 0) {
    groupAddButton.setVisible(false);
  } else if (groupCount === 1 && this.column.grouped) {
    groupButton.setSelected(true);
    groupAddButton.setVisible(false);
  } else if (groupCount > 1) {
    groupAddButton.setVisible(true);
  }

  if (table.hasPermanentHeadOrTailSortColumns() && groupCount > 0) {
    // If table has permanent head columns, other columns may not be grouped exclusively -> only enable add button (equally done for sort buttons)
    groupButton.setVisible(false);
    groupAddButton.setVisible(true);
  }

  if (this.column.grouped) {
    if (groupCount === 1) {
      groupAddButton.setSelected(true);
    } else if (groupCount > 1) {
      groupAddButton.setSelected(true);
      groupAddButton.setIcon(this.column.sortIndex + 1);
    }
  }

  group.render(this.$columnActions);
  return group;

  function groupColumn() {
    this.toggle();
    var direction = (column.sortIndex >= 0 && !column.sortAscending) ? 'desc' : 'asc';
    menuPopup.close();
    table.groupColumn(column, this.additional, direction, !this.selected);
  }
};

scout.TableHeaderMenu.prototype._renderAggregationGroup = function() {
  var table = this.table,
    column = this.column,
    aggregation = column.aggregationFunction,
    menuPopup = this,
    group = scout.create('TableHeaderMenuGroup', {
      parent: this,
      textKey: 'ui.Aggregation'
    });

  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.Sum',
    cssClass: 'aggregation-function sum',
    aggregation: 'sum',
    clickHandler: onClick
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.Average',
    cssClass: 'aggregation-function avg',
    aggregation: 'avg',
    clickHandler: onClick
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.Minimum',
    cssClass: 'aggregation-function min',
    aggregation: 'min',
    clickHandler: onClick
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.Maximum',
    cssClass: 'aggregation-function max',
    aggregation: 'max',
    clickHandler: onClick
  });

  group.children.forEach(function(button) {
    button.setSelected(button.aggregation === aggregation);
  });
  group.render(this.$columnActions);
  return group;

  function onClick() {
    menuPopup.close();
    table.changeAggregation(column, this.aggregation);
  }
};

scout.TableHeaderMenu.prototype._renderColoringGroup = function() {
  var table = this.table,
    column = this.column,
    menuPopup = this,
    backgroundEffect = column.backgroundEffect,
    group = scout.create('TableHeaderMenuGroup', {
      parent: this,
      textKey: 'ui.Coloring'
    });

  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.fromRedToGreen',
    cssClass: 'color color-gradient1',
    backgroundEffect: 'colorGradient1',
    togglable: true,
    clickHandler: onClick
  });
  scout.create('TableHeaderMenuButton', {
    parent: group,
    textKey: 'ui.fromGreenToRed',
    cssClass: 'color color-gradient2',
    backgroundEffect: 'colorGradient2',
    togglable: true,
    clickHandler: onClick
  });
  if (scout.device.supportsCssGradient()) {
    scout.create('TableHeaderMenuButton', {
      parent: group,
      textKey: 'ui.withBarChart',
      cssClass: 'color color-bar-chart',
      backgroundEffect: 'barChart',
      togglable: true,
      clickHandler: onClick
    });
  }

  group.children.forEach(function(button) {
    button.setSelected(button.backgroundEffect === backgroundEffect);
  });
  group.render(this.$columnActions);
  return group;

  function onClick() {
    menuPopup.close();
    table.setColumnBackgroundEffect(column, this.selected ? null : this.backgroundEffect);
    this.toggle(); // toggle selected state of button
  }
};

scout.TableHeaderMenu.prototype._renderFilterTable = function() {
  var $filterActions;

  this.$filterTableGroup = this.$columnFilters
    .appendDiv('table-header-menu-group first');
  var htmlComp = scout.HtmlComponent.install(this.$filterTableGroup, this.session);
  htmlComp.setLayout(new scout.RowLayout());

  $filterActions = this.$filterTableGroup
    .appendDiv('table-header-menu-filter-actions');

  this.$filterToggleChecked = $filterActions
    .appendDiv('table-header-menu-filter-toggle-checked')
    .text(this.session.text(this.filterCheckedMode.text))
    .on('click', this._onClickFilterCheckedMode.bind(this));

  this.$filterTableGroupTitle = this.$filterTableGroup
    .appendDiv('table-header-menu-group-text')
    .text(this._filterByText());
  scout.HtmlComponent.install(this.$filterTableGroupTitle, this.session);

  this.filterTable = scout.create('Table', {
    parent: this,
    headerVisible: false,
    multiSelect: false,
    autoResizeColumns: true,
    checkable: true,
    checkableStyle: scout.Table.CheckableStyle.TABLE_ROW,
    // column-texts are not visible since header is not visible
    columns: [
      scout.create('Column', {
        index: 0,
        text: 'filter-value',
        width: 160,
        session: this.session
      }),
      scout.create('Column', {
        index: 1,
        type: 'number',
        horizontalAlignment: 1,
        text: 'aggregate-count',
        width: 40,
        session: this.session
      })
    ]
  });
  this.filterTable.on('rowsChecked', this._filterTableRowsCheckedHandler);
  var tableRow, tableRows = [];
  this.filter.availableValues.forEach(function(filterValue) {
    tableRow = {
      cells: [{
          text: filterValue.text,
          iconId: filterValue.iconId
        },
        filterValue.count
      ],
      checked: this.filter.selectedValues.indexOf(filterValue.key) > -1,
      dataMap: {
        filterValue: filterValue
      }
    };
    tableRows.push(tableRow);
  }, this);
  this.filterTable.insertRows(tableRows);
  this.filterTable.render(this.$filterTableGroup);
  this.filterTable.htmlComp.pixelBasedSizing = true;

  // must do this in a setTimeout, since table/popup is not visible yet (same as Table#revealSelection).
  setTimeout(this.filterTable.revealChecked.bind(this.filterTable));

  return this.$filterTableGroup;
};

/**
 * @returns the title-text used for the filter-table
 */
scout.TableHeaderMenu.prototype._filterByText = function() {
  var text = this.session.text('ui.Filter'),
    numSelected = this.filter.selectedValues.length,
    numFilters = this.filter.availableValues.length;

  if (numSelected && numFilters) {
    text += ' ' + this.session.text('ui.FilterInfoXOfY', numSelected, numFilters);
  } else if (numFilters) {
    text += ' ' + this.session.text('ui.FilterInfoCount', numFilters);
  }
  return text;
};

scout.TableHeaderMenu.prototype._onClickFilterCheckedMode = function() {
  var checkedMode = scout.TableHeaderMenu.CheckedMode;
  var checkAll = this.filterCheckedMode.checkAll;
  this.filter.selectedValues = [];
  if (this.filterCheckedMode === checkedMode.ALL) {
    this.filterCheckedMode = checkedMode.NONE;
    this.filter.availableValues.forEach(function(filterValue) {
      this.filter.selectedValues.push(filterValue.key);
    }, this);
  } else {
    this.filterCheckedMode = checkedMode.ALL;
  }
  this.filterTable.checkAll(checkAll);
  this._updateFilterTableActions();
};

scout.TableHeaderMenu.prototype._updateFilterTable = function() {
  if (this.filter.filterActive()) {
    this.table.addFilter(this.filter);
  } else {
    this.table.removeFilterByKey(this.column.id);
  }
  // callback to table
  this.table.filter();
};

scout.TableHeaderMenu.prototype._updateFilterTableActions = function() {
  this.$filterToggleChecked.text(this.session.text(this.filterCheckedMode.text));
};

scout.TableHeaderMenu.prototype._renderFilterFields = function() {
  this.filterFieldsGroupBox = scout.create('GroupBox:FilterFields', {
    parent: this,
    column: this.column,
    filter: this.filter
  });
  this.$filterFieldsGroup = this.$columnFilters.appendDiv('table-header-menu-group');
  var htmlComp = scout.HtmlComponent.install(this.$filterFieldsGroup, this.session);
  htmlComp.setLayout(new scout.RowLayout());
  var $filterFieldsText = this.$filterFieldsGroup
    .appendDiv('table-header-menu-group-text')
    .text(this.filter.filterFieldsTitle());
  htmlComp = scout.HtmlComponent.install($filterFieldsText, this.session);
  this.filterFieldsGroupBox.render(this.$filterFieldsGroup);
  return this.$filterFieldsGroup;
};

scout.TableHeaderMenu.prototype.isOpenFor = function($headerItem) {
  return this.rendered && this.belongsTo($headerItem);
};

scout.TableHeaderMenu.prototype._sortColumnCount = function() {
  var i, sortCount = 0;
  for (i = 0; i < this.table.columns.length; i++) {
    if (this.table.columns[i].sortActive) {
      sortCount++;
    }
  }
  return sortCount;
};

scout.TableHeaderMenu.prototype._groupColumnCount = function() {
  var i, groupCount = 0;
  for (i = 0; i < this.table.columns.length; i++) {
    if (this.table.columns[i].grouped) {
      groupCount++;
    }
  }
  return groupCount;
};

scout.TableHeaderMenu.prototype._computeWhitherWidth = function() {
  var $tableHeaderContainer = this.tableHeader.$container,
    headerItemWidth = this.$headerItem.outerWidth() - this.$headerItem.cssBorderWidthX(),
    containerWidth = this.$container.outerWidth() - this.$container.cssBorderWidthX(),
    tableHeaderWidth = $tableHeaderContainer.outerWidth() - this.tableHeader.menuBar.$container.outerWidth();

  // if container is wider than header item -> use header item width, otherwise use container width
  var whitherWidth = Math.min(headerItemWidth, containerWidth);
  // if container is positioned at the right side, header item may not be fully visible (under the menubar or partly invisible due to scrolling)
  whitherWidth = Math.min(whitherWidth, tableHeaderWidth - this.$headerItem.position().left);
  var clipLeft = $tableHeaderContainer.offset().left - this.$headerItem.offset().left - this.tableHeader.table.$container.cssBorderLeftWidth();
  if (clipLeft > 0) {
    whitherWidth -= clipLeft;
  }
  return whitherWidth;
};

scout.TableHeaderMenu.prototype._renderCompact = function() {
  this.$body.toggleClass('compact', this.compact);
  this.invalidateLayoutTree();
};

scout.TableHeaderMenu.prototype.setCompact = function(compact) {
  this.setProperty('compact', compact);
};

scout.TableHeaderMenu.prototype._onLocationChanged = function(event) {
  var inView, containerBounds,
    isLocationInView = scout.scrollbars.isLocationInView,
    headerItemBounds = scout.graphics.offsetBounds(this.$headerItem),
    $tableHeaderContainer = this.tableHeader.$container;

  this.$container.setVisible(true);
  containerBounds = scout.graphics.offsetBounds(this.$container);

  // menu must only be visible if the header item is in view (menu gets repositioned when the table gets scrolled -> make sure it won't be displayed outside of the table)
  // check left side of the header item (necessary if header item is moved outside on the left side of the table)
  inView = isLocationInView(new scout.Point(headerItemBounds.x, headerItemBounds.y), $tableHeaderContainer);
  if (!inView) {
    // if left side of the header is not in view, check if right side of the header and the menu, both must be visible)
    // check right side of the header item (necessary if header item is moved outside on the right side of the table)
    inView = isLocationInView(new scout.Point(headerItemBounds.x + headerItemBounds.width, headerItemBounds.y + headerItemBounds.height), $tableHeaderContainer);
    // check right side of the menu (necessary if header item is larger than menu, and if header item is moved outside on the left side of the table)
    inView = inView && isLocationInView(new scout.Point(containerBounds.x + containerBounds.width, containerBounds.y), $tableHeaderContainer);
  }
  this.$container.setVisible(inView);

  // make sure whither is correctly positioned and sized
  // (bounds must be computed after setVisible, if it was hidden before bounds are not correct)
  containerBounds = scout.graphics.offsetBounds(this.$container);
  this.$whiter
    // if header is clipped on the left side, position whither at the left of the visible part of the header (same applies for width, see _computeWhitherWidth)
    .cssLeft(Math.max(headerItemBounds.x - containerBounds.x, $tableHeaderContainer.offset().left - containerBounds.x - this.tableHeader.table.$container.cssBorderLeftWidth()))
    .width(this._computeWhitherWidth());
};

scout.TableHeaderMenu.prototype._onAnchorScroll = function(event) {
  this.position();
};

scout.TableHeaderMenu.prototype._onFilterTableRowsChecked = function(event) {
  this.filter.selectedValues = [];
  this.filterTable.rows.forEach(function(row) {
    if (row.checked) {
      this.filter.selectedValues.push(row.dataMap.filterValue.key);
    }
  }, this);
  this._updateFilterTable();
};

scout.TableHeaderMenu.prototype._onFilterTableChanged = function() {
  this.$filterTableGroupTitle.text(this._filterByText());
  this._updateFilterTableCheckedMode();
  this._updateFilterTableActions();
};

// When no filter value is selected, we change the selection mode to ALL
// since it makes no sense to choose NONE when no value is currently selected
scout.TableHeaderMenu.prototype._updateFilterTableCheckedMode = function() {
  if (this.filter.selectedValues.length === 0) {
    this.filterCheckedMode = scout.TableHeaderMenu.CheckedMode.ALL;
  } else {
    this.filterCheckedMode = scout.TableHeaderMenu.CheckedMode.NONE;
  }
};

scout.TableHeaderMenu.prototype._onMouseDownOutside = function(event) {
  // close popup only if source of event is not $headerItem or one of it's children.
  if (this.$headerItem.isOrHas(event.target)) {
    return;
  }
  this.close();
};

/**
 * Called by table header
 */
scout.TableHeaderMenu.prototype.onColumnResized = function() {
  // Adjust whiter with if size gets changed while menu is open (may caused by TableHeader._adjustColumnMinWidth)
  this.$whiter.width(this._computeWhitherWidth());
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableHeaderMenuLayout = function(popup) {
  scout.TableHeaderMenuLayout.parent.call(this, popup);
  this.popup = popup;
};
scout.inherits(scout.TableHeaderMenuLayout, scout.PopupLayout);

/**
 * Don't use scout.HtmlEnvironment.formRowHeight here intentionally (field looks to large)
 * Now it has the same height as the buttons in the left column.
 */
scout.TableHeaderMenuLayout.TEXT_FIELD_HEIGHT = 29;

scout.TableHeaderMenuLayout.TABLE_MAX_HEIGHT = 330;

/**
 * When this layout method is called we've calculated the pref. size before. Layout does this:
 * - layout the filter-fields (their size is fixed)
 * - use the remaining height to layout the filter table
 */
scout.TableHeaderMenuLayout.prototype.layout = function($container) {
  scout.TableHeaderMenuLayout.parent.prototype.layout.call(this, $container);

  if (!this.popup.hasFilterFields && !this.popup.hasFilterTable) {
    return;
  }

  var
    actionColumnSize, filterColumnSize,
    $filterColumn = this.popup.$columnFilters,
    filterColumnInsets = scout.graphics.getInsets($filterColumn),
    filterColumnMargins = scout.graphics.getMargins($filterColumn),
    filterFieldGroupSize = new scout.Dimension();

  if (this.popup.$body.hasClass('compact')) {
    // height is auto -> read pref size
    filterColumnSize = scout.HtmlComponent.get($filterColumn).getPreferredSize();
  } else {
    // make filter column as height as body (since body is scrollable pref size is calculated which takes TABLE_MAX_HEIGHT into account)
    filterColumnSize = this.preferredLayoutSize($container).subtract(scout.graphics.getInsets($container));
    filterColumnSize = filterColumnSize.subtract(filterColumnMargins);
  }
  // width is always set with css
  filterColumnSize.width = $filterColumn.cssWidth();

  // Set explicit height, necessary if there is no filter table
  $filterColumn.cssHeight(filterColumnSize.height);

  // TODO [6.1] cgu this code could be written a lot easier -> replace following code (filter fields, filter table) with scout.HtmlComponent.get($filterColumn).setSize(filterColumnSize);
  // Same for pref size. To implement max height of table, the RowLayout could read css max-height
  // Filter fields
  if (this.popup.hasFilterFields) {
    var
      $filterFieldsGroup = this.popup.$filterFieldsGroup,
      filterFieldHtmlComp = scout.HtmlComponent.get($filterFieldsGroup.find('.form-field'));

    // Layout filter field(s) and get size
    filterFieldHtmlComp.setSize(new scout.Dimension(filterColumnSize.width - filterColumnInsets.horizontal(), this._filterFieldsGroupBoxHeight()));
    filterFieldGroupSize = scout.graphics.getSize($filterFieldsGroup, true);
  }

  // Filter table
  if (this.popup.hasFilterTable) {
    var
      filterTableContainerHeight,
      $filterTableGroup = this.popup.$filterTableGroup,
      filterTableContainerInsets = scout.graphics.getInsets($filterTableGroup),
      filterTableHtmlComp = this.popup.filterTable.htmlComp;

    filterTableContainerHeight = filterColumnSize.height;
    // subtract height of filter-fields container
    filterTableContainerHeight -= filterFieldGroupSize.height;
    // subtract group-title height
    filterTableContainerHeight -= this._groupTitleHeight($filterTableGroup);
    // subtract insets of table container
    filterTableContainerHeight -= filterTableContainerInsets.vertical();
    // limit height of table
    filterTableContainerHeight = Math.min(filterTableContainerHeight, scout.TableHeaderMenuLayout.TABLE_MAX_HEIGHT);

    // Layout filter table
    filterTableHtmlComp.setSize(new scout.Dimension(
      filterColumnSize.width - filterColumnInsets.horizontal(),
      filterTableContainerHeight));
  }

  // fix width of actions column, so it doesn't become wider when user
  // hovers over a button and thus the text of the group changes.
  this._setMaxWidth();
  actionColumnSize = scout.graphics.getSize(this.popup.$columnActions);
  this._setMaxWidth(actionColumnSize.width);
};

scout.TableHeaderMenuLayout.prototype._adjustSizeWithAnchor = function(prefSize) {
  var maxWidth,
    htmlComp = this.popup.htmlComp,
    windowPaddingX = this.popup.windowPaddingX,
    popupMargins = htmlComp.getMargins(),
    popupBounds = htmlComp.getBounds(),
    $window = this.popup.$container.window(),
    windowWidth = $window.width();

  maxWidth = (windowWidth - popupMargins.horizontal() - popupBounds.x - windowPaddingX);
  var compact = popupBounds.width > maxWidth;
  if (compact) {
    this.popup.$body.addClass('compact', compact);
    prefSize = this.preferredLayoutSize(this.popup.$container);
  }

  return scout.TableHeaderMenuLayout.parent.prototype._adjustSizeWithAnchor.call(this, prefSize);
};

// group title (size used for table + field container)
scout.TableHeaderMenuLayout.prototype._groupTitleHeight = function($group) {
  return scout.graphics.getSize($group.find('.table-header-menu-group-text'), true).height;
};

scout.TableHeaderMenuLayout.prototype._filterFieldsGroupBoxHeight = function() {
  return this.popup.filterFieldsGroupBox.htmlComp.getPreferredSize().height;
};

/**
 * The preferred layout size of this widget is
 * + size of table (but height is limited to TABLE_MAX_HEIGHT, if table becomes too large)
 * + size of filter-fields
 * + paddings of surrounding containers
 */
scout.TableHeaderMenuLayout.prototype.preferredLayoutSize = function($container) {
  var prefSize, filterColumnMargins,
    rightColumnHeight = 0,
    leftColumnHeight = 0,
    containerInsets = scout.graphics.getInsets($container),
    oldMaxWidth = this._getMaxWidth();

  this._setMaxWidth(); // temp. remove max-width so we can determine pref. size
  leftColumnHeight = scout.graphics.getSize(this.popup.$columnActions, true).height;

  // Filter table
  if (this.popup.hasFilterTable) {
    var
      $filterTableGroup = this.popup.$filterTableGroup,
      filterTableHeight = this.popup.filterTable.htmlComp.getSize(true).height,
      filterTableContainerInsets = scout.graphics.getInsets($filterTableGroup),
      filterTableContainerHeight;

    // limit height of table
    filterTableHeight = Math.min(filterTableHeight, scout.TableHeaderMenuLayout.TABLE_MAX_HEIGHT);
    // size of container with table
    filterTableContainerHeight = filterTableHeight;
    // add group-title height
    filterTableContainerHeight += this._groupTitleHeight($filterTableGroup);
    // add insets of container
    filterTableContainerHeight += filterTableContainerInsets.vertical();

    rightColumnHeight += filterTableContainerHeight;
  }

  // Filter fields
  if (this.popup.hasFilterFields) {
    var
      $filterFieldsGroup = this.popup.$filterFieldsGroup,
      filterFieldContainerInsets = scout.graphics.getInsets($filterFieldsGroup),
      filterFieldContainerHeight;

    // size of group-box with 1 or 2 filter fields
    filterFieldContainerHeight = this._filterFieldsGroupBoxHeight();
    // add group-title height
    filterFieldContainerHeight += this._groupTitleHeight($filterFieldsGroup);
    // add insets of container
    filterFieldContainerHeight += filterFieldContainerInsets.vertical();

    rightColumnHeight += filterFieldContainerHeight;
  }

  if (this.popup.hasFilterFields || this.popup.hasFilterTable) {
    filterColumnMargins = scout.graphics.getMargins(this.popup.$columnFilters);
    rightColumnHeight += filterColumnMargins.vertical();
  }

  // Use height of left or right column as preferred size (and add insets of container)
  prefSize = scout.graphics.prefSize($container);
  if (!this.popup.$body.hasClass('compact')) {
    prefSize.height = Math.max(leftColumnHeight, rightColumnHeight) + containerInsets.vertical();
  } else {
    prefSize.height = leftColumnHeight + rightColumnHeight + containerInsets.vertical();
  }

  // restore max-width
  this._setMaxWidth(oldMaxWidth);

  return prefSize;
};

scout.TableHeaderMenuLayout.prototype._getMaxWidth = function() {
  return this.popup.$columnActions.css('max-width');
};

scout.TableHeaderMenuLayout.prototype._setMaxWidth = function(maxWidth) {
  this.popup.$columnActions.css('max-width', maxWidth || '');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableHeaderMenuGroup = function() {
  scout.TableHeaderMenuGroup.parent.call(this);
  this.text;
  this.textKey;
  this.cssClass;
  this.visible = true;
  this.last = false;
};
scout.inherits(scout.TableHeaderMenuGroup, scout.Widget);

scout.TableHeaderMenuGroup.prototype._init = function(options) {
  scout.TableHeaderMenuGroup.parent.prototype._init.call(this, options);
  $.extend(this, options);
  this.text = this.session.text(this.textKey);
};

scout.TableHeaderMenuGroup.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('table-header-menu-group buttons');
  this.$text = this.$container.appendDiv('table-header-menu-group-text');
  if (this.cssClass) {
    this.$container.addClass(this.cssClass);
  }
  this._renderText();
  this.children.forEach(function(child) {
    child.render(this.$container);
  }, this);
};

scout.TableHeaderMenuGroup.prototype.appendText = function(text) {
  this.text = this.session.text(this.textKey) + ' ' + text;
  if (this.rendered) {
    this._renderText();
  }
};

scout.TableHeaderMenuGroup.prototype.resetText = function() {
  this.text = this.session.text(this.textKey);
  if (this.rendered) {
    this._renderText();
  }
};

scout.TableHeaderMenuGroup.prototype._renderText = function() {
  this.$text.text(this.text);
};

scout.TableHeaderMenuGroup.prototype.setLast = function(last) {
  this.setProperty('last', last);
};

scout.TableHeaderMenuGroup.prototype._renderLast = function() {
  this.$container.toggleClass('last', this.last);
};

scout.TableHeaderMenuButton = function() {
  scout.TableHeaderMenuButton.parent.call(this);
  this.text;
  this.cssClass;
  this.enabled = true;
  this.visible = true;
  this.selected = false;
  this.togglable = false;
  this.icon;
};
scout.inherits(scout.TableHeaderMenuButton, scout.Widget);

scout.TableHeaderMenuButton.prototype._init = function(options) {
  scout.TableHeaderMenuButton.parent.prototype._init.call(this, options);
  $.extend(this, options);
  this.text = this.session.text(this.textKey);
  this.visible = scout.nvl(options.visible, true);
};

/**
 * @override
 */
scout.TableHeaderMenuButton.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.TableHeaderMenuButton.prototype._initKeyStrokeContext = function() {
  scout.TableHeaderMenuButton.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([new scout.TableHeaderMenuButtonKeyStroke(this)]);
};

scout.TableHeaderMenuButton.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('table-header-menu-command')
    .unfocusable()
    .on('click', this._onClick.bind(this))
    .on('mouseenter', this._onMouseOver.bind(this))
    .on('mouseleave', this._onMouseOut.bind(this));
  if (this.cssClass) {
    this.$container.addClass(this.cssClass);
  }
  this._renderSelected();
  this._renderTogglable();
  this._renderIcon();
};

scout.TableHeaderMenuButton.prototype._onClick = function() {
  if (this.enabled) {
    this.clickHandler.call(this);
  }
};

// Show 'remove' text when button is already selected
scout.TableHeaderMenuButton.prototype._onMouseOver = function() {
  if (this.enabled) {
    var text = this.selected ?
        this.session.text('ui.remove') : this.text;
    this.parent.appendText(text);
  }
};

scout.TableHeaderMenuButton.prototype._onMouseOut = function() {
  this.parent.resetText();
};

scout.TableHeaderMenuButton.prototype._renderSelected = function() {
  this.$container.select(this.selected);
};

scout.TableHeaderMenuButton.prototype._renderTogglable = function() {
  this.$container.toggleClass('togglable', this.togglable);
};

scout.TableHeaderMenuButton.prototype._renderIcon = function() {
  if (this.icon) {
    this.$container.attr('data-icon', this.icon);
  } else {
    this.$container.removeAttr('data-icon');
  }
};

scout.TableHeaderMenuButton.prototype.setSelected = function(selected) {
  this.setProperty('selected', selected);
  this._updateEnabled();
};

scout.TableHeaderMenuButton.prototype._updateEnabled = function() {
  var enabled = true;
  if (this.selected) {
    enabled = this.togglable;
  }
  this.enabled = enabled;
  if (this.rendered) {
    this._renderEnabled();
  }
};

/**
 * @override
 */
scout.TableHeaderMenuButton.prototype._renderEnabled = function() {
  this.$container.toggleClass('disabled', !this.enabled);
  this.$container.setTabbable(this.enabled && !scout.device.supportsTouch());
};

scout.TableHeaderMenuButton.prototype.setIcon = function(icon) {
  this.setProperty('icon', icon);
};

scout.TableHeaderMenuButton.prototype.toggle = function() {
  this.setSelected(!this.selected);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableHeaderMenuButtonKeyStroke = function(field) {
  scout.TableHeaderMenuButtonKeyStroke.parent.call(this);
  this.field = field;
  this.which = [scout.keys.ENTER, scout.keys.SPACE];
  this.renderingHints.render = true;
  this.stopPropagation = true;
};
scout.inherits(scout.TableHeaderMenuButtonKeyStroke, scout.KeyStroke);

scout.TableHeaderMenuButtonKeyStroke.prototype.handle = function(event) {
  this.field._onClick();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableLayout = function(table) {
  scout.TableLayout.parent.call(this);
  this.table = table;
};
scout.inherits(scout.TableLayout, scout.AbstractLayout);

scout.TableLayout.prototype.layout = function($container) {
  var menuBarSize,
    menuBar = this.table.menuBar,
    footer = this.table.footer,
    header = this.table.header,
    $data = this.table.$data,
    lastColumn = this.table.columns[this.table.columns.length - 1],
    height = 0,
    htmlMenuBar = scout.HtmlComponent.get(menuBar.$container),
    htmlContainer = this.table.htmlComp,
    containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  //FIXME CGU/AWE remove this check as soon as HtmlComp.validateLayout checks for invisible components
  if (!htmlContainer.isAttachedAndVisible() || !htmlContainer.$comp.isEveryParentVisible()) {
    return;
  }

  if (menuBar.visible) {
    menuBarSize = scout.MenuBarLayout.size(htmlMenuBar, containerSize);
    htmlMenuBar.setSize(menuBarSize);
    height += menuBarSize.height;
  }
  if (footer) {
    // Layout table footer and add size of footer (including the control content) to 'height'
    footer.revalidateLayout();
    height += scout.graphics.getSize(footer.$container).height;
    if (footer.opening) {
      // Layout may be called when container stays open but changes its size using an animation.
      // At that time the controlContainer has not yet the final size, therefore measuring is not possible, but not necessary anyway.
      height += footer.selectedControl.height;
    } else if (footer.open) {
      // Measure the real height
      height += scout.graphics.getSize(footer.$controlContainer).height;
    }
  }
  if (header) {
    height += scout.graphics.getSize(header.$container).height;
  }
  var dataMargins = scout.graphics.getMargins($data);
  height += dataMargins.top + dataMargins.bottom;
  $data.css('height', 'calc(100% - ' + height + 'px)');

  if (this.table.autoResizeColumns) {
    this._layoutColumns();
  }

  // Size of last column may have to be adjusted due to the header menu items
  if (header) {
    header.resizeHeaderItem(lastColumn);
  }

  this.table.setViewRangeSize(this.table.calculateViewRangeSize());
  this.table._renderScrollTop();
  // Always render viewport (not only when viewRangeSize changes), because view range depends on scroll position and data height
  this.table._renderViewport();

  // Make sure tooltips and editor popup are at correct position after layouting (e.g after window resizing)
  this.table.tooltips.forEach(function(tooltip) {
    tooltip.position();
  }.bind(this));
  if (this.table.cellEditorPopup && this.table.cellEditorPopup.rendered) {
    this.table.cellEditorPopup.position();
    this.table.cellEditorPopup.pack();
  }

  this.table.updateScrollbars();
};

/**
 * Resizes the columns to make them use all the available space.
 */
scout.TableLayout.prototype._layoutColumns = function() {
  var newWidth, weight,
    relevantColumns = [],
    currentWidth = 0,
    totalInitialWidth = 0,
    availableWidth = Math.floor(this.table.$data.width() - this.table.rowBorderWidth);

  // Handle fixed columns
  this.table.columns.forEach(function(column) {
    if (column.fixedWidth) {
      availableWidth -= column.width;
    } else {
      relevantColumns.push(column);
      currentWidth += column.width;
      totalInitialWidth += column.initialWidth;
    }
  }.bind(this));

  if (availableWidth === currentWidth) {
    // Columns already use the available space, no need to resize
    return;
  }

  var remainingWidth = availableWidth;

  // First, filter columns which would get smaller than their minimal size
  var minWidthColumns = relevantColumns.filter(function(column) {
    // Use initial width as preferred width for auto resize columns.
    // This makes sure the column doesn't get too small on small screens. The user can still make the column smaller though.
    var minWidth = Math.max(column.minWidth, column.initialWidth);
    if (totalInitialWidth === 0) {
      weight = 1 / relevantColumns.length;
    } else {
      weight = column.initialWidth / totalInitialWidth;
    }
    newWidth = Math.floor(weight * remainingWidth);
    if (newWidth < minWidth) {
      newWidth = minWidth;
      remainingWidth = Math.max(remainingWidth - newWidth, 0);
      return true;
    }
    return false;
  }.bind(this));

  // Resize them to their minimal width
  minWidthColumns.forEach(function(column, index) {
    var minWidth = Math.max(column.minWidth, column.initialWidth);
    scout.arrays.remove(relevantColumns, column);

    newWidth = minWidth;
    totalInitialWidth -= column.initialWidth;
    // If this is the last column, add remaining space (due to rounding) to this column
    if (index === minWidthColumns.length - 1 && remainingWidth > 0 && relevantColumns.length === 0) {
      newWidth += remainingWidth;
      remainingWidth = 0;
    }
    if (newWidth !== column.width) {
      this.table.resizeColumn(column, newWidth);
    }
  }.bind(this));

  // Then resize the others
  availableWidth = remainingWidth;
  relevantColumns.forEach(function(column, index) {
    if (totalInitialWidth === 0) {
      weight = 1 / relevantColumns.length;
    } else {
      weight = column.initialWidth / totalInitialWidth;
    }
    newWidth = Math.floor(weight * availableWidth);
    remainingWidth -= newWidth;
    // If this is the last column, add remaining space (due to rounding) to this column
    if (index === relevantColumns.length - 1 && remainingWidth > 0) {
      newWidth += remainingWidth;
      remainingWidth = 0;
    }
    if (newWidth !== column.width) {
      this.table.resizeColumn(column, newWidth);
    }
  }.bind(this));
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Enhances the table with selection behaviour.<p>
 *
 * If mouseMoveSelectionEnabled is set to true, the user can select the rows by moving the mouse with pressed left mouse button.
 *
 */
scout.TableSelectionHandler = function(table) {
  this.table = table;
  this.mouseMoveSelectionEnabled = true;
  this._mouseDown;
  this.lastActionRow;
  this._allRows;
  this.mouseOverHandler;
  this.select = true;
  this.counterDebug = 0;

  this.fromIndex;
  this.toIndex;
  // Index of the row that got a 'mouseover' event previously (needed to determine if the user is going up or down)
  this._prevSelectedRowIndex;
  // The index of the selected row with the greatest distance to fromIndex (needed to efficiently clear the selection)
  this._maxSelectedRowIndex;
};

scout.TableSelectionHandler.prototype.clearLastSelectedRowMarker = function() {
  this.lastActionRow = undefined;
};

// TODO [5.2] bsh: Table Selection | Try to merge this with TableKeystrokeContext
scout.TableSelectionHandler.prototype.onMouseDown = function(event) {
  //detect context menu button event ie event.buttons is 4 others 0
  if (event.which === 3 && event.button === 2 && (event.buttons === 0 || event.buttons === 4)) {
    return false;
  }
  var $row = $(event.currentTarget),
    row = $row.data('row'),
    oldSelectedState = $row.isSelected();
  this._mouseDown = true;

  this._allRows = this.table.filteredRows();
  if (this.table.multiSelect && event.shiftKey) {
    // when a selected row in the middle of a selection-block has
    // been clicked while shift is pressed -> do nothing
    if (this.table.selectedRows.indexOf(row) > -1) {
      return;
    }
    this.fromIndex = this._allRows.indexOf(this.lastActionRow);
  } else if (event.ctrlKey) {
    this.select = !oldSelectedState;
  } else {
    this.select = true;
    // Click on the already selected row must not clear the selection it to avoid another selection event sent to the server
    // Right click on already selected rows must not clear the selection
    if (!oldSelectedState || (this.table.selectedRows.length > 1 && event.which !== 3)) {
      this.table._removeSelection();
      this.table.selectedRows = [];
    }
  }
  if (this.fromIndex === undefined || this.fromIndex < 0) {
    this.fromIndex = this._allRows.indexOf(row);
  }

  if (event.which !== 3 || !oldSelectedState) {
    this.toIndex = this._allRows.indexOf(row);
    this.handleSelection(event);
    this.table.notifyRowSelectionFinished();
  }

  if (this.mouseMoveSelectionEnabled && event.which !== 3) {
    this.table.$data.off('mouseover', this.mouseOverHandler);
    this.mouseOverHandler = this.onMouseOver.bind(this);
    this.table.$data.on('mouseover', '.table-row', this.mouseOverHandler);
    // This additionally window listener is necessary to track the clicks outside of a table row.
    // If the mouse is released on a table row, onMouseUp gets called by the table's mouseUp listener.
  }

  $row.window().one('mouseup.selectionHandler', this.onMouseUp.bind(this));
  this.lastActionRow = row;
  if (event.which === 3) {
    this.table.onContextMenu(event);
    return false;
  }
};

scout.TableSelectionHandler.prototype.onMouseOver = function(event) {
  var $row = $(event.currentTarget),
    row = $row.data('row');
  this.toIndex = this._allRows.indexOf(row);
  this.handleSelection(event);
  this.lastActionRow = row;
};

scout.TableSelectionHandler.prototype.handleSelection = function(event) {
  var rowsToUnselect;
  if (this.table.multiSelect) {
    // Multi-selection -> expand/shrink selection
    var thisIndex = this.toIndex;
    var goingUp = (thisIndex < this._prevSelectedRowIndex);
    var goingDown = (thisIndex > this._prevSelectedRowIndex);
    var beforeFromSelection = (this._prevSelectedRowIndex < this.fromIndex);
    var afterFromSelection = (this._prevSelectedRowIndex > this.fromIndex);

    // In 'ctrlKey' mode, the unselection is done via 'select=false'
    if (!event.ctrlKey) {
      // If we are going _towards_ the startIndex, unselect all rows between the current row and the
      // selected row with the greatest distance (this._maxSelectedRowIndex).
      if (goingUp && afterFromSelection) {
        rowsToUnselect = this._allRows.slice(thisIndex + 1, this._maxSelectedRowIndex + 1);
      } else if (goingDown && beforeFromSelection) {
        rowsToUnselect = this._allRows.slice(this._maxSelectedRowIndex, thisIndex);
      }
      if (rowsToUnselect) {
        rowsToUnselect.forEach(function(row) {
          this.table.removeRowFromSelection(row, true);
        }, this);
      }
    }
    // Adjust the indexes
    this._maxSelectedRowIndex = (goingUp ? Math.min(this._maxSelectedRowIndex, thisIndex) : (goingDown ? Math.max(this._maxSelectedRowIndex, thisIndex) : thisIndex));
    this._prevSelectedRowIndex = thisIndex;
  } else {
    // Single selection -> unselect previously selected row
    if (this.select) {
      this.table._removeSelection();
      this.table.selectedRows = [];
    }

    // Adjust the indexes
    this.fromIndex = this.toIndex;
  }

  // Set the new selection
  this._selectRange(this.fromIndex, this.toIndex, this.select);
};

scout.TableSelectionHandler.prototype._selectRange = function(fromIndex, toIndex, select) {
  var startIndex = Math.min(fromIndex, toIndex),
    endIndex = Math.max(fromIndex, toIndex) + 1,
    actionRows = this._allRows.slice(startIndex, endIndex);
  // set/remove selection
  if (select) {
    actionRows.forEach(function(row) {
      this.table.addRowToSelection(row, true);
    }, this);
  } else {
    actionRows.forEach(function(row) {
      this.table.removeRowFromSelection(row, true);
    }, this);
  }
};

scout.TableSelectionHandler.prototype.onMouseUp = function(event) {
  if (!this._mouseDown) {
    // May happen when selecting elements with chrome dev tools
    return;
  }
  if (!this.table.rendered) {
    // May happen when the table is removed between the mouse down and the mouse up event
    // (e.g. when the user clicks 3 times very fast --> table is removed after double click).
    return;
  }

  this._mouseDown = false;
  this.table.$data.off('mouseover', this.mouseOverHandler);
  this._allRows = null;
  this.fromIndex = -1;
  this.toIndex = -1;
  this.selected = true;
  // Update selectedRows and allRows, this might have changed in the meantime (e.g. when row
  // was replaced by update event due to cell editing)
  this.table.notifyRowSelectionFinished();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableRowDetail = function() {
  scout.TableRowDetail.parent.call(this);
  this.table;
  this.row;
};
scout.inherits(scout.TableRowDetail, scout.Widget);

scout.TableRowDetail.prototype._init = function(model) {
  scout.TableRowDetail.parent.prototype._init.call(this, model);
  this.table = model.table;
  this.row = model.row;
};

scout.TableRowDetail.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('table-row-detail');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this._renderRow();
};

scout.TableRowDetail.prototype._renderRow = function() {
  this.table.columns.forEach(function(column) {
    var name = column.text;
    var value = this.table.cellText(column, this.row);
    if (scout.strings.empty(value)) {
      return;
    }
    var $field = this.$container.appendDiv('table-row-detail-field');
    // FIXME CGU handle column without text or with icon, handle icon content, html content, bean content
    $field.appendSpan('table-row-detail-name').text(name + ': ');
    $field.appendSpan('table-row-detail-value').text(value);
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableTooltip = function() {
  scout.TableTooltip.parent.call(this);
};
scout.inherits(scout.TableTooltip, scout.Tooltip);

scout.TableTooltip.prototype._init = function(options) {
  scout.TableTooltip.parent.prototype._init.call(this, options);

  this.table = options.table;
};

scout.TableTooltip.prototype._render = function($parent) {
  scout.TableTooltip.parent.prototype._render.call(this, $parent);

  this._rowOrderChangedFunc = function(event) {
    if (event.animating) {
      // row is only set while animating
      if (event.row === this.row) {
        this.position();
      }
    } else {
      this.position();
    }
  }.bind(this);
  this.table.on('rowOrderChanged', this._rowOrderChangedFunc);
};

scout.TableTooltip.prototype._remove = function() {
  scout.TableTooltip.parent.prototype._remove.call(this);
  this.table.off('rowOrderChanged', this._rowOrderChangedFunc);
};

scout.comparators = {

  /**
   * Text comparator, used to compare strings with support for internationalization (i18n).
   * The collator object is only installed once.
   */
  TEXT: {
    collator: null,
    installed: false,
    install: function(session) {
      if (this.installed) {
        return !!this.collator;
      }

      // set static collator variable once
      if (scout.device.supportsInternationalization()) {
        this.collator = new window.Intl.Collator(session.locale.languageTag);
        $.log.info('(comparators.TEXT#install) Browser supports i18n - installed Intl.Collator, can sort in Browser');
      } else {
        $.log.info('(comparators.TEXT#install) Browser doesn\'t support i18n. Must sort on server');
      }

      this.installed = true;
      return !!this.collator;
    },
    compare: function(valueA, valueB) {
      if (!this.collator) {
        // Fallback for browsers that don't support internationalization. This is only necessary
        // for callers that call this method without check for internationalization support
        // first (e.g. TableMatrix).
        valueA = scout.nvl(valueA, '');
        valueB = scout.nvl(valueB, '');
        return (valueA < valueB ? -1 : ((valueA > valueB) ? 1 : 0));
      }
      // We don't check the installed flag here. It's a program error when we come here
      // and the collator is not set. Either we forgot to call install() or we've called
      // install but the browser does not support i18n.
      return this.collator.compare(valueA, valueB);
    }
  },

  /**
   * Numeric comparator, used to compare numeric values. Used for numbers, dates, etc.
   */
  NUMERIC: {
    install: function(session) {
      // NOP
      return true;
    },
    compare: function(valueA, valueB) {
      if (valueA < valueB) {
        return -1;
      } else if (valueA > valueB) {
        return 1;
      }
      return 0;
    }
  },

  /**
   * Alphanumeric comparator.
   */
  ALPHANUMERIC: {
    collator: null,
    installed: false,
    install: function(session) {
      scout.comparators.TEXT.install(session);
      this.collator = scout.comparators.TEXT.collator;
      return !!this.collator && scout.comparators.NUMERIC.install(session);
    },
    compare: function(valueA, valueB) {
      if (!valueA && !valueB) {
        return 0;
      }
      if (!valueA) {
        return -1;
      }
      if (!valueB) {
        return 1;
      }

      var pattern = '(([0-9]+)|([^0-9]+))';
      var regexp1 = new RegExp(pattern, 'g');
      var regexp2 = new RegExp(pattern, 'g');
      var found1 = regexp1.exec(valueA);
      var found2 = regexp2.exec(valueB);
      while (found1 && found2) {
        var n1 = parseInt(found1[1], 0);
        var n2 = parseInt(found2[1], 0);
        if (!isNaN(n1) && !isNaN(n2)) {
          var numericResult = scout.comparators.NUMERIC.compare(n1, n2);
          if (numericResult !== 0) {
            return numericResult;
          }
        } else {
          var textResult = scout.comparators.TEXT.compare(found1[1], found2[1]);
          if (textResult !== 0) {
            return textResult;
          }
        }
        found1 = regexp1.exec(valueA);
        found2 = regexp2.exec(valueB);
      }

      if (!found1 && !found2) {
        return 0;
      }
      if (!found1) {
        return -1;
      }
      return 1;
    }
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Column = function() {
  this.cssClass;
  this.editable = false;
  this.removable = false;
  this.modifiable = false;
  this.fixedWidth = false;
  this.horizontalAlignment = -1;
  this.htmlEnabled = false;
  this.mandatory = false;
  this.sortActive = false;
  this.sortAscending = true;
  this.sortIndex = -1;
  this.summary = false;
  this.type = 'text';
  this.width = 60;
  this.minWidth = scout.Column.DEFAULT_MIN_WIDTH;
  this.showSeparator = true; // currently a UI-only property, defaults to true
  this.filterType = 'TextColumnUserFilter';
  this.comparator = scout.comparators.TEXT;
};

scout.Column.DEFAULT_MIN_WIDTH = 50;
scout.Column.NARROW_MIN_WIDTH = 32; // for columns without text (icon, check box)

scout.Column.prototype.init = function(model) {
  this.session = model.session;

  // Copy all properties from model to this
  $.extend(this, model);

  // Fill in the missing default values
  scout.defaultValues.applyTo(this);

  // Initial width is only sent if it differs from width
  if (this.initialWidth === undefined) {
    this.initialWidth = scout.nvl(this.width, 0);
  }

  if (this.aggregationFunction) {
    this.setAggregationFunction(this.aggregationFunction);
  }

  scout.texts.resolveTextProperty(this);
};

/**
 * Converts the vararg if it is of type string to an object with
 * a property 'text' with the original value.
 *
 * Example:
 * 'My Company' --> { text: 'MyCompany'; }
 *
 * @see JsonCell.java
 */
scout.Column.prototype.initCell = function(vararg, row) {
  if (vararg instanceof scout.Cell) {
    return vararg;
  }
  var cellModel = this._createCellModelInternal(vararg);
  return scout.create('Cell', cellModel);
};

scout.Column.prototype._createCellModelInternal = function(vararg) {
  var cellModel;
  if (vararg && scout.objects.isPlainObject(vararg)) {
    cellModel = vararg;
  } else {
    // in this case 'vararg' is only a scalar value, typically a string
    cellModel = this._createCellModel(vararg);
  }
  this._initCell(cellModel);
  return cellModel;
};

/**
 * Override this method to create a cell model object based on the given scalar value.
 */
scout.Column.prototype._createCellModel = function(text) {
  return {
    text: text
  };
};

/**
 * Override this method to impl. type specific init cell behavior.
 */
scout.Column.prototype._initCell = function(cellModel) {
  // when cell doesn't define horiz. alignment - use value from column
  if (cellModel.horizontalAlignment === undefined) {
    cellModel.horizontalAlignment = this.horizontalAlignment;
  }
};

scout.Column.prototype.buildCellForRow = function(row) {
  var cell = this.cell(row);
  return this.buildCell(cell, row);
};

scout.Column.prototype.buildCell = function(cell, row) {
  scout.assertParameter('cell', cell, scout.Cell);

  var text = cell.text || '';
  if (!cell.htmlEnabled) {
    text = cell.encodedText() || '';
    if (this.table.multilineText) {
      text = scout.strings.nl2br(text, false);
    }
  }
  var iconId = cell.iconId;
  var icon = this._icon(iconId, !!text) || '';
  var cssClass = this._cellCssClass(cell);
  var style = this._cellStyle(cell);

  if (cell.errorStatus) {
    row.hasError = true;
  }

  var content;
  if (!text && !icon) {
    // If every cell of a row is empty the row would collapse, using nbsp makes sure the row is as height as the others even if it is empty
    content = '&nbsp;';
    cssClass = scout.strings.join(' ', cssClass, 'empty');
  } else {
    content = icon + text;
  }

  var cellHtml = '';
  cellHtml += '<div class="' + cssClass + '" style="' + style + '"' + scout.device.unselectableAttribute.string + '>';
  if (scout.device.tableAdditionalDivRequired) {
    cellHtml += '<div class="width-fix" style="max-width: ' + (this.width - this.table.cellHorizontalPadding - 2 /* unknown IE9 extra space */ ) + 'px; ' + '">';
    // same calculation in scout.Table.prototype.resizeColumn
  }
  cellHtml += content;
  if (scout.device.tableAdditionalDivRequired) {
    cellHtml += '</div>';
  }
  cellHtml += '</div>';
  return cellHtml;
};

scout.Column.prototype._icon = function(iconId, hasText) {
  var cssClass, icon;
  if (!iconId) {
    return;
  }
  cssClass = 'table-cell-icon';
  if (hasText) {
    cssClass += ' with-text';
  }
  icon = scout.icons.parseIconId(iconId);
  if (icon.isFontIcon()) {
    cssClass += ' font-icon';
    return '<span class="' + icon.appendCssClass(cssClass) + '">' + icon.iconCharacter + '</span>';
  } else {
    cssClass += ' image-icon';
    return '<img class="' + cssClass + '" src="' + icon.iconUrl + '">';
  }
};

scout.Column.prototype._cellCssClass = function(cell) {
  var cssClass = 'table-cell';
  if (this.mandatory) {
    cssClass += ' mandatory';
  }
  if (!this.table.multilineText || !this.textWrap) {
    cssClass += ' white-space-nowrap';
  }
  if (cell.editable) {
    cssClass += ' editable';
  }
  if (cell.errorStatus) {
    cssClass += ' has-error';
  }
  cssClass += ' halign-' + scout.Table.parseHorizontalAlignment(cell.horizontalAlignment);
  var columnPosition = this.table.columns.indexOf(this);
  if (columnPosition === 0) {
    cssClass += ' first';
  }
  if (columnPosition === this.table.columns.length - 1) {
    cssClass += ' last';
  }

  //TODO [5.2] cgu: cssClass is actually only sent for cells, should we change this in model? discuss with jgu
  if (cell.cssClass) {
    cssClass += ' ' + cell.cssClass;
  } else if (this.cssClass) {
    cssClass += ' ' + this.cssClass;
  }
  return cssClass;
};

scout.Column.prototype._cellStyle = function(cell) {
  var style,
    width = this.width;

  if (width === 0) {
    return 'display: none;';
  }

  style = 'min-width: ' + width + 'px; max-width: ' + width + 'px; ';
  style += scout.styles.legacyStyle(cell);

  if (this.backgroundEffect && cell.value !== undefined) {
    if (!this.backgroundEffectFunc) {
      this.backgroundEffectFunc = this._resolveBackgroundEffectFunc();
    }
    var backgroundStyle = this.backgroundEffectFunc(this._preprocessValueForGrouping(cell.value));
    if (backgroundStyle.backgroundColor) {
      style += 'background-color: ' + backgroundStyle.backgroundColor + ';';
    }
    if (backgroundStyle.backgroundImage) {
      style += 'background-image: ' + backgroundStyle.backgroundImage + ';';
    }
  }
  return style;
};

scout.Column.prototype.onMouseUp = function(event, $row) {
  var row = $row.data('row'),
    cell = this.cell(row);

  if (this.isCellEditable(row, cell, event)) {
    this.table.prepareCellEdit(this, row, true);
  }
};

scout.Column.prototype.isCellEditable = function(row, cell, event) {
  return this.table.enabled && row.enabled && cell.editable && !event.ctrlKey && !event.shiftKey;
};

scout.Column.prototype.startCellEdit = function(row, field) {
  var popup,
    $row = row.$row,
    cell = this.cell(row),
    $cell = this.table.$cell(this, $row);

  cell.field = field;
  // Override field alignment with the cell's alignment
  cell.field.gridData.horizontalAlignment = cell.horizontalAlignment;

  popup = scout.create('CellEditorPopup', {
    parent: this.table,
    column: this,
    row: row,
    cell: cell
  });
  popup.$anchor = $cell;
  popup.open(this.table.$data);
  return popup;
};

// TODO CGU/AWE cleanup these cellValue/TextForXY methods, currently they are very confusing
/**
 * @returns the cell value to be used for grouping and filtering (chart, column filter).
 */
scout.Column.prototype.cellValueForGrouping = function(row) {
  var cell = this.cell(row);
  if (cell.value !== undefined) {
    return this._preprocessValueForGrouping(cell.value);
  }
  if (!cell.text) {
    return null;
  }
  return this._preprocessTextForValueGrouping(cell.text, cell.htmlEnabled);
};

scout.Column.prototype._preprocessValueForGrouping = function(value) {
  return value;
};

scout.Column.prototype._preprocessTextForValueGrouping = function(text, htmlEnabled) {
  return this._preprocessText(text, {
    removeHtmlTags: htmlEnabled,
    removeNewlines: true,
    trim: true
  });
};

/**
 * @returns the cell text to be used for table grouping
 */
scout.Column.prototype.cellTextForGrouping = function(row) {
  var cell = this.cell(row);
  return this._preprocessTextForGrouping(cell.text, cell.htmlEnabled);
};

/**
 * @returns the cell object for this column from the given row.
 */
scout.Column.prototype.cell = function(row) {
  return this.table.cell(this, row);
};

/**
 * @returns the cell object for this column from the first selected row in the table.
 */
scout.Column.prototype.selectedCell = function() {
  var selectedRow = this.table.selectedRow();
  return this.table.cell(this, selectedRow);
};

scout.Column.prototype._preprocessTextForGrouping = function(text, htmlEnabled) {
  return this._preprocessText(text, {
    removeHtmlTags: htmlEnabled,
    trim: true
  });
};

/**
 * @returns the cell text to be used for the text filter
 */
scout.Column.prototype.cellTextForTextFilter = function(row) {
  var cell = this.cell(row);
  return this._preprocessTextForTextFilter(cell.text, cell.htmlEnabled);
};

scout.Column.prototype._preprocessTextForTextFilter = function(text, htmlEnabled) {
  return this._preprocessText(text, {
    removeHtmlTags: htmlEnabled
  });
};

/**
 * Removes html tags, converts to single line, removes leading and trailing whitespaces.
 */
scout.Column.prototype._preprocessText = function(text, options) {
  if (text === null || text === undefined) {
    return text;
  }
  options = options || {};
  if (options.removeHtmlTags) {
    text = scout.strings.plainText(text);
  }
  if (options.removeNewlines) {
    text = text.replace('\n', ' ');
  }
  if (options.trim) {
    text = text.trim();
  }
  return text;
};

scout.Column.prototype.setAggregationFunction = function(func) {
  this.aggregationFunction = func;
  if (func === 'sum') {
    this.aggrStart = scout.aggregation.sumStart;
    this.aggrStep = scout.aggregation.sumStep;
    this.aggrFinish = scout.aggregation.sumFinish;
    this.aggrSymbol = scout.aggregation.sumSymbol;
  } else if (func === 'avg') {
    this.aggrStart = scout.aggregation.avgStart;
    this.aggrStep = scout.aggregation.avgStep;
    this.aggrFinish = scout.aggregation.avgFinish;
    this.aggrSymbol = scout.aggregation.avgSymbol;
  } else if (func === 'min') {
    this.aggrStart = scout.aggregation.minStart;
    this.aggrStep = scout.aggregation.minStep;
    this.aggrFinish = scout.aggregation.minFinish;
    this.aggrSymbol = scout.aggregation.minSymbol;
  } else if (func === 'max') {
    this.aggrStart = scout.aggregation.maxStart;
    this.aggrStep = scout.aggregation.maxStep;
    this.aggrFinish = scout.aggregation.maxFinish;
    this.aggrSymbol = scout.aggregation.maxSymbol;
  }
};

scout.Column.prototype.setCellValue = function(row, value) {
  var cellModel = this._createCellModelInternal(value);
  this.cell(row).update(cellModel);
};

scout.Column.prototype.createAggrGroupCell = function(row) {
  var cell = this.cell(row);
  return this.initCell({
    // value necessary for value based columns (e.g. checkbox column)
    value: cell.value,
    text: this.cellTextForGrouping(row),
    iconId: cell.iconId,
    horizontalAlignment: this.horizontalAlignment,
    cssClass: 'table-aggregate-cell'
  });
};

scout.Column.prototype.createAggrEmptyCell = function() {
  return this.initCell({
    empty: true
  });
};

scout.Column.prototype.setBackgroundEffect = function(effect) {
  if (this.backgroundEffect === effect) {
    return;
  }

  this.backgroundEffect = effect;
  this.backgroundEffectFunc = this._resolveBackgroundEffectFunc();

  this.table.trigger('columnBackgroundEffectChanged', {
    column: this
  });

  if (this.backgroundEffect && (this.minValue === undefined || this.maxValue === undefined)) {
    // No need to calculate the values again when switching background effects
    // If background effect is turned off and on again values will be recalculated
    // This is necessary because in the meantime rows may got updated, deleted etc.
    this.calculateMinMaxValues();
  }
  if (!this.backgroundEffect) {
    // Clear to make sure values are calculated anew the next time a background effect gets set
    this.minValue = undefined;
    this.maxValue = undefined;
  }

  if (this.table.rendered) {
    this._renderBackgroundEffect();
  }
};

/**
 * Recalculates the min / max values and renders the background effect again.
 */
scout.Column.prototype.updateBackgroundEffect = function() {
  this.calculateMinMaxValues();
  if (this.table.rendered) {
    this._renderBackgroundEffect();
  }
};

scout.Column.prototype._resolveBackgroundEffectFunc = function() {
  var effect = this.backgroundEffect;
  if (effect === 'colorGradient1') {
    return this._colorGradient1.bind(this);
  }
  if (effect === 'colorGradient2') {
    return this._colorGradient2.bind(this);
  }
  if (effect === 'barChart') {
    return this._barChart.bind(this);
  }

  if (effect !== null) {
    $.log.warn('Unsupported backgroundEffect: ' + effect);
    return function() {
      return {};
    };
  }
};

scout.Column.prototype._renderBackgroundEffect = function() {
  this.table.filteredRows().forEach(function(row) {
    if (!row.$row) {
      return;
    }
    var cell = this.cell(row),
      $cell = this.table.$cell(this, row.$row);

    if (cell.value !== undefined) {
      $cell[0].style.cssText = this._cellStyle(cell);
    }
  }, this);
};

scout.Column.prototype.calculateOptimalWidth = function() {
  var row, rows = this.table.rows,
    optimalWidth = this.minWidth;
  for (var i = 0; i < rows.length; i++) {
    row = rows[i];
    var $div = $(this.buildCellForRow(row));
    $div.removeAttr('style');
    $div.hide();
    this.table.$data.append($div);
    optimalWidth = optimalWidth < $div.outerWidth() ? $div.outerWidth() : optimalWidth;
    $div.remove();
  }
  return optimalWidth;
};

scout.Column.prototype.calculateMinMaxValues = function() {
  var row, minValue, maxValue, value,
    rows = this.table.rows;

  for (var i = 0; i < rows.length; i++) {
    row = rows[i];
    value = this.cellValueForGrouping(row);

    if (value < minValue || minValue === undefined) {
      minValue = value;
    }
    if (value > maxValue || maxValue === undefined) {
      maxValue = value;
    }
  }
  this.minValue = minValue;
  this.maxValue = maxValue;
};

scout.Column.prototype._colorGradient1 = function(value) {
  var startStyle = scout.styles.get('column-background-effect-gradient1-start', 'backgroundColor'),
    endStyle = scout.styles.get('column-background-effect-gradient1-end', 'backgroundColor'),
    startColor = scout.styles.rgb(startStyle.backgroundColor),
    endColor = scout.styles.rgb(endStyle.backgroundColor);

  return this._colorGradient(value, startColor, endColor);
};

scout.Column.prototype._colorGradient2 = function(value) {
  var startStyle = scout.styles.get('column-background-effect-gradient2-start', 'backgroundColor'),
    endStyle = scout.styles.get('column-background-effect-gradient2-end', 'backgroundColor'),
    startColor = scout.styles.rgb(startStyle.backgroundColor),
    endColor = scout.styles.rgb(endStyle.backgroundColor);

  return this._colorGradient(value, startColor, endColor);
};

scout.Column.prototype._colorGradient = function(value, startColor, endColor) {
  var level = (value - this.minValue) / (this.maxValue - this.minValue);

  var r = Math.ceil(startColor.red - level * (startColor.red - endColor.red)),
    g = Math.ceil(startColor.green - level * (startColor.green - endColor.green)),
    b = Math.ceil(startColor.blue - level * (startColor.blue - endColor.blue));

  return {
    backgroundColor: 'rgb(' + r + ',' + g + ', ' + b + ')'
  };
};

scout.Column.prototype._barChart = function(value) {
  var level = Math.ceil((value - this.minValue) / (this.maxValue - this.minValue) * 100) + '';
  var color = scout.styles.get('column-background-effect-bar-chart', 'backgroundColor').backgroundColor;
  return {
    backgroundImage: 'linear-gradient(to left, ' + color + ' 0%, ' + color + ' ' + level + '%, transparent ' + level + '%, transparent 100% )'
  };
};

/**
 * Returns a type specific column user-filter. The default impl. returns a ColumnUserFilter.
 * Sub-classes that must return another type, must simply change the value of the 'filterType' property.
 */
scout.Column.prototype.createFilter = function(model) {
  return scout.create(this.filterType, {
    session: this.session,
    table: this.table,
    column: this
  });
};

/**
 * @returns a field instance used as editor when a cell of this column is in edit mode.
 */
scout.Column.prototype.createDefaultEditor = function(row) {
  var field = scout.create('StringField', {
    parent: this.table,
    labelVisible: false
  });
  field.setValue(this.cell(row).text);
  return field;
};

/**
 * Override this function to install a specific compare function on a column instance.
 * The default impl. installs a generic comparator working with less than and greater than.
 *
 * @returns whether or not it was possible to install a compare function. If not, client side sorting is disabled.
 */
scout.Column.prototype.installComparator = function() {
  return this.comparator.install(this.session);
};

/**
 * @returns whether or not this column can be used to sort on the client side. In a JS only the flag 'uiSortPossible'
 *     is never set and defaults to true. As a side effect of this function a comparator is installed on each column.
 *     In a remote app the server sets the 'uiSortPossible' flag, which decides if the column must be sorted by the
 *     server or can be sorted by the client.
 */
scout.Column.prototype.isUiSortPossible = function() {
  var uiSortPossible = scout.nvl(this.uiSortPossible, true);
  return uiSortPossible && this.installComparator();
};

scout.Column.prototype.compare = function(row1, row2) {
  var valueA = this.table.cellValue(this, row1);
  var valueB = this.table.cellValue(this, row2);
  return this.comparator.compare(valueA, valueB);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AlphanumericSortingStringColumn = function() {
  scout.AlphanumericSortingStringColumn.parent.call(this);
  this.comparator = scout.comparators.ALPHANUMERIC;
};
scout.inherits(scout.AlphanumericSortingStringColumn, scout.Column);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BeanColumn = function() {
  scout.BeanColumn.parent.call(this);
  this.additionalDivMode = scout.BeanColumn.AdditionalDivMode.AUTO;
};
scout.inherits(scout.BeanColumn, scout.Column);

scout.BeanColumn.AdditionalDivMode = {
  NEVER: 0,
  AUTO: 1
};

scout.BeanColumn.prototype.buildCellForRow = function(row) {
  var $cell, value;
  $cell = $(scout.BeanColumn.parent.prototype.buildCellForRow.call(this, row));
  // Clear any content (e.g. nbsp due to empty text)
  $cell.empty();
  $cell.removeClass('empty');

  value = this.table.cellValue(this, row);
  this._renderValue($cell, value);
  if (this.additionalDivMode === scout.BeanColumn.AdditionalDivMode.AUTO && scout.device.tableAdditionalDivRequired) {
    $cell.html('<div class="width-fix" style="max-width: ' + (this.width - this.table.cellHorizontalPadding - 2 /* unknown IE9 extra space */ ) + 'px; ' + '">' + $cell.html() + '</div>');
  }
  return $cell[0].outerHTML;
};

/**
 * Override to render the value.<p>
 * If you have a large table you should consider overriding buildCellForRow instead and create the html as string instead of using jquery.
 */
scout.BeanColumn.prototype._renderValue = function($cell, value) {
  // to be implemented by the subclass
};

scout.BeanColumn.prototype._plainTextForRow = function(row) {
  var cell = this.table.cell(this, row);
  if (!cell.plainText) {
    // Convert to plain text and cache it because rendering is expensive
    var html = this.buildCellForRow(row);
    cell.plainText = scout.strings.plainText(html);
  }
  return cell.plainText;
};

/**
 * Default approach reads the html using buildCellForRow and uses _preprocessTextForGrouping to generate the value. Just using text() does not work because new lines get omitted.
 * If this approach does not work for a specific bean column, just override this method.
 */
scout.BeanColumn.prototype.cellValueForGrouping = function(row) {
  var plainText = this._plainTextForRow(row);
  return this._preprocessTextForValueGrouping(plainText);
};

scout.BeanColumn.prototype.cellTextForGrouping = function(row) {
  var plainText = this._plainTextForRow(row);
  return this._preprocessTextForGrouping(plainText);
};

scout.BeanColumn.prototype.cellTextForTextFilter = function(row) {
  var plainText = this._plainTextForRow(row);
  return this._preprocessTextForTextFilter(plainText);
};

scout.BeanColumn.prototype.compare = function(row1, row2) {
  var plainText1 = this._plainTextForRow(row1);
  var plainText2 = this._plainTextForRow(row2);
  return this.comparator.compare(plainText1, plainText2);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * May be an ordinary boolean column or the table's checkable column (table.checkableColumn)
 * Difference: the table's checkable column represents the row.checked state, other boolean columns represent their own value.
 */
scout.BooleanColumn = function() {
  scout.BooleanColumn.parent.call(this);
  this.minWidth = scout.Column.NARROW_MIN_WIDTH;
  this.filterType = 'ColumnUserFilter';
  this.comparator = scout.comparators.NUMERIC;
  this.triStateEnabled = false;
};
scout.inherits(scout.BooleanColumn, scout.Column);

/**
 * @override
 */
scout.BooleanColumn.prototype.buildCell = function(cell, row) {
  var style, content, tooltipText, tooltip, cssClass, checkBoxCssClass;
  var enabled = row.enabled;
  if (cell.empty) {
    // if cell wants to be really empty (e.g. no checkbox icon, use logic of base class)
    return scout.BooleanColumn.parent.prototype.buildCell.call(this, cell, row);
  }

  enabled = enabled && cell.editable;
  cssClass = this._cellCssClass(cell);
  style = this._cellStyle(cell);
  if (!enabled) {
    cssClass += ' disabled';
  }
  tooltipText = cell.tooltipText;
  tooltip = (scout.strings.empty(tooltipText) ? '' : ' title="' + tooltipText + '"');

  checkBoxCssClass = 'check-box';
  if (cell.value === true) {
    checkBoxCssClass += ' checked';
  }
  if (this.triStateEnabled && cell.value !== true && cell.value !== false) {
    checkBoxCssClass += ' undefined';
  }
  if (!enabled) {
    checkBoxCssClass += ' disabled';
  }
  content = '<div class="' + checkBoxCssClass + '"/>';

  return '<div class="' + cssClass + '" style="' + style + '"' + tooltip + scout.device.unselectableAttribute.string + '>' + content + '</div>';
};

scout.BooleanColumn.prototype.$checkBox = function($row) {
  var $cell = this.table.$cell(this, $row);
  return $cell.children('.check-box');
};

scout.BooleanColumn.prototype._cellCssClass = function(cell) {
  var cssClass = scout.BooleanColumn.parent.prototype._cellCssClass.call(this, cell);
  cssClass = cssClass.replace(' editable', '');
  cssClass += ' checkable';
  return cssClass;
};

/**
 * This function does intentionally _not_ call the super function (prepareCellEdit) because we don't want to
 * show an editor for BooleanColumns when user clicks on a cell.
 */
scout.BooleanColumn.prototype.onMouseUp = function(event, $row) {
  var row = $row.data('row'),
    cell = this.cell(row);

  if (this.table.checkableColumn === this) {
    this.table.checkRow(row, !row.checked);
  } else if (this.isCellEditable(row, cell, event)) {
    this._toggleCellValue(row, cell);
  }
};

/**
 * In a remote app this function is overridden by RemoteApp.js, the default implementation is the local case.
 * @see RemoteApp.js
 */
scout.BooleanColumn.prototype._toggleCellValue = function(row, cell) {
  this.table.setCellValue(this, row, !cell.value);
};

/**
 * @override Columns.js
 */
scout.BooleanColumn.prototype._createCellModel = function(value) {
  return {
    value: value
  };
};


/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CodeColumn = function() { // FIXME [awe] 6.1 - discuss with C.GU - keep CodeColumn or use SmartColumn with codeLookup?
  scout.CodeColumn.parent.call(this);
  this.codeType;
  this.uiSortPossible = true;
  this.comparator = scout.comparators.NUMERIC;
};
scout.inherits(scout.CodeColumn, scout.Column);

/**
 * @override Columns.js
 */
scout.CodeColumn.prototype._createCellModel = function(codeId) {
  if (scout.objects.isNullOrUndefined(codeId)) {
    return scout.CodeColumn.parent.prototype._createCellModel('');
  }

  var code = scout.codes.get(this.codeType, codeId);
  return {
    text: code.text(this.session.locale),
    value: code
  };
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DateColumn = function() {
  scout.DateColumn.parent.call(this);
  this.hasDate = true;
  this.hasTime = false;
  this.filterType = 'DateColumnUserFilter';
  this.comparator = scout.comparators.NUMERIC;
};
scout.inherits(scout.DateColumn, scout.Column);

scout.DateColumn.DATE_PATTERN = 'dd.MM.yyyy';
scout.DateColumn.TIME_PATTERN = 'HH:mm';

scout.DateColumn.prototype.init = function(model) {
  scout.DateColumn.parent.prototype.init.call(this, model);

  this.groupFormatFormatter = new scout.DateFormat(this.session.locale, this.groupFormat);
};

/**
 * @override Columns.js
 */
scout.DateColumn.prototype._createCellModel = function(text) {
  var date = scout.dates.parseJsonDate(text);
  var formattedDate = scout.dates.format(date, this.session.locale, this._createDatePattern());
  return {
    text: formattedDate,
    value: date
  };
};

scout.DateColumn.prototype._createDatePattern = function() {
  if (this.hasDate && this.hasTime) {
    return scout.DateColumn.DATE_PATTERN + ' ' + scout.DateColumn.TIME_PATTERN;
  }
  if (this.hasDate) {
    return scout.DateColumn.DATE_PATTERN;
  }
  return scout.DateColumn.TIME_PATTERN;
};

/**
 * If cell.value is a Date instance or undefined we do nothing. If value is a String, we assume
 * its a JSON date string and convert it to a Date instance.
 * @override Column.js
 */
scout.DateColumn.prototype._initCell = function(cell) {
  scout.DateColumn.parent.prototype._initCell.call(this, cell);
  if (typeof cell.value === 'string') {
    cell.value = scout.dates.parseJsonDate(cell.value);
  }
};

scout.DateColumn.prototype.cellTextForGrouping = function(row) {
  if (this.groupFormat === undefined || this.groupFormat === this.format || !this.groupFormatFormatter) {
    // fallback/shortcut, if no groupFormat defined or groupFormat equals format use cellText
    return scout.DateColumn.parent.prototype.cellTextForGrouping.call(this, row);
  }

  var val = this.table.cellValue(this, row);
  return this.groupFormatFormatter.format(val);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.IconColumn = function() {
  scout.IconColumn.parent.call(this);
  this.minWidth = scout.Column.NARROW_MIN_WIDTH;
  this.filterType = 'ColumnUserFilter';
};
scout.inherits(scout.IconColumn, scout.Column);

/**
 * @override
 */
scout.IconColumn.prototype._initCell = function(cell) {
  scout.IconColumn.parent.prototype._initCell.call(this, cell);
  cell.text = null; // only display icon, no text
  cell.iconId = cell.value || cell.iconId;
  return cell;
};

/**
 * @override
 */
scout.IconColumn.prototype.cellTextForGrouping = function(row) {
  var cell = this.table.cell(this, row);
  return cell.value;
};

scout.IconColumn.prototype.createAggrGroupCell = function(row) {
  var cell = scout.IconColumn.parent.prototype.createAggrGroupCell.call(this, row);
  // Make sure only icon and no text is displayed
  cell.text = null;
  return cell;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.NumberColumn = function() {
  scout.NumberColumn.parent.call(this);
  this.filterType = 'NumberColumnUserFilter';
  this.comparator = scout.comparators.NUMERIC;
};
scout.inherits(scout.NumberColumn, scout.Column);

/**
 * @override Column.js
 */
scout.NumberColumn.prototype.init = function(model) {
  scout.NumberColumn.parent.prototype.init.call(this, model);
  if (!(this.decimalFormat instanceof scout.DecimalFormat)) {
    this.decimalFormat = new scout.DecimalFormat(this.session.locale, this.decimalFormat);
  }
};

/**
 * @override Column.js
 */
scout.NumberColumn.prototype._initCell = function(cell) {
  scout.NumberColumn.parent.prototype._initCell.call(this, cell);
  // server sends cell.value only if it differs from text -> make sure cell.value is set and has the right type
  // Cell.value may be undefined for other column types -> use table.cellValue to access the value.
  // The only reason is to save some memory (may get obsolete in the future)
  if (cell.value === undefined && cell.text) { // Number('') would generate 0 -> don't set in that case
    cell.value = Number(cell.text);
  }
};

/**
 * Override this method to create a cell model object based on the given scalar value.
 */
scout.NumberColumn.prototype._createCellModel = function(text) {
  var formattedNumber = this.decimalFormat.format(text);
  return {
    text: formattedNumber,
    value: text
  };
};

scout.NumberColumn.prototype.createAggrValueCell = function(value) {
  var formattedValue = this.decimalFormat.format(value);
  return this.initCell({
    text: formattedValue,
    iconId: (formattedValue ? this.aggrSymbol : null),
    horizontalAlignment: this.horizontalAlignment,
    cssClass: 'table-aggregate-cell'
  });
};

/**
 * @override Column.js
 */
scout.NumberColumn.prototype.cellValueForGrouping = function(row) {
  var cell = this.table.cell(this, row);
  return this._preprocessValueForGrouping(cell.value);
};

/**
 * @override Column.js
 */
scout.NumberColumn.prototype._preprocessValueForGrouping = function(value) {
  return this.decimalFormat.round(value);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SmartColumn = function() {
  scout.SmartColumn.parent.call(this);
  this.codeType;
  this.lookupCall;
};
scout.inherits(scout.SmartColumn, scout.Column);

/**
 * @override
 */
scout.SmartColumn.prototype.init = function(model) { // FIXME CGU eigentlich bruchte es ein _init
  scout.SmartColumn.parent.prototype.init.call(this, model);
  this._syncLookupCall(this.lookupCall);
};

scout.SmartColumn.prototype._syncLookupCall = function(lookupCall) {
  if (typeof lookupCall === 'string') {
    lookupCall = scout.create(lookupCall);
  }
  this.lookupCall = lookupCall;
};


scout.SmartColumn.prototype._createCellModel = function(id) {
  return {
    value: id
  };
};

scout.SmartColumn.prototype.initCell = function(model, row) {
  var cell = scout.SmartColumn.parent.prototype.initCell.call(this, model),
    value = cell.value;

  if (scout.objects.isNullOrUndefined(value)) {
    return cell;
  }

  // FIXME CGU This needs to be done as well if cell value changes
  // FIXME [awe, cgu] 6.1 - it's a bad idea to call updateRow here, because when a row and a cell is initialized and
  // the deferred is resolved immediately the table throws an error because the row is not yet added to the table :-(
  // check if (initialized) below
  this.lookupCall.textById(value).done(function(text) {
    cell.setText(text);
    if (this.table.rows.indexOf(row) > -1) { // add function hasRow()?
      this.table.updateRow(row);
    }
  }.bind(this));

  return cell;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableControl = function() {
  scout.TableControl.parent.call(this);
  this.tableFooter;
  this.contentRendered = false;
  this.height = scout.TableControl.CONTAINER_SIZE;
  this.animateDuration = scout.TableControl.CONTAINER_ANIMATE_DURATION;
  this.resizerVisible = true;
};
scout.inherits(scout.TableControl, scout.Action);

scout.TableControl.CONTAINER_SIZE = 345;
scout.TableControl.CONTAINER_ANIMATE_DURATION = 350;

scout.TableControl.prototype._init = function(model) {
  this.parent = model.parent;
  this.table = this.getTable();
  scout.TableControl.parent.prototype._init.call(this, model);
};

/**
 * @override
 */
scout.TableControl.prototype._initKeyStrokeContext = function() {
  scout.TableControl.parent.prototype._initKeyStrokeContext.call(this);

  this.tableControlKeyStrokeContext = this._createKeyStrokeContextForTableControl();
};

scout.TableControl.prototype._createKeyStrokeContextForTableControl = function() {
  var keyStrokeContext = new scout.KeyStrokeContext();
  keyStrokeContext.$scopeTarget = function() {
    return this.tableFooter.$controlContent;
  }.bind(this);
  keyStrokeContext.$bindTarget = function() {
    return this.tableFooter.$controlContent;
  }.bind(this);
  keyStrokeContext.registerKeyStroke(new scout.TableControlCloseKeyStroke(this));
  return keyStrokeContext;
};

scout.TableControl.prototype._createLayout = function() {
  return new scout.NullLayout();
};

scout.TableControl.prototype._render = function($parent) {
  var classes = 'table-control ';
  if (this.cssClass) {
    classes += this.cssClass + '-table-control';
  }
  this.$container = $parent.appendDiv(classes)
    .on('mousedown', this._onMouseDown.bind(this))
    .data('control', this);
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(this._createLayout());
};

scout.TableControl.prototype.remove = function() {
  this.removeContent();
  scout.TableControl.parent.prototype.remove.call(this);
};

scout.TableControl.prototype._renderContent = function($parent) {
  // to be implemented by subclass
};

scout.TableControl.prototype._removeContent = function() {
  // to be implemented by subclass
};

scout.TableControl.prototype.removeContent = function() {
  if (this.contentRendered) {
    this._removeContent();
    if (this.cssClass) {
      this.tableFooter.$controlContainer.removeClass(this.cssClass + '-table-control-container');
      this.tableFooter.$controlContent.removeClass(this.cssClass + '-table-control-content');
    }
    this.session.keyStrokeManager.uninstallKeyStrokeContext(this.tableControlKeyStrokeContext);
    this.contentRendered = false;
  }
};

/**
 * Renders the content if not already rendered.<br>
 * Opens the container if the container is not already open.<br>
 * Does nothing if the content is not available yet to -> don't open container if content is not rendered yet to prevent blank container or laggy opening.
 */
scout.TableControl.prototype.renderContent = function() {
  if (!this.contentRendered && !this.isContentAvailable()) {
    return;
  }

  if (!this.tableFooter.open) {
    this.tableFooter.openControlContainer(this);
  }

  if (!this.contentRendered) {
    if (this.cssClass) {
      this.tableFooter.$controlContainer.addClass(this.cssClass + '-table-control-container');
      this.tableFooter.$controlContent.addClass(this.cssClass + '-table-control-content');
    }
    this._renderContent(this.tableFooter.$controlContent);
    this.session.keyStrokeManager.installKeyStrokeContext(this.tableControlKeyStrokeContext);
    if (this.htmlComp) {
      this.htmlComp.invalidateLayoutTree(false);
    }
    this.contentRendered = true;
  }
};

scout.TableControl.prototype._renderSelected = function(selected, closeWhenUnselected) {
  selected = scout.nvl(selected, this.selected);
  closeWhenUnselected = scout.nvl(closeWhenUnselected, true);

  this.$container.select(selected);

  if (selected) {
    this.tableFooter.onControlSelected(this);
    this.renderContent();
  } else {

    // Don't modify the state initially, only on property change events
    if (this.rendered) {

      if (closeWhenUnselected && this === this.tableFooter.selectedControl) {
        // Don't remove immediately, wait for the animation to finish (handled by onControlContainerClosed)
        this.tableFooter.onControlSelected(null);
        this.tableFooter.closeControlContainer(this);
      } else {
        this.removeContent();
      }

    }
  }
  this._updateTooltip();
};

/**
 * Returns true if the table control may be displayed (opened).
 */
scout.TableControl.prototype.isContentAvailable = function() {
  return true;
};

scout.TableControl.prototype.toggle = function() {
  if(!this.enabled){
    return;
  }
  if (this.tableFooter.selectedControl === this) {
    this.setSelected(false);
  } else {
    this.setSelected(true);
  }
};

scout.TableControl.prototype.setSelected = function(selected, closeWhenUnselected) {
  if (selected && !this.visible) {
    return;
  }
  if (selected === this.selected) {
    return;
  }

  if (this.tableFooter && this.tableFooter.selectedControl && this.tableFooter.selectedControl !== this) {
    this.tableFooter.selectedControl.setSelected(false, false);
  }

  // Instead of calling parent.setSelected(), we manually execute the required code. Otherwise
  // we would not be able to pass 'closeWhenUnselected' to _renderSelected().
  this._setProperty('selected', selected);
  if (this.rendered) {
    this._renderSelected(selected, closeWhenUnselected);
  }
};

scout.TableControl.prototype._configureTooltip = function() {
  var options = scout.TableControl.parent.prototype._configureTooltip.call(this);
  options.cssClass = 'table-control-tooltip';
  return options;
};

scout.TableControl.prototype._onMouseDown = function() {
  this.toggle();
};

scout.TableControl.prototype.onControlContainerOpened = function() {
  // nop
};

scout.TableControl.prototype.onControlContainerClosed = function() {
  this.removeContent();
};

/**
 * @override Action.js
 */
scout.TableControl.prototype._createActionKeyStroke = function() {
  return new scout.TableControlActionKeyStroke(this);
};

scout.TableControl.prototype.getTable = function() {
  var parent = this.parent;
  while (parent) {
    if (parent instanceof scout.Table) {
      return parent;
    }
    parent = parent.parent;
  }

  return null;
};


/**
 * TableControlActionKeyStroke
 */
scout.TableControlActionKeyStroke = function(action) {
  scout.TableControlActionKeyStroke.parent.call(this, action);
  this.renderingHints.offset = 6;
};
scout.inherits(scout.TableControlActionKeyStroke, scout.ActionKeyStroke);

scout.TableControlActionKeyStroke.prototype.handle = function(event) {
  this.field.toggle();
};

scout.TableControlActionKeyStroke.prototype._postRenderKeyBox = function($drawingArea) {
  if (this.field.iconId) {
    var wIcon = $drawingArea.find('.icon').width();
    var wKeybox = $drawingArea.find('.key-box').outerWidth();
    var containerPadding = Number($drawingArea.css('padding-left').replace('px', ''));
    var leftKeyBox = wIcon / 2 - wKeybox / 2 + containerPadding;
    $drawingArea.find('.key-box').css('left', leftKeyBox + 'px');
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableControlAdapter = function() {
  scout.TableControlAdapter.parent.call(this);
};
scout.inherits(scout.TableControlAdapter, scout.ActionAdapter);

scout.TableControlAdapter.prototype._goOffline = function() {
  if (this.widget.isContentAvailable()) {
    return;
  }
  this._enabledBeforeOffline = this.widget.enabled;
  this.widget.setEnabled(false);
};

scout.TableControlAdapter.prototype._goOnline = function() {
  if (this.widget.isContentAvailable()) {
    return;
  }
  this.widget.setEnabled(this._enabledBeforeOffline);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableControlAdapterMenu = function() {
  scout.TableControlAdapterMenu.parent.call(this);

  this._tableControlPropertyChangeHandler = this._onTableControlPropertyChange.bind(this);
  this._tableControlDestroyHandler = this._onTableControlDestroy.bind(this);

  this._addCloneProperties(['tableControl']);
};
scout.inherits(scout.TableControlAdapterMenu, scout.FormMenu);

/**
 * @override Action.js
 */
scout.TableControlAdapterMenu.prototype._init = function(model) {
  scout.TableControlAdapterMenu.parent.prototype._init.call(this, model);
  if (!this.tableControl) {
    throw new Error('Cannot adapt to undefined tableControl');
  }
  this._installListeners();
};

scout.TableControlAdapterMenu.prototype._installListeners = function() {
  this.tableControl.on('propertyChange', this._tableControlPropertyChangeHandler);
  this.tableControl.on('destroy', this._tableControlDestroyHandler);
};

scout.TableControlAdapterMenu.prototype._uninstallListeners = function() {
  this.tableControl.off('propertyChange', this._tableControlPropertyChangeHandler);
  this.tableControl.off('destroy', this._tableControlDestroyHandler);
};

scout.TableControlAdapterMenu.prototype._render = function($parent) {
  scout.TableControlAdapterMenu.parent.prototype._render.call(this, $parent);
  // Convenience: Add ID of original tableControl to DOM for debugging purposes
  this.$container.attr('data-tableControlAdapter', this.tableControl.id);
};

scout.TableControlAdapterMenu.prototype._onTableControlPropertyChange = function(event) {
  // Whenever a tableControl property changes, apply the changes to the menu
  var changedProperties = {};
  event.changedProperties.forEach(function(prop) {
    changedProperties[prop] = event.newProperties[prop];
  });
  changedProperties = scout.TableControlAdapterMenu.adaptTableControlProperties(changedProperties);
  for (var prop in changedProperties) { // NOSONAR
    this.setProperty(prop, changedProperties[prop]);
  }
};

scout.TableControlAdapterMenu.prototype._onTableControlDestroy = function(event) {
  this.destroy();
  this._uninstallListeners();
};

/**
 * @override Action.js
 */
scout.TableControlAdapterMenu.prototype.doAction = function() {
  return this.tableControl.doAction();
};

/**
 * @override Action.js
 */
scout.TableControlAdapterMenu.prototype.setSelected = function(selected) {
  this.tableControl.setSelected(selected);
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * @memberOf scout.TableControlAdapterMenu
 */
scout.TableControlAdapterMenu.adaptTableControlProperties = function(tableControlProperties, menuProperties) {
  menuProperties = menuProperties || {};

  // Plain properties: simply copy, no translation required
  ['text', 'iconId', 'enabled', 'visible', 'selected', 'tooltipText', 'keyStroke', 'keyStrokes', 'modelClass', 'classId', 'form'].forEach(function(prop) {
    menuProperties[prop] = tableControlProperties[prop];
  });

  // Cleanup: Remove all properties that have value 'undefined' from the result object,
  // otherwise, they would be applied to the model adapter.
  for (var prop in menuProperties) {
    if (menuProperties[prop] === undefined) {
      delete menuProperties[prop];
    }
  }
  return menuProperties;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
// (c) Copyright 2013-2014, BSI Business Systems Integration AG

scout.AggregateTableControl = function() {
  scout.AggregateTableControl.parent.call(this);
  this._tableDataScrollHandler = this._onTableDataScroll.bind(this);
  this._tableRowsChangedHandler = this._onTableRowsChanged.bind(this);
  this._tableRowsFilteredHandler = this._onTableRowsFiltered.bind(this);
  this._tableRowsSelectedHandler = this._onTableRowsSelected.bind(this);
  this._tableColumnResizedHandler = this._onTableColumnResized.bind(this);
  this._tableColumnMovedHandler = this._onTableColumnMoved.bind(this);
  this._tableColumnStructureChangedHandler = this._onTableColumnStructureChanged.bind(this);
  this._tableAggregationFunctionHandler = this._onTableAggregationFunctionChanged.bind(this);
  this._tableGroupingHandler = this._onTableGroupingChanged.bind(this);
  this.cssClass = 'aggregate';
  this.height = scout.AggregateTableControl.CONTAINER_SIZE;
  this.animateDuration = scout.AggregateTableControl.CONTAINER_ANIMATE_DURATION;
  this.resizerVisible = false;
  this.aggregateRow;
};
scout.inherits(scout.AggregateTableControl, scout.TableControl);

scout.AggregateTableControl.CONTAINER_SIZE = 40;
scout.AggregateTableControl.CONTAINER_ANIMATE_DURATION = 200;

scout.AggregateTableControl.prototype._init = function(model) {
  scout.AggregateTableControl.parent.prototype._init.call(this, model);

  this.table.on('columnStructureChanged', this._tableColumnStructureChangedHandler);
};

scout.AggregateTableControl.prototype.destroy = function() {
  scout.AggregateTableControl.parent.prototype.destroy.call(this);

  this.table.off('columnStructureChanged', this._tableColumnStructureChangedHandler);
};

scout.AggregateTableControl.prototype._render = function($parent) {
  scout.AggregateTableControl.parent.prototype._render.call(this, $parent);

  this._updateEnabledAndSelectedState();
};

scout.AggregateTableControl.prototype._renderContent = function($parent) {
  this.$contentContainer = $parent.appendDiv('table-aggregate');

  this._aggregate();
  this._renderAggregate();
  this._reconcileScrollPos();

  this.table.$data.on('scroll', this._tableDataScrollHandler);
  this.table.on('rowsInserted', this._tableRowsChangedHandler);
  this.table.on('rowsDeleted', this._tableRowsChangedHandler);
  this.table.on('allRowsDeleted', this._tableRowsChangedHandler);
  this.table.on('rowsFiltered', this._tableRowsFilteredHandler);
  this.table.on('rowsSelected', this._tableRowsSelectedHandler);
  this.table.on('columnResized', this._tableColumnResizedHandler);
  this.table.on('columnMoved', this._tableColumnMovedHandler);
  this.table.on('aggregationFunctionChanged', this._tableAggregationFunctionHandler);
  this.table.on('groupingChanged', this._tableGroupingHandler);
};

scout.AggregateTableControl.prototype._removeContent = function() {
  this.$contentContainer.remove();

  this.table.$data.off('scroll', this._tableDataScrollHandler);
  this.table.off('rowsInserted', this._tableRowsChangedHandler);
  this.table.off('rowsDeleted', this._tableRowsChangedHandler);
  this.table.off('allRowsDeleted', this._tableRowsChangedHandler);
  this.table.off('rowsFiltered', this._tableRowsFilteredHandler);
  this.table.off('rowsSelected', this._tableRowsSelectedHandler);
  this.table.off('columnResized', this._tableColumnResizedHandler);
  this.table.off('columnMoved', this._tableColumnMovedHandler);
  this.table.off('aggregationFunctionChanged', this._tableAggregationFunctionHandler);
  this.table.off('groupingChanged', this._tableGroupingHandler);
};

scout.AggregateTableControl.prototype._renderAggregate = function() {
  this.table.columns.forEach(function(column, c) {
    var aggregateValue, cell, $cell;

    aggregateValue = this.aggregateRow[c];
    // Aggregation functions are not available if column is grouped -> do not show aggregated value
    if (aggregateValue === undefined || aggregateValue === null || column.grouped) {
      cell = column.createAggrEmptyCell();
    } else {
      cell = column.createAggrValueCell(aggregateValue);
    }
    $cell = $(column.buildCell(cell, {}));

    // If aggregation is based on the selection and not on all rows -> mark it
    if (this.aggregateRow.selection) {
      $cell.addClass('selection');
    }

    $cell.appendTo(this.$contentContainer);
  }, this);

  if (this.aggregateRow.selection) {
    this.$contentContainer.addClass('selection');
  }
};

scout.AggregateTableControl.prototype._rerenderAggregate = function() {
  this.$contentContainer.empty();
  this._renderAggregate();
};

scout.AggregateTableControl.prototype._aggregate = function() {
  var rows,
    aggregateRow = [],
    selectedRows = this.table.selectedRows;

  if (selectedRows.length > 1) {
    rows = selectedRows;
    aggregateRow.selection = true;
  } else {
    rows = this.table.filteredRows();
  }

  this.table._forEachColumn('aggrStart', aggregateRow);
  rows.forEach(function(row) {
    this.table._forEachColumn('aggrStep', aggregateRow, row);
  }, this);
  this.table._forEachColumn('aggrFinish', aggregateRow);

  this.aggregateRow = aggregateRow;
};

scout.AggregateTableControl.prototype._reconcileScrollPos = function() {
  // When scrolling horizontally scroll aggregate content as well
  var scrollLeft = this.table.$data.scrollLeft();
  this.$contentContainer.scrollLeft(scrollLeft);
};

scout.AggregateTableControl.prototype._updateEnabledAndSelectedState = function() {
  var enabled = this.table.containsNumberColumn();
  // Make sure a disabled control is not selected
  if (!enabled && this.selected) {
    this.setSelected(false);
  }
  this.setEnabled(enabled);
};

scout.AggregateTableControl.prototype._syncEnabled = function(enabled) {
  this._setProperty('enabled', enabled);
  this._updateEnabledAndSelectedState();
};

scout.AggregateTableControl.prototype._syncSelected = function(selected) {
  this._setProperty('selected', selected);
  this._updateEnabledAndSelectedState();
};

scout.AggregateTableControl.prototype._onTableDataScroll = function() {
  this._reconcileScrollPos();
};

scout.AggregateTableControl.prototype._onTableRowsChanged = function(event) {
  this._aggregate();
  this._rerenderAggregate();
};

scout.AggregateTableControl.prototype._onTableRowsFiltered = function(event) {
  this._aggregate();
  this._rerenderAggregate();
};

scout.AggregateTableControl.prototype._onTableRowsSelected = function(event) {
  this._aggregate();
  this._rerenderAggregate();
};

scout.AggregateTableControl.prototype._onTableColumnResized = function(event) {
  this._rerenderAggregate();
};

scout.AggregateTableControl.prototype._onTableColumnMoved = function(event) {
  // move aggregated value in aggregateRow
  scout.arrays.move(this.aggregateRow, event.oldPos, event.newPos);
  this._rerenderAggregate();
};

scout.AggregateTableControl.prototype._onTableColumnStructureChanged = function(event) {
  this._updateEnabledAndSelectedState();
  if (this.selected && this.rendered) {
    this._aggregate();
    this._rerenderAggregate();
  }
};

scout.AggregateTableControl.prototype._onTableAggregationFunctionChanged = function(event) {
  this._aggregate();
  this._rerenderAggregate();
};

scout.AggregateTableControl.prototype._onTableGroupingChanged = function(event) {
  this._aggregate();
  this._rerenderAggregate();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AggregateTableControlAdapter = function() {
  scout.AggregateTableControlAdapter.parent.call(this);
};
scout.inherits(scout.AggregateTableControlAdapter, scout.TableControlAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormTableControl = function() {
  scout.FormTableControl.parent.call(this);
  this._addAdapterProperties('form');
};
scout.inherits(scout.FormTableControl, scout.TableControl);

scout.FormTableControl.prototype._init = function(model) {
  scout.FormTableControl.parent.prototype._init.call(this, model);
  this._syncForm(this.form);
};

scout.FormTableControl.prototype._createLayout = function() {
  return new scout.FormTableControlLayout(this);
};

scout.FormTableControl.prototype._renderContent = function($parent) {
  this.form.renderInitialFocusEnabled = false;
  this.form.render($parent);

  // Tab box gets a special style if it is the first field in the root group box
  var rootGroupBox = this.form.rootGroupBox;
  if (rootGroupBox.fields[0] instanceof scout.TabBox) {
    rootGroupBox.fields[0].$container.addClass('in-table-control');
  }

  this.form.$container.height($parent.height());
  this.form.$container.width($parent.width());
  this.form.htmlComp.pixelBasedSizing = true;
  this.form.htmlComp.validateRoot = true;
  this.form.htmlComp.validateLayout();
};

scout.FormTableControl.prototype._removeContent = function() {
  this.form.remove();
};

scout.FormTableControl.prototype._removeForm = function() {
  this.removeContent();
};

scout.FormTableControl.prototype._renderForm = function(form) {
  this.renderContent();
};

/**
 * Returns true if the table control may be displayed (opened).
 */
scout.FormTableControl.prototype.isContentAvailable = function() {
  return !!this.form;
};

scout.FormTableControl.prototype._syncForm = function(form) {
  if (form) {
    form.rootGroupBox.menuBar.bottom();
  }
  this._setProperty('form', form);
};

scout.FormTableControl.prototype.onControlContainerOpened = function() {
  // TODO [5.2] dwi: temporary solution; set focus to last known position
  this.form.renderInitialFocus();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormTableControlAdapter = function() {
  scout.FormTableControlAdapter.parent.call(this);
  this._addAdapterProperties('form');
};
scout.inherits(scout.FormTableControlAdapter, scout.TableControlAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormTableControlLayout = function(control) {
  scout.FormTableControlLayout.parent.call(this);
  this.control = control;
};
scout.inherits(scout.FormTableControlLayout, scout.AbstractLayout);

scout.FormTableControlLayout.prototype.layout = function($container) {
  if (!this.control.contentRendered) {
    return;
  }

  var formSize,
    controlContentSize = scout.graphics.getSize(this.control.tableFooter.$controlContent);

  if (this.control.form) {
    var htmlForm = this.control.form.htmlComp;
    formSize = controlContentSize.subtract(htmlForm.getMargins());
    htmlForm.setSize(formSize);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CellEditorPopup = function() {
  scout.CellEditorPopup.parent.call(this);
  this.table;
  this.column;
  this.row;
  this.cell;
};
scout.inherits(scout.CellEditorPopup, scout.Popup);

scout.CellEditorPopup.prototype._init = function(options) {
  options.scrollType = options.scrollType || 'position';
  scout.CellEditorPopup.parent.prototype._init.call(this, options);

  this.table = options.column.table;
  this.column = options.column;
  this.row = options.row;
  this.cell = options.cell;
  this.link(this.cell.field);
};

scout.CellEditorPopup.prototype._createLayout = function() {
  return new scout.CellEditorPopupLayout(this);
};

/**
 * @override
 */
scout.CellEditorPopup.prototype._initKeyStrokeContext = function() {
  scout.CellEditorPopup.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([
    new scout.CellEditorCompleteEditKeyStroke(this),
    new scout.CellEditorTabKeyStroke(this)
  ]);
};

/**
 * @override Popup.js
 */
scout.CellEditorPopup.prototype._createCloseKeyStroke = function() {
  return new scout.CellEditorCancelEditKeyStroke(this);
};

/**
 * @override
 */
scout.CellEditorPopup.prototype._open = function($parent, event) {
  this.render($parent, event);
  this.position();
  this.pack();
};

scout.CellEditorPopup.prototype._render = function($parent) {
  scout.CellEditorPopup.parent.prototype._render.call(this, $parent);

  var firstCell = this.table.columns.indexOf(this.column) === 0;
  this.$container.addClass('cell-editor-popup');
  this.$container.data('popup', this);
  if (firstCell) {
    this.$container.addClass('first');
  }

  var field = this.cell.field;
  field.mode = scout.FormField.MODE_CELLEDITOR; // hint that this field is used within a cell-editor
  field.render(this.$container);
  field.prepareForCellEdit({
    firstCell: firstCell
  });

  // Make sure cell content is not visible while the editor is open (especially necessary for transparent editors like checkboxes)
  this.$anchor.css('visibility', 'hidden');

  this._rowOrderChangedFunc = function(event) {
    if (event.animating) {
      // row is only set while animating
      if (event.row === this.row) {
        this.position();
      }
    } else {
      this.position();
    }
  }.bind(this);
  this.table.on('rowOrderChanged', this._rowOrderChangedFunc);
  // Set table style to focused, so that it looks as it still has the focus.
  // This prevents flickering if the cell editor gets opened, especially when tabbing to the next cell editor.
  if (this.table.enabled) {
    this.table.$container.addClass('focused');
  }
};

scout.CellEditorPopup.prototype._postRender = function() {
  scout.CellEditorPopup.parent.prototype._postRender.call(this); // installs the focus context for this popup

  // If applicable, invoke the field's function 'onCellEditorRendered' to signal the cell-editor to be rendered.
  var field = this.cell.field;
  if (field.onCellEditorRendered) {
    field.onCellEditorRendered({
      openFieldPopup: this.table.openFieldPopupOnCellEdit
    });
  }
};

scout.CellEditorPopup.prototype._remove = function() {
  scout.CellEditorPopup.parent.prototype._remove.call(this); // uninstalls the focus context for this popup

  this.table.off('rowOrderChanged', this._rowOrderChangedFunc);
  // table may have been removed in the meantime
  if (this.table.rendered) {
    this.table.$container.removeClass('focused');
  }
  this.$anchor.css('visibility', '');
};

scout.CellEditorPopup.prototype.position = function() {
  var cellBounds, rowBounds,
    $tableData = this.table.$data,
    $row = this.row.$row,
    $cell = this.$anchor,
    insetsLeft = $tableData.cssPxValue('padding-left') + $row.cssBorderLeftWidth();

  cellBounds = scout.graphics.bounds($cell, false, true);
  rowBounds = scout.graphics.bounds($row, false, true);
  this.setLocation(new scout.Point(insetsLeft + cellBounds.x, $tableData.scrollTop() + rowBounds.y));
};

scout.CellEditorPopup.prototype.completeEdit = function() {
  var field = this.cell.field;
  if (this.completeCellEditRequested) {
    // Make sure complete cell edit does not get sent twice since it will lead to exceptions. This may happen if user clicks very fast multiple times.
    return;
  }

  // There is no blur event when the popup gets closed -> trigger blur so that the field may react (accept display text, close popups etc.)
  field.acceptInput();

  this.table.completeCellEdit(field);
  this.completeCellEditRequested = true;
};

scout.CellEditorPopup.prototype.cancelEdit = function() {
  this.table.cancelCellEdit(this.cell.field);
  this.remove();
};

scout.CellEditorPopup.prototype._onMouseDownOutside = function(event) {
  this.completeEdit();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CellEditorPopupLayout = function(cellEditorPopup) {
  scout.CellEditorPopupLayout.parent.call(this);
  this.cellEditorPopup = cellEditorPopup;
  this._field = cellEditorPopup.cell.field;
  this._htmlContainer = cellEditorPopup.htmlComp;
};
scout.inherits(scout.CellEditorPopupLayout, scout.AbstractLayout);

scout.CellEditorPopupLayout.prototype.layout = function($container) {
  var size,
    htmlField = this._field.htmlComp;

  size = this._htmlContainer.getAvailableSize()
    .subtract(this._htmlContainer.getInsets())
    .subtract(htmlField.getMargins());
  htmlField.setSize(size);
};

scout.CellEditorPopupLayout.prototype.preferredLayoutSize = function($container) {
  var cellBounds, rowBounds, margin,
    $row = this.cellEditorPopup.row.$row,
    $cell = this.cellEditorPopup.$anchor;

  cellBounds = scout.graphics.bounds($cell, false, true);
  rowBounds = scout.graphics.bounds($row, false, true);
  margin = this.cellEditorPopup.$container.cssMarginLeft();
  if (margin < 0) {
    // extend the width if the popup has a negative margin (used for the first cell)
    cellBounds.width = cellBounds.width + -margin;
  }
  return new scout.Dimension(cellBounds.width, rowBounds.height);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CellEditorCancelEditKeyStroke = function(popup) {
  scout.CellEditorCancelEditKeyStroke.parent.call(this);
  this.field = popup;
  this.which = [scout.keys.ESC];
  this.stopPropagation = true;
};
scout.inherits(scout.CellEditorCancelEditKeyStroke, scout.KeyStroke);

scout.CellEditorCancelEditKeyStroke.prototype.handle = function(event) {
  this.field.cancelEdit();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CellEditorCompleteEditKeyStroke = function(popup) {
  scout.CellEditorCompleteEditKeyStroke.parent.call(this);
  this.field = popup;
  this.which = [scout.keys.ENTER];
  this.stopPropagation = true;
};
scout.inherits(scout.CellEditorCompleteEditKeyStroke, scout.KeyStroke);

scout.CellEditorCompleteEditKeyStroke.prototype.handle = function(event) {
  this.field.completeEdit();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CellEditorTabKeyStroke = function(popup) {
  scout.CellEditorTabKeyStroke.parent.call(this);
  this.field = popup;
  this.which = [scout.keys.TAB];
  this.shift = undefined; // to tab forward and backward
};
scout.inherits(scout.CellEditorTabKeyStroke, scout.KeyStroke);

scout.CellEditorTabKeyStroke.prototype._accept = function(event) {
  var accepted = scout.CellEditorTabKeyStroke.parent.prototype._accept.call(this, event);
  return accepted && !this.field.completeCellEditRequested; // Make sure events (complete, prepare) don't get sent twice since it will lead to exceptions. This may happen if user presses and holds the tab key.
};

scout.CellEditorTabKeyStroke.prototype.handle = function(event) {
  var pos,
    backwards = event.shiftKey,
    table = this.field.table,
    column = this.field.column,
    row = this.field.row;

  this.field.completeEdit();

  pos = table.nextEditableCellPos(column, row, backwards);
  if (pos) {
    table.prepareCellEdit(pos.column, pos.row);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AbstractTableNavigationKeyStroke = function(table) {
  scout.AbstractTableNavigationKeyStroke.parent.call(this);
  this.repeatable = true;
  this.field = table;
  this.shift = table.multiSelect ? undefined : false; // multiselect tables have both, shift and not-shift functionality
  this.stopPropagation = true;
  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
};
scout.inherits(scout.AbstractTableNavigationKeyStroke, scout.KeyStroke);

scout.AbstractTableNavigationKeyStroke.prototype._accept = function(event) {
  var accepted = scout.AbstractTableNavigationKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted) {
    return false;
  }

  if (!this.field.filteredRows().length) {
    return false;
  }

  var activeElement = this.field.$container.activeElement(true),
    elementType = activeElement.tagName.toLowerCase();
  if (activeElement.className !== 'table-text-filter' &&
    (elementType === 'textarea' || elementType === 'input') &&
    (!event.originalEvent || (event.originalEvent && !event.originalEvent.smartFieldEvent))) {
    return false;
  }

  return true;
};

/**
 * Returns viewport sensitive information containing the first and last visible row in the viewport.
 */
scout.AbstractTableNavigationKeyStroke.prototype._viewportInfo = function() {
  var x, y, viewportBounds, dataInsets, dataMarginTop, firstRow, lastRow,
    table = this.field,
    viewport = {},
    rows = table.filteredRows();

  if (rows.length === 0) {
    return viewport;
  }

  viewportBounds = scout.graphics.offsetBounds(table.$data);
  dataInsets = scout.graphics.getInsets(table.$data);
  dataMarginTop = table.$data.cssMarginTop();
  viewportBounds = viewportBounds.subtract(dataInsets);

  // if data has a negative margin, adjust viewport otherwise a selected first row will never be in the viewport
  if (dataMarginTop < 0) {
    viewportBounds.y -= Math.abs(dataMarginTop);
    viewportBounds.height += Math.abs(dataMarginTop);
  }

  // get first element at the top of the viewport
  x = viewportBounds.x + 1;
  y = viewportBounds.y + 1;

  firstRow = this._findFirstRowInViewport(table, viewportBounds);
  lastRow = this._findLastRowInViewport(table, rows.indexOf(firstRow), viewportBounds);

  viewport.firstRow = firstRow;
  viewport.lastRow = lastRow;
  return viewport;
};

scout.AbstractTableNavigationKeyStroke.prototype.firstRowAfterSelection = function() {
  var $selectedRows = this.field.$selectedRows();
  if (!$selectedRows.length) {
    return;
  }

  var rows = this.field.filteredRows(),
    row = $selectedRows.last().data('row'),
    rowIndex = this.field.filteredRows().indexOf(row);

  return rows[rowIndex + 1];
};

scout.AbstractTableNavigationKeyStroke.prototype.firstRowBeforeSelection = function() {
  var $selectedRows = this.field.$selectedRows();
  if (!$selectedRows.length) {
    return;
  }
  var rows = this.field.filteredRows(),
    row = $selectedRows.first().data('row'),
    rowIndex = this.field.filteredRows().indexOf(row);

  return rows[rowIndex - 1];
};

/**
 * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.
 */
scout.AbstractTableNavigationKeyStroke.prototype._findLastSelectedRowBefore = function(table, rowIndex) {
  var row, rows = table.filteredRows();
  if (rowIndex === 0) {
    return rows[rowIndex];
  }
  row = scout.arrays.findFromPrev(rows, rowIndex, function(row, i) {
    var previousRow = rows[i - 1];
    if (!previousRow) {
      return false;
    }
    return !table.isRowSelected(previousRow);
  });
  // when no row has been found, use first row in table
  if (!row) {
    row = rows[0];
  }
  return row;
};

/**
 * Searches for the last selected row in the current selection block, starting from rowIndex. Expects row at rowIndex to be selected.
 */
scout.AbstractTableNavigationKeyStroke.prototype._findLastSelectedRowAfter = function(table, rowIndex) {
  var row, rows = table.filteredRows();
  if (rowIndex === rows.length - 1) {
    return rows[rowIndex];
  }
  row = scout.arrays.findFromPrev(rows, rowIndex, function(row, i) {
    var nextRow = rows[i + 1];
    if (!nextRow) {
      return false;
    }
    return !table.isRowSelected(nextRow);
  });
  // when no row has been found, use last row in table
  if (!row) {
    row = rows[rows.length - 1];
  }
  return row;
};

scout.AbstractTableNavigationKeyStroke.prototype._findFirstRowInViewport = function(table, viewportBounds) {
  var rows = table.filteredRows();
  return scout.arrays.find(rows, function(row, i) {
    var rowOffset, rowMarginTop,
      $row = row.$row;

    if (!row.$row) {
      // If row is not rendered, it cannot be part of the view port -> check next row
      return false;
    }
    rowOffset = $row.offset();
    rowMarginTop = row.$row.cssMarginTop();
    // Selected row has a negative row margin
    // -> add this margin to the offset to make sure this function does always return the same row independent of selection state
    if (rowMarginTop < 0) {
      rowOffset.top += Math.abs(rowMarginTop);
    }

    // If the row is fully visible in the viewport -> break and return the row
    return viewportBounds.contains(rowOffset.left, rowOffset.top);
  });
};

scout.AbstractTableNavigationKeyStroke.prototype._findLastRowInViewport = function(table, startRowIndex, viewportBounds) {
  var rows = table.filteredRows();
  if (startRowIndex === rows.length - 1) {
    return rows[startRowIndex];
  }
  return scout.arrays.findFromNext(rows, startRowIndex, function(row, i) {
    var nextRowOffsetBounds, $nextRow,
      nextRow = rows[i + 1];

    if (!nextRow) {
      // If next row is not available (row is the last row) -> break and return current row
      return true;
    }
    $nextRow = nextRow.$row;
    if (!$nextRow) {
      // If next row is not rendered anymore, current row has to be the last in the viewport
      return true;
    }
    nextRowOffsetBounds = scout.graphics.offsetBounds($nextRow);
    // If the next row is not fully visible in the viewport -> break and return current row
    return !viewportBounds.contains(nextRowOffsetBounds.x, nextRowOffsetBounds.y + nextRowOffsetBounds.height);
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableControlCloseKeyStroke = function(tableControl) {
  scout.TableControlCloseKeyStroke.parent.call(this);
  this.field = tableControl;
  this.which = [scout.keys.ESC];
  this.stopPropagation = true;
  this.renderingHints.render = false;
};
scout.inherits(scout.TableControlCloseKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.TableControlCloseKeyStroke.prototype.handle = function(event) {
  this.field.toggle();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableCopyKeyStroke = function(table) {
  scout.TableCopyKeyStroke.parent.call(this);
  this.field = table;
  this.which = [scout.keys.C];
  this.ctrl = true;
  this.renderingHints.render = false;
};
scout.inherits(scout.TableCopyKeyStroke, scout.KeyStroke);

scout.TableCopyKeyStroke.prototype.handle = function(event) {
  this.field.exportToClipboard();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableSelectAllKeyStroke = function(table) {
  scout.TableSelectAllKeyStroke.parent.call(this);
  this.field = table;
  this.ctrl = true;
  this.which = [scout.keys.A];
  this.renderingHints.offset = 14;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.field.footer ? this.field.footer._$infoSelection.find('.table-info-button') : null;
  }.bind(this);
};
scout.inherits(scout.TableSelectAllKeyStroke, scout.KeyStroke);

scout.TableSelectAllKeyStroke.prototype.handle = function(event) {
  var table = this.field;
  table.toggleSelection();
  table.selectionHandler.lastActionRow = null;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableStartCellEditKeyStroke = function(table) {
  scout.TableStartCellEditKeyStroke.parent.call(this);
  this.field = table;
  this.ctrl = true;
  this.which = [scout.keys.ENTER];
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var editPosition = event._editPosition;
    return this.field.$cell(editPosition.column, editPosition.row.$row);
  }.bind(this);
};
scout.inherits(scout.TableStartCellEditKeyStroke, scout.KeyStroke);

scout.TableStartCellEditKeyStroke.prototype._accept = function(event) {
  var accepted = scout.TableStartCellEditKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted) {
    return false;
  }

  var selectedRows = this.field.selectedRows;
  if (!selectedRows.length) {
    return false;
  }

  var position = this.field.nextEditableCellPosForRow(0, selectedRows[0]);
  if (position) {
    event._editPosition = position;
    return true;
  } else {
    return false;
  }
};

scout.TableStartCellEditKeyStroke.prototype.handle = function(event) {
  var editPosition = event._editPosition;
  this.field.prepareCellEdit(editPosition.column, editPosition.row, true);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableRefreshKeyStroke = function(table) {
  scout.TableRefreshKeyStroke.parent.call(this);
  this.field = table;
  this.which = [scout.keys.F5];
  this.renderingHints.offset = 14;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.field.footer ? this.field.footer._$infoLoad.find('.table-info-button') : null;
  }.bind(this);
};
scout.inherits(scout.TableRefreshKeyStroke, scout.KeyStroke);

scout.TableRefreshKeyStroke.prototype._accept = function(event) {
  var accepted = scout.TableRefreshKeyStroke.parent.prototype._accept.call(this, event);
  return accepted && this.field.hasReloadHandler;
};

scout.TableRefreshKeyStroke.prototype.handle = function(event) {
  this.field.reload();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableToggleRowKeyStroke = function(table) {
  scout.TableToggleRowKeyStroke.parent.call(this);
  this.field = table;

  this.which = [scout.keys.SPACE];
  this.stopPropagation = true;
  this.renderingHints.render = false;
};
scout.inherits(scout.TableToggleRowKeyStroke, scout.KeyStroke);

scout.TableToggleRowKeyStroke.prototype._accept = function(event) {
  var accepted = scout.TableToggleRowKeyStroke.parent.prototype._accept.call(this, event);
  return accepted &&
    this.field.checkable &&
    this.field.selectedRows.length;
};

scout.TableToggleRowKeyStroke.prototype.handle = function(event) {
  var table = this.field,
    selection = table.selectedRows;

  var checked = selection[0].checked;
  selection.forEach(function(row) {
    table.checkRow(row, !checked);
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableNavigationUpKeyStroke = function(table) {
  scout.TableNavigationUpKeyStroke.parent.call(this, table);
  this.which = [scout.keys.UP];
  this.renderingHints.text = '';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var row = this.firstRowBeforeSelection();
    if (row) {
      return row.$row;
    }
  }.bind(this);
};
scout.inherits(scout.TableNavigationUpKeyStroke, scout.AbstractTableNavigationKeyStroke);

scout.TableNavigationUpKeyStroke.prototype.handle = function(event) {
  var table = this.field,
    rows = table.filteredRows(),
    selectedRows = table.selectedRows,
    lastActionRow = table.selectionHandler.lastActionRow,
    lastActionRowIndex = -1,
    newActionRowIndex = -1,
    newSelectedRows, newActionRow;

  if (lastActionRow) {
    lastActionRowIndex = rows.indexOf(lastActionRow);
  }

  if (rows.length > 1 && (selectedRows.length > 0 || lastActionRowIndex > -1)) {
    // last action row index maybe < 0 if row got invisible (e.g. due to filtering), or if the user has not made a selection before
    if (lastActionRowIndex < 0) {
      if (rows.length === selectedRows.length){
        lastActionRow = scout.arrays.last(rows);
      } else {
        lastActionRow = scout.arrays.first(selectedRows);
      }
      lastActionRowIndex = rows.indexOf(lastActionRow);
    }
    if (lastActionRowIndex ===  0) {
      return;
    }

    newActionRowIndex = lastActionRowIndex - 1;
    newActionRow = rows[newActionRowIndex];
    newSelectedRows = [newActionRow];

    if (event.shiftKey) {
      if (table.isRowSelected(newActionRow)) {
        // if new action row already is selected, remove last action row from selection
        // use case: rows 2,3,4 are selected, last action row is 4. User presses shift-up -> rows 2,3 need to be the new selection
        newSelectedRows = [];
        scout.arrays.pushAll(newSelectedRows, selectedRows);
        scout.arrays.remove(newSelectedRows, lastActionRow);
      } else {
        newSelectedRows = scout.arrays.union(newSelectedRows, selectedRows);
        newActionRow = this._findLastSelectedRowBefore(table, newActionRowIndex);
      }
    }
  } else {
    newSelectedRows = [scout.arrays.last(rows)];
    newActionRow = newSelectedRows[0];
  }

  table.selectionHandler.lastActionRow = newActionRow;
  table.selectRows(newSelectedRows, true);
  table.scrollTo(newActionRow);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableNavigationDownKeyStroke = function(table) {
  scout.TableNavigationDownKeyStroke.parent.call(this, table);
  this.which = [scout.keys.DOWN];
  this.renderingHints.text = '';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var row = this.firstRowAfterSelection();
    if (row) {
      return row.$row;
    }
  }.bind(this);
};
scout.inherits(scout.TableNavigationDownKeyStroke, scout.AbstractTableNavigationKeyStroke);

scout.TableNavigationDownKeyStroke.prototype.handle = function(event) {
  var table = this.field,
    rows = table.filteredRows(),
    selectedRows = table.selectedRows,
    lastActionRow = table.selectionHandler.lastActionRow,
    lastActionRowIndex = -1,
    newActionRowIndex = -1,
    newSelectedRows, newActionRow;

  if (lastActionRow) {
    lastActionRowIndex = rows.indexOf(lastActionRow);
  }

  if (rows.length > 1 && (selectedRows.length > 0 || lastActionRowIndex > -1)) {
    // last action row index maybe < 0 if row got invisible (e.g. due to filtering), or if the user has not made a selection before
    if (lastActionRowIndex < 0) {
      if (rows.length === selectedRows.length){
        lastActionRow = scout.arrays.first(rows);
      } else {
        lastActionRow = scout.arrays.last(selectedRows);
      }
      lastActionRowIndex = rows.indexOf(lastActionRow);
    }
    if (lastActionRowIndex === rows.length - 1) {
      return;
    }

    newActionRowIndex = lastActionRowIndex + 1;
    newActionRow = rows[newActionRowIndex];
    newSelectedRows = [newActionRow];

    if (event.shiftKey) {
      if (table.isRowSelected(newActionRow)) {
        // if new action row already is selected, remove last action row from selection
        // use case: rows 2,3,4 are selected, last action row is 2. User presses shift-down -> rows 3,4 need to be the new selection
        newSelectedRows = [];
        scout.arrays.pushAll(newSelectedRows, selectedRows);
        scout.arrays.remove(newSelectedRows, lastActionRow);
      } else {
        newSelectedRows = scout.arrays.union(selectedRows, newSelectedRows);
        newActionRow = this._findLastSelectedRowAfter(table, newActionRowIndex);
      }
    }
  } else {
    newSelectedRows = [scout.arrays.first(rows)];
    newActionRow = newSelectedRows[0];
  }

  table.selectionHandler.lastActionRow = newActionRow;
  table.selectRows(newSelectedRows, true);
  table.scrollTo(newActionRow);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableNavigationHomeKeyStroke = function(table) {
  scout.TableNavigationHomeKeyStroke.parent.call(this, table);
  this.which = [scout.keys.HOME];
  this.renderingHints.text = 'Home';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var viewport = this._viewportInfo();
    if (viewport.firstRow) {
      return viewport.firstRow.$row;
    }
  }.bind(this);
};
scout.inherits(scout.TableNavigationHomeKeyStroke, scout.AbstractTableNavigationKeyStroke);

scout.TableNavigationHomeKeyStroke.prototype.handle = function(event) {
  var table = this.field,
    rows = table.filteredRows(),
    firstRow = scout.arrays.first(rows),
    selectedRows = table.selectedRows,
    newSelectedRows = [],
    lastActionRow = table.selectionHandler.lastActionRow,
    lastActionRowIndex = -1;

  if (event.shiftKey && selectedRows.length > 0) {
    if (lastActionRow) {
      lastActionRowIndex = rows.indexOf(lastActionRow);
    }
    // last action row index maybe < 0 if row got invisible (e.g. due to filtering), or if the user has not made a selection before
    if (lastActionRowIndex < 0) {
      lastActionRow = scout.arrays.first(selectedRows);
      lastActionRowIndex = rows.indexOf(lastActionRow);
    }
    newSelectedRows = rows.slice(0, lastActionRowIndex);
    newSelectedRows = scout.arrays.union(newSelectedRows, selectedRows);
  } else {
    newSelectedRows = firstRow;
  }
  table.selectionHandler.lastActionRow = firstRow;
  table.selectRows(newSelectedRows);
  table.scrollTo(firstRow);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableNavigationEndKeyStroke = function(table) {
  scout.TableNavigationEndKeyStroke.parent.call(this, table);
  this.which = [scout.keys.END];
  this.renderingHints.text = 'End';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var viewport = this._viewportInfo();
    if (viewport.lastRow) {
      return viewport.lastRow.$row;
    }
  }.bind(this);
};
scout.inherits(scout.TableNavigationEndKeyStroke, scout.AbstractTableNavigationKeyStroke);

scout.TableNavigationEndKeyStroke.prototype.handle = function(event) {
  var table = this.field,
    rows = table.filteredRows(),
    lastRow = scout.arrays.last(rows),
    selectedRows = table.selectedRows,
    newSelectedRows = [],
    lastActionRow = table.selectionHandler.lastActionRow,
    lastActionRowIndex = -1;

  if (event.shiftKey && selectedRows.length > 0) {
    if (lastActionRow) {
      lastActionRowIndex = rows.indexOf(lastActionRow);
    }
    // last action row index maybe < 0 if row got invisible (e.g. due to filtering), or if the user has not made a selection before
    if (lastActionRowIndex < 0) {
      lastActionRow = scout.arrays.last(selectedRows);
      lastActionRowIndex = rows.indexOf(lastActionRow);
    }
    newSelectedRows = rows.slice(lastActionRowIndex + 1, rows.length);
    newSelectedRows = scout.arrays.union(selectedRows, newSelectedRows);
  } else {
    newSelectedRows = lastRow;
  }
  table.selectionHandler.lastActionRow = lastRow;
  table.selectRows(newSelectedRows);
  table.scrollTo(lastRow);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableNavigationPageUpKeyStroke = function(table) {
  scout.TableNavigationPageUpKeyStroke.parent.call(this, table);
  this.which = [scout.keys.PAGE_UP];
  this.renderingHints.text = 'PgUp';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var viewport = this._viewportInfo();
    if (viewport.firstRow) {
      return viewport.firstRow.$row;
    }
  }.bind(this);
};
scout.inherits(scout.TableNavigationPageUpKeyStroke, scout.AbstractTableNavigationKeyStroke);

scout.TableNavigationPageUpKeyStroke.prototype.handle = function(event) {
  var table = this.field,
    viewport = this._viewportInfo(),
    rows = table.filteredRows(),
    selectedRows = table.selectedRows,
    firstSelectedRow = scout.arrays.first(selectedRows),
    lastActionRow = table.selectionHandler.lastActionRow,
    lastActionRowIndex = -1,
    newSelectedRows;

  // First row may be undefined if there is only one row visible in the viewport and this row is bigger than the viewport. In that case just scroll up.
  // If it already is at the top nothing will happen
  if (!viewport.firstRow) {
    table.scrollPageUp();
    viewport = this._viewportInfo();
    if (!viewport.firstRow) {
      return;
    }
  }

  if (lastActionRow) {
    lastActionRowIndex = rows.indexOf(lastActionRow);
  }
  // last action row index maybe < 0 if row got invisible (e.g. due to filtering), or if the user has not made a selection before
  if (lastActionRowIndex < 0) {
    lastActionRow = firstSelectedRow;
    lastActionRowIndex = rows.indexOf(lastActionRow);
  }

  // If first row in viewport already is selected -> scroll a page up
  // Don't do it if multiple rows are selected and user only presses page up without shift
  if (selectedRows.length > 0 && lastActionRow === viewport.firstRow && !(selectedRows.length > 1 && !event.shiftKey)) {
    table.scrollPageUp();
    viewport = this._viewportInfo();
    if (!viewport.firstRow) {
      // May happen due to same reason as above -> Row will fill the whole viewport after scrolling
      return;
    }
  }

  if (event.shiftKey && selectedRows.length > 0) {
    newSelectedRows = rows.slice(rows.indexOf(viewport.firstRow), lastActionRowIndex);
    newSelectedRows = scout.arrays.union(selectedRows, newSelectedRows);
  } else {
    newSelectedRows = [viewport.firstRow];
  }

  table.selectionHandler.lastActionRow = viewport.firstRow;
  table.selectRows(newSelectedRows, true);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableNavigationPageDownKeyStroke = function(table) {
  scout.TableNavigationPageDownKeyStroke.parent.call(this, table);
  this.which = [scout.keys.PAGE_DOWN];
  this.renderingHints.text = 'PgDn';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var viewport = this._viewportInfo();
    if (viewport.lastRow) {
      return viewport.lastRow.$row;
    }
  }.bind(this);
};
scout.inherits(scout.TableNavigationPageDownKeyStroke, scout.AbstractTableNavigationKeyStroke);

scout.TableNavigationPageDownKeyStroke.prototype.handle = function(event) {
  var table = this.field,
    viewport = this._viewportInfo(),
    rows = table.filteredRows(),
    selectedRows = table.selectedRows,
    lastSelectedRow = scout.arrays.last(selectedRows),
    lastActionRow = table.selectionHandler.lastActionRow,
    lastActionRowIndex = -1,
    newSelectedRows;

  // Last row may be undefined if there is only one row visible in the viewport and this row is bigger than the viewport. In that case just scroll down.
  // If it already is at the bottom nothing will happen
  if (!viewport.lastRow) {
    table.scrollPageDown();
    viewport = this._viewportInfo();
    if (!viewport.lastRow) {
      return;
    }
  }

  if (lastActionRow) {
    lastActionRowIndex = rows.indexOf(lastActionRow);
  }
  // last action row index maybe < 0 if row got invisible (e.g. due to filtering), or if the user has not made a selection before
  if (lastActionRowIndex < 0) {
    lastActionRow = lastSelectedRow;
    lastActionRowIndex = rows.indexOf(lastActionRow);
  }

  // If last row in viewport already is selected -> scroll a page down
  // Don't do it if multiple rows are selected and user only presses page down without shift
  if (selectedRows.length > 0 && lastActionRow === viewport.lastRow && !(selectedRows.length > 1 && !event.shiftKey)) {
    table.scrollPageDown();
    viewport = this._viewportInfo();
    if (!viewport.lastRow) {
      // May happen due to same reason as above -> Row will fill the whole viewport after scrolling
      return;
    }
  }

  if (event.shiftKey && selectedRows.length > 0) {
    // Using lastActionRow instead of lastSelectedRow is essential if the user does a multi selection using ctrl and presses shift-pagedown afterwards
    newSelectedRows = rows.slice(lastActionRowIndex + 1, rows.indexOf(viewport.lastRow) + 1);
    newSelectedRows = scout.arrays.union(selectedRows, newSelectedRows);
  } else {
    newSelectedRows = [viewport.lastRow];
  }

  table.selectionHandler.lastActionRow = viewport.lastRow;
  table.selectRows(newSelectedRows, true);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Keystroke to move the cursor into field field to table footer.
 *
 * Hint: This keystroke is not implemented as RangeKeyStroke.js because:
 *       a) the accepted keys are not rendered on F1, but a condensed 'a-z' instead;
 *       b) there is no need to evaluate a concrete key's propagation status when being rendered (because of (a))
 *
 */
scout.TableFocusFilterFieldKeyStroke = function(table) {
  scout.TableFocusFilterFieldKeyStroke.parent.call(this);
  this.field = table;

  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return event._$filterInput;
  }.bind(this);

  this.virtualKeyStrokeWhich = 'a-Z;a-z;0-9';
  this.preventDefault = false; // false so that the key is inserted into the search field.
  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
};
scout.inherits(scout.TableFocusFilterFieldKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.TableFocusFilterFieldKeyStroke.prototype._accept = function(event) {
  if (!this._isKeyStrokeInRange(event)) {
    return false;
  }

  var $filterInput = $('.table-text-filter', this.field.$container);
  if (!$filterInput.length) {
    return false;
  }

  var activeElement = this.field.$container.activeElement(true),
    activeElementType = activeElement.tagName.toLowerCase(),
    focusOnInputField = (activeElementType === 'textarea' || activeElementType === 'input');
  if (activeElement.className !== 'table-text-filter' || !focusOnInputField) {
    event._$filterInput = $filterInput;
    this._isKeyStrokeInRange(event);
    return true;
  } else {
    return false;
  }
};

/**
 * @override KeyStroke.js
 */
scout.TableFocusFilterFieldKeyStroke.prototype.handle = function(event) {
  var $filterInput = event._$filterInput;

  // Focus the field and move cursor to the end.
  if (this.field.session.focusManager.requestFocus($filterInput)) {
    $filterInput.focus();

    var length = scout.nvl($filterInput.val(), '').length;
    $filterInput[0].setSelectionRange(length, length);
  }
};

/**
 * Returns a virtual key to represent this keystroke.
 */
scout.TableFocusFilterFieldKeyStroke.prototype.keys = function() {
  return [new scout.Key(this, this.virtualKeyStrokeWhich)];
};

/**
 * @override KeyStroke.js
 */
scout.TableFocusFilterFieldKeyStroke.prototype.renderKeyBox = function($drawingArea, event) {
  var $filterInput = event._$filterInput;

  var filterInputPosition = $filterInput.position();
  var left = filterInputPosition.left + parseInt($filterInput.css('margin-left').replace('px', ''), 0) + 4;
  $filterInput.beforeDiv('key-box char', 'a - z').css('left', left + 'px');
  return $filterInput.parent();
};

scout.TableFocusFilterFieldKeyStroke.prototype._isKeyStrokeInRange = function(event) {
  if (event.which === this.virtualKeyStrokeWhich) {
    return true; // the event has this keystroke's 'virtual which part' in case it is rendered.
  }

  if (event.altKey | event.ctrlKey) { // NOSONAR
    return false;
  }
  return (event.which >= scout.keys.a && event.which <= scout.keys.z) ||
    (event.which >= scout.keys.A && event.which <= scout.keys.Z) ||
    (event.which >= scout.keys['0'] && event.which <= scout.keys['9']) ||
    (event.which >= scout.keys.NUMPAD_0 && event.which <= scout.keys.NUMPAD_9);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableUserFilter = function() {};

scout.TableUserFilter.prototype.init = function(model) {
  this.session = model.session;
  if (!this.session) {
    throw new Error('Session expected: ' + this);
  }
  this._init(model);
};

scout.TableUserFilter.prototype._init = function(model) {
  $.extend(this, model);
};

scout.TableUserFilter.prototype.createAddFilterEventData = function() {
  return {
    filterType: this.filterType
  };
};

scout.TableUserFilter.prototype.createRemoveFilterEventData = function() {
  return {
    filterType: this.filterType
  };
};

scout.TableUserFilter.prototype.createKey = function() {
  return this.filterType;
};

scout.TableUserFilter.prototype.createLabel = function() {
  // to be implemented by subclasses
  return '';
};

scout.TableUserFilter.prototype.accept = function($row) {
  // to be implemented by subclasses
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ColumnUserFilter = function() {
  scout.ColumnUserFilter.parent.call(this);
  this.filterType = scout.ColumnUserFilter.Type;
  this.events = new scout.EventSupport();

  /**
   * This property is used to check early whether or not this filter can produce filter-fields.
   * Set this property to true in your sub-class, if it creates filter fields.
   */
  this.hasFilterFields = false;

  /**
   * array of (normalized) key, text composite
   */
  this.availableValues = [];

  /**
   * array of (normalized) keys
   */
  this.selectedValues = [];
};
scout.inherits(scout.ColumnUserFilter, scout.TableUserFilter);

scout.ColumnUserFilter.Type = 'column';

scout.ColumnUserFilter.prototype.axisGroup = function() {
  return scout.TableMatrix.NumberGroup.COUNT;
};

scout.ColumnUserFilter.prototype.calculate = function() {
  var containsSelectedValue, reorderAxis;

  this.matrix = new scout.TableMatrix(this.table, this.session);
  this.matrix.addData(this.column, scout.TableMatrix.NumberGroup.COUNT);
  this.xAxis = this.matrix.addAxis(this.column, this.axisGroup());
  var cube = this.matrix.calculate();

  this.selectedValues.forEach(function(selectedValue) {
    containsSelectedValue = false;
    if (this._useTextInsteadOfNormValue(selectedValue)) {
      // selected value was not normalized -> normalize
      selectedValue = this.xAxis.norm(selectedValue);
    }
    this.xAxis.some(function(key) {
      if (key === selectedValue) {
        containsSelectedValue = true;
        return true;
      }
    }, this);

    if (!containsSelectedValue) {
      this.xAxis.push(selectedValue);
      reorderAxis = true;
    }
  }, this);

  if (reorderAxis) {
    this.xAxis.reorder();
  }

  var text, displayKey, cubeValue, iconId;
  this.availableValues = [];
  this.xAxis.forEach(function(key) {
    displayKey = key;
    text = this.xAxis.format(key);
    iconId = null;
    if (this._useTextInsteadOfNormValue(key)) {
      displayKey = text;
    }
    if (key !== null && this.xAxis.textIsIcon) {
      // Only display icon if textIsIcon (still display empty text if key is null)
      iconId = text;
      text = null;
    }
    cubeValue = cube.getValue([key]);
    this.availableValues.push({
      key: displayKey,
      text: text,
      iconId: iconId,
      count: cubeValue ? cubeValue[0] : 0
    });
  }, this);
};

/**
 * In case of text columns, the normalized key generated by the matrix is not deterministic,
 * it depends on the table data -> use the text. In the other cases it is possible to use the
 * normalized key which has the advantage that it is locale independent.
 */
scout.ColumnUserFilter.prototype._useTextInsteadOfNormValue = function(value) {
  return false;
};

/**
 * @override TableUserFilter.js
 */
scout.ColumnUserFilter.prototype.createAddFilterEventData = function() {
  var data = scout.ColumnUserFilter.parent.prototype.createAddFilterEventData.call(this);
  data.columnId = this.column.id;
  data.selectedValues = this.selectedValues;
  return data;
};

scout.ColumnUserFilter.prototype.createRemoveFilterEventData = function() {
  var data = scout.ColumnUserFilter.parent.prototype.createRemoveFilterEventData.call(this);
  data.columnId = this.column.id;
  return data;
};

scout.ColumnUserFilter.prototype.createLabel = function() {
  return this.column.text || '';
};

scout.ColumnUserFilter.prototype.createKey = function() {
  return this.column.id;
};

scout.ColumnUserFilter.prototype.accept = function(row) {
  if (!this.xAxis) {
    // Lazy calculation. It is not possible on init, because the table is not rendered yet.
    this.calculate();
  }
  var
    acceptByTable = true,
    acceptByFields = true,
    key = this.column.cellValueForGrouping(row),
    normKey = this.xAxis.norm(key);

  if (this._useTextInsteadOfNormValue(normKey)) {
    normKey = this.xAxis.format(normKey);
  }
  if (this.tableFilterActive()) {
    acceptByTable = this.selectedValues.indexOf(normKey) > -1;
  }
  if (this.fieldsFilterActive()) {
    acceptByFields = this.acceptByFields(key, normKey, row);
  }

  return acceptByTable && acceptByFields;
};

scout.ColumnUserFilter.prototype.filterActive = function() {
  return this.tableFilterActive() || this.fieldsFilterActive();
};

scout.ColumnUserFilter.prototype.tableFilterActive = function() {
  return this.selectedValues.length > 0;
};

scout.ColumnUserFilter.prototype.triggerFilterFieldsChanged = function(event) {
  this.events.trigger('filterFieldsChanged', event);
};

scout.ColumnUserFilter.prototype.on = function(type, func) {
  this.events.on(type, func);
};

scout.ColumnUserFilter.prototype.off = function(type, func) {
  this.events.off(type, func);
};

/**
 * Returns whether or not the given key is accepted by the filter-fields in their current state.
 * The default impl. returns true.
 */
scout.ColumnUserFilter.prototype.acceptByFields = function(key, normKey, row) {
  return true;
};

/**
 * Returns whether or not filter-fields have an effect on the column-filter in their current state.
 * The default impl. returns false.
 */
scout.ColumnUserFilter.prototype.fieldsFilterActive = function() {
  return false;
};

/**
 * Adds filter fields for this type of column filter.
 * The default impl. adds no fields.
 *
 * @param groupBox FilterFieldsGroupBox
 */
scout.ColumnUserFilter.prototype.addFilterFields = function(groupBox) {
  // NOP
};

/**
 * Called after filter group-box has been rendered. Gives the filter impl. a chance to
 * modify the rendered fields. The default impl. does nothing.
 */
scout.ColumnUserFilter.prototype.modifyFilterFields = function() {
  // NOP
};

/**
 * Returns the title displayed above the filter fields.
 * The default impl. returns a null value, which means the title is not displayed.
 */
scout.ColumnUserFilter.prototype.filterFieldsTitle = function() {
  return null;
};

scout.ColumnUserFilter.prototype.createComparator = function() {
  return scout.comparators.NUMERIC;
};

scout.DateColumnUserFilter = function() {
  scout.DateColumnUserFilter.parent.call(this);

  this.dateFrom;
  this.dateFromField;
  this.dateTo;
  this.dateToField;

  this.hasFilterFields = true;
};
scout.inherits(scout.DateColumnUserFilter, scout.ColumnUserFilter);

/**
 * @override TableUserFilter.js
 */
scout.DateColumnUserFilter.prototype._init = function(model) {
  scout.DateColumnUserFilter.parent.prototype._init.call(this, model);
  this.dateFrom = scout.dates.parseJsonDate(this.dateFrom);
  this.dateTo = scout.dates.parseJsonDate(this.dateTo);
};

/**
 * @override ColumnUserFilter.js
 */
scout.DateColumnUserFilter.prototype.axisGroup = function() {
  if (this.column.hasDate) {
    // Default grouping for date columns is year
    return scout.TableMatrix.DateGroup.YEAR;
  } else {
    // No grouping for time columns
    return scout.TableMatrix.DateGroup.NONE;
  }
};

/**
 * @override ColumnUserFilter.js
 */
scout.DateColumnUserFilter.prototype.createAddFilterEventData = function() {
  var data = scout.DateColumnUserFilter.parent.prototype.createAddFilterEventData.call(this);
  data.dateFrom = scout.dates.toJsonDate(this.dateFrom);
  data.dateTo = scout.dates.toJsonDate(this.dateTo);
  return data;
};

/**
 * @override ColumnUserFilter.js
 */
scout.DateColumnUserFilter.prototype.fieldsFilterActive = function() {
  return this.dateFrom || this.dateTo;
};

/**
 * @override ColumnUserFilter.js
 */
scout.DateColumnUserFilter.prototype.acceptByFields = function(key, normKey, row) {
  // if date is empty and dateFrom/dateTo is set, the row should never match
  if (!key) {
    return false;
  }

  var
    keyValue = key.valueOf(),
    fromValue = this.dateFrom ? this.dateFrom.valueOf() : null,
    // Shift the toValue to 1ms before midnight/next day. Thus any time of the selected day is accepted.
    toValue = this.dateTo ? scout.dates.shift(this.dateTo, 0, 0, 1).valueOf() - 1 : null;

  if (fromValue && toValue) {
    return keyValue >= fromValue && keyValue <= toValue;
  } else if (fromValue) {
    return keyValue >= fromValue;
  } else if (toValue) {
    return keyValue <= toValue;
  }

  // acceptByFields is only called when filter fields are active
  throw new Error('illegal state');
};

/**
 * @implements ColumnUserFilter.js
 */
scout.DateColumnUserFilter.prototype.filterFieldsTitle = function() {
  return this.session.text('ui.DateRange');
};

/**
 * TODO awe, cgu: (value-field) refactor DateField.js -
 * rename timestampAsDate to value (also on JsonDateField)
 * use Date object everywhere and todays 'timestamp' date-string
 * only when we communicate with the UI server. Then remove the toJsonDate
 * function used here and work with the Date object. Implement a _syncValue
 * method to convert the date-string into a Date object in DateField.js
 *
 * @override ColumnUserFilter.js
 */
scout.DateColumnUserFilter.prototype.addFilterFields = function(groupBox) {
  this.dateFromField = groupBox.addFilterField('DateField', 'ui.from', 0);
  this.dateFromField.setTimestamp(toJsonDate(this.dateFrom));
  this.dateFromField.on('timestampChanged', this._onDisplayTextChanged.bind(this));

  this.dateToField = groupBox.addFilterField('DateField', 'ui.to', 1);
  this.dateToField.setTimestamp(toJsonDate(this.dateTo));
  this.dateToField.on('timestampChanged', this._onDisplayTextChanged.bind(this));

  function toJsonDate(date) {
    return date ? scout.dates.toJsonDate(date) : null;
  }
};

scout.DateColumnUserFilter.prototype._onDisplayTextChanged = function(event) {
  this.dateFrom = this.dateFromField.timestampAsDate;
  this.dateTo = this.dateToField.timestampAsDate;
  $.log.debug('(DateColumnUserFilter#_onDisplayTextChanged) dateFrom=' + this.dateFrom + ' dateTo=' + this.dateTo);
  this.triggerFilterFieldsChanged(event);
};

scout.DateColumnUserFilter.prototype.modifyFilterFields = function() {
  this.dateFromField.$field.on('input', '', $.debounce(this._onInput.bind(this)));
  this.dateToField.$field.on('input', '', $.debounce(this._onInput.bind(this)));
};

scout.DateColumnUserFilter.prototype._onInput = function(event) {
  if (!this.dateFromField.rendered) {
    // popup has been closed in the mean time
    return;
  }
  this.dateFrom = this._readDate(this.dateFromField);
  this.dateTo = this._readDate(this.dateToField);
  this.triggerFilterFieldsChanged(event);
};

scout.DateColumnUserFilter.prototype._readDate = function(dateField) {
  var displayText = dateField.$dateField.val();
  if (!displayText) {
    return null;
  }
  var datePrediction = dateField._predictDate(displayText);
  if (datePrediction && datePrediction.date) {
    return dateField._newTimestampAsDate(datePrediction.date, dateField.timestampAsDate);
  }
};

scout.NumberColumnUserFilter = function() {
  scout.NumberColumnUserFilter.parent.call(this);

  this.numberFrom;
  this.numberFromField;
  this.numberTo;
  this.numberToField;

  this.hasFilterFields = true;
};
scout.inherits(scout.NumberColumnUserFilter, scout.ColumnUserFilter);

/**
 * @override ColumnUserFilter.js
 */
scout.NumberColumnUserFilter.prototype.createAddFilterEventData = function() {
  var data = scout.NumberColumnUserFilter.parent.prototype.createAddFilterEventData.call(this);
  data.numberFrom = this.numberFrom;
  data.numberTo = this.numberTo;
  return data;
};

/**
 * @override ColumnUserFilter.js
 */
scout.NumberColumnUserFilter.prototype.fieldsFilterActive = function() {
  return scout.objects.isNumber(this.numberFrom) || scout.objects.isNumber(this.numberTo);
};

/**
 * @override ColumnUserFilter.js
 */
scout.NumberColumnUserFilter.prototype.acceptByFields = function(key, normKey, row) {
  var
    hasFrom = scout.objects.isNumber(this.numberFrom),
    hasTo = scout.objects.isNumber(this.numberTo);
  if (hasFrom && hasTo) {
    return normKey >= this.numberFrom && normKey <= this.numberTo;
  } else if (hasFrom) {
    return normKey >= this.numberFrom;
  } else if (hasTo) {
    return normKey <= this.numberTo;
  }
};

/**
 * @implements ColumnUserFilter.js
 */
scout.NumberColumnUserFilter.prototype.filterFieldsTitle = function() {
  return this.session.text('ui.NumberRange');
};

/**
 * @override ColumnUserFilter.js
 */
scout.NumberColumnUserFilter.prototype.addFilterFields = function(groupBox) {
  this.numberFromField = groupBox.addFilterField('NumberField', 'ui.from', 0);
  this.numberFromField.decimalFormat = this.column.decimalFormat;
  this.numberFromField.setDisplayText(this.numberFrom);
  this.numberFromField.on('displayTextChanged', this._onDisplayTextChanged.bind(this));

  this.numberToField = groupBox.addFilterField('NumberField', 'ui.to', 1);
  this.numberToField.decimalFormat = this.column.decimalFormat;
  this.numberToField.setDisplayText(this.numberTo);
  this.numberToField.on('displayTextChanged', this._onDisplayTextChanged.bind(this));
};

scout.NumberColumnUserFilter.prototype._onDisplayTextChanged = function(event) {
  this.numberFrom = this.numberFromField.parse();
  this.numberTo = this.numberToField.parse();
  $.log.debug('(NumberColumnUserFilter#_onDisplayTextChanged) numberFrom=' + this.numberFrom + ' numberTo=' + this.numberTo);
  this.triggerFilterFieldsChanged(event);
};

scout.TextColumnUserFilter = function() {
  scout.TextColumnUserFilter.parent.call(this);

  this.freeText;
  this.freeTextField;

  this.hasFilterFields = true;
};
scout.inherits(scout.TextColumnUserFilter, scout.ColumnUserFilter);

/**
 * @override ColumnUserFilter.js
 */
scout.TextColumnUserFilter.prototype.createAddFilterEventData = function() {
  var data = scout.TextColumnUserFilter.parent.prototype.createAddFilterEventData.call(this);
  data.freeText = this.freeText;
  return data;
};

/**
 * @override ColumnUserFilter.js
 */
scout.TextColumnUserFilter.prototype.fieldsFilterActive = function() {
  return scout.strings.hasText(this.freeText);
};

/**
 * @override ColumnUserFilter.js
 */
scout.TextColumnUserFilter.prototype.acceptByFields = function(key, normKey, row) {
  var filterFieldText = scout.strings.nvl(this.freeText).toLowerCase(),
    rowText = scout.strings.nvl(this.column.cellTextForTextFilter(row)).toLowerCase();
  return rowText.indexOf(filterFieldText) > -1;
};

/**
 * @implements ColumnUserFilter.js
 */
scout.TextColumnUserFilter.prototype._useTextInsteadOfNormValue = function(value) {
  // null is valid, if for text columns. We do not want to store -empty-
  return value === null ? false : true;
};

/**
 * @implements ColumnUserFilter.js
 */
scout.TextColumnUserFilter.prototype.filterFieldsTitle = function() {
  return this.session.text('ui.FreeText');
};

/**
 * @override ColumnUserFilter.js
 */
scout.TextColumnUserFilter.prototype.addFilterFields = function(groupBox) {
  this.freeTextField = scout.create('StringField', {
    parent: groupBox,
    labelVisible: false,
    statusVisible: false,
    maxLength: 100,
    displayText: this.freeText,
    updateDisplayTextOnModify: true
  });
  this.freeTextField.on('displayTextChanged', this._onDisplayTextChanged.bind(this));
  groupBox.addField0(this.freeTextField);
};

scout.TextColumnUserFilter.prototype._onDisplayTextChanged = function(event) {
  this.freeText = this.freeTextField.$field.val().trim();
  $.log.debug('(TextColumnUserFilter#_onDisplayTextChanged) freeText=' + this.freeText);
  this.triggerFilterFieldsChanged(event);
};

/**
 * @override ColumnUserFilter.js
 */
scout.TextColumnUserFilter.prototype.modifyFilterFields = function() {
  this.freeTextField.removeMandatoryIndicator();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableTextUserFilter = function() {
  scout.TableTextUserFilter.parent.call(this);
  this.filterType = scout.TableTextUserFilter.Type;
};
scout.inherits(scout.TableTextUserFilter, scout.TableUserFilter);

scout.TableTextUserFilter.Type = 'text';

/**
 * @override TableUserFilter.js
 */
scout.TableTextUserFilter.prototype.createAddFilterEventData = function() {
  var data = scout.ColumnUserFilter.parent.prototype.createAddFilterEventData.call(this);
  data.text = this.text;
  return data;
};

scout.TableTextUserFilter.prototype.createLabel = function() {
  return this.text;
};

scout.TableTextUserFilter.prototype.accept = function(row) {
  var rowText = '';
  for (var i = 0; i < this.table.columns.length; i++) {
    var column = this.table.columns[i];
    rowText += column.cellTextForTextFilter(row) + ' ';
  }
  rowText = rowText.trim().toLowerCase();
  return rowText.indexOf(this.text) > -1;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * @class
 * @constructor
 */
scout.Tree = function() {
  scout.Tree.parent.call(this);

  this.displayStyle = scout.Tree.DisplayStyle.DEFAULT;
  this.autoCheckChildren = false;
  this.checkable = false;
  this.enabled = true;
  this.filterEnabled = false;
  this.lazyExpandingEnabled = true;
  this.menus = [];
  this.contextMenu;
  this.menuBar;
  this.keyStrokes = [];
  this.multiCheck = true;
  this.nodes = []; // top-level nodes
  this.nodesMap = {}; // all nodes by id
  this.scrollToSelection = false;
  this.scrollTop = 0;
  this.selectedNodes = [];
  this.checkedNodes = [];
  this.groupedNodes = {};
  this.visibleNodesFlat = [];
  this.visibleNodesMap = {};
  this._addAdapterProperties(['menus', 'keyStrokes']);
  this._additionalContainerClasses = ''; // may be used by subclasses to set additional CSS classes
  this._treeItemPaddingLeft = 23;
  this._treeItemCheckBoxPaddingLeft = 29;
  this._treeItemPaddingLevel = 15;
  this._filters = [];
  this._doubleClickSupport = new scout.DoubleClickSupport();
  this._$animationWrapper; // used by _renderExpansion()
  this._$expandAnimationWrappers = [];
  this._filterMenusHandler = this._filterMenus.bind(this);

  // contains all parents of a selected node, the selected node and the first level children
  this._inSelectionPathList = {};
  this.viewRangeRendered = new scout.Range(0, 0);
  this.viewRangeSize = 20;

  this.startAnimationFunc = function() {
    this.runningAnimations++;
  }.bind(this);
  this.runningAnimations = 0;
  this.runningAnimationsFinishFunc = function() {
    this.runningAnimations--;
    if (this.runningAnimations <= 0) {
      this.runningAnimations = 0;
      this._renderViewportBlocked = false;
      this.invalidateLayoutTree();
    }
  }.bind(this);

  this.nodeHeight = 0;
  this.nodeWidth = 0;
  this.maxNodeWidth = 0;
  this.nodeWidthDirty = false;
  this.$data;
  this._scrolldirections = 'both';
};
scout.inherits(scout.Tree, scout.Widget);

scout.Tree.DisplayStyle = {
  DEFAULT: 'default',
  BREADCRUMB: 'breadcrumb'
};

scout.Tree.prototype._init = function(model) {
  scout.Tree.parent.prototype._init.call(this, model);
  this.addFilter(new scout.LazyNodeFilter(this), true);
  this.breadcrumbFilter = new scout.TreeBreadcrumbFilter(this);
  if (this.displayStyle === scout.Tree.DisplayStyle.BREADCRUMB) {
    this.addFilter(this.breadcrumbFilter, true, true);
  }
  this.initialTraversing = true;
  this._ensureTreeNodes(this.nodes);
  this._visitNodes(this.nodes, this._initTreeNode.bind(this));
  this._visitNodes(this.nodes, this._updateFlatListAndSelectionPath.bind(this));
  this.initialTraversing = false;
  this.selectedNodes = this._nodesByIds(this.selectedNodes);
  this.menuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.MenuItemsOrder(this.session, 'Tree'),
    menuFilter: this._filterMenusHandler
  });
  this.menuBar.bottom();
  this._updateItemPath(true);
  this._syncDisplayStyle(this.displayStyle);
  this._syncKeyStrokes(this.keyStrokes);
  this._syncMenus(this.menus);
};

/**
 * Iterates through the given array and converts node-models to instances of scout.TreeNode (or a subclass).
 * If the array element is already a TreeNode the function leaves the element untouched. This function also
 * ensures that the attribute childNodeIndex is set. By default we use the order of the nodes array as index
 * but only if childNodeIndex is undefined.
 *
 * @param nodes Array of node-models (plain object) or nodes (instance of scout.TreeNode)
 */
scout.Tree.prototype._ensureTreeNodes = function(nodes) {
  var i, node;
  for (i = 0; i < nodes.length; i++) {
    node = nodes[i];
    node.childNodeIndex = scout.nvl(node.childNodeIndex, i);
    if (node instanceof scout.TreeNode) {
      continue;
    }
    nodes[i] = this._createTreeNode(node);
  }
};

scout.Tree.prototype._createTreeNode = function(nodeModel) {
  nodeModel.parent = this;
  return scout.create('TreeNode', nodeModel);
};

/**
 * @override
 */
scout.Tree.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.Tree.prototype._initKeyStrokeContext = function() {
  scout.Tree.parent.prototype._initKeyStrokeContext.call(this);

  this._initTreeKeyStrokeContext();
};

scout.Tree.prototype._initTreeKeyStrokeContext = function() {
  var modifierBitMask = scout.keyStrokeModifier.NONE;

  this.keyStrokeContext.registerKeyStroke([
    new scout.TreeSpaceKeyStroke(this),
    new scout.TreeNavigationUpKeyStroke(this, modifierBitMask),
    new scout.TreeNavigationDownKeyStroke(this, modifierBitMask),
    new scout.TreeCollapseAllKeyStroke(this, modifierBitMask),
    new scout.TreeCollapseOrDrillUpKeyStroke(this, modifierBitMask),
    new scout.TreeNavigationEndKeyStroke(this, modifierBitMask),
    new scout.TreeExpandOrDrillDownKeyStroke(this, modifierBitMask)
  ]);

  // Prevent default action and do not propagate  or  keys if ctrl- or alt-modifier is not pressed.
  // Otherwise, an '-event' on the first node, or an '-event' on the last row will bubble up (because not consumed by tree navigation keystrokes) and cause a superior tree to move its selection;
  // Use case: - outline tree with a detail form that contains a tree;
  //           - preventDefault because of smartfield, so that the cursor is not moved on first or last row;
  this.keyStrokeContext.registerStopPropagationInterceptor(function(event) {
    if (!event.ctrlKey && !event.altKey && scout.isOneOf(event.which, scout.keys.UP, scout.keys.DOWN)) {
      event.stopPropagation();
      event.preventDefault();
    }
  });
};

scout.Tree.prototype._syncMenus = function(menus) {
  this.updateKeyStrokes(menus, this.menus);
  this._setProperty('menus', menus);
  this._updateMenuBar();
};

scout.Tree.prototype._updateMenuBar = function() {
  var menuItems = this._filterMenus(this.menus, scout.MenuDestinations.MENU_BAR, false, true);
  this.menuBar.setMenuItems(menuItems);
  var contextMenuItems = this._filterMenus(this.menus, scout.MenuDestinations.CONTEXT_MENU, true);
  if (this.contextMenu) {
    this.contextMenu.updateMenuItems(contextMenuItems);
  }
};

scout.Tree.prototype._syncKeyStrokes = function(keyStrokes) {
  this.updateKeyStrokes(keyStrokes, this.keyStrokes);
  this._setProperty('keyStrokes', keyStrokes);
};

scout.Tree.prototype._resetTreeNode = function(node, parentNode) {
  node.reset();
};

scout.Tree.prototype._isSelectedNode = function(node) {
  if (this.initialTraversing) {
    return this.selectedNodes.indexOf(node.id) > -1;
  } else {
    return this.selectedNodes.indexOf(node) > -1;
  }
};

scout.Tree.prototype._updateFlatListAndSelectionPath = function(node, parentNode) {
  // if this node is selected all parent nodes have to be added to selectionPath
  if (this._isSelectedNode(node) && ((node.parentNode && !this.visibleNodesMap[node.parentNode.id]) || node.level === 0)) {
    var p = node;
    while (p) {
      this._inSelectionPathList[p.id] = true;
      p.filterDirty = true;

      if (p !== node) {
        // ensure node is expanded
        node.expanded = true;
        // if parent was filtered before, try refilter after adding to selection path.
        if (p.level === 0) {
          this._applyFiltersForNode(p);

          // add visible nodes to visible nodes array when they are initialized
          this._addToVisibleFlatList(p, false);

          // process children
          this._addChildrenToFlatList(p, this.visibleNodesFlat.length - 1, false, null, true);
        }
      }
      p = p.parentNode;
    }
  } else if (node.parentNode && this._isSelectedNode(node.parentNode)) {
    this._inSelectionPathList[node.id] = true;
  }

  this._applyFiltersForNode(node);

  // add visible nodes to visible nodes array when they are initialized
  this._addToVisibleFlatList(node, false);
};

scout.Tree.prototype._initTreeNode = function(node, parentNode) {
  this.nodesMap[node.id] = node;
  if (parentNode) {
    node.parentNode = parentNode;
    node.level = node.parentNode.level + 1;
  }
  if (node.checked) {
    this.checkedNodes.push(node);
  }
  this._initTreeNodeInternal(node, parentNode);
  this._updateMarkChildrenChecked(node, true, node.checked);
  node.initialized = true;
};

scout.Tree.prototype._applyNodeDefaultValues = function(node) {
  scout.defaultValues.applyTo(node, 'TreeNode');
};

/**
 * Override this function if you want a custom node init before filtering.
 * The default impl. applies default values to the given node.
 */
scout.Tree.prototype._initTreeNodeInternal = function(node, parentNode) {
  this._applyNodeDefaultValues(node);
};

scout.Tree.prototype.destroy = function() {
  scout.Tree.parent.prototype.destroy.call(this);
  this._visitNodes(this.nodes, this._destroyTreeNode.bind(this));
};

scout.Tree.prototype._destroyTreeNode = function(node, parentNode) {
  delete this.nodesMap[node.id];
  scout.arrays.remove(this.selectedNodes, node); // ensure deleted node is not in selection list anymore (in case the model does not update the selection)
  this._removeFromFlatList(node, false); //ensure node is not longer in visible nodes list.
  node.destroy();

  if (this._onNodeDeleted) { // Necessary for subclasses
    this._onNodeDeleted(node);
  }
};

scout.Tree.prototype._visitNodes = function(nodes, func, parentNode) {
  return scout.Tree.visitNodes(nodes, func, parentNode);
};

scout.Tree.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('tree');
  if (this._additionalContainerClasses) {
    this.$container.addClass(this._additionalContainerClasses);
  }

  var layout = new scout.TreeLayout(this);
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(layout);
  this.htmlComp.pixelBasedSizing = false;

  this.$data = this.$container.appendDiv('tree-data')
    .on('contextmenu', this._onContextMenu.bind(this))
    .on('mousedown', '.tree-node', this._onNodeMouseDown.bind(this))
    .on('mouseup', '.tree-node', this._onNodeMouseUp.bind(this))
    .on('dblclick', '.tree-node', this._onNodeDoubleClick.bind(this))
    .on('mousedown', '.tree-node-control', this._onNodeControlMouseDown.bind(this))
    .on('mouseup', '.tree-node-control', this._onNodeControlMouseUp.bind(this))
    .on('dblclick', '.tree-node-control', this._onNodeControlDoubleClick.bind(this))
    .on('scroll', this._onDataScroll.bind(this));
  scout.HtmlComponent.install(this.$data, this.session);

  if (this.isHorizontalScrollingEnabled()) {
    this.$data.toggleClass('scrollable-tree', true);
  }

  scout.scrollbars.install(this.$data, {
    parent: this,
    axis: this._scrolldirections
  });
  this._installNodeTooltipSupport();
  this.menuBar.render(this.$container);
  this._updateNodeDimensions();
  // render display style before viewport (not in renderProperties) to have a correct style from the beginning
  this._renderDisplayStyle();
  this._renderViewport();
};

scout.Tree.prototype._postRender = function() {
  scout.Tree.parent.prototype._postRender.call(this);
  this._renderSelection();
};

scout.Tree.prototype._remove = function() {
  // stop all animations
  if (this._$animationWrapper) {
    this._$animationWrapper.stop(false, true);
  }
  // Detach nodes from jQuery objects (because those will be removed)
  this._visitNodes(this.nodes, this._resetTreeNode.bind(this));

  scout.scrollbars.uninstall(this.$data, this.session);
  this._uninstallDragAndDropHandler();
  this._uninstallNodeTooltipSupport();
  this.$fillBefore = null;
  this.$fillAfter = null;
  this.$data = null;
  // reset rendered view range because now range is rendered
  this.viewRangeRendered = new scout.Range(0, 0);
  scout.Tree.parent.prototype._remove.call(this);
};

scout.Tree.prototype._renderProperties = function() {
  scout.Tree.parent.prototype._renderProperties.call(this);
  this._renderDropType();
};

scout.Tree.prototype.isHorizontalScrollingEnabled = function() {
  return this._scrolldirections === 'both' || this._scrolldirections === 'x';
};

scout.Tree.prototype._onDataScroll = function() {
  var scrollToSelectionBackup = this.scrollToSelection;
  this.scrollToSelection = false;
  var scrollTop = this.$data[0].scrollTop;
  if (this.scrollTop === scrollTop) {
    return;
  }
  this._renderViewport();
  this.scrollTop = scrollTop;
  this.scrollToSelection = scrollToSelectionBackup;
};

scout.Tree.prototype.setScrollTop = function(scrollTop) {
  this.setProperty('scrollTop', scrollTop);
//call _renderViewport to make sure nodes are rendered immediately. The browser fires the scroll event handled by onDataScroll delayed
  if(this.rendered){
    this._renderViewport();
  }
};

scout.Tree.prototype._renderScrollTop = function() {
  scout.scrollbars.scrollTop(this.$data, this.scrollTop);
};

scout.Tree.prototype._renderViewport = function() {
  if (this.runningAnimations > 0 || this._renderViewportBlocked) {
    //animation pending do not render view port because finishing should rerenderViewport
    return;
  }
  var viewRange = this._calculateCurrentViewRange();
  this._renderViewRange(viewRange);
};

scout.Tree.prototype._calculateCurrentViewRange = function() {
  var node,
    scrollTop = this.$data[0].scrollTop,
    maxScrollTop = this.$data[0].scrollHeight - this.$data[0].clientHeight;

  if (maxScrollTop === 0 && this.visibleNodesFlat.length > 0) {
    // no scrollbars visible
    node = this.visibleNodesFlat[0];
  } else {
    node = this._nodeAtScrollTop(scrollTop);
  }

  return this._calculateViewRangeForNode(node);
};

scout.Tree.prototype._rerenderViewport = function() {
  if (this._renderViewportBlocked) {
    return;
  }
  this._removeRenderedNodes();
  this._renderFiller();
  this._updateDomNodeWidth();
  this._renderViewport();
};

scout.Tree.prototype._removeRenderedNodes = function() {
  var $nodes = this.$data.find('.tree-node');
  $nodes.each(function(i, elem) {
    var $node = $(elem),
      node = $node.data('node');
    if ($node.hasClass('hiding')) {
      // Do not remove nodes which are removed using an animation
      return;
    }
    this._removeNode(node);
  }.bind(this));
  this.viewRangeRendered = new scout.Range(0, 0);
};

scout.Tree.prototype._renderViewRangeForNode = function(node) {
  var viewRange = this._calculateViewRangeForNode(node);
  this._renderViewRange(viewRange);
};

scout.Tree.prototype._renderNodesInRange = function(range) {
  var prepend = false;

  var nodes = this.visibleNodesFlat;
  if (nodes.length === 0) {
    return;
  }

  var maxRange = new scout.Range(0, nodes.length);
  range = maxRange.intersect(range);
  if (!range.intersect(this.viewRangeRendered).equals(new scout.Range(0, 0))) {
    throw new Error('New range must not intersect with existing.');
  }
  if (range.to <= this.viewRangeRendered.from) {
    prepend = true;
  }
  var newRange = this.viewRangeRendered.union(range);
  if (newRange.length === 2) {
    throw new Error('Can only prepend or append rows to the existing range. Existing: ' + this.viewRangeRendered + '. New: ' + newRange);
  }
  this.viewRangeRendered = newRange[0];

  var numNodesRendered = this.ensureRangeVisible(range);

  if ($.log.isTraceEnabled()) {
    $.log.trace(numNodesRendered + ' new nodes rendered from ' + range);
  }
};

scout.Tree.prototype.ensureRangeVisible = function(range) {
  var nodes = this.visibleNodesFlat,
    numNodesRendered = 0;
  for (var r = range.from; r < range.to; r++) {
    var node = nodes[r];
    if (!node.attached) {
      this._insertNodeInDOM(node);
      numNodesRendered++;
    }
  }
  return numNodesRendered;
};

scout.Tree.prototype._renderFiller = function() {
  if (!this.$fillBefore) {
    this.$fillBefore = this.$data.prependDiv('tree-data-fill');
  }

  var fillBeforeDimensions = this._calculateFillerDimension(new scout.Range(0, this.viewRangeRendered.from));
  this.$fillBefore.cssHeight(fillBeforeDimensions.height);
  if (this.isHorizontalScrollingEnabled()) {
    this.$fillBefore.cssWidth(fillBeforeDimensions.width);
    this.maxNodeWidth = Math.max(fillBeforeDimensions.width, this.maxNodeWidth);
  }
  $.log.trace('FillBefore height: ' + fillBeforeDimensions.height);

  if (!this.$fillAfter) {
    this.$fillAfter = this.$data.appendDiv('tree-data-fill');
  }

  var fillAfterDimensions = {
    height: 0,
    width: 0
  };
  fillAfterDimensions = this._calculateFillerDimension(new scout.Range(this.viewRangeRendered.to, this.visibleNodesFlat.length));
  this.$fillAfter.cssHeight(fillAfterDimensions.height);
  if (this.isHorizontalScrollingEnabled()) {
    this.$fillAfter.cssWidth(fillAfterDimensions.width);
    this.maxNodeWidth = Math.max(fillAfterDimensions.width, this.maxNodeWidth);
  }
  $.log.trace('FillAfter height: ' + fillAfterDimensions.height);
};

scout.Tree.prototype._calculateFillerDimension = function(range) {
  var dimension = {
    height: 0,
    width: Math.max(this.$data.outerWidth(), this.maxNodeWidth)
  };
  for (var i = range.from; i < range.to; i++) {
    var node = this.visibleNodesFlat[i];
    dimension.height += this._heightForNode(node);
    dimension.width = Math.max(dimension.width, this._widthForNode(node));
  }
  return dimension;
};

scout.Tree.prototype._removeNodesInRange = function(range) {
  var fromNode, toNode, node, i,
    numNodesRemoved = 0,
    nodes = this.visibleNodesFlat;

  var maxRange = new scout.Range(0, nodes.length);
  range = maxRange.intersect(range);
  fromNode = nodes[range.from];
  toNode = nodes[range.to];

  var newRange = this.viewRangeRendered.subtract(range);
  if (newRange.length === 2) {
    throw new Error('Can only remove nodes at the beginning or end of the existing range. ' + this.viewRangeRendered + '. New: ' + newRange);
  }
  this.viewRangeRendered = newRange[0];

  for (i = range.from; i < range.to; i++) {
    node = nodes[i];
    this._removeNode(node);
    numNodesRemoved++;
  }

  if ($.log.isTraceEnabled()) {
    $.log.trace(numNodesRemoved + ' nodes removed from ' + range + '.');
  }
};

/**
 * Just removes the node, does NOT adjust this.viewRangeRendered
 */
scout.Tree.prototype._removeNode = function(node) {
  var $node = node.$node;
  if (!$node) {
    return;
  }
  if ($node.hasClass('hiding')) {
    // Do not remove nodes which are removed using an animation
    return;
  }
  //only remove node
  $node.detach();
  node.attached = false;
};

/**
 * Renders the rows visible in the viewport and removes the other rows
 */
scout.Tree.prototype._renderViewRange = function(viewRange) {
  if (viewRange.from === this.viewRangeRendered.from && viewRange.to === this.viewRangeRendered.to && !this.viewRangeDirty) {
    // Range already rendered -> do nothing
    return;
  }
  if (!this.viewRangeDirty) {
    var rangesToRender = viewRange.subtract(this.viewRangeRendered);
    var rangesToRemove = this.viewRangeRendered.subtract(viewRange);
    var maxRange = new scout.Range(0, this.visibleNodesFlat.length);

    rangesToRemove.forEach(function(range) {
      this._removeNodesInRange(range);
      if (maxRange.to < range.to) {
        this.viewRangeRendered = viewRange;
      }
    }.bind(this));
    rangesToRender.forEach(function(range) {
      this._renderNodesInRange(range);
    }.bind(this));
  } else {
    //expansion changed
    this.viewRangeRendered = viewRange;
    this.ensureRangeVisible(viewRange);
  }

  // check if at least last and first row in range got correctly rendered
  if (this.viewRangeRendered.size() > 0) {
    var nodes = this.visibleNodesFlat;
    var firstNode = nodes[this.viewRangeRendered.from];
    var lastNode = nodes[this.viewRangeRendered.to - 1];
    if (this.viewRangeDirty) {
      // cleanup nodes before range and after
      var $nodesBeforFirstNode = firstNode.$node.prevAll('.tree-node');
      var $nodesAfterLastNode = lastNode.$node.nextAll('.tree-node');
      this._cleanupNodes($nodesBeforFirstNode);
      this._cleanupNodes($nodesAfterLastNode);
    }
    if (!firstNode.attached || !lastNode.attached) {
      throw new Error('Nodes not rendered as expected. ' + this.viewRangeRendered + '. First: ' + firstNode.$node + '. Last: ' + lastNode.$node);
    }
  }

  this._postRenderViewRange();
  this.viewRangeDirty = false;
};

scout.Tree.prototype._postRenderViewRange = function() {
  this._renderFiller();
  this._updateDomNodeWidth();
  this._renderSelection();
};

scout.Tree.prototype._updateDomNodeWidth = function($nodes) {
  if (!this.isHorizontalScrollingEnabled()) {
    return;
  }
  if (this.rendered && this.nodeWidthDirty) {
    for (var i = this.viewRangeRendered.from; i < this.viewRangeRendered.to; i++) {
      this.maxNodeWidth = Math.max(this.visibleNodesFlat[i].width, this.maxNodeWidth);
    }
    this.$data.find('.tree-node').css('width', this.maxNodeWidth);
    this.nodeWidthDirty = false;
  }
};

scout.Tree.prototype._cleanupNodes = function($nodes) {
  for (var i = 0; i < $nodes.length; i++) {
    this._removeNode($nodes.eq(i).data('node'));
  }
};

/**
 * Returns the index of the node which is at position scrollTop.
 */
scout.Tree.prototype._nodeAtScrollTop = function(scrollTop) {
  var height = 0,
    nodeTop;
  this.visibleNodesFlat.some(function(node, i) {
    height += this._heightForNode(node);
    if (scrollTop < height) {
      nodeTop = node;
      return true;
    }
  }.bind(this));
  var visibleNodesLength = this.visibleNodesFlat.length;
  if (!nodeTop && visibleNodesLength > 0) {
    nodeTop = this.visibleNodesFlat[visibleNodesLength - 1];
  }
  return nodeTop;
};

scout.Tree.prototype._heightForNode = function(node) {
  var height = 0;
  if (node.height) {
    height = node.height;
  } else {
    height = this.nodeHeight;
  }
  return height;
};

scout.Tree.prototype._widthForNode = function(node) {
  var width = 0;
  if (node.width) {
    width = node.width;
  } else {
    width = this.nodeWidth;
  }
  return width;
};

/**
 * Returns a range of size this.viewRangeSize. Start of range is nodeIndex - viewRangeSize / 4.
 * -> 1/4 of the nodes are before the viewport 2/4 in the viewport 1/4 after the viewport,
 * assuming viewRangeSize is 2*number of possible nodes in the viewport (see calculateViewRangeSize).
 */
scout.Tree.prototype._calculateViewRangeForNode = function(node) {
  var viewRange = new scout.Range(),
    quarterRange = Math.floor(this.viewRangeSize / 4),
    diff;

  var nodeIndex = this.visibleNodesFlat.indexOf(node);
  viewRange.from = Math.max(nodeIndex - quarterRange, 0);
  viewRange.to = Math.min(viewRange.from + this.viewRangeSize, this.visibleNodesFlat.length);
  if (!node || nodeIndex === -1) {
    return viewRange;
  }

  // Try to use the whole viewRangeSize (extend from if necessary)
  diff = this.viewRangeSize - viewRange.size();
  if (diff > 0) {
    viewRange.from = Math.max(viewRange.to - this.viewRangeSize, 0);
  }
  return viewRange;
};

/**
 * Calculates the optimal view range size (number of nodes to be rendered).
 * It uses the default node height to estimate how many nodes fit in the view port.
 * The view range size is this value * 2.
 */
scout.Tree.prototype.calculateViewRangeSize = function() {
  // Make sure row height is up to date (row height may be different after zooming)
  this._updateNodeDimensions();

  if (this.nodeHeight === 0) {
    throw new Error('Cannot calculate view range with nodeHeight = 0');
  }
  return Math.ceil(this.$data.outerHeight() / this.nodeHeight) * 2;
};

scout.Tree.prototype.setViewRangeSize = function(viewRangeSize) {
  if (this.viewRangeSize === viewRangeSize) {
    return;
  }
  this._setProperty('viewRangeSize', viewRangeSize);
  if (this.rendered) {
    this._renderViewport();
  }
};

scout.Tree.prototype._updateNodeDimensions = function() {
  var node = {
    level: 0
  };
  var $emptyNode = this._$buildNode(node).appendTo(this.$data);
  this._renderNodeText(node);
  this.nodeHeight = $emptyNode.outerHeight(true);
  if (this.isHorizontalScrollingEnabled()) {
    var oldNodeWidth = this.nodeWidth;
    this.nodeWidth = $emptyNode.outerWidth(true);
    if (oldNodeWidth !== this.nodeWidth) {
      this.viewRangeDirty = true;
    }
  }
  $emptyNode.remove();
};

/**
 * Updates the node heights for every visible node and clears the height of the others
 */
scout.Tree.prototype.updateNodeHeights = function() {
  this.visibleNodesFlat.forEach(function(node) {
    if (!node.attached) {
      node.height = null;
    } else {
      node.height = node.$node.outerHeight(true);
    }
  });
};

/**
 * @param parentNode optional. If provided, this node's state will be updated (e.g. it will be collapsed)
 */
scout.Tree.prototype._removeNodes = function(nodes, parentNode) {
  if (nodes.length === 0) {
    return;
  }

  nodes.forEach(function(node) {
    this._removeFromFlatList(node, true);
    if (node.childNodes.length > 0) {
      this._removeNodes(node.childNodes, node);
    }
    if (node.$node) {
      if (this._$animationWrapper && this._$animationWrapper.find(node.$node).length > 0) {
        this._$animationWrapper.stop(false, true);
      }
      node.reset();
    }
  }, this);

  //If every child node was deleted mark node as collapsed (independent of the model state)
  //--> makes it consistent with addNodes and expand (expansion is not allowed if there are no child nodes)
  var $parentNode = (parentNode ? parentNode.$node : undefined);
  if ($parentNode) {
    var childNodesOfParent = parentNode.childNodes;
    if (!childNodesOfParent || childNodesOfParent.length === 0) {
      $parentNode.removeClass('expanded');
      $parentNode.removeClass('lazy');
    }
  }
  if (this.rendered) {
    this.viewRangeDirty = true;
    this.invalidateLayoutTree();
  }
};

scout.Tree.prototype._$buildNode = function(node) {
  var $node = this.$container.makeDiv('tree-node')
    .data('node', node)
    .attr('data-nodeid', node.id)
    .attr('data-level', node.level)
    .css('padding-left', this._computeTreeItemPaddingLeft(node.level));
  node.$node = $node;
  $node.appendSpan('text');

  this._renderTreeItemControl(node);

  if (this.checkable) {
    this._renderTreeItemCheckbox(node);
  }

  return $node;
};

scout.Tree.prototype._decorateNode = function(node) {
  var formerClasses,
    $node = node.$node;
  if (!$node) {
    // This node is not yet rendered, nothing to do
    return;
  }

  formerClasses = 'tree-node';
  if ($node.isSelected()) {
    formerClasses += ' selected';
  }
  if ($node.hasClass('ancestor-of-selected')) {
    formerClasses += ' ancestor-of-selected';
  }
  if ($node.hasClass('parent-of-selected')) {
    formerClasses += ' parent-of-selected';
  }
  $node.removeClass();
  $node.addClass(formerClasses);
  $node.addClass(node.cssClass);
  $node.toggleClass('leaf', !!node.leaf);
  $node.toggleClass('expanded', (!!node.expanded && node.childNodes.length > 0));
  $node.toggleClass('lazy', $node.hasClass('expanded') && node.expandedLazy);
  $node.toggleClass('group', !!this.groupedNodes[node.id]);
  $node.setEnabled(!!node.enabled);
  $node.children('.tree-node-control').setVisible(!node.leaf);
  $node.children('.tree-node-checkbox')
    .children('.check-box')
    .toggleClass('disabled', !(this.enabled && node.enabled));

  if (!node.parentNode && this.selectedNodes.length === 0) {
    // Root nodes have class child-of-selected if no node is selected
    $node.addClass('child-of-selected');
  } else if (node.parentNode && this.selectedNodes.indexOf(node.parentNode) > -1) {
    $node.addClass('child-of-selected');
  }

  this._renderNodeText(node);

  scout.styles.legacyStyle(node, $node);

  // TODO [6.1] bsh: More attributes...
  // iconId

  // If parent node is marked as 'lazy', check if any visible child nodes remain.
  if (node.parentNode && node.parentNode.expandedLazy) {
    var hasVisibleNodes = node.parentNode.childNodes.some(function(childNode) {
      if (this.visibleNodesMap[childNode.id]) {
        return true;
      }
    }.bind(this));
    if (!hasVisibleNodes && node.parentNode.$node) {
      // Remove 'lazy' from parent
      node.parentNode.$node.removeClass('lazy');
    }
  }
};

scout.Tree.prototype._renderTreeItemControl = function(node) {
  var $node = node.$node;
  var $control = $node.prependDiv('tree-node-control');
  if (this.checkable) {
    $control.addClass('checkable');
  }
  $control.setVisible(!node.leaf);
};

scout.Tree.prototype._renderTreeItemCheckbox = function(node) {
  var $node = node.$node,
    $controlItem = $node.prependDiv('tree-node-checkbox');
  var $checkboxDiv = $controlItem
    .appendDiv('check-box')
    .toggleClass('checked', node.checked)
    .toggleClass('disabled', !(this.enabled && node.enabled));

  if (node.childrenChecked) {
    $checkboxDiv.toggleClass('children-checked', true);
  } else {
    $checkboxDiv.toggleClass('children-checked', false);
  }
};

scout.Tree.prototype._renderNodeText = function(node) {
  var $node = node.$node,
    $text = $node.children('.text');
  if (node.htmlEnabled) {
    $text.html(node.text);
  } else {
    $text.textOrNbsp(node.text);
  }
};

scout.Tree.prototype._renderNodeChecked = function(node) {
  if (!node.$node) {
    // if node is not rendered, do nothing
    return;
  }

  node.$node
    .children('.tree-node-checkbox')
    .children('.check-box')
    .toggleClass('checked', node.checked);
};

scout.Tree.prototype._removeMenus = function() {
  // menubar takes care about removal
};

scout.Tree.prototype._filterMenus = function(menus, destination, onlyVisible, enableDisableKeyStroke) {
  return scout.menus.filterAccordingToSelection('Tree', this.selectedNodes.length, menus, destination, onlyVisible, enableDisableKeyStroke);
};

/**
 * @override
 */
scout.Tree.prototype._renderEnabled = function() {
  var enabled = this.enabled;
  this.$data.setEnabled(enabled);
  this.$container.setTabbable(enabled);

  if (this.rendered) {
    // Enable/disable all checkboxes
    this.$nodes().each(function() {
      var $node = $(this),
        node = $node.data('node');

      $node.children('.tree-node-checkbox')
        .children('.check-box')
        .toggleClass('disabled', !(enabled && node.enabled));
    });
  }
};

scout.Tree.prototype._renderCheckable = function() {
  // Define helper functions
  var isNodeRendered = function(node) {
    return !!node.$node;
  };
  var updateCheckableStateRec = function(node) {
    var $node = node.$node;
    var $control = $node.children('.tree-node-control');
    var $checkbox = $node.children('.tree-node-checkbox');

    if (this.checkable) {
      $control.addClass('checkable');
      if ($checkbox.length === 0) {
        this._renderTreeItemCheckbox(node);
      }
    } else {
      $control.removeClass('checkable');
      $checkbox.remove();
    }

    $node.css('padding-left', this._computeTreeItemPaddingLeft(parseFloat($node.attr('data-level'))));

    // Recursion
    if (node.childNodes) {
      node.childNodes.filter(isNodeRendered).forEach(updateCheckableStateRec);
    }
  }.bind(this);

  // Start recursion
  this.nodes.filter(isNodeRendered).forEach(updateCheckableStateRec);
};

scout.Tree.prototype._renderDisplayStyle = function() {
  this.$container.toggleClass('breadcrumb', this.isBreadcrumbStyleActive());

  // update scrollbar if mode has changed (from tree to bc or vice versa)
  this.invalidateLayoutTree();
};

scout.Tree.prototype._renderExpansion = function(node, options) {
  var opts = {
    expandLazyChanged: false,
    expansionChanged: false
  };
  $.extend(opts, options);

  var $node = node.$node,
    expanded = node.expanded;

  // Only render if node is rendered to make it possible to expand/collapse currently hidden nodes (used by collapseAll).
  if (!$node || $node.length === 0) {
    return;
  }

  // Only expand / collapse if there are child nodes
  if (node.childNodes.length === 0) {
    return true;
  }

  $node.toggleClass('lazy', expanded && node.expandedLazy);
  if (!opts.expansionChanged && !opts.expandLazyChanged) {
    // Expansion state has not changed -> return
    return;
  }

  if (expanded) {
    $node.addClass('expanded');
  } else {
    $node.removeClass('expanded');
  }
};

scout.Tree.prototype._renderSelection = function() {
  // Add children class to root nodes if no nodes are selected
  if (this.selectedNodes.length === 0) {
    this.nodes.forEach(function(childNode) {
      if (childNode.rendered) {
        childNode.$node.addClass('child-of-selected');
      }
    }, this);
  }

  this.selectedNodes.forEach(function(node) {
    if (!this.visibleNodesMap[node.id]) {
      return;
    }

    // Mark all ancestor nodes, especially necessary for bread crumb mode
    var parentNode = node.parentNode;
    if (parentNode && parentNode.rendered) {
      parentNode.$node.addClass('parent-of-selected');
    }
    while (parentNode) {
      if (parentNode.rendered) {
        parentNode.$node.addClass('ancestor-of-selected');
      }
      parentNode = parentNode.parentNode;
    }

    // Mark all child nodes
    if (node.expanded) {
      node.childNodes.forEach(function(childNode) {
        if (childNode.rendered) {
          childNode.$node.addClass('child-of-selected');
        }
      }, this);
    }

    if (node.rendered) {
      node.$node.select(true);
    }
  }, this);

  // Update 'group' markers for all rendered nodes
  for (var i = this.viewRangeRendered.from; i < this.viewRangeRendered.to; i++) {
    if (i >= this.visibleNodesFlat.length) {
      break;
    }
    var node = this.visibleNodesFlat[i];
    if (node && node.rendered) {
      node.$node.toggleClass('group', !!this.groupedNodes[node.id]);
    }
  }

  if (this.scrollToSelection) {
    this.revealSelection();
  }
};

scout.Tree.prototype._removeSelection = function() {
  // Remove children class on root nodes if no nodes were selected
  if (this.selectedNodes.length === 0) {
    this.nodes.forEach(function(childNode) {
      if (childNode.rendered) {
        childNode.$node.removeClass('child-of-selected');
      }
    }, this);
  }

  this.selectedNodes.forEach(this._removeNodeSelection, this);
};

scout.Tree.prototype._removeNodeSelection = function(node) {
  if (node.rendered) {
    node.$node.select(false);
  }

  // remove ancestor and child classes
  var parentNode = node.parentNode;
  if (parentNode && parentNode.rendered) {
    parentNode.$node.removeClass('parent-of-selected');
  }
  while (parentNode && parentNode.rendered) {
    parentNode.$node.removeClass('ancestor-of-selected');
    parentNode = parentNode.parentNode;
  }
  if (node.expanded) {
    node.childNodes.forEach(function(childNode) {
      if (childNode.rendered) {
        childNode.$node.removeClass('child-of-selected');
      }
    }, this);
  }
};

scout.Tree.prototype._renderDropType = function() {
  if (this.dropType) {
    this._installDragAndDropHandler();
  } else {
    this._uninstallDragAndDropHandler();
  }
};

scout.Tree.prototype._installDragAndDropHandler = function(event) {
  if (this.dragAndDropHandler) {
    return;
  }
  this.dragAndDropHandler = scout.dragAndDrop.handler(this, {
    supportedScoutTypes: scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,
    dropType: function() {
      return this.dropType;
    }.bind(this),
    dropMaximumSize: function() {
      return this.dropMaximumSize;
    }.bind(this),
    additionalDropProperties: function(event) {
      var $target = $(event.currentTarget);
      var properties = {
        nodeId: ''
      };
      if ($target.hasClass('tree-node')) {
        var node = $target.data('node');
        properties.nodeId = node.id;
      }
      return properties;
    }.bind(this)
  });
  this.dragAndDropHandler.install(this.$container, '.tree-data,.tree-node');
};

scout.Tree.prototype._uninstallDragAndDropHandler = function(event) {
  if (!this.dragAndDropHandler) {
    return;
  }
  this.dragAndDropHandler.uninstall();
  this.dragAndDropHandler = null;
};

scout.Tree.prototype._updateMarkChildrenChecked = function(node, init, checked, checkChildrenChecked) {
  if (!this.checkable) {
    return;
  }

  if (checkChildrenChecked) {
    var childrenFound = false;
    for (var j = 0; j < node.childNodes.length > 0; j++) {
      var childNode = node.childNodes[j];
      if (childNode.checked || childNode.childrenChecked) {
        node.childrenChecked = true;
        checked = true;
        childrenFound = true;
        if (this.rendered && node.$node) {
          node.$node
            .children('.tree-node-checkbox')
            .children('.check-box')
            .toggleClass('children-checked', true);
        }
        break;
      }
    }
    if (!childrenFound) {
      node.childrenChecked = false;
      if (this.rendered && node.$node) {
        node.$node.children('.tree-node-checkbox')
          .children('.check-box')
          .toggleClass('children-checked', false);
      }
    }
  }

  if (!node.parentNode || node.parentNode.checked) {
    return;
  }

  var stateChanged = false;
  if (!checked && !init) {
    //node was unchecked check siblings
    var hasCheckedSiblings = false;
    for (var i = 0; i < node.parentNode.childNodes.length > 0; i++) {
      var siblingNode = node.parentNode.childNodes[i];
      if (siblingNode.checked || siblingNode.childrenChecked) {
        hasCheckedSiblings = true;
        break;
      }
    }
    if (hasCheckedSiblings !== node.parentNode.childrenChecked) {
      //parentNode.checked should be false
      node.parentNode.childrenChecked = hasCheckedSiblings;
      stateChanged = true;
    }
  }
  if ((checked && !node.parentNode.childrenChecked)) {
    node.parentNode.childrenChecked = true;
    stateChanged = true;
  }
  if (stateChanged) {
    this._updateMarkChildrenChecked(node.parentNode, init, checked);
    if (this.rendered && node.parentNode.$node) {
      if (checked) {
        node.parentNode.$node.children('.tree-node-checkbox')
          .children('.check-box')
          .toggleClass('children-checked', true);
      } else {
        node.parentNode.$node.children('.tree-node-checkbox')
          .children('.check-box')
          .toggleClass('children-checked', false);
      }
    }
  }
};

scout.Tree.prototype._installNodeTooltipSupport = function() {
  scout.tooltips.install(this.$data, {
    parent: this,
    selector: '.tree-node',
    text: this._nodeTooltipText.bind(this),
    arrowPosition: 50,
    arrowPositionUnit: '%',
    nativeTooltip: !scout.device.isCustomEllipsisTooltipPossible()
  });
};

scout.Tree.prototype._uninstallNodeTooltipSupport = function() {
  scout.tooltips.uninstall(this.$data);
};

scout.Tree.prototype._nodeTooltipText = function($node) {
  var node = $node.data('node');

  if (node.tooltipText) {
    return node.tooltipText;
  } else if (this._isTruncatedNodeTooltipEnabled() && $node.isContentTruncated()) {
    return $node.children('.text').text();
  }
};

scout.Tree.prototype._isTruncatedNodeTooltipEnabled = function() {
  return true;
};

scout.Tree.prototype.setDisplayStyle = function(displayStyle) {
  if (this.displayStyle === displayStyle) {
    return;
  }
  this._renderViewportBlocked = true;
  this._syncDisplayStyle(displayStyle);
  if (this.rendered) {
    this._renderDisplayStyle();
  }
  this._renderViewportBlocked = false;
};

scout.Tree.prototype._syncDisplayStyle = function(displayStyle) {
  this._setProperty('displayStyle', displayStyle);

  if (displayStyle && this.selectedNodes.length > 0) {
    var selectedNode = this.selectedNodes[0];
    if (!selectedNode.expanded) {
      this.expandNode(selectedNode);
    }
  }

  if (this.displayStyle === scout.Tree.DisplayStyle.BREADCRUMB) {
    this.addFilter(this.breadcrumbFilter, true, true);
    this.filterVisibleNodes();
  } else if (this.displayStyle !== scout.Tree.DisplayStyle.BREADCRUMB) {
    this.removeFilter(this.breadcrumbFilter, true);
    this.filter();
  }
};

scout.Tree.prototype.setBreadcrumbStyleActive = function(active) {
  if (active) {
    this.setDisplayStyle(scout.Tree.DisplayStyle.BREADCRUMB);
  } else {
    this.setDisplayStyle(scout.Tree.DisplayStyle.DEFAULT);
  }
};

scout.Tree.prototype.isNodeInBreadcrumbVisible = function(node) {
  return this._inSelectionPathList[node.id] === undefined ? false : this._inSelectionPathList[node.id];
};

scout.Tree.prototype.isBreadcrumbStyleActive = function() {
  return this.displayStyle === scout.Tree.DisplayStyle.BREADCRUMB;
};

scout.Tree.prototype.setBreadcrumbTogglingThreshold = function(width) {
  this.setProperty('breadcrumbTogglingThreshold', width);
};

scout.Tree.prototype.expandNode = function(node, opts) {
  this.setNodeExpanded(node, true, opts);
};

scout.Tree.prototype.collapseNode = function(node, opts) {
  this.setNodeExpanded(node, false, opts);
};

scout.Tree.prototype.collapseAll = function() {
  this.rebuildSuppressed = true;
  // Collapse all expanded child nodes (only model)
  this._visitNodes(this.nodes, function(node) {
    this.collapseNode(node);
  }.bind(this));

  if (this.rendered) {
    // ensure correct rendering
    this._rerenderViewport();
  }

  this.rebuildSuppressed = false;
};

scout.Tree.prototype.setNodeExpanded = function(node, expanded, opts) {
  opts = opts || {};
  var lazy = scout.nvl(opts.lazy, node.lazyExpandingEnabled);
  var renderAnimated = scout.nvl(opts.renderAnimated, true);

  // Never do lazy expansion if it is disabled on the tree
  if (!this.lazyExpandingEnabled) {
    lazy = false;
  }

  if (this.isBreadcrumbStyleActive()) {
    // Do not allow to collapse a selected node
    if (!expanded && this.selectedNodes.indexOf(node) > -1) {
      this.setNodeExpanded(node, true, opts);
      return;
    }
  }

  // Optionally collapse all children (recursively)
  if (opts.collapseChildNodes) {
    // Suppress render expansion
    var childOpts = scout.objects.valueCopy(opts);
    childOpts.renderExpansion = false;

    node.childNodes.forEach(function(childNode) {
      if (childNode.expanded) {
        this.collapseNode(childNode, childOpts);
      }
    }.bind(this));
  }
  var renderExpansionOpts = {
    expansionChanged: false,
    expandLazyChanged: false
  };

  // Set expansion state
  if (node.expanded !== expanded || node.expandedLazy !== lazy) {
    renderExpansionOpts.expansionChanged = node.expanded !== expanded;
    renderExpansionOpts.expandLazyChanged = node.expandedLazy !== lazy;
    node.expanded = expanded;
    node.expandedLazy = lazy;
    if (this.groupedNodes[node.id]) {
      this._updateItemPath(false, node);
    }
    var filterStateChanged = this._applyFiltersForNode(node);
    if (filterStateChanged && renderExpansionOpts.expansionChanged) {
      this._rebuildParent(node.parentNode, opts);
    } else if (renderExpansionOpts.expandLazyChanged) {
      node.childNodes.forEach(function(child) {
        this._applyFiltersForNode(child);
      }.bind(this));
    }

    if (node.expanded) {
      node.ensureLoadChildren().done(
        this._addChildrenToFlatList.bind(this, node, null, renderAnimated, null, true));
    } else {
      this._removeChildrenFromFlatList(node, renderAnimated);
    }
    this.trigger('nodeExpanded', {
      node: node,
      expanded: expanded,
      expandedLazy: lazy
    });
    this.viewRangeDirty = true;
  }

  // Render expansion
  if (this.rendered && scout.nvl(opts.renderExpansion, true)) {
    this._renderExpansion(node, renderExpansionOpts);
  }
};

scout.Tree.prototype.setNodeExpandedRecursive = function(nodes, expanded, opts) {
  this._visitNodes(nodes, function(childNode) {
    this.setNodeExpanded(childNode, expanded, opts);
  }.bind(this));
};

scout.Tree.prototype._rebuildParent = function(node, opts) {
  if (this.rebuildSuppressed) {
    return;
  }
  if (node.expanded || node.expandedLazy) {
    this._addChildrenToFlatList(node, null, false, null, true);
  } else {
    this._removeChildrenFromFlatList(node, false);
  }
  // Render expansion
  if (this.rendered && scout.nvl(opts.renderExpansion, true)) {
    var renderExpansionOpts = {
      expansionChanged: true
    };
    this._renderExpansion(node, renderExpansionOpts);
  }
};

scout.Tree.prototype._removeChildrenFromFlatList = function(parentNode, animatedRemove) {
  // Only if a parent is available the children are available.
  if (this.visibleNodesMap[parentNode.id]) {
    var parentIndex = this.visibleNodesFlat.indexOf(parentNode);
    var elementsToDelete = 0;
    var parentLevel = parentNode.level;
    var removedNodes = [];
    animatedRemove = animatedRemove && this.rendered;
    if (this._$animationWrapper) {
      // Note: Do _not_ use finish() here! Although documentation states that it is "similar" to stop(true, true),
      // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when
      // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling
      // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)
      this._$animationWrapper.stop(false, true);
    }
    this._$expandAnimationWrappers.forEach(function($wrapper) {
      $wrapper.stop(false, true);
    });
    for (var i = parentIndex + 1; i < this.visibleNodesFlat.length; i++) {
      if (this.visibleNodesFlat[i].level > parentLevel) {
        var node = this.visibleNodesFlat[i];
        if (this.isHorizontalScrollingEnabled()) {
          //if node is the node which defines the widest width then recalculate width for render
          if (node.width === this.maxNodeWidth) {
            this.maxNodeWidth = 0;
            this.nodeWidthDirty = true;
          }
        }
        delete this.visibleNodesMap[this.visibleNodesFlat[i].id];
        if (node.attached && animatedRemove) {
          if (!this._$animationWrapper) {
            this._$animationWrapper = $('<div class="animation-wrapper">').insertBefore(node.$node);
            this._$animationWrapper.data('parentNode', parentNode);
          }
          if (node.isChildOf(this._$animationWrapper.data('parentNode'))) {
            this._$animationWrapper.append(node.$node);
          }
          node.attached = false;
          node.displayBackup = node.$node.css('display');
          removedNodes.push(node);
        } else if (node.attached && !animatedRemove) {
          this.hideNode(node, false, false);
        }
        elementsToDelete++;
      } else {
        break;
      }
    }

    this.visibleNodesFlat.splice(parentIndex + 1, elementsToDelete);
    // animate closing
    if (animatedRemove) { // don't animate while rendering (not necessary, or may even lead to timing issues)
      this._renderViewportBlocked = true;
      if (removedNodes.length > 0) {
        this._$animationWrapper.animate({
          height: 0
        }, {
          start: this.startAnimationFunc,
          complete: onAnimationComplete.bind(this, removedNodes),
          duration: 200,
          queue: false
        });
      } else if (this._$animationWrapper) {
        this._$animationWrapper.remove();
        this._$animationWrapper = null;
        onAnimationComplete.call(this, removedNodes);
      } else {
        this._renderViewportBlocked = false;
      }
    }
    return removedNodes;
  }

  //----- Helper functions -----
  function onAnimationComplete(affectedNodes) {
    affectedNodes.forEach(function(node) {
      node.$node.detach();
      node.$node.css('display', node.displayBackup);
      node.displayBackup = null;
    });
    if (this._$animationWrapper) {
      this._$animationWrapper.remove();
      this._$animationWrapper = null;
    }
    this.runningAnimationsFinishFunc();
  }

};

scout.Tree.prototype._removeFromFlatList = function(node, animatedRemove) {
  var removedNodes = [];
  if (this.visibleNodesMap[node.id]) {
    var index = this.visibleNodesFlat.indexOf(node);
    this._removeChildrenFromFlatList(node, false);
    if (this.isHorizontalScrollingEnabled()) {
      //if node is the node which defines the widest width then recalculate width for render
      if (node.width === this.maxNodeWidth) {
        this.maxNodeWidth = 0;
        this.nodeWidthDirty = true;
      }
    }
    removedNodes = scout.arrays.ensure(this.visibleNodesFlat.splice(index, 1));
    delete this.visibleNodesMap[node.id];
    this.hideNode(node, animatedRemove);
  }
  removedNodes.push(node);
  return removedNodes;
};

scout.Tree.prototype._addToVisibleFlatList = function(node, renderingAnimated) {
  // if node already is in visible list don't do anything. If no parentNode is available this node is on toplevel, if a parent is available
  // it has to be in visible list and also be expanded
  if (!this.visibleNodesMap[node.id] && node.isFilterAccepted() && (!node.parentNode ||
      (node.parentNode.expanded && this.visibleNodesMap[node.parentNode.id]))) {
    if (this.initialTraversing) {
      // for faster index calculation
      this._addToVisibleFlatListNoCheck(node, this.visibleNodesFlat.length, renderingAnimated);
    } else {
      var insertIndex = this._findIndexToInsertNode(node);
      this._addToVisibleFlatListNoCheck(node, insertIndex, renderingAnimated);
    }
  }
};

scout.Tree.prototype._findIndexToInsertNode = function(node) {
  var findValidSiblingBefore = function(childNodeIndex, siblings) {
    for (var i = childNodeIndex - 1; i >= 0; i--) {
      if (this.visibleNodesMap[siblings[i].id]) {
        return siblings[i];
      }
    }
    // no sibling before
    return null;
  }.bind(this);
  // function to traverse last child nodes to first child nodes of a parent.
  var findLastVisibleNodeInParent = function(parent) {
    if (parent.expanded) {
      for (var i = parent.childNodes.length - 1; i >= 0; i--) {
        if (this.visibleNodesMap[parent.childNodes[i].id]) {
          return findLastVisibleNodeInParent(parent.childNodes[i]);
        }
      }
    }
    return parent;
  }.bind(this);

  var parentNode = node.parentNode,
    siblingBefore, nodeBefore;
  if (!parentNode) {
    // use toplevel to find index
    siblingBefore = findValidSiblingBefore(node.childNodeIndex, this.nodes);
    if (!siblingBefore) {
      return 0;
    }
    nodeBefore = findLastVisibleNodeInParent(siblingBefore);
    return this.visibleNodesFlat.indexOf(nodeBefore) + 1;
  } else {
    siblingBefore = findValidSiblingBefore(node.childNodeIndex, node.parentNode.childNodes);
    if (!siblingBefore) {
      nodeBefore = parentNode;
    } else {
      nodeBefore = findLastVisibleNodeInParent(siblingBefore);
    }
    return this.visibleNodesFlat.indexOf(nodeBefore) + 1;
  }
};

// TODO [6.1] CGU applies to all the add/remove to/from flat list methods:
// Is it really necessary to update dom on every operation? why not just update the list and renderViewport at the end?
// The update of the flat list is currently implemented quite complicated -> it should be simplified.
// And: because add to flat list renders all the children the rendered node count is greater than the viewRangeSize until the layout renders the viewport again -> this must not happen (can be seen when a node gets expanded=
scout.Tree.prototype._addChildrenToFlatList = function(parentNode, parentIndex, animatedRendering, insertBatch, forceFilter) {
  //add nodes recursively
  if (!this.visibleNodesMap[parentNode.id]) {
    return 0;
  }
  var isSubAdding = !!insertBatch;
  parentIndex = parentIndex ? parentIndex : this.visibleNodesFlat.indexOf(parentNode);
  animatedRendering = animatedRendering && this.rendered; // don't animate while rendering (not necessary, or may even lead to timing issues)
  if (this._$animationWrapper && !isSubAdding) {
    // Note: Do _not_ use finish() here! Although documentation states that it is "similar" to stop(true, true),
    // this does not seem to be the case. Implementations differ slightly in details. The effect is, that when
    // calling stop() the animation stops and the 'complete' callback is executed immediately. However, when calling
    // finish(), the callback is _not_ executed! (This may or may not be a bug in jQuery, I cannot tell...)
    this._$animationWrapper.stop(false, true);
  }
  insertBatch = insertBatch ? insertBatch : this.setUpInsertBatch(parentIndex + 1);
  parentNode.childNodes.forEach(function(node, index) {
    var isAlreadyAdded = this.visibleNodesMap[node.id];
    if (node.initialized && node.isFilterAccepted(forceFilter) && !isAlreadyAdded) {
      insertBatch.insertNodes.push(node);
      this.visibleNodesMap[node.id] = true;
      insertBatch = this.checkAndHandleBatch(insertBatch, parentNode, animatedRendering);
      if (node.expanded) {
        insertBatch = this._addChildrenToFlatList(node, insertBatch.lastBatchInsertIndex(), animatedRendering, insertBatch, forceFilter);
      }
    } else if (node.initialized && node.isFilterAccepted(forceFilter) && isAlreadyAdded) {
      this.insertBatchInVisibleNodes(insertBatch, this.viewRangeRendered.from + this.viewRangeSize >= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex(), animatedRendering);
      this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);
      var updateIndex = insertBatch.insertedAny() ? 2 : 1;
      insertBatch = this.setUpInsertBatch(insertBatch.lastBatchInsertIndex() + updateIndex);
      if (node.expanded) {
        insertBatch = this._addChildrenToFlatList(node, insertBatch.lastBatchInsertIndex(), animatedRendering, insertBatch, forceFilter);
      }
      //do not animate following
      animatedRendering = false;
    }
  }.bind(this));

  if (!isSubAdding) {
    // animation is not done yet and all added nodes are in visible range
    this.insertBatchInVisibleNodes(insertBatch, this.viewRangeRendered.from + this.viewRangeSize >= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex(), animatedRendering);
    this.invalidateLayoutTree();
  }

  return insertBatch;
};

scout.Tree.prototype.setUpInsertBatch = function(insertIndex) {
  return {
    insertNodes: [insertIndex, 0],
    $animationWrapper: null,
    lastBatchInsertIndex: function() {
      if (this.insertNodes.length === 2) {
        return this.insertNodes[0];
      }
      return this.insertNodes[0] + this.insertNodes.length - 3;
    },
    insertedAny: function() {
      return this.insertNodes.length > 2;
    }
  };
};

scout.Tree.prototype.checkAndHandleBatchAnimationWrapper = function(parentNode, animatedRendering, insertBatch) {
  if (animatedRendering && this.viewRangeRendered.from <= insertBatch.lastBatchInsertIndex() && this.viewRangeRendered.to >= insertBatch.lastBatchInsertIndex() && !insertBatch.$animationWrapper) {
    //we are in visible area so we need a animation wrapper
    //if parent is in visible area insert after parent else insert before first node.
    var lastNodeIndex = insertBatch.lastBatchInsertIndex() - 1,
      nodeBefore = this.viewRangeRendered.from === insertBatch.lastBatchInsertIndex() ? null : this.visibleNodesFlat[lastNodeIndex];
    if (nodeBefore && lastNodeIndex >= this.viewRangeRendered.from && lastNodeIndex < this.viewRangeRendered.to && !nodeBefore.attached) {
      //ensure node before is visible
      this.showNode(nodeBefore, false, lastNodeIndex);
    }
    if (nodeBefore && nodeBefore.attached) {
      insertBatch.$animationWrapper = $('<div class="animation-wrapper">').insertAfter(nodeBefore.$node);
    } else if (parentNode.attached) {
      insertBatch.$animationWrapper = $('<div class="animation-wrapper">').insertAfter(parentNode.$node);
    } else if (this.$fillBefore) {
      insertBatch.$animationWrapper = $('<div class="animation-wrapper">').insertAfter(this.$fillBefore);
    } else {
      var nodeAfter = this.visibleNodesFlat[insertBatch.lastBatchInsertIndex()];
      insertBatch.$animationWrapper = $('<div class="animation-wrapper">').insertBefore(nodeAfter.$node);
    }
    insertBatch.animationCompleteFunc = onAnimationComplete;
    this._$expandAnimationWrappers.push(insertBatch.$animationWrapper);
  }
  //----- Helper functions ----- //

  function onAnimationComplete() {
    insertBatch.$animationWrapper.replaceWith(insertBatch.$animationWrapper.contents());
    scout.arrays.remove(this._$expandAnimationWrappers, insertBatch.$animationWrapper);
    insertBatch.$animationWrapper = null;
    this.runningAnimationsFinishFunc();
  }
};

scout.Tree.prototype.checkAndHandleBatch = function(insertBatch, parentNode, animatedRendering) {
  if (this.viewRangeRendered.from - 1 === insertBatch.lastBatchInsertIndex()) {
    //do immediate rendering because list could be longer
    this.insertBatchInVisibleNodes(insertBatch, false, false);
    insertBatch = this.setUpInsertBatch(insertBatch.lastBatchInsertIndex() + 1);
  }
  this.checkAndHandleBatchAnimationWrapper(parentNode, animatedRendering, insertBatch);

  if (this.viewRangeRendered.from + this.viewRangeSize - 1 === insertBatch.lastBatchInsertIndex()) {
    //do immediate rendering because list could be longer
    this.insertBatchInVisibleNodes(insertBatch, true, animatedRendering);
    insertBatch = this.setUpInsertBatch(insertBatch.lastBatchInsertIndex() + 1);
  }
  return insertBatch;
};

scout.Tree.prototype.insertBatchInVisibleNodes = function(insertBatch, showNodes, animate) {
  if (insertBatch.insertNodes < 3) {
    //nothing to add
    return;
  }
  this.visibleNodesFlat.splice.apply(this.visibleNodesFlat, insertBatch.insertNodes);
  if (showNodes) {
    var indexHint = insertBatch.insertNodes[0];
    for (var i = 2; i < insertBatch.insertNodes.length; i++) {
      var node = insertBatch.insertNodes[i];
      this.showNode(node, false, indexHint);
      if (insertBatch.$animationWrapper) {
        insertBatch.$animationWrapper.append(node.$node);
      }
      indexHint++;
    }
    if (insertBatch.$animationWrapper) {
      var h = insertBatch.$animationWrapper.outerHeight();
      insertBatch.$animationWrapper
        .css('height', 0)
        .animate({
          height: h
        }, {
          start: this.startAnimationFunc,
          complete: insertBatch.animationCompleteFunc.bind(this),
          duration: 200,
          queue: false
        });
    }
  }
};

scout.Tree.prototype._addToVisibleFlatListNoCheck = function(node, insertIndex, animatedRendering) {
  scout.arrays.insert(this.visibleNodesFlat, node, insertIndex);
  this.visibleNodesMap[node.id] = true;
  if (this.rendered) {
    this.showNode(node, animatedRendering, insertIndex);
  }
};

scout.Tree.prototype.scrollTo = function(node) {
  if (this.viewRangeRendered.size() === 0) {
    // Cannot scroll to a node if no node is rendered
    return;
  }
  if (!node.attached) {
    this._renderViewRangeForNode(node);
  }
  scout.scrollbars.scrollTo(this.$data, node.$node);
};

scout.Tree.prototype.revealSelection = function() {
  if (!this.rendered) {
    // Execute delayed because table may be not layouted yet
    this.session.layoutValidator.schedulePostValidateFunction(this.revealSelection.bind(this));
    return;
  }

  if (this.selectedNodes.length > 0) {
    if (!this.visibleNodesMap[this.selectedNodes[0].id]) {
      this._expandAllParentNodes(this.selectedNodes[0]);
    }
    this.scrollTo(this.selectedNodes[0]);
  }
};

scout.Tree.prototype.deselectAll = function() {
  this.selectNodes([]);
};

scout.Tree.prototype.selectNode = function(node, debounceSend) {
  this.selectNodes(node);
};

scout.Tree.prototype.selectNodes = function(nodes, debounceSend) {
  var scrollTop;
  nodes = scout.arrays.ensure(nodes);

  if (scout.arrays.equalsIgnoreOrder(nodes, this.selectedNodes)) {
    return;
  }

  if (this.rendered) {
    if (this.isBreadcrumbStyleActive()) {
      scrollTop = this.$data[0].scrollTop;
    }
    this._removeSelection();
  }

  // Make a copy so that original array stays untouched
  this.selectedNodes = nodes.slice();
  this._nodesSelectedInternal();
  this._triggerNodesSelected(debounceSend);

  if (this.selectedNodes.length > 0 && !this.visibleNodesMap[this.selectedNodes[0].id]) {
    this._expandAllParentNodes(this.selectedNodes[0]);
  }

  this._updateItemPath(true);
  if (this.isBreadcrumbStyleActive()) {
    // In breadcrumb mode selected node has to expanded
    if (this.selectedNodes.length > 0 && !this.selectedNodes[0].expanded) {
      this.expandNode(this.selectedNodes[0]);
      this.selectedNodes[0].filterDirty = true;
    }
    this.filter(true);
  }
  this._updateMenuBar();
  if (this.rendered) {
    this._renderSelection();
    // restore scrollTop (removeSelection removes all the selection classes which makes a lot of elements invisible and therefore the scrollHeight smaller)
    if (this.isBreadcrumbStyleActive()) {
      this.$data[0].scrollTop = scrollTop;
    }
  }
};

/**
 * This method is overridden by subclasses of Tree. The default impl. does nothing.
 */
scout.Tree.prototype._nodesSelectedInternal = function(node) {
  // NOP
};

scout.Tree.prototype.deselectNode = function(node) {
  this.deselectNodes(node);
};

scout.Tree.prototype.deselectNodes = function(nodes) {
  nodes = scout.arrays.ensure(nodes);
  var selectedNodes = this.selectedNodes.slice(); // copy
  if (scout.arrays.removeAll(selectedNodes, nodes)) {
    this.selectNodes(selectedNodes);
  }
};

scout.Tree.prototype.isNodeSelected = function(node) {
  return this.selectedNodes.indexOf(node) > -1;
};

scout.Tree.prototype._computeTreeItemPaddingLeft = function(level, selected) {
  if (this.checkable) {
    return level * this._treeItemPaddingLevel + this._treeItemPaddingLeft + this._treeItemCheckBoxPaddingLeft;
  }
  return level * this._treeItemPaddingLevel + this._treeItemPaddingLeft;
};

scout.Tree.prototype._expandAllParentNodes = function(node) {
  var i, currNode = node,
    parentNodes = [];

  currNode = node;
  var nodesToInsert = [];
  while (currNode.parentNode) {
    parentNodes.push(currNode.parentNode);
    if (!this.visibleNodesMap[currNode.id]) {
      nodesToInsert.push(currNode);
    }
    currNode = currNode.parentNode;
  }

  for (i = parentNodes.length - 1; i >= 0; i--) {
    if (nodesToInsert.indexOf(parentNodes[i]) !== -1) {
      this._addToVisibleFlatList(parentNodes[i], false);
    }
    if (!parentNodes[i].expanded) {
      this.expandNode(parentNodes[i], {
        renderExpansion: false,
        renderAnimated: false
      });
    }
  }
  if (this.rendered && nodesToInsert.length > 0) {
    this._rerenderViewport();
    this.invalidateLayoutTree();
  }
};

scout.Tree.prototype._updateChildNodeIndex = function(nodes, startIndex) {
  for (var i = scout.nvl(startIndex, 0); i < nodes.length; i++) {
    nodes[i].childNodeIndex = i;
  }
};

scout.Tree.prototype.insertNodes = function(nodes, parentNode) {
  this._ensureTreeNodes(nodes);
  if (parentNode && !(parentNode instanceof scout.TreeNode)) {
    throw new Error('parent has to be a tree node: ' + parentNode);
  }

  // Append continuous node blocks
  nodes.sort(function(a, b) {
    return a.childNodeIndex - b.childNodeIndex;
  });

  // Update parent with new child nodes
  if (parentNode) {
    if (parentNode.childNodes && parentNode.childNodes.length > 0) {
      nodes.forEach(function(entry) {
        scout.arrays.insert(parentNode.childNodes, entry, entry.childNodeIndex);
      }.bind(this));
      this._updateChildNodeIndex(parentNode.childNodes, nodes[0].childNodeIndex);
    } else {
      nodes.forEach(function(entry) {
        parentNode.childNodes.push(entry);
      }.bind(this));
    }
    //initialize node and add to visible list if node is visible
    this._visitNodes(nodes, this._initTreeNode.bind(this), parentNode);
    this._visitNodes(nodes, this._updateFlatListAndSelectionPath.bind(this), parentNode);
    if (this.groupedNodes[parentNode.id]) {
      this._updateItemPath(false, parentNode);
    }
    if (this.rendered) {
      var opts = {
        expansionChanged: true
      };
      this._renderExpansion(parentNode, opts);
    }
  } else {
    if (this.nodes && this.nodes.length > 0) {
      nodes.forEach(function(entry) {
        scout.arrays.insert(this.nodes, entry, entry.childNodeIndex);
      }.bind(this));
      this._updateChildNodeIndex(this.nodes, nodes[0].childNodeIndex);
    } else {
      scout.arrays.pushAll(this.nodes, nodes);
    }
    //initialize node and add to visible list if node is visible
    this._visitNodes(nodes, this._initTreeNode.bind(this), parentNode);
    this._visitNodes(nodes, this._updateFlatListAndSelectionPath.bind(this), parentNode);
  }
  if (this.rendered) {
    this.viewRangeDirty = true;
    this.invalidateLayoutTree();
  }
  this.trigger('nodesInserted', {
    nodes: nodes,
    parentNode: parentNode
  });
};

scout.Tree.prototype.updateNode = function(node) {
  this.updateNodes([node]);
};

scout.Tree.prototype.updateNodes = function(nodes) {
  nodes.forEach(function(updatedNode) {
    var propertiesChanged,
      oldNode = this.nodesMap[updatedNode.id];

    // if same instance has been updated we must set the flag always to true
    // because we cannot compare against an "old" node
    if (updatedNode === oldNode) {
      propertiesChanged = true;
    } else {
      this._applyNodeDefaultValues(updatedNode);
      propertiesChanged = this._applyUpdatedNodeProperties(oldNode, updatedNode);
    }

    if (propertiesChanged) {
      if (this._applyFiltersForNode(oldNode)) {
        if (!oldNode.isFilterAccepted()) {
          this._nodesFiltered([oldNode]);
          this._removeFromFlatList(oldNode, false);
        } else {
          this._addToVisibleFlatList(oldNode, false);
        }
      }
      this._updateItemPath(false, oldNode.parentNode);
      if (this.rendered) {
        this._decorateNode(oldNode);
      }
    }
  }, this);

  this.trigger('nodesUpdated', {
    nodes: nodes
  });
};

/**
 * Called by _onNodesUpdated for every updated node. The function is expected to apply
 * all updated properties from the updatedNode to the oldNode. May be overridden by
 * subclasses so update their specific node properties.
 *
 * @param oldNode
 *          The target node to be updated
 * @param updatedNode
 *          The new node with potentially updated properties. Default values are already applied!
 * @returns
 *          true if at least one property has changed, false otherwise. This value is used to
 *          determine if the node has to be rendered again.
 */
scout.Tree.prototype._applyUpdatedNodeProperties = function(oldNode, updatedNode) {
  // Note: We only update _some_ of the properties, because everything else will be handled
  // with separate events. --> See also: JsonTree.java/handleModelNodesUpdated()
  var propertiesChanged = false;
  if (oldNode.leaf !== updatedNode.leaf) {
    oldNode.leaf = updatedNode.leaf;
    propertiesChanged = true;
  }
  if (oldNode.enabled !== updatedNode.enabled) {
    oldNode.enabled = updatedNode.enabled;
    propertiesChanged = true;
  }
  if (oldNode.lazyExpandingEnabled !== updatedNode.lazyExpandingEnabled) {
    oldNode.lazyExpandingEnabled = updatedNode.lazyExpandingEnabled;
    // Also make sure expandedLazy is resetted (same code as in AbstractTreeNode.setLazyExpandingEnabled)
    oldNode.expandedLazy = updatedNode.lazyExpandingEnabled && this.lazyExpandingEnabled;
    propertiesChanged = true;
  }
  return propertiesChanged;
};

scout.Tree.prototype.deleteNodes = function(nodes, parentNode) {
  var deletedNodes = [];

  nodes.forEach(function(node) {
    if (parentNode) {
      if (node.parentNode !== parentNode) {
        throw new Error('Unexpected parent. Node.parent: ' + node.parentNode + ', parentNode: ' + parentNode);
      }
      scout.arrays.remove(parentNode.childNodes, node);
    } else {
      scout.arrays.remove(this.nodes, node);
    }
    this._destroyTreeNode(node, node.parentNode);
    deletedNodes.push(node);
    this._updateMarkChildrenChecked(node, false, false);

    // remove children from node map
    this._visitNodes(node.childNodes, this._destroyTreeNode.bind(this));
  }, this);

  // update child node indices
  if (parentNode) {
    this._updateChildNodeIndex(parentNode.childNodes);
  } else {
    this._updateChildNodeIndex(this.nodes);
  }

  // remove node from html document
  if (this.rendered) {
    this._removeNodes(deletedNodes, parentNode);
  }

  this.trigger('nodesDeleted', {
    nodes: nodes,
    parentNode: parentNode
  });
};

scout.Tree.prototype.deleteAllChildNodes = function(parentNode) {
  var nodes;
  if (parentNode) {
    nodes = parentNode.childNodes;
    parentNode.childNodes = [];
  } else {
    nodes = this.nodes;
    this.nodes = [];
  }
  this._visitNodes(nodes, updateNodeMap.bind(this));

  // remove node from html document
  if (this.rendered) {
    this._removeNodes(nodes, parentNode);
  }

  this.trigger('allChildNodesDeleted', {
    parentNode: parentNode
  });

  // --- Helper functions ---

  // Update model and nodemap
  function updateNodeMap(node, parentNode) {
    this._destroyTreeNode(node, parentNode);
    this._updateMarkChildrenChecked(node, false, false);
  }
};

scout.Tree.prototype.updateNodeOrder = function(childNodes, parentNode) {
  childNodes = scout.arrays.ensure(childNodes);

  this._updateChildNodeIndex(childNodes);
  if (parentNode) {
    if (parentNode.childNodes.length !== childNodes.length) {
      throw new Error('Node order may not be updated because lengths of the arrays differ.');
    }
    // Make a copy so that original array stays untouched
    parentNode.childNodes = childNodes.slice();
    this._removeChildrenFromFlatList(parentNode, false);
    if (parentNode.expanded) {
      this._addChildrenToFlatList(parentNode, null, false);
    }
  } else {
    if (this.nodes.length !== childNodes.length) {
      throw new Error('Node order may not be updated because lengths of the arrays differ.');
    }
    // Make a copy so that original array stays untouched
    this.nodes = childNodes.slice();
    this.nodes.forEach(function(node) {
      this._removeFromFlatList(node, false);
      this._addToVisibleFlatList(node, false);
      if (node.expanded) {
        this._addChildrenToFlatList(node, null, false);
      }
    }, this);
  }

  this.trigger('childNodeOrderChanged', {
    parentNode: parentNode
  });
};

scout.Tree.prototype.checkNode = function(node, checked) {
  this.checkNodes([node], {
    checked: checked
  });
};

scout.Tree.prototype.checkNodes = function(nodes, options) {
  var opts = {
    checked: true,
    checkOnlyEnabled: true,
    checkChildren: this.autoCheckChildren
  };
  $.extend(opts, options);
  var updatedNodes = [];
  if (!this.checkable || (!this.enabled && opts.checkOnlyEnabled)) {
    return;
  }
  nodes = scout.arrays.ensure(nodes);
  nodes.forEach(function(node) {
    if ((!node.enabled && opts.checkOnlyEnabled) || node.checked === opts.checked) {
      if (opts.checkChildren) {
        this.checkNodes(node.childNodes, opts);
      }
      return;
    }
    if (!this.multiCheck && opts.checked) {
      for (var i = 0; i < this.checkedNodes.length; i++) {
        this.checkedNodes[i].checked = false;
        this._updateMarkChildrenChecked(this.checkedNodes[i], false, false, true);
        updatedNodes.push(this.checkedNodes[i]);
      }
      this.checkedNodes = [];
    }
    node.checked = opts.checked;
    if (node.checked) {
      this.checkedNodes.push(node);
    }
    updatedNodes.push(node);
    this._updateMarkChildrenChecked(node, false, opts.checked, true);
    if (opts.checkChildren) {
      this.checkNodes(node.childNodes, opts);
    }
  }, this);

  if (updatedNodes.length > 0) {
    this.trigger('nodesChecked', {
      nodes: updatedNodes
    });
  }
  if (this.rendered) {
    updatedNodes.forEach(function(node) {
      this._renderNodeChecked(node);
    }, this);
  }
};

scout.Tree.prototype.uncheckNode = function(node) {
  this.uncheckNodes([node], {
    checkOnlyEnabled: true
  });
};

scout.Tree.prototype.uncheckNodes = function(nodes, options) {
  options.checked = false;
  this.checkNodes(nodes, options);
};

scout.Tree.prototype._triggerNodesSelected = function(debounce) {
  this.trigger('nodesSelected', {
    debounce: debounce
  });
};

scout.Tree.prototype._showContextMenu = function(event) {
  var func = function(event) {
    event.preventDefault();

    var filteredMenus = this._filterMenus(this.menus, scout.MenuDestinations.CONTEXT_MENU, true),
      $part = $(event.currentTarget);
    if (filteredMenus.length === 0) {
      return; // at least one menu item must be visible
    }
    this.contextMenu = scout.create('ContextMenuPopup', {
      parent: this,
      menuItems: filteredMenus,
      location: {
        x: event.pageX,
        y: event.pageY
      },
      $anchor: $part,
      menuFilter: this._filterMenusHandler
    });
    this.contextMenu.open();

    // Set table style to focused, so that it looks as it still has the focus.
    // Must be called after open(), because opening the popup might cause another
    // popup to close first (which will remove the 'focused' class).
    if (this.enabled) {
      this.$container.addClass('focused');
      this.contextMenu.on('close', function(event) {
        this.$container.removeClass('focused');
        this.contextMenu = null;
      }.bind(this));
    }
  };

  scout.menus.showContextMenuWithWait(this.session, func.bind(this), event);
};

scout.Tree.prototype._onNodeMouseDown = function(event) {
  this._doubleClickSupport.mousedown(event);
  if (this._doubleClickSupport.doubleClicked()) {
    //don't execute on double click events
    return false;
  }

  var $node = $(event.currentTarget);
  var node = $node.data('node');
  if (!this.hasNode(node)) {
    // if node does not belong to this tree, do nothing (may happen if another tree is embedded inside the node)
    return;
  }
  this._$mouseDownNode = $node;
  $node.window().one('mouseup', function() {
    this._$mouseDownNode = null;
  }.bind(this));

  this.selectNodes(node);

  if (this.checkable && this._isCheckboxClicked(event)) {
    // TODO awe: (check-box) testen ob wir hier den aufruf supportsFocus* wegnehmen knnen (analog CheckBox.js)
    // sollte nach dem refactoring des ::before Elements in der CheckBox nicht mehr ntig sein
    if (!scout.device.supportsFocusEmptyBeforeDiv()) {
      this.session.focusManager.requestFocus(this.$container);
      event.preventDefault();
    }
    this.checkNode(node, !node.checked);
  }
  return true;
};

scout.Tree.prototype._onNodeMouseUp = function(event) {
  if (this._doubleClickSupport.doubleClicked()) {
    //don't execute on double click events
    return false;
  }

  var $node = $(event.currentTarget);
  var node = $node.data('node');
  if (!this._$mouseDownNode || this._$mouseDownNode[0] !== $node[0]) {
    // Don't accept if mouse up happens on another node than mouse down, or mousedown didn't happen on a node at all
    return;
  }

  this.trigger('nodeClicked', {
    node: node
  });
  return true;
};

scout.Tree.prototype._isCheckboxClicked = function(event) {
  return $(event.target).is('.check-box');
};

scout.Tree.prototype._updateItemPath = function(selectionChanged, ultimate) {
  var selectedNodes, node, level;
  if (selectionChanged) {
    // first remove and select selected
    this.groupedNodes = {};

    this._inSelectionPathList = {};
  }

  if (!ultimate) {
    // find direct children
    selectedNodes = this.selectedNodes;
    if (selectedNodes.length === 0) {
      return;
    }
    node = selectedNodes[0];

    if (selectionChanged) {
      this._inSelectionPathList[node.id] = true;
      if (node.childNodes) {
        node.childNodes.forEach(function(child) {
          this._inSelectionPathList[child.id] = true;
        }.bind(this));
      }
    }
    level = node.level;

    // find grouping end (ultimate parent)
    while (node.parentNode) {
      var parent = node.parentNode;
      if (this._isGroupingEnd(parent) && !ultimate) {
        ultimate = node;
        if (!selectionChanged) {
          break;
        }
      }
      if (selectionChanged) {
        this._inSelectionPathList[parent.id] = true;
      }
      node = parent;
    }
    // find group with same ultimate parent
    ultimate = ultimate || selectedNodes[0];
    this.groupedNodes[ultimate.id] = true;
  }
  node = ultimate;
  if (node && node.expanded && this.groupedNodes[node.id]) {
    addToGroup.call(this, node.childNodes);
  }
  //------ helper function ------//

  function addToGroup(nodes) {
    nodes.forEach(function(node) {
      this.groupedNodes[node.id] = true;
      this._decorateNode(node);
      if (node.expanded && node.isFilterAccepted()) {
        addToGroup.call(this, node.childNodes);
      }
    }.bind(this));
  }
};

scout.Tree.prototype._isGroupingEnd = function(node) {
  // May be implemented by subclasses, default tree has no grouping parent
  return false;
};

/**
 * @returns {scout.TreeNode} the first selected node or null when no node is selected.
 */
scout.Tree.prototype.selectedNode = function() {
  if (this.selectedNodes.length === 0) {
    return null;
  }
  return this.selectedNodes[0];
};

scout.Tree.prototype.$selectedNodes = function() {
  return this.$data.find('.selected');
};

scout.Tree.prototype.$nodes = function() {
  return this.$data.find('.tree-node');
};

/**
 * @param filter object with createKey() and accept()
 */
scout.Tree.prototype.addFilter = function(filter, doNotFilter, notAnimated) {
  if (this._filters.indexOf(filter) < 0) {
    this._filters.push(filter);
    if (!doNotFilter) {
      this.filter(notAnimated);
    }
    return true;
  }
  return false;
};

scout.Tree.prototype.removeFilter = function(filter, notAnimated) {
  scout.arrays.remove(this._filters, filter);
  this.filter(notAnimated);
};

scout.Tree.prototype.filter = function(notAnimated) {
  var useAnimation = !!!notAnimated,
    changedNodes = [],
    newHiddenNodes = [];
  // Filter nodes
  this._visitNodes(this.nodes, function(node) {
    var changed = this._applyFiltersForNode(node);
    if (changed) {
      changedNodes.push(node);
      if (!node.isFilterAccepted()) {
        scout.arrays.pushAll(newHiddenNodes, this._removeFromFlatList(node, useAnimation));
      } else {
        this._addToVisibleFlatList(node, useAnimation);
      }
      this.viewRangeDirty = true;
    } else {
      // this else branch is required when the filter-state of a node has not changed
      // for instance Node "Telefon mit Sabrina" is visible for filter "tel" and also
      // for filter "abr". However, it is possible that the node is _not_ attached, when
      // we switch from one filter to another, because the node was not in the view-range
      // with the previous filter. That's why we must make sure, the node is attached to
      // the DOM, even though the filter state hasn't changed. Otherwise we'd have a
      // problem when we insert nodes in this._insertNodeInDOMAtPlace.
      this.showNode(node, useAnimation);
    }
    if ((node.expanded || node.expandedLazy) && node.isFilterAccepted()) {
      return false;
    }
    // don't process children->optimize performance
    return true;
  }.bind(this));

  this._nodesFiltered(newHiddenNodes);
};

/**
 * use filtered nodes are removed from visible nodes
 */
scout.Tree.prototype.filterVisibleNodes = function(animated) {
  // Filter nodes
  var newHiddenNodes = [];
  for (var i = 0; i < this.visibleNodesFlat.length; i++) {
    var node = this.visibleNodesFlat[i];
    var changed = this._applyFiltersForNode(node);
    if (changed) {
      if (!node.isFilterAccepted()) {
        i--;
        scout.arrays.pushAll(newHiddenNodes, this._removeFromFlatList(node, animated));
      }
      this.viewRangeDirty = true;
    }
  }

  this._nodesFiltered(newHiddenNodes);
};

scout.Tree.prototype._nodesFiltered = function(hiddenNodes) {
  // non visible nodes must be deselected
  this.deselectNodes(hiddenNodes);
};

scout.Tree.prototype._nodeAcceptedByFilters = function(node) {
  for (var i = 0; i < this._filters.length; i++) {
    var filter = this._filters[i];
    if (!filter.accept(node)) {
      return false;
    }
  }
  return true;
};

/**
 * @returns {Boolean} true if node state has changed, false if not
 */
scout.Tree.prototype._applyFiltersForNode = function(node) {
  var changed = node.filterDirty;
  if (this._nodeAcceptedByFilters(node)) {
    if (!node.filterAccepted) {
      node.filterAccepted = true;
      changed = true;
    }
  } else {
    if (node.filterAccepted) {
      node.filterAccepted = false;
      changed = true;
    }
  }
  if (changed) {
    node.filterDirty = false;
    node.childNodes.forEach(function(childNode) {
      childNode.filterDirty = true;
    });
    return true;
  }
  return false;
};

/**
 * Just insert node in DOM. NO check if in viewRange
 */
scout.Tree.prototype._insertNodeInDOM = function(node, indexHint) {
  if (!this.rendered && !this.rendering) {
    return;
  }
  var index = indexHint === undefined ? this.visibleNodesFlat.indexOf(node) : indexHint;
  if (index === -1 || !(this.viewRangeRendered.from + this.viewRangeSize >= index && this.viewRangeRendered.from <= index && this.viewRangeRendered.size() > 0) || node.attached) {
    //node is not visible
    return;
  }
  if (!node.$node) {
    this._$buildNode(node);
  }
  this._decorateNode(node);

  this._insertNodeInDOMAtPlace(node, index);

  node.height = node.$node.outerHeight(true);
  if (this.isHorizontalScrollingEnabled()) {
    var widthBackup = node.width ? node.width : 0,
      displayBackup = node.$node.css('display');
    node.$node.css('width', 'auto');
    node.$node.css('display', 'inline-block');
    var newWidth = node.$node.outerWidth();
    if (widthBackup === this.maxNodeWidth && newWidth < this.maxNodeWidth) {
      this.maxNodeWidth = 0;
      this.nodeWidthDirty = true;
    } else if (newWidth > this.maxNodeWidth) {
      this.maxNodeWidth = newWidth;
      this.nodeWidthDirty = true;
    }
    if (!this.nodeWidthDirty) {
      node.$node.css('width', this.maxNodeWidth);
    }
    node.$node.css('display', displayBackup);
    node.width = newWidth;
  }
  node.rendered = true;
  node.attached = true;
};

/**
 * Attaches node to DOM, if it is visible and in view range
 * */
scout.Tree.prototype._ensureNodeInDOM = function(node, useAnimation, indexHint) {
  if (node && !node.attached && node === this.visibleNodesFlat[indexHint] && indexHint >= this.viewRangeRendered.from && indexHint < this.viewRangeRendered.to) {
    this.showNode(node, useAnimation, indexHint);
  }
};

scout.Tree.prototype._insertNodeInDOMAtPlace = function(node, index) {
  var $node = node.$node;

  if (index === 0) {
    if (this.$fillBefore) {
      $node.insertAfter(this.$fillBefore);
    } else {
      this.$data.prepend($node);
    }
    return;
  }

  // append after index
  var nodeBefore = this.visibleNodesFlat[index - 1];
  this._ensureNodeInDOM(nodeBefore, false, index - 1);
  if (nodeBefore.attached) {
    $node.insertAfter(nodeBefore.$node);
    return;
  }

  if (index + 1 < this.visibleNodesFlat.length) {
    var nodeAfter = this.visibleNodesFlat[index + 1];
    if (nodeAfter.attached) {
      $node.insertBefore(nodeAfter.$node);
      return;
    }
  }

  // used when the tree is scrolled
  if (this.$fillBefore) {
    $node.insertAfter(this.$fillBefore);
  } else {
    this.$data.prepend($node);
  }
};

scout.Tree.prototype.showNode = function(node, useAnimation, indexHint) {
  if (node.attached || !this.rendered) {
    return;
  }
  this._ensureNodeInDOM(node.parentNode, useAnimation, indexHint - 1);
  this._insertNodeInDOM(node, indexHint);
  if (!node.rendered) {
    return;
  }
  var $node = node.$node;
  if ($node.is('.showing')) {
    return;
  }
  $node.addClass('showing');
  $node.removeClass('hiding');
  var that = this;
  if (useAnimation) {
    $node.data('oldStyle', $node.attr('style'));
    $node.setVisible(false);
    $node.stop().slideDown({
      duration: 250,
      start: that.startAnimationFunc,
      complete: function() {
        that.runningAnimationsFinishFunc();
        var oldStyle = $node.data('oldStyle');
        if (oldStyle) {
          $node.removeData('oldStyle');
          $node.attrOrRemove('style', oldStyle);
        }
      }
    });
  }

};

scout.Tree.prototype.hideNode = function(node, useAnimation, suppressDetachHandling) {
  if (!node.attached) {
    return;
  }
  this.viewRangeDirty = true;
  var that = this,
    $node = node.$node;
  if (!$node) {
    //node is not rendered
    return;
  }

  if ($node.is('.hiding')) {
    return;
  }

  $node.addClass('hiding');
  $node.removeClass('showing');

  if (useAnimation) {
    this._renderViewportBlocked = true;
    $node.data('oldStyle', $node.attr('style'));
    $node.stop().slideUp({
      duration: 250,
      start: that.startAnimationFunc,
      complete: function() {
        that.runningAnimationsFinishFunc();
        $node.detach();
        node.attached = false;
        var oldStyle = $node.data('oldStyle');
        if (oldStyle) {
          $node.removeData('oldStyle');
          $node.attrOrRemove('style', oldStyle);
        }
      }
    });
  } else if (!suppressDetachHandling) {
    $node.detach();
    node.attached = false;
    that.invalidateLayoutTree();
  }
};

scout.Tree.prototype._nodesToIds = function(nodes) {
  return nodes.map(function(node) {
    return node.id;
  });
};

scout.Tree.prototype._nodesByIds = function(ids) {
  return ids.map(function(id) {
    return this.nodesMap[id];
  }.bind(this));
};

scout.Tree.prototype._nodeById = function(id) {
  return this.nodesMap[id];
};

scout.Tree.prototype.hasNode = function(node) {
  return !!this._nodeById(node.id);
};

scout.Tree.prototype._onNodeDoubleClick = function(event) {
  var $node = $(event.currentTarget);
  var node = $node.data('node');
  var expanded = !$node.hasClass('expanded');

  if (this.isBreadcrumbStyleActive()) {
    return;
  }

  this.trigger('nodeAction', {
    node: node
  });

  this.setNodeExpanded(node, expanded, {
    lazy: false // always show all nodes on node double click
  });
};

scout.Tree.prototype._onNodeControlMouseDown = function(event) {
  this._doubleClickSupport.mousedown(event);
  if (this._doubleClickSupport.doubleClicked()) {
    //don't execute on double click events
    return false;
  }

  var $node = $(event.currentTarget).parent();
  var node = $node.data('node');
  var expanded = !$node.hasClass('expanded');
  var expansionOpts = {
    lazy: false // always show all nodes when the control gets clicked
  };

  // Click on "show all" control shows all nodes
  if ($node.hasClass('lazy')) {
    if (event.ctrlKey || event.shiftKey) {
      // Collapse
      expanded = false;
      expansionOpts.collapseChildNodes = true;
    } else {
      // Show all nodes
      this.expandNode(node, expansionOpts);
      return false;
    }
  }
  //because we suppress handling by browser we have to set focus manually.
  this._onNodeControlMouseDownDoFocus();
  this.selectNodes(node); // <---- ### 1
  this.setNodeExpanded(node, expanded, expansionOpts); // <---- ### 2
  // prevent bubbling to _onNodeMouseDown()
  $.suppressEvent(event);

  // ...but return true, so Outline.js can override this method and check if selection has been changed or not
  return true;
};

//some fields doesn't want to set focus on container.
scout.Tree.prototype._onNodeControlMouseDownDoFocus = function() {
  this.session.focusManager.requestFocus(this.$container);
};

scout.Tree.prototype._onNodeControlMouseUp = function(event) {
  // prevent bubbling to _onNodeMouseUp()
  return false;
};

scout.Tree.prototype._onNodeControlDoubleClick = function(event) {
  // prevent bubbling to _onNodeDoubleClick()
  return false;
};

scout.Tree.prototype._onContextMenu = function(event) {
  this._showContextMenu(event);
};

scout.Tree.prototype.changeNode = function(node) {
  if (this._applyFiltersForNode(node)) {
    if (node.isFilterAccepted()) {
      this._addToVisibleFlatList(node, false);
    } else {
      this._removeFromFlatList(node, false);
    }
  }
  if (this.rendered) {
    this._decorateNode(node);
  }
  this.trigger('nodeChanged', {
    node: node
  });
};

/* --- STATIC HELPERS ------------------------------------------------------------- */

/**
 * @memberOf scout.Tree
 */
scout.Tree.collectSubtree = function($rootNode, includeRootNodeInResult) {
  if (!$rootNode) {
    return $();
  }
  var rootLevel = parseFloat($rootNode.attr('data-level'));
  // Find first node after the root element that has the same or a lower level
  var $nextNode = $rootNode.next();
  while ($nextNode.length > 0) {
    var level = parseFloat($nextNode.attr('data-level'));
    if (isNaN(level) || level <= rootLevel) {
      break;
    }
    $nextNode = $nextNode.next();
  }

  // The result set consists of all nodes between the root node and the found node
  var $result = $rootNode.nextUntil($nextNode);
  if (includeRootNodeInResult === undefined || includeRootNodeInResult) {
    $result = $result.add($rootNode);
  }
  return $result;
};

/**
 * if func returns true the children of the visited node are not visited.
 */
scout.Tree.visitNodes = function(nodes, func, parentNode) {
  var i, node;
  if (!nodes) {
    return;
  }

  for (i = 0; i < nodes.length; i++) {
    node = nodes[i];
    var doNotProcessChildren = func(node, parentNode);
    if (!doNotProcessChildren && node.childNodes.length > 0) {
      scout.Tree.visitNodes(node.childNodes, func, node);
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeAdapter = function() {
  scout.TreeAdapter.parent.call(this);
  this._addAdapterProperties(['menus', 'keyStrokes']);
  this._addRemoteProperties(['displayStyle']);
};
scout.inherits(scout.TreeAdapter, scout.ModelAdapter);

scout.TreeAdapter.prototype._sendNodesSelected = function(nodeIds, debounceSend) {
  var eventData = {
    nodeIds: nodeIds
  };

  // send delayed to avoid a lot of requests while selecting
  // coalesce: only send the latest selection changed event for a field
  this._send('nodesSelected', eventData, {
    delay: (debounceSend ? 250 : 0),
    coalesce: function(previous) {
      return this.id === previous.id && this.type === previous.type;
    }
  });
};

scout.TreeAdapter.prototype._onWidgetNodeClicked = function(event) {
  this._send('nodeClicked', {
    nodeId: event.node.id
  });
};

scout.TreeAdapter.prototype._onWidgetNodeAction = function(event) {
  this._send('nodeAction', {
    nodeId: event.node.id
  });
};

scout.TreeAdapter.prototype._onWidgetNodesSelected = function(event) {
  var nodeIds = this.widget._nodesToIds(this.widget.selectedNodes);
  this._sendNodesSelected(nodeIds, event.debounce);
};

scout.TreeAdapter.prototype._onWidgetNodeExpanded = function(event) {
  this._send('nodeExpanded', {
    nodeId: event.node.id,
    expanded: event.expanded,
    expandedLazy: event.expandedLazy
  });
};

scout.TreeAdapter.prototype._onWidgetNodesChecked = function(event) {
  this._sendNodesChecked(event.nodes);
};

scout.TreeAdapter.prototype._sendNodesChecked = function(nodes) {
  var data = {
    nodes: []
  };

  for (var i = 0; i < nodes.length; i++) {
    data.nodes.push({
      nodeId: nodes[i].id,
      checked: nodes[i].checked
    });
  }

  this._send('nodesChecked', data);
};

scout.TreeAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'nodesSelected') {
    this._onWidgetNodesSelected(event);
  } else if (event.type === 'nodeClicked') {
    this._onWidgetNodeClicked(event);
  } else if (event.type === 'nodeAction') {
    this._onWidgetNodeAction(event);
  } else if (event.type === 'nodeExpanded') {
    this._onWidgetNodeExpanded(event);
  } else if (event.type === 'nodesChecked') {
    this._onWidgetNodesChecked(event);
  } else {
    scout.TreeAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

scout.TreeAdapter.prototype.onModelAction = function(event) {
  if (event.type === 'nodesInserted') {
    this._onNodesInserted(event.nodes, event.commonParentNodeId);
  } else if (event.type === 'nodesUpdated') {
    this._onNodesUpdated(event.nodes);
  } else if (event.type === 'nodesDeleted') {
    this._onNodesDeleted(event.nodeIds, event.commonParentNodeId);
  } else if (event.type === 'allChildNodesDeleted') {
    this._onAllChildNodesDeleted(event.commonParentNodeId);
  } else if (event.type === 'nodesSelected') {
    this._onNodesSelected(event.nodeIds);
  } else if (event.type === 'nodeExpanded') {
    this._onNodeExpanded(event.nodeId, event);
  } else if (event.type === 'nodeChanged') {
    this._onNodeChanged(event.nodeId, event);
  } else if (event.type === 'nodesChecked') {
    this._onNodesChecked(event.nodes);
  } else if (event.type === 'childNodeOrderChanged') {
    this._onChildNodeOrderChanged(event.childNodeIds, event.parentNodeId);
  } else if (event.type === 'requestFocus') {
    this._onRequestFocus();
  } else if (event.type === 'scrollToSelection') {
    this._onScrollToSelection();
  } else {
    scout.TreeAdapter.parent.prototype.onModelAction.call(this, event);
  }
};

scout.TreeAdapter.prototype._onNodesInserted = function(nodes, parentNodeId) {
  var parentNode;
  if (parentNodeId !== null && parentNodeId !== undefined) {
    parentNode = this.widget.nodesMap[parentNodeId];
    if (!parentNode) {
      throw new Error('Parent node could not be found. Id: ' + parentNodeId);
    }
  }
  this.widget.insertNodes(nodes, parentNode);
};

scout.TreeAdapter.prototype._onNodesUpdated = function(nodes) {
  this.widget.updateNodes(nodes);
};

scout.TreeAdapter.prototype._onNodesDeleted = function(nodeIds, parentNodeId) {
  var parentNode;
  if (parentNodeId !== null && parentNodeId !== undefined) {
    parentNode = this.widget.nodesMap[parentNodeId];
    if (!parentNode) {
      throw new Error('Parent node could not be found. Id: ' + parentNodeId);
    }
  }
  var nodes = this.widget._nodesByIds(nodeIds);
  this.widget.deleteNodes(nodes, parentNode);
};

scout.TreeAdapter.prototype._onAllChildNodesDeleted = function(parentNodeId) {
  var parentNode;
  if (parentNodeId !== null && parentNodeId !== undefined) {
    parentNode = this.widget.nodesMap[parentNodeId];
    if (!parentNode) {
      throw new Error('Parent node could not be found. Id: ' + parentNodeId);
    }
  }
  this.widget.deleteAllChildNodes(parentNode);
};

scout.TreeAdapter.prototype._onNodesSelected = function(nodeIds) {
  this.addFilterForWidgetEvent(function(widgetEvent) {
    return widgetEvent.type === 'nodesSelected' &&
      scout.arrays.equals(nodeIds, this.widget._nodesToIds(this.widget.selectedNodes));
  }.bind(this));
  var nodes = this.widget._nodesByIds(nodeIds);
  this.widget.selectNodes(nodes);
};

scout.TreeAdapter.prototype._onNodeExpanded = function(nodeId, event) {
  var node = this.widget.nodesMap[nodeId],
    options = {
      lazy: event.expandedLazy
    };
  this.addFilterForWidgetEvent(function(widgetEvent) {
    return widgetEvent.type === 'nodeExpanded' &&
      nodeId === widgetEvent.node.id &&
      event.expanded === widgetEvent.expanded &&
      event.expandedLazy === widgetEvent.expandedLazy;
  }.bind(this));
  this.widget.setNodeExpanded(node, event.expanded, options);
  if (event.recursive) {
    this.widget.setNodeExpandedRecursive(node.childNodes, event.expanded, options);
  }
};

scout.TreeAdapter.prototype._onNodeChanged = function(nodeId, cell) {
  var node = this.widget.nodesMap[nodeId];

  scout.defaultValues.applyTo(cell, 'TreeNode');
  node.text = cell.text;
  node.cssClass = cell.cssClass;
  node.iconId = cell.iconId;
  node.tooltipText = cell.tooltipText;
  node.foregroundColor = cell.foregroundColor;
  node.backgroundColor = cell.backgroundColor;
  node.font = cell.font;

  this.widget.changeNode(node);
};

scout.TreeAdapter.prototype._onNodesChecked = function(nodes) {
  var checkedNodes = [],
    uncheckedNodes = [];

  nodes.forEach(function(nodeData) {
    var node = this.widget._nodeById(nodeData.id);
    if (nodeData.checked) {
      checkedNodes.push(node);
    } else {
      uncheckedNodes.push(node);
    }
  }, this);

  this.addFilterForWidgetEventType('nodesChecked');

  this.widget.checkNodes(checkedNodes, {
    checked: true,
    checkOnlyEnabled: false,
    checkChildren: false
  });
  this.widget.uncheckNodes(uncheckedNodes, {
    checkOnlyEnabled: false,
    checkChildren: false
  });
};

scout.TreeAdapter.prototype._onChildNodeOrderChanged = function(childNodeIds, parentNodeId) {
  var parentNode = this.widget._nodeById([parentNodeId]);
  var nodes = this.widget._nodesByIds(childNodeIds);
  this.widget.updateNodeOrder(nodes, parentNode);
};

scout.TreeAdapter.prototype._onRequestFocus = function() {
  this.widget.requestFocus();
};

scout.TreeAdapter.prototype._onScrollToSelection = function() {
  this.widget.revealSelection();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * @class
 * @constructor
 */
scout.TreeNode = function() {
  this.$node; // FIXME [awe] 6.1 discuss with CGU... properties without assignment do not exist after ctor call
  this.attached = false;
  this.checked = false;
  this.childNodes = [];
  this.childrenLoaded = false;
  this.enabled = true;
  this.expanded = false;
  this.expandedLazy = false;
  this.filterAccepted = true;
  this.filterDirty;
  this.id;
  this.initialized;
  this.lazyExpandingEnabled = false;
  this.leaf = false;
  this.level = 0;
  this.parentNode;
  this.destroyed = false;
  this.rendered = false;
  this.text;

  /**
   * This internal variable stores the promise which is used when a loadChildren() operation is in progress.
   */
  this._loadChildrenPromise = false;
};

scout.TreeNode.prototype.init = function(model) {
  this._init(model);
  scout.texts.resolveTextProperty(this, 'text', this.parent.session);
};

scout.TreeNode.prototype.destroy = function() {
  if (this.destroyed) {
    // Already destroyed, do nothing
    return;
  }
  this._destroy();
  this.destroyed = true;
};

/**
 * Override this method to do something when TreeNode gets destroyed. The default impl. does nothing.
 */
scout.TreeNode.prototype._destroy = function() {
  // NOP
};

scout.TreeNode.prototype.getTree = function() {
  return this.parent;
};

scout.TreeNode.prototype._init = function(model) {
  scout.assertParameter('parent', model.parent, scout.Tree);
  this.session = model.session || model.parent.session;

  $.extend(this, model);
  scout.defaultValues.applyTo(this);

  // make sure all child nodes are TreeNodes too
  if (this.hasChildNodes()) {
    this.getTree()._ensureTreeNodes(this.childNodes);
  }
};

scout.TreeNode.prototype.hasChildNodes = function() {
  return this.childNodes.length > 0;
};

scout.TreeNode.prototype.reset = function() {
  if (this.$node) {
    this.$node.remove();
    delete this.$node;
  }
  this.rendered = false;
  this.attached = false;
};

/**
 * Check if node is in hierarchy of a parent. is used on removal from flat list.
 */
scout.TreeNode.prototype.isChildOf = function(parentNode) {
  if (parentNode === this.parentNode) {
    return true;
  } else if (!this.parentNode) {
    return false;
  }
  return this.parentNode.isChildOf(parentNode);
};

scout.TreeNode.prototype.isFilterAccepted = function(forceFilter) {
  if (this.filterDirty || forceFilter) {
    this.getTree()._applyFiltersForNode(this);
  }
  return this.filterAccepted;
};

/**
 * This method loads the child nodes of this node and returns a jQuery.Deferred to register callbacks
 * when loading is done or has failed. This method should only be called when childrenLoaded is false.
 *
 * @return {$.Deferred} or null when TreeNode cannot load children (which is the case for all
 *     TreeNodes in the remote case). The default impl. return null.
 */
scout.TreeNode.prototype.loadChildren = function() {
  return $.resolvedDeferred();
};

/**
 * This method calls loadChildren() but does nothing when children are already loaded or when loadChildren()
 * is already in progress.
 */
scout.TreeNode.prototype.ensureLoadChildren = function() {
  // when children are already loaded we return an already resolved promise so the caller can continue immediately
  if (this.childrenLoaded) {
    return $.resolvedPromise();
  }
  // when load children is already in progress, we return the same promise
  if (this._loadChildrenPromise) {
    return this._loadChildrenPromise;
  }
  var deferred = this.loadChildren();
  var promise = deferred.promise();
  if (deferred.state() === 'resolved') { // FIXME [awe] 6.1 - better solution as this deferred mess -> create own deferred here?
    this._loadChildrenPromise = null;
    return promise;
  }

  this._loadChildrenPromise = promise;
  promise.done(this._onLoadChildrenDone.bind(this));
  return promise; // we must always return a promise, never null - otherwise caller would throw an error
};

scout.TreeNode.prototype._onLoadChildrenDone = function() {
  this._loadChildrenPromise = null;
};

scout.TreeNode.prototype.setText = function(text) {
  this.text = text;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeLayout = function(tree) {
  scout.TreeLayout.parent.call(this);
  this.tree = tree;
};
scout.inherits(scout.TreeLayout, scout.AbstractLayout);

scout.TreeLayout.prototype.layout = function($container) {
  var htmlContainer = this.tree.htmlComp;

  //FIXME CGU/AWE remove this check as soon as HtmlComp.validateLayout checks for invisible components
  if (!htmlContainer.isAttachedAndVisible() || !htmlContainer.$comp.isEveryParentVisible()) {
    return;
  }

  this._layout($container);
  scout.scrollbars.update(this.tree.$data);
};

scout.TreeLayout.prototype._layout = function($container) {
  var menuBarSize, containerSize, heightOffset,
    menuBar = this.tree.menuBar,
    htmlMenuBar = menuBar.htmlComp,
    htmlContainer = this.tree.htmlComp;

  containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  if (this.tree.autoToggleBreadcrumbStyle) {
    this.tree.setBreadcrumbStyleActive(containerSize.width <= this.tree.breadcrumbTogglingThreshold);
  }

  heightOffset = 0;
  if (menuBar.$container.isVisible()) {
    menuBarSize = scout.MenuBarLayout.size(htmlMenuBar, containerSize);
    htmlMenuBar.setSize(menuBarSize);
    heightOffset += menuBarSize.height;
  }

  this._setDataHeight(heightOffset);

  // Check if width has changed
  if (htmlContainer.size && htmlContainer.size.width !== htmlContainer.getSize().width) {
    if (this.tree.isHorizontalScrollingEnabled()) {
      // Width is only relevant if horizontal scrolling is enabled -> mark as dirty
      this.tree.nodeWidthDirty = true;
      this.tree.maxNodeWidth = 0;
    } else {
      // Nodes may contain wrapped text (with breadcrumb style-or if nodes contain html) -> update heights
      this.tree.updateNodeHeights();
      this.tree._renderFiller();
    }
  }

  this.tree.setViewRangeSize(this.tree.calculateViewRangeSize());

  this.tree._renderScrollTop();
  // Always render viewport (not only when viewRangeSize changes), because view range depends on scroll position and data height
  this.tree._renderViewport();
};

scout.TreeLayout.prototype._setDataHeight = function(heightOffset) {
  var $data = this.tree.$data;

  heightOffset += $data.cssMarginTop() + $data.cssMarginBottom();

  $data.css('height', (heightOffset === 0 ? '100%' : 'calc(100% - ' + heightOffset + 'px)'));
};

scout.TreeLayout.prototype.preferredLayoutSize = function($container) {
  // Make sure viewport is up to date before calculating pref size.
  // This is necessary because the tree does not render the view port on any change (like insert or delete nodes). Instead it just invalidates the layout.
  this.tree._renderViewport();

  return scout.graphics.prefSize($container);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.LazyNodeFilter = function(tree) { //
  this.tree = tree;
};

scout.LazyNodeFilter.prototype.accept = function(node) {
  if (!node.expanded && node.parentNode && node.parentNode.expandedLazy && node.parentNode.lazyExpandingEnabled && this.tree.lazyExpandingEnabled) {
    // if this node is not expanded and parent is lazyExpanding.
    for (var i = 0; i < this.tree.selectedNodes.length; i++) {
      var selectedNode = this.tree.selectedNodes[i];
      //not initialized selected nodes
      if (typeof selectedNode === 'string') {
        break;
      }
      if (selectedNode === node || selectedNode.isChildOf(node)) {
        return true;
      }
    }
    return false;
  }
  return true;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeBreadcrumbFilter = function(tree) {
  this.tree = tree;
};

scout.TreeBreadcrumbFilter.prototype.accept = function(node) {
  if(this.tree.selectedNodes.length === 0 ){
    return node.parentNode === undefined;
  }
  return this.tree.isNodeInBreadcrumbVisible(node);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AbstractTreeNavigationKeyStroke = function(tree, modifierBitMask) {
  scout.AbstractTreeNavigationKeyStroke.parent.call(this);
  this.field = tree;
  this.repeatable = true;
  this.stopPropagation = true;
  this.renderingHints.hAlign = scout.hAlign.RIGHT;

  this.ctrl = scout.keyStrokeModifier.isCtrl(modifierBitMask);
  this.shift = scout.keyStrokeModifier.isShift(modifierBitMask);
  this.alt = scout.keyStrokeModifier.isAlt(modifierBitMask);

  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
};
scout.inherits(scout.AbstractTreeNavigationKeyStroke, scout.KeyStroke);

scout.AbstractTreeNavigationKeyStroke.prototype._accept = function(event) {
  var accepted = scout.AbstractTreeNavigationKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted) {
    return false;
  }

  if (this.field.selectedNodes.length > 0) {
    event._treeCurrentNode = this.field.selectedNodes[0];
    event._$treeCurrentNode = event._treeCurrentNode.$node;
  }
  return true;
};

scout.AbstractTreeNavigationKeyStroke.prototype.handle = function(event) {
  var newSelection = this._computeNewSelection(event._treeCurrentNode);
  if (newSelection) {
    this.selectNodesAndReveal(newSelection, true);
  }
};

scout.AbstractTreeNavigationKeyStroke.prototype._computeNewSelection = function(currentNode) {
  return [];
};

scout.AbstractTreeNavigationKeyStroke.prototype.selectNodesAndReveal = function(newSelection, debounceSend) {
  this.field.selectNodes(newSelection, debounceSend);
  this.field.revealSelection();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeSpaceKeyStroke = function(tree) {
  scout.TreeSpaceKeyStroke.parent.call(this);
  this.field = tree;
  this.which = [scout.keys.SPACE];
  this.renderingHints.render = false;
};
scout.inherits(scout.TreeSpaceKeyStroke, scout.KeyStroke);

scout.TreeSpaceKeyStroke.prototype._accept = function(event) {
  var accepted = scout.TreeSpaceKeyStroke.parent.prototype._accept.call(this, event);
  return accepted && this.field.checkable && this.field.selectedNodes.length > 0;
};

scout.TreeSpaceKeyStroke.prototype.handle = function(event) {
  var selection = this.field.selectedNodes;
  var checked = selection[0].checked;
  selection.forEach(function(node) {
    this.field.checkNode(node, !checked);
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeNavigationUpKeyStroke = function(tree, modifierBitMask) {
  scout.TreeNavigationUpKeyStroke.parent.call(this, tree, modifierBitMask);
  this.which = [scout.keys.UP];
  this.renderingHints.text = '';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var newSelectedNode = this._computeNewSelection(event._treeCurrentNode);
    if (newSelectedNode) {
      return newSelectedNode.$node;
    }
  }.bind(this);
};
scout.inherits(scout.TreeNavigationUpKeyStroke, scout.AbstractTreeNavigationKeyStroke);

scout.TreeNavigationUpKeyStroke.prototype._computeNewSelection = function(currentNode) {
  var nodes = this.field.visibleNodesFlat;
  if (nodes.length === 0) {
    return;
  }
  if (!currentNode) {
    return scout.arrays.last(nodes);
  }
  return nodes[nodes.indexOf(currentNode) - 1];
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeNavigationDownKeyStroke = function(tree, modifierBitMask) {
  scout.TreeNavigationDownKeyStroke.parent.call(this, tree, modifierBitMask);
  this.which = [scout.keys.DOWN];
  this.renderingHints.text = '';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var newSelectedNode = this._computeNewSelection(event._treeCurrentNode);
    if (newSelectedNode) {
      return newSelectedNode.$node;
    }
  }.bind(this);
};
scout.inherits(scout.TreeNavigationDownKeyStroke, scout.AbstractTreeNavigationKeyStroke);

scout.TreeNavigationDownKeyStroke.prototype._computeNewSelection = function(currentNode) {
  var nodes = this.field.visibleNodesFlat;
  if (nodes.length === 0) {
    return;
  }
  if (!currentNode) {
    return nodes[0];
  }
  return nodes[nodes.indexOf(currentNode) + 1];
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeNavigationEndKeyStroke = function(tree, modifierBitMask) {
  scout.TreeNavigationEndKeyStroke.parent.call(this, tree, modifierBitMask);
  this.which = [scout.keys.END];
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var newSelectedNode = this._computeNewSelection(event._treeCurrentNode);
    if (newSelectedNode) {
      return newSelectedNode.$node;
    }
  }.bind(this);
};
scout.inherits(scout.TreeNavigationEndKeyStroke, scout.AbstractTreeNavigationKeyStroke);

scout.TreeNavigationEndKeyStroke.prototype.handle = function(event) {
  var newSelection = this._computeNewSelection(event._treeCurrentNode);
  if (newSelection) {
    this.selectNodesAndReveal(newSelection);
  }
};

scout.TreeNavigationEndKeyStroke.prototype._computeNewSelection = function(currentNode) {
  var nodes = this.field.visibleNodesFlat;
  if (nodes.length === 0) {
    return;
  }
  return scout.arrays.last(nodes);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeCollapseAllKeyStroke = function(tree, keyStrokeModifier) {
  scout.TreeCollapseAllKeyStroke.parent.call(this, tree, keyStrokeModifier);
  this.which = [scout.keys.HOME];
  this.renderingHints.hAlign = scout.hAlign.RIGHT;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    if (this.field.visibleNodesFlat.length > 0) {
      return this.field.visibleNodesFlat[0].$node;
    }
  }.bind(this);
};
scout.inherits(scout.TreeCollapseAllKeyStroke, scout.AbstractTreeNavigationKeyStroke);

scout.TreeCollapseAllKeyStroke.prototype.handle = function(event) {
  this.field.collapseAll();
  if (this.field.visibleNodesFlat.length > 0) {
    this.selectNodesAndReveal(this.field.visibleNodesFlat[0]);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeCollapseOrDrillUpKeyStroke = function(tree, modifierBitMask) {
  scout.TreeCollapseOrDrillUpKeyStroke.parent.call(this, tree, modifierBitMask);
  this.which = [scout.keys.SUBTRACT];
  this.renderingHints.text = '-';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var currentNode = event._treeCurrentNode;
    if (currentNode.expanded) {
      return currentNode.$node;
    } else if (currentNode.parentNode) {
      return currentNode.parentNode.$node;
    }
  }.bind(this);
};
scout.inherits(scout.TreeCollapseOrDrillUpKeyStroke, scout.AbstractTreeNavigationKeyStroke);

scout.TreeCollapseOrDrillUpKeyStroke.prototype._accept = function(event) {
  var accepted = scout.TreeCollapseOrDrillUpKeyStroke.parent.prototype._accept.call(this, event);
  var currentNode = event._treeCurrentNode;
  return accepted && currentNode && (currentNode.expanded || currentNode.parentNode);
};

scout.TreeCollapseOrDrillUpKeyStroke.prototype.handle = function(event) {
  var currentNode = event._treeCurrentNode;
  if (currentNode.expanded) {
    this.field.collapseNode(currentNode);
  } else if (currentNode.parentNode) {
    this.selectNodesAndReveal(currentNode.parentNode, true);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeExpandOrDrillDownKeyStroke = function(tree, modifierBitMask) {
  scout.TreeExpandOrDrillDownKeyStroke.parent.call(this, tree, modifierBitMask);
  this.which = [scout.keys.ADD];
  this.renderingHints.text = '+';
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var currentNode = event._treeCurrentNode;
    if (this.isNodeExpandable(currentNode)) {
      return currentNode.$node;
    } else if (currentNode.childNodes.length > 0) {
      return currentNode.childNodes[0].$node;
    }
  }.bind(this);
};
scout.inherits(scout.TreeExpandOrDrillDownKeyStroke, scout.AbstractTreeNavigationKeyStroke);

scout.TreeExpandOrDrillDownKeyStroke.prototype._accept = function(event) {
  var accepted = scout.TreeExpandOrDrillDownKeyStroke.parent.prototype._accept.call(this, event);
  var currentNode = event._treeCurrentNode;
  return accepted && currentNode && (this.isNodeExpandable(currentNode) || currentNode.childNodes.length > 0);
};

scout.TreeExpandOrDrillDownKeyStroke.prototype.isNodeExpandable = function(node) {
  return !node.expanded && !node.leaf;
};

scout.TreeExpandOrDrillDownKeyStroke.prototype.handle = function(event) {
  var currentNode = event._treeCurrentNode;
  if (this.isNodeExpandable(currentNode)) {
    this.field.expandNode(currentNode, {
      lazy: false // always show all nodes on node double click
    });
  } else if (currentNode.childNodes.length > 0) {
    this.selectNodesAndReveal(currentNode.childNodes[0], true);
  }
};

scout.CompactTree = function() {
  scout.CompactTree.parent.call(this);
  this.$nodesContainer;
  this._scrolldirections = 'y';
};
scout.inherits(scout.CompactTree, scout.Tree);

/**
 * @override Tree.js
 */
scout.CompactTree.prototype._initTreeKeyStrokeContext = function() {
  this.keyStrokeContext.registerKeyStroke([
    new scout.CompactTreeUpKeyStroke(this),
    new scout.CompactTreeDownKeyStroke(this),
    new scout.CompactTreeLeftKeyStroke(this),
    new scout.CompactTreeRightKeyStroke(this)
  ]);
};

scout.CompactTree.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('compact-tree');

  var layout = new scout.TreeLayout(this);
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(layout);

  this.$data = this.$container.appendDiv('tree-data');
  scout.scrollbars.install(this.$data, {
    parent: this,
    borderless: true
  });
  this.menuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.MenuItemsOrder(this.session, 'Tree')
  });
  this.menuBar.render(this.$container);

  this.$nodesContainer = this.$data.appendDiv('nodes');
  this._updateNodeDimensions();
  this._renderViewport();
  this.invalidateLayoutTree();
};

/**
 * @override
 */
scout.CompactTree.prototype._calculateCurrentViewRange = function() {
  this.viewRangeSize = this.visibleNodesFlat.length;
  return new scout.Range(0, Math.max(this.visibleNodesFlat.length, 0));
};

/**
 * @override
 */
scout.CompactTree.prototype.calculateViewRangeSize = function() {
  return this.visibleNodesFlat.length;
};

/**
 * @override
 */
scout.CompactTree.prototype._remove = function() {
  scout.scrollbars.uninstall(this.$data, this.session);
  scout.CompactTree.parent.prototype._remove.call(this);
};

/**
 * @override
 */
scout.CompactTree.prototype._$buildNode = function(node) {
  if (node.level === 0) {
    //TODO [jgu] sections without child nodes are not visible, never build
    // Sections (only draw if they have child nodes)
    //    if (node.childNodes.length > 0) {
    var $section = this.$container.makeDiv('section expanded')
      .data('node', node);
    $section.appendDiv('title')
      .text(node.text);

    node.$node = $section;
    //    }
  } else {
    var $parent = node.parentNode.$node;
    // Sections nodes
    var $sectionNode = $parent.makeDiv('section-node')
      .data('node', node)
      .on('mousedown', this._onNodeMouseDown.bind(this))
      .on('mouseup', this._onNodeMouseUp.bind(this));

    node.$node = $sectionNode;

  }

  return node.$node;
};

/**
 * @override
 */
scout.CompactTree.prototype._insertNodeInDOMAtPlace = function(node, index) {
  var visibleNodeBefore = this.visibleNodesFlat[index - 1];
  var n;
  if (!visibleNodeBefore) {
    node.$node.prependTo(this.$nodesContainer);
  } else if (visibleNodeBefore.level < node.level) {
    //insert after first child node (title from the level above)
    node.$node.insertAfter(visibleNodeBefore.$node.children()[0]);
  } else {
    n = visibleNodeBefore.$node;
    for (var i = 0; i < visibleNodeBefore.level - node.level; i++) {
      n = n.parent();
    }
    node.$node.insertAfter(n);
  }
};

/**
 * @override
 */
scout.CompactTree.prototype._decorateNode = function(node) {
  var formerClasses,
    $node = node.$node;
  if (!$node) {
    // This node is not yet rendered, nothing to do
    return;
  }

  if ($node.hasClass('section')) {
    $node = $node.children('title');
    formerClasses = 'title';
  } else {
    formerClasses = 'section-node';
    if ($node.isSelected()) {
      formerClasses += ' selected';
    }
  }
  $node.removeClass();
  $node.addClass(formerClasses);
  $node.addClass(node.cssClass);
  $node.text(node.text);

  scout.styles.legacyStyle(node, $node);

  if (scout.strings.hasText(node.tooltipText)) {
    $node.attr('title', node.tooltipText);
  }

  // TODO [15.1] bsh: More attributes...
  // iconId
  // tooltipText
};

/**
 * @override
 */
scout.CompactTree.prototype.selectNodes = function(nodes) {
  var selectedSectionNodes = [];
  nodes = scout.arrays.ensure(nodes);
  // If a section is selected, automatically change selection to first section-node
  nodes.forEach(function(node) {
    var $node = node.$node;
    if (!$node.hasClass('section-node')) {
      node = $node.children('.section-node').first().data('node');
    }
    if (node) {
      selectedSectionNodes.push(node);
    }
  }, this);

  scout.CompactTree.parent.prototype.selectNodes.call(this, selectedSectionNodes);
};

/**
 * @override
 */
scout.CompactTree.prototype._renderExpansion = function(node) {
  // nop (not supported by CompactTree)
};

/**
 * @override
 */
scout.CompactTree.prototype._updateItemPath = function() {
  // nop (not supported by CompactTree)
};

scout.AbstractCompactTreeControlKeyStroke = function(compactProcessTree) {
  scout.AbstractCompactTreeControlKeyStroke.parent.call(this);
  this.repeatable = true;
  this.field = compactProcessTree;
  this.keyStrokeMode = scout.KeyStrokeMode.DOWN;
};
scout.inherits(scout.AbstractCompactTreeControlKeyStroke, scout.KeyStroke);

scout.AbstractCompactTreeControlKeyStroke.prototype._accept = function(event) {
  var accepted = scout.AbstractCompactTreeControlKeyStroke.parent.prototype._accept.call(this, event);
  if (!accepted) {
    return false;
  }

  if (!this.field.nodes || !this.field.nodes.length) {
    return false;
  }

  var $currentNode = this.field.$nodesContainer.find('.section-node.selected'),
    currentNode = $currentNode.data('node');

  var nextNode = this._findNextNode($currentNode, currentNode);
  if (nextNode) {
    event._nextNode = nextNode;
    return true;
  } else {
    return false;
  }
};

scout.AbstractCompactTreeControlKeyStroke.prototype.handle = function(event) {
  this.field.selectNodes(event._nextNode);
  this.field.checkNode(event._nextNode, true);
};

scout.AbstractCompactTreeControlKeyStroke.prototype._findNextNode = function($currentNode, currentNode) {
  throw new Error('method must be overwritten by subclass');
};

scout.CompactTreeUpKeyStroke = function(compactProcessTree) {
  scout.CompactTreeUpKeyStroke.parent.call(this, compactProcessTree);
  this.which = [scout.keys.UP];
  this.renderingHints.text = '';
};
scout.inherits(scout.CompactTreeUpKeyStroke, scout.AbstractCompactTreeControlKeyStroke);

scout.CompactTreeUpKeyStroke.prototype._findNextNode = function($currentNode, currentNode) {
  if (currentNode) {
    // Find last process node, or last process node in previous section.
    return $currentNode.prev('.section-node').data('node') || $currentNode.parent().prev('.section').children('.section-node').last().data('node');
  } else {
    // Find last process node.
    return scout.arrays.last(scout.arrays.last(this.field.nodes).childNodes);
  }
};

scout.CompactTreeDownKeyStroke = function(compactProcessTree) {
  scout.CompactTreeDownKeyStroke.parent.call(this, compactProcessTree);
  this.which = [scout.keys.DOWN];
  this.renderingHints.text = '';
};
scout.inherits(scout.CompactTreeDownKeyStroke, scout.AbstractCompactTreeControlKeyStroke);

scout.CompactTreeDownKeyStroke.prototype._findNextNode = function($currentNode, currentNode) {
  if (currentNode) {
    // Find first process node, or first process node in next section.
    return $currentNode.next('.section-node').data('node') || $currentNode.parent().next('.section').children('.section-node').first().data('node');
  } else {
    // Find first process node.
    return scout.arrays.first(scout.arrays.first(this.field.nodes).childNodes);
  }
};

scout.CompactTreeLeftKeyStroke = function(compactProcessTree) {
  scout.CompactTreeLeftKeyStroke.parent.call(this, compactProcessTree);
  this.renderingHints.text = '';
  this.which = [scout.keys.LEFT];
};
scout.inherits(scout.CompactTreeLeftKeyStroke, scout.AbstractCompactTreeControlKeyStroke);

scout.CompactTreeLeftKeyStroke.prototype._findNextNode = function($currentNode, currentNode) {
  // Find first process node of previous section, or first process node.
  return $currentNode.parent().prev('.section').children('.section-node').first().data('node') || $currentNode.parent().children('.section-node').not($currentNode).first().data('node');
};

scout.CompactTreeRightKeyStroke = function(compactProcessTree) {
  scout.CompactTreeRightKeyStroke.parent.call(this, compactProcessTree);
  this.renderingHints.text = '';
  this.which = [scout.keys.RIGHT];
};
scout.inherits(scout.CompactTreeRightKeyStroke, scout.AbstractCompactTreeControlKeyStroke);

scout.CompactTreeRightKeyStroke.prototype._findNextNode = function($currentNode, currentNode) {
  // Find first process node of next section.
  return $currentNode.parent().next('.section').children('.section-node').first().data('node');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Desktop = function() {
  scout.Desktop.parent.call(this);

  this.desktopStyle = scout.Desktop.DisplayStyle.DEFAULT;
  this.benchVisible = true;
  this.headerVisible = true;
  this.navigationVisible = true;
  this.navigationHandleVisible = true;
  this.menus = [];
  this.addOns = [];
  this.dialogs = [];
  this.views = [];
  this.viewButtons = [];
  this.messageBoxes = [];
  this.fileChoosers = [];
  this.navigation;
  this.header;
  this.bench;
  this.splitter;
  this.formController;
  this.messageBoxController;
  this.fileChooserController;
  this.initialFormRendering = false;
  this.offline = false;
  this.notifications = [];
  this.inBackground = false;
  this.geolocationServiceAvailable = scout.device.supportsGeolocation();
  this._addAdapterProperties(['activeForm', 'viewButtons', 'menus', 'views', 'dialogs', 'outline', 'messageBoxes', 'fileChoosers', 'addOns', 'keyStrokes']);

  // event listeners
  this._benchActiveViewChangedHandler = this._onBenchActivateViewChanged.bind(this);
};
scout.inherits(scout.Desktop, scout.Widget);

scout.Desktop.DisplayStyle = {
  DEFAULT: 'default',
  BENCH: 'bench',
  COMPACT: 'compact'
};

scout.Desktop.prototype._init = function(model) {
  scout.Desktop.parent.prototype._init.call(this, model);
  this.formController = new scout.DesktopFormController(this, this.session);
  this.messageBoxController = new scout.MessageBoxController(this, this.session);
  this.fileChooserController = new scout.FileChooserController(this, this.session);
  this._resizeHandler = this.onResize.bind(this);
  this._popstateHandler = this.onPopstate.bind(this);
  this.updateSplitterVisibility();
  this.resolveTextKeys(['title']);
  this._syncViewButtons(this.viewButtons);
  this._syncMenus(this.menus);
};

/**
 * @override
 */
scout.Desktop.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.Desktop.prototype._initKeyStrokeContext = function() {
  scout.Desktop.parent.prototype._initKeyStrokeContext.call(this);

  // Keystroke on the top-level DOM element which works as a catch-all when the busy indicator is active
  this.keyStrokeContext.registerKeyStroke(new scout.DesktopKeyStroke(this.session));
  this.keyStrokeContext.registerKeyStroke(new scout.DisableBrowserTabSwitchingKeyStroke(this));
};

scout.Desktop.prototype._onBenchActivateViewChanged = function(event) {
  if (this.initialFormRendering) {
    return;
  }
  var view = event.view;
  if (view instanceof scout.Form && this.bench.outlineContent !== view && !view.detailForm) {
    // Notify model that this form is active (only for regular views, not detail forms)
    this._setFormActivated(view);
  }
};

scout.Desktop.prototype._render = function($parent) {
  this.$container = $parent;
  this.$container.addClass('desktop');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(this._createLayout());

  // Desktop elements are added before this separator, all overlays are opened after (dialogs, popups, tooltips etc.)
  this.$overlaySeparator = this.$container.appendDiv('overlay-separator').setVisible(false);

  this._renderNavigationVisible();
  this._renderHeaderVisible();
  this._renderBenchVisible();
  this._renderTitle();
  this._renderLogoUrl();
  this._renderSplitterVisible();
  this._renderInBackground();
  this._renderDisplayStyle();
  this.addOns.forEach(function(addOn) {
    addOn.render(this.$container);
  }, this);

  this.$container.window()
    .on('resize', this._resizeHandler)
    .on('popstate', this._popstateHandler);

  // prevent general drag and drop, dropping a file anywhere in the application must not open this file in browser
  this._setupDragAndDrop();

  this._disableContextMenu();
};

scout.Desktop.prototype._remove = function() {
  this.formController.remove();
  this.messageBoxController.remove();
  this.fileChooserController.remove();
  this.$container.window()
    .off('resize', this._resizeHandler)
    .off('popstate', this._popstateHandler);
  scout.Desktop.parent.prototype._remove.call(this);
};

scout.Desktop.prototype._postRender = function() {
  scout.Desktop.parent.prototype._postRender.call(this);

  // Render attached forms, message boxes and file choosers.
  this.initialFormRendering = true;
  this.formController.render();
  this.messageBoxController.render();
  this.fileChooserController.render();
  this._renderDisplayChildsOfOutline();

  this.initialFormRendering = false;
};

scout.Desktop.prototype._renderDisplayStyle = function() {
  var DisplayStyle = scout.Desktop.DisplayStyle,
    isCompact = this.displayStyle === DisplayStyle.COMPACT;

  if (this.header) {
    this.header.setToolBoxVisible(!isCompact);
    this.header.animateRemoval = isCompact;
  }
  if (this.navigation) {
    this.navigation.setToolBoxVisible(isCompact);
    this.navigation.htmlComp.layoutData.fullWidth = isCompact;
  }
  if (this.bench) {
    this.bench.setOutlineContentVisible(!isCompact);
  }
  if (this.outline) {
    this.outline.setCompact(isCompact);
    this.outline.setEmbedDetailContent(isCompact);
  }

  this.invalidateLayoutTree();
};

scout.Desktop.prototype._createLayout = function() {
  return new scout.DesktopLayout(this);
};

/**
 * Displays attached forms, message boxes and file choosers.
 * Outline does not need to be rendered to show the child elements, it needs to be active (necessary if navigation is invisible)
 */
scout.Desktop.prototype._renderDisplayChildsOfOutline = function() {
  if (!this.outline) {
    return;
  }
  this.outline.formController.render();
  this.outline.messageBoxController.render();
  this.outline.fileChooserController.render();
};

scout.Desktop.prototype._removeDisplayChildsOfOutline = function() {
  if (!this.outline) {
    return;
  }
  this.outline.formController.remove();
  this.outline.messageBoxController.remove();
  this.outline.fileChooserController.remove();
};

scout.Desktop.prototype._renderTitle = function() {
  var title = this.title;
  if (title === undefined || title === null) {
    return;
  }
  var $scoutDivs = $('div.scout');
  if ($scoutDivs.length <= 1) { // only set document title in non-portlet case
    $scoutDivs.document(true).title = title;
  }
};

scout.Desktop.prototype._renderActiveForm = function() {
  // NOP -> is handled in _setFormActivated when ui changes active form or if model changes form in _onFormShow/_onFormActivate
};

scout.Desktop.prototype._renderBench = function() {
  if (this.bench) {
    return;
  }
  this.bench = scout.create('DesktopBench', {
    parent: this,
    animateRemoval: true,
    headerTabArea: this.header ? this.header.tabArea : undefined,
    outlineContentVisible: this.displayStyle !== scout.Desktop.DisplayStyle.COMPACT
  });
  this.bench.on('viewActivated', this._benchActiveViewChangedHandler);
  this.bench.render(this.$container);
  this.bench.$container.insertBefore(this.$overlaySeparator);
  this.invalidateLayoutTree();
};

scout.Desktop.prototype._removeBench = function() {
  if (!this.bench) {
    return;
  }
  this.bench.off('viewActivated', this._benchActiveViewChangedHandler);
  this.bench.on('destroy', function() {
    this.bench = null;
    this.invalidateLayoutTree();
  }.bind(this));
  this.bench.destroy();
};

scout.Desktop.prototype._renderBenchVisible = function() {
  this.animateLayoutChange = this.rendered;
  if (this.benchVisible) {
    this._renderBench();
    this._renderInBackground();
  } else {
    this._removeBench();
  }
};

scout.Desktop.prototype._renderNavigation = function() {
  if (this.navigation) {
    return;
  }
  this.navigation = scout.create('DesktopNavigation', {
    parent: this,
    outline: this.outline,
    toolBoxVisible: this.displayStyle === scout.Desktop.DisplayStyle.COMPACT,
    layoutData: {
      fullWidth: this.displayStyle === scout.Desktop.DisplayStyle.COMPACT
    }
  });
  this.navigation.render(this.$container);
  this.navigation.$container.prependTo(this.$container);
  this.invalidateLayoutTree();
};

scout.Desktop.prototype._removeNavigation = function() {
  if (!this.navigation) {
    return;
  }
  this.navigation.destroy();
  this.navigation = null;
  this.invalidateLayoutTree();
};

scout.Desktop.prototype._renderNavigationVisible = function() {
  this.animateLayoutChange = this.rendered;
  if (this.navigationVisible) {
    this._renderNavigation();
  } else {
    if (!this.animateLayoutChange) {
      this._removeNavigation();
    } else {
      // re layout to trigger animation
      this.invalidateLayoutTree();
    }
  }
};

scout.Desktop.prototype._renderHeader = function() {
  if (this.header) {
    return;
  }

  this.header = scout.create('DesktopHeader', {
    parent: this,
    animateRemoval: this.displayStyle === scout.Desktop.DisplayStyle.COMPACT,
    toolBoxVisible: this.displayStyle !== scout.Desktop.DisplayStyle.COMPACT
  });

  this.header.render(this.$container);
  this.header.$container.insertBefore(this.$overlaySeparator);
  this.invalidateLayoutTree();
};

scout.Desktop.prototype._removeHeader = function() {
  if (!this.header) {
    return;
  }
  this.header.on('destroy', function() {
    this.invalidateLayoutTree();
    this.header = null;
  }.bind(this));
  this.header.destroy();
};

scout.Desktop.prototype._renderHeaderVisible = function() {
  if (this.headerVisible) {
    this._renderHeader();
  } else {
    this._removeHeader();
  }
};

scout.Desktop.prototype._renderLogoUrl = function() {
  if (this.header) {
    this.header.setLogoUrl(this.logoUrl);
  }
};

scout.Desktop.prototype._renderSplitterVisible = function() {
  if (this.splitterVisible) {
    this._renderSplitter();
  } else {
    this._removeSplitter();
  }
};

scout.Desktop.prototype._renderSplitter = function() {
  if (this.splitter || !this.navigation) {
    return;
  }
  this.splitter = scout.create('Splitter', {
    parent: this,
    $anchor: this.navigation.$container,
    $root: this.$container
  });
  this.splitter.render(this.$container);
  this.splitter.$container.insertBefore(this.$overlaySeparator);
  this.splitter.on('move', this._onSplitterMove.bind(this));
  this.splitter.on('moveEnd', this._onSplitterMoveEnd.bind(this));
  this.splitter.on('positionChanged', this._onSplitterPositionChanged.bind(this));
  this.updateSplitterPosition();
};

scout.Desktop.prototype._removeSplitter = function() {
  if (!this.splitter) {
    return;
  }
  this.splitter.destroy();
  this.splitter = null;
};

scout.Desktop.prototype._renderInBackground = function() {
  if (this.bench) {
    this.bench.$container.toggleClass('drop-shadow', this.inBackground);
  }
};

scout.Desktop.prototype._renderBrowserHistoryEntry = function() {
  if (!scout.device.supportsHistoryApi()) {
    return;
  }
  var myWindow = this.$container.window(true),
    history = this.browserHistoryEntry;
  myWindow.history.pushState({
    deepLinkPath: history.deepLinkPath
  }, history.title, history.path);
};

scout.Desktop.prototype._setupDragAndDrop = function() {
  var dragEnterOrOver = function(event) {
    event.stopPropagation();
    event.preventDefault();
    // change cursor to forbidden (no dropping allowed)
    event.originalEvent.dataTransfer.dropEffect = 'none';
  };

  this.$container.on('dragenter', dragEnterOrOver);
  this.$container.on('dragover', dragEnterOrOver);
  this.$container.on('drop', function(event) {
    event.stopPropagation();
    event.preventDefault();
  });
};

scout.Desktop.prototype.updateSplitterVisibility = function() {
  // Splitter should only be visible if navigation and bench are visible, but never in compact mode (to prevent unnecessary splitter rendering)
  this.setSplitterVisible(this.navigationVisible && this.benchVisible && this.displayStyle !== scout.Desktop.DisplayStyle.COMPACT);
};

scout.Desktop.prototype.setSplitterVisible = function(visible) {
  this.setProperty('splitterVisible', visible);
};

scout.Desktop.prototype.updateSplitterPosition = function() {
  if (!this.splitter) {
    return;
  }
  // TODO awe: (user-prefs) Use user-preferences instead of sessionStorage
  var storedSplitterPosition = this.cacheSplitterPosition && sessionStorage.getItem('scout:desktopSplitterPosition');
  if (storedSplitterPosition) {
    // Restore splitter position
    var splitterPosition = parseInt(storedSplitterPosition, 10);
    this.splitter.setPosition(splitterPosition);
    this.invalidateLayoutTree();
  } else {
    // Set initial splitter position (default defined by css)
    this.splitter.setPosition();
    this.invalidateLayoutTree();
  }
};

scout.Desktop.prototype._disableContextMenu = function() {
  // Switch off browser's default context menu for the entire scout desktop (except input fields)
  this.$container.on('contextmenu', function(event) {
    if (event.target.nodeName !== 'INPUT' && event.target.nodeName !== 'TEXTAREA' && !event.target.isContentEditable) {
      event.preventDefault();
    }
  });
};

scout.Desktop.prototype.setOutline = function(outline) {
  if (this.rendered) {
    this._removeDisplayChildsOfOutline();
  }

  this.outline = outline;
  this._setOutlineActivated();
  if (this.navigation) {
    this.navigation.setOutline(this.outline);
  }
  // call render after triggering event so glasspane rendering taking place can refer to the current outline content
  this.trigger('outlineChanged');

  if (this.rendered) {
    this._renderDisplayChildsOfOutline();
    this._renderDisplayStyle();
  }
};

scout.Desktop.prototype._syncViewButtons = function(viewButtons) {
  this.updateKeyStrokes(viewButtons, this.viewButtons);
  this._setProperty('viewButtons', viewButtons);
};

scout.Desktop.prototype._syncMenus = function(menus) {
  this.updateKeyStrokes(menus, this.menus);
  this._setProperty('menus', menus);
};

scout.Desktop.prototype.setMenus = function(menus) {
  if (this.header) {
    this.header.setMenus(menus);
  }
};

scout.Desktop.prototype.setNavigationHandleVisible = function(visible) {
  this.setProperty('navigationHandleVisible', visible);
};

scout.Desktop.prototype.setNavigationVisible = function(visible) {
  this.setProperty('navigationVisible', visible);
  this.updateSplitterVisibility();
};

scout.Desktop.prototype.setBenchVisible = function(visible) {
  this.setProperty('benchVisible', visible);
  this.updateSplitterVisibility();
};

scout.Desktop.prototype.setHeaderVisible = function(visible) {
  this.setProperty('headerVisible', visible);
};

scout.Desktop.prototype.outlineDisplayStyle = function() {
  if (this.outline) {
    return this.outline.displayStyle;
  }
};

scout.Desktop.prototype.shrinkNavigation = function() {
  if (this.navigationVisible && this.outlineDisplayStyle() === scout.Tree.DisplayStyle.DEFAULT) {
    this.outline.setDisplayStyle(scout.Tree.DisplayStyle.BREADCRUMB);
  } else {
    this.setNavigationVisible(false);
  }
};

scout.Desktop.prototype.enlargeNavigation = function() {
  if (this.navigationVisible && this.outlineDisplayStyle() === scout.Tree.DisplayStyle.BREADCRUMB) {
    this.outline.setDisplayStyle(scout.Tree.DisplayStyle.DEFAULT);
  } else {
    this.setNavigationVisible(true);
    // Layout immediately to have view tabs positioned correctly before animation starts
    this.validateLayoutTree();
  }
};

scout.Desktop.prototype.switchToBench = function() {
  this.setHeaderVisible(true);
  this.setBenchVisible(true);
  this.setNavigationVisible(false);
};

scout.Desktop.prototype.switchToNavigation = function() {
  this.setNavigationVisible(true);
  this.setHeaderVisible(false);
  this.setBenchVisible(false);
};

scout.Desktop.prototype.revalidateHeaderLayout = function() {
  if (this.header) {
    this.header.revalidateLayout();
  }
};

scout.Desktop.prototype.goOffline = function() {
  if (this.offline) {
    return;
  }
  this.offline = true;
  this._removeOfflineNotification();
  this._offlineNotification = scout.create('DesktopNotification:Offline', {
    parent: this
  });
  this._offlineNotification.show();
};

scout.Desktop.prototype.goOnline = function() {
  this._removeOfflineNotification();
};

scout.Desktop.prototype._removeOfflineNotification = function() {
  if (this._offlineNotification) {
    setTimeout(this.removeNotification.bind(this, this._offlineNotification), 3000);
    this._offlineNotification = null;
  }
};

scout.Desktop.prototype.addNotification = function(notification) {
  if (!this.rendered) {
    this._postRenderActions.push(this.addNotification.bind(this, notification));
    return;
  }

  if (!notification) {
    return;
  }
  this.notifications.push(notification);
  if (this.$notifications) {
    // Bring to front
    this.$notifications.appendTo(this.$container);
  } else {
    this.$notifications = this.$container.appendDiv('notifications');
  }
  notification.fadeIn(this.$notifications);
};

/**
 * Removes the given notification.
 * @param notification Either an instance of scout.DesktopNavigation or a String containing an ID of a notification instance.
 */
scout.Desktop.prototype.removeNotification = function(notification) {
  if (!this.rendered) {
    this._postRenderActions.push(this.removeNotification.bind(this, notification));
    return;
  }

  if (typeof notification === 'string') {
    var notificationId = notification;
    notification = scout.arrays.find(this.notifications, function(n) {
      return notificationId === n.id;
    });
  }
  if (!notification) {
    return;
  }
  if (this.$notifications) {
    notification.fadeOut(this._onNotificationRemoved.bind(this, notification));
  } else {
    scout.arrays.remove(this.notifications, notification);
  }
};

/**
 * Destroys every popup which is a descendant of the given widget.
 */
scout.Desktop.prototype.destroyPopupsFor = function(widget) {
  this.$container.children('.popup').each(function(i, elem) {
    var $popup = $(elem),
      popup = scout.Widget.getWidgetFor($popup);

    if (widget.has(popup)) {
      popup.destroy();
    }
  });
};

scout.Desktop.prototype.openUri = function(uri, action) {
  if (!this.rendered) {
    this._postRenderActions.push(this.openUri.bind(this, uri, action));
    return;
  }

  $.log.debug('(Desktop#openUri) uri=' + uri + ' action=' + action);
  if (!uri) {
    return;
  }
  action = action || 'open';

  if (action === 'download') {
    if (scout.device.isIos()) {
      // The iframe trick does not work for ios
      // Since the file cannot be stored on the file system it will be shown in the browser if possible
      // -> create a new window to not replace the existing content.
      // Drawback: Popup-Blocker will show up
      this._openUriAsNewWindow(uri);
    } else {
      this._openUriInIFrame(uri);
    }
  } else if (action === 'open') {
    if (scout.device.isIos()) {
      // Open in same window.
      // Don't call _openUriInIFrame here, if action is set to open, an url is expected to be opened in the same window
      // Additionally, some url types require to be opened in the same window like tel or mailto, at least on mobile devices
      this._openUriInSameWindow(uri);
    } else {
      this._openUriInIFrame(uri);
    }
  } else if (action === 'newWindow') {
    this._openUriAsNewWindow(uri);
  } else if (action === 'sameWindow') {
    this._openUriInSameWindow(uri);
  }
};

scout.Desktop.prototype._openUriInSameWindow = function(uri) {
  window.location.href = uri;
};

scout.Desktop.prototype._openUriInIFrame = function(uri) {
  // Create a hidden iframe and set the URI as src attribute value
  var $iframe = this.session.$entryPoint.appendElement('<iframe>', 'download-frame')
    .attr('tabindex', -1)
    .attr('src', uri);

  // Remove the iframe again after 10s (should be enough to get the download started)
  setTimeout(function() {
    $iframe.remove();
  }, 10 * 1000);
};

scout.Desktop.prototype._openUriAsNewWindow = function(uri) {
  var popupBlockerHandler = new scout.PopupBlockerHandler(this.session),
    popup = popupBlockerHandler.openWindow(uri);

  if (!popup) {
    popupBlockerHandler.showNotification(uri);
  }
};

scout.Desktop.prototype.bringOutlineToFront = function() {
  if (!this.rendered) {
    this._postRenderActions.push(this.bringOutlineToFront.bind(this));
    return;
  }

  if (!this.inBackground || this.displayStyle === scout.Desktop.DisplayStyle.BENCH) {
    return;
  }

  this.inBackground = false;
  this._setOutlineActivated();

  if (this.navigationVisible) {
    this.navigation.bringToFront();
  }
  if (this.benchVisible) {
    this.bench.bringToFront();
  }
  if (this.headerVisible) {
    this.header.bringToFront();
  }

  this._renderInBackground();
};

scout.Desktop.prototype.sendOutlineToBack = function() {
  if (this.inBackground) {
    return;
  }
  this.inBackground = true;
  if (this.navigationVisible) {
    this.navigation.sendToBack();
  }
  if (this.benchVisible) {
    this.bench.sendToBack();
  }
  if (this.headerVisible) {
    this.header.sendToBack();
  }
  this._renderInBackground();
};

/**
 * === Method required for objects that act as 'displayParent' ===
 *
 * Returns 'true' if the Desktop is currently accessible to the user.
 */
scout.Desktop.prototype.inFront = function() {
  return true; // Desktop is always available to the user.
};

/**
 * === Method required for objects that act as 'displayParent' ===
 *
 * Returns the DOM elements to paint a glassPanes over, once a modal Form, message-box, file-chooser or wait-dialog is showed with the Desktop as its 'displayParent'.
 */
scout.Desktop.prototype.glassPaneTargets = function() {
  // Do not return $container, because this is the parent of all forms and message boxes. Otherwise, no form could gain focus, even the form requested desktop modality.
  var glassPaneTargets = $.makeArray(this.$container
    .children()
    .not('.splitter') // exclude splitter to be locked
    .not('.notifications') // exclude notification box like 'connection interrupted' to be locked
    .not('.overlay-separator') // exclude overlay separator (marker element)
  );

  // When a popup-window is opened its container must also be added to the result
  this._pushPopupWindowGlassPaneTargets(glassPaneTargets);

  return glassPaneTargets;
};

/**
 * This 'deferred' object is used because popup windows are not immediately usable when they're opened.
 * That's why we must render the glass-pane of a popup window later. Which means, at the point in time
 * when its $container is created and ready for usage. To avoid race conditions we must also wait until
 * the glass pane renderer is ready. Only when both conditions are fullfilled, we can render the glass
 * pane.
 */
scout.Desktop.prototype._deferredGlassPaneTarget = function(popupWindow) {
  var deferred = new scout.DeferredGlassPaneTarget();
  popupWindow.one('init', function() {
    deferred.ready([popupWindow.$container]);
  });
  return deferred;
};

scout.Desktop.prototype._pushPopupWindowGlassPaneTargets = function(glassPaneTargets) {
  this.formController._popupWindows.forEach(function(popupWindow) {
    glassPaneTargets.push(popupWindow.initialized ?
      popupWindow.$container[0] : this._deferredGlassPaneTarget(popupWindow));
  }, this);
};

scout.Desktop.prototype.showForm = function(form, displayParent, position) {
  displayParent = displayParent || this;

  this._setFormActivated(form);
  // register listener to recover active form when child dialog is removed
  displayParent.formController.registerAndRender(form, position, true);
};

scout.Desktop.prototype.hideForm = function(form) {
  if (this.displayStyle === scout.Desktop.DisplayStyle.COMPACT && form.isView() && this.benchVisible) {
    var openViews = this.bench.getViews().slice();
    scout.arrays.remove(openViews, form);
    if (openViews.length === 0) {
      // Hide bench and show navigation if this is the last view to be hidden
      this.switchToNavigation();
    }
  }
  form.displayParent.formController.unregisterAndRemove(form);
};

scout.Desktop.prototype.activateForm = function(form) {
  form.displayParent.formController.activateForm(form);
  this._setFormActivated(form);
};

scout.Desktop.prototype._setOutlineActivated = function() {
  this._setFormActivated();
  if (this.outline) {
    this.outline.activateCurrentPage();
  }
};

scout.Desktop.prototype._setFormActivated = function(form) {
  // If desktop is in rendering process the can not set a new active for. instead the active form from the model is set selected.
  if (!this.rendered || this.initialFormRendering) {
    return;
  }

  if (this.activeForm === form) {
    return;
  }

  this.activeForm = form;
  this.triggerFormActivated(form);
};

scout.Desktop.prototype.triggerFormActivated = function(form) {
  this.trigger('formActivated', {
    form: form
  });
};

/**
 * Called when the animation triggered by animationLayoutChange is complete (e.g. navigation or bench got visible/invisible)
 */
scout.Desktop.prototype.onLayoutAnimationComplete = function() {
  if (!this.headerVisible) {
    this._removeHeader();
  }
  if (!this.navigationVisible) {
    this._removeNavigation();
  }
  if (!this.benchVisible) {
    this._removeBench();
  }
  this.trigger('animationEnd');
  this.animateLayoutChange = false;
};

scout.Desktop.prototype.onResize = function(event) {
  this.revalidateLayout();
};

scout.Desktop.prototype.onPopstate = function(event) {
  var historyState = event.originalEvent.state;
  if (historyState && historyState.deepLinkPath) {
    this.trigger('historyEntryActivated', historyState);
  }
};

scout.Desktop.prototype._onSplitterMove = function(event) {
  // disallow wider than 50%
  this.resizing = true;
  var max = Math.floor(this.$container.outerWidth(true) / 2);
  if (event.position > max) {
    event.setPosition(max);
  }
};

scout.Desktop.prototype._onSplitterPositionChanged = function(event) {
  this.revalidateLayout();
};

scout.Desktop.prototype._onSplitterMoveEnd = function(event) {
  var splitterPosition = event.position;

  // Store size
  if (this.cacheSplitterPosition) {
    storeSplitterPosition(this.splitter.position);
  }

  // Check if splitter is smaller than min size
  if (splitterPosition < scout.DesktopNavigation.BREADCRUMB_STYLE_WIDTH) {
    // Set width of navigation to BREADCRUMB_STYLE_WIDTH, using an animation.
    // While animating, update the desktop layout.
    // At the end of the animation, update the desktop layout, and store the splitter position.
    this.navigation.$container.animate({
      width: scout.DesktopNavigation.BREADCRUMB_STYLE_WIDTH
    }, {
      progress: function() {
        this.resizing = true;
        this.splitter.setPosition();
        this.revalidateLayout();
        this.resizing = false; // progress seems to be called after complete again -> layout requires flag to be properly set
      }.bind(this),
      complete: function() {
        this.resizing = true;
        this.splitter.setPosition();
        // Store size
        storeSplitterPosition(this.splitter.position);
        this.revalidateLayout();
        this.resizing = false;
      }.bind(this)
    });
  } else {
    this.resizing = false;
  }

  // ----- Helper functions -----

  function storeSplitterPosition(splitterPosition) {
    try {
      sessionStorage.setItem('scout:desktopSplitterPosition', splitterPosition);
    } catch (err) {
      // ignore errors (e.g. this can happen in "private mode" on Safari)
      $.log.error('Error while storing "scout:desktopSplitterPosition" in sessionStorage: ' + err);
    }
  }
};

scout.Desktop.prototype._onNotificationRemoved = function(notification) {
  scout.arrays.remove(this.notifications, notification);
  if (this.notifications.length === 0) {
    this.$notifications.remove();
    this.$notifications = null;
  }
};

scout.Desktop.prototype.onReconnecting = function() {
  if (!this.offline) {
    return;
  }
  this._offlineNotification.reconnect();
};

scout.Desktop.prototype.onReconnectingSucceeded = function() {
  if (!this.offline) {
    return;
  }
  this.offline = false;
  this._offlineNotification.reconnectSucceeded();
  this._removeOfflineNotification();
};

scout.Desktop.prototype.onReconnectingFailed = function() {
  if (!this.offline) {
    return;
  }
  this._offlineNotification.reconnectFailed();
};

scout.Desktop.prototype.dataChange = function(dataType) {
  this.events.trigger('dataChange', dataType);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopAdapter = function() {
  scout.DesktopAdapter.parent.call(this);
  this._addAdapterProperties(['activeForm', 'viewButtons', 'menus', 'views', 'dialogs', 'outline', 'messageBoxes', 'fileChoosers', 'addOns', 'keyStrokes']);
  this._addRemoteProperties(['benchVisible', 'navigationVisible', 'headerVisible', 'geolocationServiceAvailable']);
};
scout.inherits(scout.DesktopAdapter, scout.ModelAdapter);

scout.DesktopAdapter.prototype._goOffline = function() {
  this.widget.goOffline();
};

scout.DesktopAdapter.prototype._goOnline = function() {
  this.widget.goOnline();
};

scout.DesktopAdapter.prototype._onWidgetHistoryEntryActivated = function(event) {
  this._send('historyEntryActivated', {
    deepLinkPath: event.deepLinkPath
  });
};

scout.DesktopAdapter.prototype._onWidgetFormActivated = function(event) {
  this._sendFormActivated(event.form);
};

scout.DesktopAdapter.prototype._sendFormActivated = function(form) {
  var eventData = {
    formId: form ? form.modelAdapter.id : null
  };

  this._send('formActivated', eventData, {
    coalesce: function(previous) {
      return this.type === previous.type;
    }
  });
};

scout.DesktopAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'formActivated') {
    this._onWidgetFormActivated(event);
  } else if (event.type === 'historyEntryActivated') {
    this._onWidgetHistoryEntryActivated(event);
  } else {
    scout.DesktopAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

scout.DesktopAdapter.prototype._onFormShow = function(event) {
  var form,
    displayParent = this.session.getModelAdapter(event.displayParent);

  if (displayParent) {
    form = this.session.getOrCreateWidget(event.form, this.widget);
    this.addFilterForWidgetEvent(function(widgetEvent) {
      return (widgetEvent.type === 'formActivated' &&
          widgetEvent.form === form);
    });
    this.widget.showForm(form, displayParent.widget, event.position);
  }
};

scout.DesktopAdapter.prototype._onFormHide = function(event) {
  var form,
    displayParent = this.session.getModelAdapter(event.displayParent);

  if (displayParent) {
    form = this.session.getModelAdapter(event.form);
    this.widget.hideForm(form.widget);
  }
};

scout.DesktopAdapter.prototype._onFormActivate = function(event) {
  var form,
    displayParent = this.session.getModelAdapter(event.displayParent);

  if (displayParent) {
    form = this.session.getOrCreateWidget(event.form, this.widget);
    this.widget.activateForm(form, false);
  }
};

scout.DesktopAdapter.prototype._onMessageBoxShow = function(event) {
  var messageBox,
    displayParent = this.session.getModelAdapter(event.displayParent);

  if (displayParent) {
    messageBox = this.session.getOrCreateWidget(event.messageBox, this.widget);
    displayParent.widget.messageBoxController.registerAndRender(messageBox);
  }
};

scout.DesktopAdapter.prototype._onMessageBoxHide = function(event) {
  var messageBox,
    displayParent = this.session.getModelAdapter(event.displayParent);

  if (displayParent) {
    messageBox = this.session.getModelAdapter(event.messageBox);
    displayParent.widget.messageBoxController.unregisterAndRemove(messageBox.widget);
  }
};

scout.DesktopAdapter.prototype._onFileChooserShow = function(event) {
  var fileChooser,
    displayParent = this.session.getModelAdapter(event.displayParent);

  if (displayParent) {
    fileChooser = this.session.getOrCreateWidget(event.fileChooser, this.widget);
    displayParent.widget.fileChooserController.registerAndRender(fileChooser);
  }
};

scout.DesktopAdapter.prototype._onFileChooserHide = function(event) {
  var fileChooser,
    displayParent = this.session.getModelAdapter(event.displayParent);

  if (displayParent) {
    fileChooser = this.session.getModelAdapter(event.fileChooser);
    displayParent.widget.fileChooserController.unregisterAndRemove(fileChooser.widget);
  }
};

scout.DesktopAdapter.prototype._onOpenUri = function(event) {
  this.widget.openUri(event.uri, event.action);
};

scout.DesktopAdapter.prototype._onOutlineChanged = function(event) {
  var outline = this.session.getOrCreateWidget(event.outline, this.widget);
  this.widget.setOutline(outline);
};

scout.DesktopAdapter.prototype._onAddNotification = function(event) {
  scout.create('DesktopNotification', {
    parent: this.widget,
    id: event.id,
    duration: event.duration,
    status: event.status,
    closable: event.closable
  }).show();
};

scout.DesktopAdapter.prototype._onRemoveNotification = function(event) {
  this.widget.removeNotification(event.id);
};

scout.DesktopAdapter.prototype._onOutlineContentActivate = function(event) {
  this.widget.bringOutlineToFront();
};

scout.DesktopAdapter.prototype._onRequestGeolocation = function(event) {
  if (navigator.geolocation) {
    var success = function(position) {
      this._send('geolocationDetermined', {
        latitude: position.coords.latitude,
        longitude: position.coords.longitude
      });
    }.bind(this);
    var error = function(error) {
      this._send('geolocationDetermined', {
        errorCode: error.code,
        errorMessage: error.message
      });
    }.bind(this);
    navigator.geolocation.getCurrentPosition(success, error);
  }
};

scout.DesktopAdapter.prototype.onModelAction = function(event) {
  if (event.type === 'formShow') {
    this._onFormShow(event);
  } else if (event.type === 'formHide') {
    this._onFormHide(event);
  } else if (event.type === 'formActivate') {
    this._onFormActivate(event);
  } else if (event.type === 'messageBoxShow') {
    this._onMessageBoxShow(event);
  } else if (event.type === 'messageBoxHide') {
    this._onMessageBoxHide(event);
  } else if (event.type === 'fileChooserShow') {
    this._onFileChooserShow(event);
  } else if (event.type === 'fileChooserHide') {
    this._onFileChooserHide(event);
  } else if (event.type === 'openUri') {
    this._onOpenUri(event);
  } else if (event.type === 'outlineChanged') {
    this._onOutlineChanged(event);
  } else if (event.type === 'outlineContentActivate') {
    this._onOutlineContentActivate(event);
  } else if (event.type === 'addNotification') {
    this._onAddNotification(event);
  } else if (event.type === 'removeNotification') {
    this._onRemoveNotification(event);
  } else if (event.type === 'requestGeolocation') {
    this._onRequestGeolocation(event);
  } else {
    scout.DesktopAdapter.parent.prototype.onModelAction.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopLayout = function(desktop) {
  scout.DesktopLayout.parent.call(this);
  this.desktop = desktop;
};
scout.inherits(scout.DesktopLayout, scout.AbstractLayout);

scout.DesktopLayout.prototype.layout = function($container) {
  var navigationSize, headerSize, htmlHeader, htmlBench, benchSize, htmlNavigation, animationProps,
    navigationWidth = 0,
    headerHeight = 0,
    desktop = this.desktop,
    navigation = desktop.navigation,
    header = desktop.header,
    bench = desktop.bench,
    // Animation moves header and bench to the left when navigation gets invisible or moves bench to the right if bench gets invisible (used for mobile)
    animated = desktop.animateLayoutChange,
    containerSize = this.containerSize(),
    fullWidthNavigation = navigation && navigation.htmlComp.layoutData.fullWidth;

  if (navigation) {
    navigationWidth = this.calculateNavigationWidth(containerSize);
    if (desktop.splitter) {
      desktop.splitter.setPosition(navigationWidth, true);
    }

    if (desktop.navigationVisible) {
      htmlNavigation = navigation.htmlComp;
      navigationSize = new scout.Dimension(navigationWidth, containerSize.height)
        .subtract(htmlNavigation.getMargins());
      htmlNavigation.setSize(navigationSize);
    }
  }

  if (header) {
    htmlHeader = header.htmlComp;
    headerHeight = htmlHeader.$comp.outerHeight(true);
    if (desktop.headerVisible) {
      // positioning
      if (!animated) {
        header.$container.cssLeft(navigationWidth);
      }

      // sizing
      headerSize = new scout.Dimension(containerSize.width - navigationWidth, headerHeight)
        .subtract(htmlHeader.getMargins());
      if (!animated || fullWidthNavigation) {
        htmlHeader.setSize(headerSize);
      }

      if (animated) {
        animationProps = {
          left: containerSize.width
        };
        prepareAnimate(animationProps, htmlHeader, headerSize);
        this._animate(animationProps, htmlHeader, headerSize);
      }
    }
  }

  if (bench) {
    htmlBench = bench.htmlComp;
    if (desktop.benchVisible) {
      // positioning
      bench.$container.cssTop(headerHeight);
      if (!animated) {
        bench.$container.cssLeft(navigationWidth);
      }

      // sizing
      benchSize = new scout.Dimension(containerSize.width - navigationWidth, containerSize.height - headerHeight)
        .subtract(htmlBench.getMargins());
      if (!animated || fullWidthNavigation) {
        htmlBench.setSize(benchSize);
      }

      if (animated) {
        animationProps = {
          left: containerSize.width
        };
        prepareAnimate(animationProps, htmlBench, benchSize);
        this._animate(animationProps, htmlBench, benchSize);
      }
    }
  }

  function prepareAnimate(animationProps, htmlComp, size) {
    if (fullWidthNavigation) {
      // Slide bench in from right to left, don't resize
      htmlComp.$comp.cssLeft(containerSize.width);
    } else {
      // Resize bench
      animationProps.width = size.width;
      // Layout once before animation begins
      // Resizing on every step/progress would result in poor performance (e.g. when a form is open in the bench)
      htmlComp.setSize(size);
    }
    // Move to new point (=0, if navigation is invisible)
    animationProps.left = navigationWidth;
  }
};

/**
 * Used to animate bench and header
 */
scout.DesktopLayout.prototype._animate = function(animationProps, htmlComp, size) {
  // If animation is already running, stop the existing and don't use timeout to schedule the new to have a smoother transition
  // Concurrent animation of the same element is bad because jquery messes up the overflow style
  if (htmlComp.$comp.is(':animated')) {
    htmlComp.$comp.stop().animate(animationProps, {
      complete: this.desktop.onLayoutAnimationComplete.bind(this.desktop)
    });
  } else {
    // schedule animation to have a smoother start
    setTimeout(function() {
      htmlComp.$comp.stop().animate(animationProps, {
        complete: this.desktop.onLayoutAnimationComplete.bind(this.desktop)
      });
    }.bind(this));
  }
};

scout.DesktopLayout.prototype.containerSize = function() {
  var htmlContainer = this.desktop.htmlComp,
    containerSize = htmlContainer.getAvailableSize();

  return containerSize.subtract(htmlContainer.getInsets());
};

scout.DesktopLayout.prototype.calculateNavigationWidth = function(containerSize) {
  if (!this.desktop.navigationVisible) {
    return 0;
  }
  var navigationLayoutData = this.desktop.navigation.htmlComp.layoutData;
  if (navigationLayoutData.fullWidth) {
    return containerSize.width;
  }
  var splitterPosition = 0;
  if (this.desktop.splitter) {
    splitterPosition = this.desktop.splitter.position;
  }
  var outline = this.desktop.outline;
  if (!this.desktop.resizing && outline && outline.autoToggleBreadcrumbStyle) {
    // If autoToggleBreadcrumbStyle is true, BREADCRUMB_STYLE_WIDTH triggers the toggling between the two modes.
    // This code ensures this rule is never violated (necessary if mode is toggled programmatically rather than by the user)
    if (outline.displayStyle === scout.Tree.DisplayStyle.BREADCRUMB) {
      splitterPosition = scout.DesktopNavigation.BREADCRUMB_STYLE_WIDTH;
    } else if (splitterPosition <= scout.DesktopNavigation.BREADCRUMB_STYLE_WIDTH) {
      splitterPosition = scout.DesktopNavigation.DEFAULT_STYLE_WIDTH;
    }
  }
  return Math.max(splitterPosition, scout.DesktopNavigation.MIN_WIDTH); // ensure newSize is not negative
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopLogo = function() {
  scout.DesktopLogo.parent.call(this);
};
scout.inherits(scout.DesktopLogo, scout.Widget);

scout.DesktopLogo.prototype._init = function(model) {
  scout.DesktopLogo.parent.prototype._init.call(this, model);
  this.url = model.url;
};

scout.DesktopLogo.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('desktop-logo');

  // in memory of the first one...
  this.$container.dblclick(function(event) {
    if (event.altKey && event.ctrlKey) {
      $(event.target).css('background', 'none');
      $(event.target).css('font-size', '9px');
      $(event.target).text('make software not war');
    }
  });
};

scout.DesktopLogo.prototype._renderProperties = function() {
  scout.DesktopLogo.parent.prototype._renderProperties.call(this);
  this._renderUrl();
};

scout.DesktopLogo.prototype._renderUrl = function() {
  this.$container.css('backgroundImage', 'url(' + this.url + ')');
};

scout.DesktopLogo.prototype.setUrl = function(url) {
  this.setProperty('url', url);
};

/**
 * This KeyStroke works as "catch all" on the top-most DOM element of the Scout application.
 * It prevents that key-strokes from the Scout application (like F5 for reload) 'leak' into the
 * browser which typically happens when the glasspane/busy-indicator is visible. Thus this
 * key-stroke only accepts the event when busy-indicator is active.
 */
scout.DesktopKeyStroke = function(session) {
  scout.DesktopKeyStroke.parent.call(this);

  var keys = scout.keys;
  this.preventDefault = false;
  this.session = session;

  // this key-stroke handles key-shortcuts with and without Ctrl key
  this.whiteListCtrlKeys = [keys.N, keys.R, keys.T, keys.PAGE_UP, keys.PAGE_DOWN];
  this.whiteListKeys = [keys.F11, keys.F12];

  // Never delegate these keys to the browser (F5 is used to reload tables or forms, ctrl-r may be used to reload the browser)
  this.blackListKeys = [keys.F5];
};
scout.inherits(scout.DesktopKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.DesktopKeyStroke.prototype._accept = function(event) {
  if (scout.isOneOf(event.which, this.blackListKeys)) {
    this.preventDefault = true;
    return true;
  }

  // only apply "catch-all" when busy indicator is displayed
  if (this.session._busyIndicator) {
    var whiteList, delegateToBrowser;
    if (event.ctrlKey || event.metaKey) {
      whiteList = this.whiteListCtrlKeys;
    } else {
      whiteList = this.whiteListKeys;
    }
    delegateToBrowser = scout.isOneOf(event.which, whiteList);
    this.preventDefault = !delegateToBrowser;
    // return true since we want to catch all keys and we rely on the _applyPropagationFlags
    // which is executed later and interprets the preventDefault property
    return true;
  }

  return false;
};

/**
 * @override KeyStroke.js
 */
scout.DesktopKeyStroke.prototype.handle = function(event) {
  // NOP
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PopupWindow = function(myWindow, form) { // use 'myWindow' in place of 'window' to prevent confusion with global window variable
  this.myWindow = myWindow;
  this.form = form;
  this.session = form.session;
  this.events = new scout.EventSupport();
  this.initialized = false;
  this.$container;
  this.htmlComp;

  // link Form instance with this popupWindow instance
  // this is required when form (and popup-window) is closed by the model
  form.popupWindow = this;

  // link Window instance with this popupWindow instance
  // this is required when we want to check if a certain DOM element belongs
  // to a popup window
  myWindow.popupWindow = this;
  myWindow.name = 'Scout popup-window ' + form.modelClass;
};

scout.PopupWindow.prototype._onUnload = function() {
  $.log.debug('stored form ID ' + this.form.id + ' to session storage');
  if (this.form.destroyed) {
    $.log.debug('form ID ' + this.form.id + ' is already destroyed - don\'t trigger unload event');
  } else {
    this.events.trigger('popupWindowUnload', this);
  }
};

scout.PopupWindow.prototype._onReady = function() {
  // set container (used as document-root from callers)
  var myDocument = this.myWindow.document,
    $myWindow = $(this.myWindow),
    $myDocument = $(myDocument);

  // Install polyfills on new window
  scout.polyfills.install(this.myWindow);
  scout.prepareDOM(myDocument);

  this.$container = $('.scout', myDocument);
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.SingleLayout());
  this.$container.height($myWindow.height());
  this.form.render(this.$container);

  // resize browser-window before layout?
  if (this.resizeToPrefSize) {
    var prefSize = this.htmlComp.getPreferredSize(),
    // we cannot simply set the pref. size of the component as window size,
    // since the window "chrome" (window-border, -title and location bar)
    // occupies some space. That's why we measure the difference between
    // the current document size and the window size first.
      myWindowSize = new scout.Dimension(this.myWindow.outerWidth, this.myWindow.outerHeight),
      myDocumentSize = new scout.Dimension($myDocument.width(), $myDocument.height()),
      windowChromeHoriz = myWindowSize.width - myDocumentSize.width,
      windowChromeVert = myWindowSize.height - myDocumentSize.height;

    this.myWindow.resizeTo(prefSize.width + windowChromeHoriz, prefSize.height + windowChromeVert);
    this.resizeToPrefSize = false;
  }
  this.form.htmlComp.validateLayout();

  // Must register some top-level keystroke- and mouse-handlers on popup-window
  // We do the same thing here, as with the $entryPoint of the main window
  this.session.keyStrokeManager.installTopLevelKeyStrokeHandlers(this.$container);
  this.session.focusManager.installTopLevelMouseHandlers(this.$container);
  scout._installGlobalMouseDownInterceptor(myDocument);

  // Attach event handlers on window
  $(this.myWindow)
    .on('unload', this._onUnload.bind(this))
    .on('resize', this._onResize.bind(this));

  // Delegate uncaught JavaScript errors in the popup-window to the main-window
  this.myWindow.onerror = this.myWindow.opener.onerror;

  // Finally set initialized flag to true, at this point the PopupWindow is fully initialized
  this.initialized = true;
  this.events.trigger('init');
};

// Note: currently _onResize is only called when the window is resized, but not when the position of the window changes.
// if we need to do that in a later release we should take a look on the SO-post below:
// http://stackoverflow.com/questions/4319487/detecting-if-the-browser-window-is-moved-with-javascript
scout.PopupWindow.prototype._onResize = function() {
  var $myWindow = $(this.myWindow),
    width = $myWindow.width(),
    height = $myWindow.height(),
    left = this.myWindow.screenX,
    top = this.myWindow.screenY;
  $.log.debug('popup-window resize: width=' + width + ' height=' + height + ' top=' + top + ' left=' + left);

  // store window bounds by class ID
  if (this.form.cacheBounds) {
    scout.PopupWindow.storeWindowBounds(this.form, new scout.Rectangle(left, top, width, height));
  }

  var windowSize = new scout.Dimension($myWindow.width(), $myWindow.height());
  this.htmlComp.setSize(windowSize);
};

scout.PopupWindow.storeWindowBounds = function(form, bounds) {
  var storageKey = 'scout:formBounds:' + form.cacheBoundsKey;
  try {
    localStorage.setItem(storageKey, JSON.stringify(bounds));
  }
  catch (err) {
    // ignore errors (e.g. this can happen in "private mode" on Safari)
    $.log.error('Error while storing "' + storageKey + '" in localStorage: ' + err);
  }
};

scout.PopupWindow.readWindowBounds = function(form) {
  var storageKey = 'scout:formBounds:' + form.cacheBoundsKey;
  var bounds = localStorage.getItem(storageKey);
  if (!bounds) {
    return null;
  }
  bounds = JSON.parse(bounds);
  return new scout.Rectangle(bounds.x, bounds.y, bounds.width, bounds.height);
};

scout.PopupWindow.prototype.isClosed = function() {
  return this.myWindow.closed;
};

scout.PopupWindow.prototype.one = function(type, func) {
  this.events.one(type, func);
};

scout.PopupWindow.prototype.close = function() {
  this.myWindow.close();
};

scout.PopupWindow.prototype.title = function(title) {
  this.myWindow.document.title = title;
};


/*******************************************************************************

* Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * The {@link {@link scout.SimpleTabBoxController}} is used to link a {@link {@link scout.SimpleTabBox}} with a {@link {@link scout.SimpleTabArea}}.
 * There are {@link {@link scout.SimpleTabBox}} with more than one {@link {@link scout.SimpleTabArea}} to actualized.
 * Therefore the linking is separated in a controller.
 * The controller basically listens to 'viewAdded', 'viewRemoved', 'viewActivated', 'viewDeactivated' on the {@link {@link scout.SimpleTabBox}} and
 * updates the {@link {@link scout.SimpleTabArea}}.
 */
scout.SimpleTabBoxController = function(tabBox, tabArea) {
  this.tabBox = tabBox;
  this.tabArea = tabArea;

  this._viewAddedHandler = this._onViewAdded.bind(this);
  this._viewRemovedHandler = this._onViewRemoved.bind(this);
  this._viewActivatedHandler = this._onViewActivated.bind(this);
  this._viewDeactivatedHandler = this._onViewDeactivated.bind(this);

  this._viewTabSelectedHandler = this._onViewTabSelected.bind(this);

  this._installListeners();
};

scout.SimpleTabBoxController.prototype._installListeners = function() {
  this.tabBox.on('viewAdded', this._viewAddedHandler);
  this.tabBox.on('viewRemoved', this._viewRemovedHandler);
  this.tabBox.on('viewActivated', this._viewActivatedHandler);
  this.tabBox.on('viewDeactivated', this._viewDeactivatedHandler);

  this.tabArea.on('tabSelected', this._viewTabSelectedHandler);
};

scout.SimpleTabBoxController.prototype._onViewAdded = function(event) {
  var view = event.view,
    siblingView = event.siblingView,
    viewTab,
    // the sibling to insert the tab after.
    siblingViewTab;

  if (!scout.SimpleTabBoxController.hasViewTab(view)) {
    return;
  }
  viewTab = this._getTab(view);
  if (!viewTab) {
    siblingViewTab = this._getTab(siblingView);
    viewTab = scout.create('DesktopTab', {
      parent: this.tabArea,
      view: view
    });
    this.tabArea.addTab(viewTab, siblingViewTab);
  }
};

scout.SimpleTabBoxController.prototype._onViewRemoved = function(event) {
  var view = event.view;
  if (!view) {
    return;
  }
  var viewTab = this._getTab(view);
  if (viewTab) {
    this.tabArea.destroyTab(viewTab);
  }
};

scout.SimpleTabBoxController.prototype._onViewActivated = function(event) {
  var viewTab = this._getTab(event.view);
  // also reset selection if no view tab of the view is found.
  this.tabArea.selectTab(viewTab);
};

scout.SimpleTabBoxController.prototype._onViewDeactivated = function(event) {
  var viewTab = this._getTab(event.view);
  // also reset selection if no view tab of the view is found.
  this.tabArea.deselectTab(viewTab);
};

scout.SimpleTabBoxController.prototype._onViewTabSelected = function(event) {
  if (!event.viewTab) {
    return;
  }
  var view = event.viewTab.view;
  this.tabBox.activateView(view);
};

scout.SimpleTabBoxController.prototype._getTab = function(view) {
  if (!view) {
    return;
  }
  var viewTab;
  this.tabArea.getTabs().some(function(tab) {
    if (tab.view === view) {
      viewTab = tab;
      return true;
    }
    return false;
  });
  return viewTab;
};

scout.SimpleTabBoxController.prototype.getTabs = function() {
  return this.tabArea.getTabs();
};

/* ----- static functions ----- */

scout.SimpleTabBoxController.hasViewTab = function(view) {
  return scout.objects.someProperties(view, ['title', 'subTitle', 'iconId']);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SimpleTabBox = function() {
  scout.SimpleTabBox.parent.call(this);
  this.$body;
  this.htmlComp;
  this.tabArea;
  this.viewStack = [];
  this.currentView;
  this._removeViewInProgress = 0;
};
scout.inherits(scout.SimpleTabBox, scout.Widget);

scout.SimpleTabBox.prototype._init = function(model) {
  scout.SimpleTabBox.parent.prototype._init.call(this, model);

  // create view tabs
  this.tabArea = scout.create('SimpleTabArea', {
    parent: this
  });
  // link
  this.controller = new scout.SimpleTabBoxController(this, this.tabArea);

  this._viewDestroyedHandler = this._onViewDestroyed.bind(this);
};

/**
 * Returns a $container used as a bind target for the key-stroke context of the group-box.
 * By default this function returns the container of the form, or when group-box is has no
 * form as a parent the container of the group-box.
 */
scout.SimpleTabBox.prototype._keyStrokeBindTarget = function() {
  return this.$container;
};

scout.SimpleTabBox.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('view-tab-box');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.SimpleTabBoxLayout(this));

  // render content
  this.$viewContent = this.$container.appendDiv('tab-content');
  this.viewContent = scout.HtmlComponent.install(this.$viewContent, this.session);
  this.viewContent.setLayout(new scout.SimpleTabViewContentLayout(this));
};

scout.SimpleTabBox.prototype._renderProperties = function() {
  scout.SimpleTabBox.parent.prototype._renderProperties.call(this);
  // render tabArea
  this._renderTabArea();
  this._renderView(this.currentView);
};

scout.SimpleTabBox.prototype._renderTabArea = function() {
  this.tabArea.render(this.$container);
  this.$tabArea = this.tabArea.$container;
  if (this.tabArea.attached) {
    this.$tabArea.insertBefore(this.$viewContent);
  }
};

scout.SimpleTabBox.prototype._renderView = function(view) {
  if (!view) {
    return;
  }
  if (view.rendered) {
    return;
  }
  view.render(this.$viewContent);
  view.$container.addClass('view');
  view.validateRoot = true;
};

scout.SimpleTabBox.prototype.postRender = function() {
  if (this.viewStack.length > 0 && !this.currentView) {
    this.activateView(this.viewStack[this.viewStack.length - 1]);
  }
};

scout.SimpleTabBox.prototype._remove = function() {
  scout.SimpleTabBox.parent.prototype._remove.call(this);
  if (this.scrollable) {
    scout.scrollbars.uninstall(this.$body);
  }
};

scout.SimpleTabBox.prototype.activateView = function(view) {
  if (view === this.currentView) {
    return;
  }

  if (this.currentView) {
    this.currentView.detach();
    this.trigger('viewDeactivated', {
      view: this.currentView
    });
    this.currentView = null;
  }
  // ensure rendered
  if (this.rendered) {
    this._renderView(view);
  }
  if (!view.attached) {
    view.attach();
  }
  this.currentView = view;

  this.trigger('viewActivated', {
    view: view
  });

  this.revalidateLayout();
};

scout.SimpleTabBox.prototype.revalidateLayout = function() {
  if (this.rendered) {
    this.viewContent.invalidateLayoutTree();
    // Layout immediate to prevent 'laggy' form visualization,
    // but not initially while desktop gets rendered because it will be done at the end anyway
    this.viewContent.validateLayoutTree();
  }
};

/**
 *
 * @param view
 * @param bringToTop whether the view should be placed on top of the view stack. the view tab will be selected.
 */
scout.SimpleTabBox.prototype.addView = function(view, bringToTop) {
  var activate = scout.nvl(bringToTop, true);
  if (this.viewStack.length === 0) {
    activate = true;
  }
  // add to view stack
  var siblingView = this._addToViewStack(view);
  view.setParent(this);
  this.trigger('viewAdded', {
    view: view,
    siblingView: siblingView
  });

  if (activate) {
    this.activateView(view);
  }
};

/**
 * @param view
 * @return the view which is gonna be the sibling to insert the new view tab after.
 */
scout.SimpleTabBox.prototype._addToViewStack = function(view) {
  var sibling;
  var index = this.viewStack.indexOf(view);
  if (index > -1) {
    return this.viewStack[index - 1];
  }

  if (!scout.SimpleTabBoxController.hasViewTab(view)) {
    // first
    this.viewStack.unshift(view);
    this._addDestroyListener(view);
    return sibling;
  }
  if (!this.currentView) {
    // end
    sibling = this.viewStack[this.viewStack.length - 1];
    this.viewStack.push(view);
    this._addDestroyListener(view);
    return;
  }
  var currentIndex = this.viewStack.indexOf(this.currentView);
  sibling = this.viewStack[currentIndex];
  // it does not matter when index is -1 will be inserted at first position
  this.viewStack.splice(currentIndex + 1, 0, view);
  return sibling;
};

scout.SimpleTabBox.prototype._addDestroyListener = function(view) {
  view.one('destroy', this._viewDestroyedHandler);
};

scout.SimpleTabBox.prototype._removeDestroyListener = function(view) {
  view.off('destroy', this._viewDestroyedHandler);
};

scout.SimpleTabBox.prototype._onViewDestroyed = function(event) {
  var view = event.source;
  scout.arrays.remove(this.viewStack, view);
  if (this.currentView === view) {
    if (this.rendered) {
      view.remove();
    }
    this.currentView = null;
  }
};

scout.SimpleTabBox.prototype.removeView = function(view, showSiblingView) {
  if (!view) {
    return;
  }
  showSiblingView = scout.nvl(showSiblingView, true);
  var index = this.viewStack.indexOf(view);
  var viewToActivate;
  // if current view is the view to remove reset current view
  if (this.currentView === view) {
    this.currentView = null;
  }

  if (index > -1) {
    // activate previous
    if (showSiblingView) {
      if (index - 1 >= 0) {
        viewToActivate = this.viewStack[index - 1];
      } else if (index + 1 < this.viewStack.length) {
        viewToActivate = this.viewStack[index + 1];
      }
    }

    // remove
    this.viewStack.splice(index, 1);
    if (view.rendered) {
      this._removeViewInProgress++;
      view.remove();
      this._removeViewInProgress--;
    }
    this.trigger('viewRemoved', {
      view: view
    });

    if (this._removeViewInProgress === 0) {
      if (viewToActivate) {
        this.activateView(viewToActivate);
      }
      if (this.rendered) {
        this.viewContent.invalidateLayoutTree();
        this.viewContent.validateLayoutTree();
      }
    }
  }
};

scout.SimpleTabBox.prototype.getController = function() {
  return this.controller;
};

scout.SimpleTabBox.prototype.viewCount = function() {
  return this.viewStack.length;
};

scout.SimpleTabBox.prototype.hasViews = function() {
  return this.viewStack.length > 0;
};

scout.SimpleTabBox.prototype.getViews = function(displayViewId) {
  return this.viewStack.filter(function(view) {
    if (!displayViewId) {
      return true;
    }
    return displayViewId === view.displayViewId;
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SimpleTabBoxLayout = function(tabBox) {
  scout.SimpleTabBoxLayout.parent.call(this);
  this.tabBox = tabBox;
};
scout.inherits(scout.SimpleTabBoxLayout, scout.AbstractLayout);

scout.SimpleTabBoxLayout.prototype.layout = function($container) {
  var containerSize, viewContentSize,
    htmlContainer = scout.HtmlComponent.get($container),
    htmlViewContent = scout.HtmlComponent.get(this.tabBox.$viewContent),
    tabAreaSize ;

  containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  tabAreaSize = this._layoutTabArea(containerSize);

  viewContentSize = containerSize.subtract(htmlViewContent.getMargins());
  viewContentSize.height -= tabAreaSize.height;
  htmlViewContent.setSize(viewContentSize);
};

/**
 * @param containerSize
 * @returns {@link {@link scout.Dimension}} used of the tab area
 */
scout.SimpleTabBoxLayout.prototype._layoutTabArea = function(containerSize) {
  if (!this.tabBox.rendered) {
    return new scout.Dimension(0,0);
  }
  // exprected the tab area is layouted dynamically only
  var htmlViewTabs = scout.HtmlComponent.get(this.tabBox.$tabArea),
    prefSize = htmlViewTabs.getPreferredSize(),
    margins = htmlViewTabs.getMargins();
  var size = new scout.Dimension(containerSize.width, prefSize.height + margins.top + margins.bottom);
  htmlViewTabs.setSize(size);
  return  size;
};

/**
 * Preferred size of the tab-box aligns every tab-item in a single line, so that each item is visible.
 */
scout.SimpleTabBoxLayout.prototype.preferredLayoutSize = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    htmlViewContent = scout.HtmlComponent.get(this.tabBox.$viewContent),
    htmlViewTabs = scout.HtmlComponent.get(this.tabBox.$tabArea),
    viewTabsSize = new scout.Dimension(),
    viewContentSize = new scout.Dimension();

  if (htmlViewTabs.isVisible()) {
    viewTabsSize = htmlViewTabs.getPreferredSize()
      .add(htmlViewTabs.getMargins());
  }

  viewContentSize = htmlViewContent.getPreferredSize()
    .add(htmlContainer.getInsets())
    .add(htmlViewContent.getMargins());

  return new scout.Dimension(
    Math.max(viewTabsSize.width, viewContentSize.width),
    viewContentSize.height + viewTabsSize.height);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SimpleTabViewContentLayout = function(tabBox) {
  scout.SimpleTabViewContentLayout.parent.call(this);
  this.tabBox = tabBox;
};
scout.inherits(scout.SimpleTabViewContentLayout, scout.AbstractLayout);

// FIXME [6.1] BSH/CGU Improve this
scout.SimpleTabViewContentLayout.prototype.layout = function($container) {
  var currentView = this.tabBox.currentView;
  if (!currentView || !currentView.rendered || !currentView.htmlComp) {
    return;
  }

  var htmlContainer = scout.HtmlComponent.get($container);
  var size = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets())
    .subtract(currentView.htmlComp.getMargins());

  currentView.htmlComp.setSize(size);
};

scout.SimpleTabViewContentLayout.prototype.preferredLayoutSize = function($container) {
  var currentView = this.tabBox.currentView;
  if (!currentView || !currentView.rendered || !currentView.htmlComp) {
    return new scout.Dimension();
  }

  var htmlContainer = scout.HtmlComponent.get($container);
  var prefSize = currentView.htmlComp.getPreferredSize()
    .add(htmlContainer.getInsets())
    .add(currentView.htmlComp.getMargins());

  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopBench = function() {
  scout.DesktopBench.parent.call(this);
  this.htmlComp;
  this.columns = [];
  this.components;
  this.tabBoxMap = {}; // [key=viewId, value=SimpleTabBox instance]
  this._removeViewInProgress = 0;

  this._desktopOutlineChangedHandler = this._onDesktopOutlineChanged.bind(this);
  this._desktopPropertyChangeHandler = this._onDesktopPropertyChange.bind(this);
  this._outlineNodesSelectedHandler = this._onOutlineNodesSelected.bind(this);
  this._outlinePageChangedHandler = this._onOutlinePageChanged.bind(this);
  this._outlinePropertyChangeHandler = this._onOutlinePropertyChange.bind(this);
  this._onOutlineContentDestroyedHandler = this._onOutlineContentDestroyed.bind(this);

  // event listener functions
  this._viewAddedHandler = this._onViewAdded.bind(this);
  this._viewRemovedHandler = this._onViewRemoved.bind(this);
  this._viewActivatedHandler = this._onViewActivated.bind(this);
  this._viewDeactivatedHandler = this._onViewDeactivated.bind(this);

  this._desktopAnimationEndHandler = this._onDesktopAnimationEnd.bind(this);
};
scout.inherits(scout.DesktopBench, scout.Widget);

scout.DesktopBench.VIEW_MIN_HEIGHT; // Configured in sizes.css
scout.DesktopBench.VIEW_MIN_WIDTH; // Configured in sizes.css
scout.DesktopBench.VIEW_AREA_COLUMN_INDEX = {
  LEFT: 0,
  CENTER: 1,
  RIGHT: 2
};

scout.DesktopBench.prototype._init = function(model) {
  scout.DesktopBench.parent.prototype._init.call(this, model);

  scout.DesktopBench.VIEW_MIN_HEIGHT = $.pxToNumber(scout.styles.get('view-tab-box', 'min-height').minHeight);
  scout.DesktopBench.VIEW_MIN_WIDTH = $.pxToNumber(scout.styles.get('view-tab-box', 'min-width').minWidth);

  this._createColumns();
  this.desktop = this.session.desktop;
  this.headerTabArea = model.headerTabArea;
  // controller for headerTabArea
  if (this.headerTabArea) {
    this.headerTabAreaController = new scout.HeaderTabBoxController(this, this.headerTabArea);
  }
  this.outlineContentVisible = scout.nvl(model.outlineContentVisible, true);
  this.setOutline(this.desktop.outline);
  this.updateNavigationHandleVisibility();
};

scout.DesktopBench.prototype._createColumns = function() {
  for (var i = 0; i < 3; i++) {
    var column = scout.create('BenchColumn', {
      parent: this
    });
    column.on('viewAdded', this._viewAddedHandler);
    column.on('viewRemoved', this._viewRemovedHandler);
    column.on('viewActivated', this._viewActivatedHandler);
    column.on('viewDeactivated', this._viewDeactivatedHandler);
    this.columns.push(column);
  }
};

scout.DesktopBench.prototype._initKeyStrokeContext = function() {
  scout.DesktopBench.parent.prototype._initKeyStrokeContext.call(this);

  // Bound to desktop
  this.desktopKeyStrokeContext = new scout.KeyStrokeContext();
  this.desktopKeyStrokeContext.invokeAcceptInputOnActiveValueField = true;
  this.desktopKeyStrokeContext.$bindTarget = this.desktop.$container;
  this.desktopKeyStrokeContext.$scopeTarget = this.$container;
  this.desktopKeyStrokeContext.registerKeyStroke(this.desktop.keyStrokes);
  this.desktopKeyStrokeContext.registerKeyStroke(new scout.DesktopTabSelectKeyStroke(this.desktop));
};

scout.DesktopBench.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('desktop-bench');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);

  this.htmlComp.setLayout(this._createLayout());

  this._renderColumns();
  this._revalidateSplitters();
  this._renderNavigationHandleVisible();

  this.session.keyStrokeManager.installKeyStrokeContext(this.desktopKeyStrokeContext);
  this.desktop.on('propertyChange', this._desktopPropertyChangeHandler);
  this.desktop.on('outlineChanged', this._desktopOutlineChangedHandler);
  this.desktop.on('animationEnd', this._desktopAnimationEndHandler);
};

scout.DesktopBench.prototype._createLayout = function() {
  return new scout.DesktopBenchLayout(this);
};

scout.DesktopBench.prototype._renderColumns = function() {
  this.columns.forEach(function(column) {
    if (column.viewCount() > 0) {
      this._renderColumn(column);

    }
  }.bind(this));
};

scout.DesktopBench.prototype._renderColumn = function(column) {
  if (!column || column.rendered) {
    return;
  }

  column.render(this.$container);
};

scout.DesktopBench.prototype._remove = function() {
  this.desktop.off('propertyChange', this._desktopPropertyChangeHandler);
  this.desktop.off('outlineChanged', this._desktopOutlineChangedHandler);
  this.desktop.off('animationEnd', this._desktopAnimationEndHandler);
  this.session.keyStrokeManager.uninstallKeyStrokeContext(this.desktopKeyStrokeContext);
  scout.DesktopBench.parent.prototype._remove.call(this);
};

scout.DesktopBench.prototype._renderOutlineContent = function() {
  if (!this.outlineContent) {
    return;
  }

  // Reset view tab relevant properties to make sure no tab is visible for the outline content
  delete this.outlineContent.title;
  delete this.outlineContent.subTitle;
  delete this.outlineContent.iconId;

  // bring the view to top if the desktop is not in background.
  this.addView(this.outlineContent, !this.desktop.inBackground);

  if (this.desktop.rendered) {
    // Request focus on first element in outline content
    this.session.focusManager.validateFocus();
  }

};

scout.DesktopBench.prototype._removeOutlineContent = function() {
  if (!this.outlineContent) {
    return;
  }
  this.removeView(this.outlineContent, false);
};

scout.DesktopBench.prototype._renderNavigationHandle = function() {
  if (this.navigationHandle) {
    return;
  }
  this.navigationHandle = scout.create('DesktopNavigationHandle', {
    parent: this,
    leftVisible: false
  });
  this.navigationHandle.render(this.$container);
  this.navigationHandle.$container.addClass('navigation-closed');
  this.navigationHandle.on('action', this._onNavigationHandleAction.bind(this));
};

scout.DesktopBench.prototype._removeNavigationHandle = function() {
  if (!this.navigationHandle) {
    return;
  }
  this.navigationHandle.destroy();
  this.navigationHandle = null;
};

scout.DesktopBench.prototype._renderNavigationHandleVisible = function() {
  if (this.navigationHandleVisible) {
    this._renderNavigationHandle();
  } else {
    this._removeNavigationHandle();
  }
};

/**
 * is called in post render of desktop used to initialize the ui state. E.g. show default views
 */
scout.DesktopBench.prototype.postRender = function() {
  this.columns.forEach(function(column) {
    column.postRender();
  });
};

scout.DesktopBench.prototype.setNavigationHandleVisible = function(visible) {
  this.setProperty('navigationHandleVisible', visible);
};

scout.DesktopBench.prototype.setOutline = function(outline) {
  if (this.outline) {
    this.outline.off('nodesSelected', this._outlineNodesSelectedHandler);
    this.outline.off('pageChanged', this._outlinePageChangedHandler);
    this.outline.off('propertyChange', this._outlinePropertyChangeHandler);
  }
  this._setProperty('outline', outline);
  if (this.outline) {
    this.outline.on('nodesSelected', this._outlineNodesSelectedHandler);
    this.outline.on('pageChanged', this._outlinePageChangedHandler);
    this.outline.on('propertyChange', this._outlinePropertyChangeHandler);
  }
  this.updateOutlineContent();
};

scout.DesktopBench.prototype.setOutlineContent = function(content) {
  var oldContent = this.outlineContent;
  if (this.outlineContent === content) {
    return;
  }
  if (oldContent) {
    oldContent.off('destroy', this._onOutlineContentDestroyedHandler);
  }
  if (this.rendered) {
    this._removeOutlineContent();
  }
  // add a destroy listener to the outline-content, so we can reset the property - otherwise we'd work
  // with a potentially destroyed content which would cause an error later, when we try to render the
  // bench with the outline-content.
  if (content) {
    content.one('destroy', this._onOutlineContentDestroyedHandler);
  }

  this._setProperty('outlineContent', content);

  // Inform header that outline content has changed
  // (having a listener in the header is quite complex due to initialization phase, a direct call here is much easier to implement)
  if (this.desktop.header) {
    this.desktop.header.onBenchOutlineContentChange(content, oldContent);
  }
  this._renderOutlineContent();
};

scout.DesktopBench.prototype.setOutlineContentVisible = function(visible) {
  if (visible === this.outlineContentVisible) {
    return;
  }
  this._setProperty('outlineContentVisible', visible);
  this.updateOutlineContent();
};

scout.DesktopBench.prototype.bringToFront = function() {
  if (!this.outlineContent) {
    return;
  }
  this._renderOutlineContent();
};

scout.DesktopBench.prototype.sendToBack = function() {
  // nop
};

scout.DesktopBench.prototype._computeDefaultDetailForm = function() {
  return this.outline.defaultDetailForm;
};

scout.DesktopBench.prototype._computeOutlineOverview = function() {
  return this.outline.outlineOverview;
};

scout.DesktopBench.prototype._computeDetailContentForPage = function(node) {
  if (!node) {
    throw new Error('called _showDetailContentForPage without node');
  }

  var content;
  if (node.detailForm && node.detailFormVisible && node.detailFormVisibleByUi) {
    content = node.detailForm;
    content.uiCssClass = 'detail-form';
  } else if (node.detailTable && node.detailTableVisible) {
    content = node.detailTable;
    content.uiCssClass = 'detail-table';
  }

  return content;
};

scout.DesktopBench.prototype.updateOutlineContent = function() {
  if (!this.outlineContentVisible || !this.outline) {
    return;
  }
  var content,
    selectedPage = this.outline.selectedNode();
  if (selectedPage) {
    // Outline does not support multi selection
    content = this._computeDetailContentForPage(selectedPage);
  } else {
    if (this.outline.defaultDetailForm) {
      content = this._computeDefaultDetailForm();
    } else if (this.outline.outlineOverview) {
      content = this._computeOutlineOverview();
    }
  }
  if (content) {
    if (content instanceof scout.Table) {
      content.menuBar.top();
      content.menuBar.large();
    }
    content.displayViewId = 'C';
  }
  this.setOutlineContent(content);
};

scout.DesktopBench.prototype.updateOutlineContentDebounced = function() {
  clearTimeout(this._updateOutlineContentTimeout);
  this._updateOutlineContentTimeout = setTimeout(function() {
    this.updateOutlineContent();
  }.bind(this), 300);
};

scout.DesktopBench.prototype.updateNavigationHandleVisibility = function() {
  // Don't show handle if desktop says handle must not be visible
  // Only show handle if navigation is invisible
  this.setNavigationHandleVisible(this.desktop.navigationHandleVisible && !this.desktop.navigationVisible);
};

scout.DesktopBench.prototype._onDesktopOutlineChanged = function(event) {
  this.setOutline(this.desktop.outline);
  this.updateNavigationHandleVisibility();
};

scout.DesktopBench.prototype._onOutlineContentDestroyed = function(event) {
  this.setOutlineContent(null);
};

scout.DesktopBench.prototype._onOutlineNodesSelected = function(event) {
  if (event.debounce) {
    this.updateOutlineContentDebounced();
  } else {
    this.updateOutlineContent();
  }
};

scout.DesktopBench.prototype._onOutlinePageChanged = function(event) {
  var selectedPage = this.outline.selectedNode();
  if (!event.page && !selectedPage || event.page === selectedPage) {
    this.updateOutlineContent();
  }
};

scout.DesktopBench.prototype._onOutlinePropertyChange = function(event) {
  if(scout.arrays.containsAny(event.changedProperties, ['defaultDetailForm', 'outlineOverview'])){
    this.updateOutlineContent();
  }
};

scout.DesktopBench.prototype._onDesktopNavigationVisibleChange = function(event) {
  // If navigation gets visible: Hide handle immediately
  // If navigation gets hidden using animation: Show handle when animation ends
  if (this.desktop.navigationVisible) {
    this.updateNavigationHandleVisibility();
  }
};

scout.DesktopBench.prototype._onDesktopNavigationHandleVisibleChange = function(event) {
  this.updateNavigationHandleVisibility();
};

scout.DesktopBench.prototype._onDesktopAnimationEnd = function(event) {
  if (!this.desktop.navigationVisible) {
    this.updateNavigationHandleVisibility();
  }
};

scout.DesktopBench.prototype._onDesktopPropertyChange = function(event) {
  if (event.changedProperties.indexOf('navigationVisible') !== -1) {
    this._onDesktopNavigationVisibleChange();
  } else if (event.changedProperties.indexOf('navigationHandleVisible') !== -1) {
    this._onDesktopNavigationHandleVisibleChange();
  }
};

scout.DesktopBench.prototype._onNavigationHandleAction = function(event) {
  this.desktop.enlargeNavigation();
};

scout.DesktopBench.prototype._revalidateSplitters = function() {
  // remove old splitters
  if (this.components) {
    this.components.forEach(function(comp) {
      if (comp instanceof scout.Splitter) {
        comp.destroy();
      }
    });
  }
  var splitterParent = this;
  this.components = this.columns.filter(function(column) {
    return column.hasViews();
  }).reduce(function(arr, col) {
    if (arr.length > 0) {
      // add sep
      var splitter = scout.create('Splitter', {
        parent: splitterParent,
        $anchor: arr[arr.length - 1].$container,
        $root: splitterParent.$container,
        maxRatio: 1
      });
      splitter.render(splitterParent.$container);
      splitter.$container.addClass('line');
      splitter.on('move', splitterParent._onSplitterMove.bind(splitterParent));
      splitter.on('positionChanged', splitterParent._onSplitterPositionChanged.bind(splitterParent));
      arr.push(splitter);
    }
    arr.push(col);
    return arr;
  }, []);
  // well order the dom elements (reduce is used for simple code reasons, the result of reduce is not of interest).
  this.components.filter(function(comp) {
      return comp instanceof scout.BenchColumn;
    })
    .reduce(function(c1, c2, index) {
      if (index > 0) {
        c2.$container.insertAfter(c1.$container);
      }
      return c2;
    }, undefined);

};

scout.DesktopBench.prototype._onSplitterMove = function(event) {
  var splitterIndex = this.components.indexOf(event.source);
  if (splitterIndex > 0 /*cannot be 0 since first element is a BenchColumn*/ ) {
    var $before = this.components[splitterIndex - 1].$container,
      $after = this.components[splitterIndex + 1].$container,
      diff = event.position - event.source.position;

    if (($before.width() + diff) < scout.DesktopBench.VIEW_MIN_WIDTH) {
      // set to min
      event.setPosition($before.position().left + scout.DesktopBench.VIEW_MIN_WIDTH);
    }
    if (($after.position().left + $after.width() - event.position) < scout.DesktopBench.VIEW_MIN_WIDTH) {
      event.setPosition($after.position().left + $after.width() - scout.DesktopBench.VIEW_MIN_WIDTH);
    }
  }
};

scout.DesktopBench.prototype._onSplitterPositionChanged = function(event) {
  this.revalidateLayout();
};

scout.DesktopBench.prototype._onViewAdded = function(event) {
  this.trigger('viewAdded', {
    view: event.view
  });
};

scout.DesktopBench.prototype._onViewRemoved = function(event) {
  this.trigger('viewRemoved', {
    view: event.view
  });
};

scout.DesktopBench.prototype._onViewActivated = function(event) {
  var view = event.view;
  if (this.outlineContent === view) {
    this.desktop.bringOutlineToFront(this.desktop.outline);
  }
  this.trigger('viewActivated', {
    view: view
  });
};

scout.DesktopBench.prototype._onViewDeactivated = function(event) {
  if (this.outlineContent === event.view) {
    this.desktop.sendOutlineToBack();
  }
  this.trigger('viewDeactivated', {
    view: event.view
  });
};

scout.DesktopBench.prototype.addView = function(view, activate) {
  // normalize displayViewId
  switch (view.displayViewId) {
    case 'NW':
    case 'W':
    case 'SW':
    case 'N':
    case 'C':
    case 'S':
    case 'NE':
    case 'E':
    case 'SE':
      break;
    default:
      // map all other displayViewIds to center
      view.displayViewId = 'C';
      break;
  }
  var column = this._getColumn(view.displayViewId);
  this.tabBoxMap[view.id] = column;
  column.addView(view, activate);

  if (this.rendered) {
    if (column.viewCount() === 1) {
      this._renderColumn(column);
      this._revalidateSplitters();
      this.htmlComp.invalidateLayoutTree();
      // Layout immediate to prevent 'laggy' form visualization,
      // but not initially while desktop gets rendered because it will be done at the end anyway
      this.htmlComp.validateLayoutTree();
    }
  }
};

scout.DesktopBench.prototype.activateView = function(view) {
  var column = this._getColumn(view.displayViewId);
  if (column) {
    column.activateView(view);
  }
};

scout.DesktopBench.prototype._getColumn = function(displayViewId) {
  var column;

  switch (displayViewId) {
    case 'NW':
    case 'W':
    case 'SW':
      column = this.columns[scout.DesktopBench.VIEW_AREA_COLUMN_INDEX.LEFT];
      break;
    case 'NE':
    case 'E':
    case 'SE':
      column = this.columns[scout.DesktopBench.VIEW_AREA_COLUMN_INDEX.RIGHT];
      break;
    default:
      column = this.columns[scout.DesktopBench.VIEW_AREA_COLUMN_INDEX.CENTER];
      break;
  }
  return column;
};

scout.DesktopBench.prototype.removeView = function(view, showSiblingView) {
  var column = this.tabBoxMap[view.id];
  if (column) {
    this._removeViewInProgress++;
    column.removeView(view, showSiblingView);
    this._removeViewInProgress--;
    delete this.tabBoxMap[view.id];
    // remove if empty
    if (this.rendered && column.viewCount() === 0 && this._removeViewInProgress === 0) {
      column.remove();
      this._revalidateSplitters(true);
      this.htmlComp.invalidateLayoutTree();
      // Layout immediate to prevent 'laggy' form visualization,
      // but not initially while desktop gets rendered because it will be done at the end anyway
      this.htmlComp.validateLayoutTree();
    }
  }
};

scout.DesktopBench.prototype.getComponents = function() {
  return this.components;
};

scout.DesktopBench.prototype.getTabBox = function(displayViewId) {
  var viewColumn = this._getColumn(displayViewId);
  if (!viewColumn) {
    return;
  }
  return viewColumn.getTabBox(displayViewId);
};

scout.DesktopBench.prototype.getViews = function(displayViewId) {
  return this.columns.reduce(function(arr, column) {
    scout.arrays.pushAll(arr, column.getViews(displayViewId));
    return arr;
  }, []);
};

scout.DesktopBench.prototype.getViewTab = function(view) {
  var viewTab;
  this.getTabs().some(function(vt) {
    if (vt.view === view) {
      viewTab = vt;
      return true;
    }
    return false;
  });
  return viewTab;
};

scout.DesktopBench.prototype.getTabs = function() {
  var tabs = [];
  // consider right order
  tabs = tabs.concat(this.getTabBox('NW').getController().getTabs());
  tabs = tabs.concat(this.getTabBox('W').getController().getTabs());
  tabs = tabs.concat(this.getTabBox('SW').getController().getTabs());
  tabs = tabs.concat(this.getTabBox('N').getController().getTabs());
  if (this.headerTabAreaController) {
    tabs = tabs.concat(this.headerTabAreaController.getTabs());
  } else {
    tabs = tabs.concat(this.getTabBox('C').getController().getTabs());
  }
  tabs = tabs.concat(this.getTabBox('S').getController().getTabs());
  tabs = tabs.concat(this.getTabBox('NE').getController().getTabs());
  tabs = tabs.concat(this.getTabBox('E').getController().getTabs());
  tabs = tabs.concat(this.getTabBox('SE').getController().getTabs());
  return tabs;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopBenchLayout = function(bench) {
  scout.DesktopBenchLayout.parent.call(this);
  this.bench = bench;
  this.containerSize;
};
scout.inherits(scout.DesktopBenchLayout, scout.AbstractLayout);

scout.DesktopBenchLayout.prototype.layout = function($container) {
  var
    htmlContainer = this.bench.htmlComp,
    containerSize = htmlContainer.getAvailableSize(),
    components = this.bench.getComponents(),
    layoutBySplitterPosition;

  if (!components) {
    return;
  }
  containerSize = containerSize.subtract(htmlContainer.getInsets());

  layoutBySplitterPosition = components.filter(function(comp) {
    return comp instanceof scout.Splitter;
  }).map(function(splitter) {
    return $.isNumeric(splitter.getPosition()) && $.isNumeric(splitter.getRatio());
  }).reduce(function(b1, b2, index) {
    if (index === 0) {
      return b2;
    }
    return b1 && b2;
  }, false);

  if (!layoutBySplitterPosition) {
    this._layoutInitial(components, containerSize);
  } else if (containerSize.equals(this.containerSize)) {
    this._layoutBySplitterPosition(components, containerSize);
  } else {
    this._layoutByRatio(components, containerSize);
  }

  this.containerSize = containerSize;
};

scout.DesktopBenchLayout.prototype._layoutByRatio = function(components, containerSize) {
  // set positions from ratio
  components.forEach(function(comp) {
    if (comp instanceof scout.Splitter) {
      comp.setPosition(Math.floor(comp.getRatio() * containerSize.width));
    }
  });
  this._layoutBySplitterPosition(components, containerSize);
};

scout.DesktopBenchLayout.prototype._layoutBySplitterPosition = function(components, containerSize) {
  var x = 0;
  components.forEach(function(comp, index) {
    if (!(comp instanceof scout.Splitter)) {
      var bounds = new scout.Rectangle(x, 0, 0, containerSize.height);
      if ((components.length - 1) > index) {
        bounds.width = components[index + 1].position - x;
        x = x + bounds.width;
      } else {
        bounds.width = containerSize.width - x;
      }
      comp.htmlComp.setBounds(bounds);
    }
  });
};

scout.DesktopBenchLayout.prototype._layoutInitial = function(components, containerSize) {
  var columnWidth = containerSize.width;
  var columnCount = components.filter(function(comp) {
    return comp instanceof scout.BenchColumn;
  }).length;
  if (columnCount > 0) {
    columnWidth = containerSize.width / columnCount;
  }
  var x = 0;
  components.forEach(function(comp, index) {
    if (comp instanceof scout.Splitter) {
      comp.setPosition(x, true);
    } else {
      var bounds = new scout.Rectangle(x, 0, columnWidth, containerSize.height);
      comp.htmlComp.setBounds(bounds);
      x = x + columnWidth;
    }
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BenchColumn = function() {
  scout.BenchColumn.parent.call(this);
  this.htmlComp;
  this.tabBoxs = [];
  this._widgetToTabBox = {}; // [key=viewId, value=SimpleTabBox instance]
  this.components;
  this._removeViewInProgress = 0;

  // event listener functions
  this._viewAddedHandler = this._onViewAdded.bind(this);
  this._viewRemovedHandler = this._onViewRemoved.bind(this);
  this._viewActivatedHandler = this._onViewActivated.bind(this);
  this._viewDeactivatedHandler = this._onViewDeactivated.bind(this);
};
scout.inherits(scout.BenchColumn, scout.Widget);

scout.BenchColumn.TAB_BOX_INDEX = {
  TOP: 0,
  CENTER: 1,
  BOTTOM: 2
};

scout.BenchColumn.prototype._init = function(model) {
  scout.BenchColumn.parent.prototype._init.call(this, model);
  this._createTabBoxes();
};

/**
 * Returns a $container used as a bind target for the key-stroke context of the group-box.
 * By default this function returns the container of the form, or when group-box is has no
 * form as a parent the container of the group-box.
 */
scout.BenchColumn.prototype._keyStrokeBindTarget = function() {
  return this.$container;
};

scout.BenchColumn.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('bench-column');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(this._createLayout());
};

scout.BenchColumn.prototype._renderProperties = function() {
  scout.BenchColumn.parent.prototype._renderProperties.call(this);
  this._renderTabBoxs();
  this._revalidateSplitters();
};

scout.BenchColumn.prototype._renderTabBoxs = function() {
  this.tabBoxs.forEach(function(tabBox) {
    if (tabBox.viewCount() > 0) {

      this._renderTabBox(tabBox);
    }
  }.bind(this));

};

scout.BenchColumn.prototype._renderTabBox = function(tabBox) {
  if (!tabBox.rendered) {
    tabBox.render(this.$container);
  }
};

scout.BenchColumn.prototype._remove = function() {
  scout.SimpleTabBox.parent.prototype._remove.call(this);
  if (this.scrollable) {
    scout.scrollbars.uninstall(this.$body);
  }
  this.htmlComp = null;
};

scout.BenchColumn.prototype.postRender = function() {
  this.tabBoxs.forEach(function(tabBox) {
    tabBox.postRender();
  });
};

scout.BenchColumn.prototype._createLayout = function() {
  return new scout.BenchColumnLayout(this);
};

scout.BenchColumn.prototype._onViewAdded = function(event) {
  this.trigger('viewAdded', {
    view: event.view
  });
};

scout.BenchColumn.prototype._onViewRemoved = function(event) {
  this.trigger('viewRemoved', {
    view: event.view
  });
};

scout.BenchColumn.prototype._onViewActivated = function(event) {
  this.trigger('viewActivated', {
    view: event.view
  });
};

scout.BenchColumn.prototype._onViewDeactivated = function(event) {
  this.trigger('viewDeactivated', {
    view: event.view
  });
};

scout.BenchColumn.prototype.activateView = function(view) {
  var tabBox = this.getTabBox(view.displayViewId);
  tabBox.activateView(view);
};

scout.BenchColumn.prototype._createTabBoxes = function() {
  for (var i = 0; i < 3; i++) {
    var tabBox = scout.create('SimpleTabBox', {
      parent: this
    });
    tabBox.on('viewAdded', this._viewAddedHandler);
    tabBox.on('viewRemoved', this._viewRemovedHandler);
    tabBox.on('viewActivated', this._viewActivatedHandler);
    tabBox.on('viewDeactivated', this._viewDeactivatedHandler);
    this.tabBoxs.push(tabBox);
  }
};

scout.BenchColumn.prototype._revalidateSplitters = function(clearPosition) {
  // remove old splitters
  if (this.components) {
    this.components.forEach(function(comp) {
      if (comp instanceof scout.Splitter) {
        comp.destroy();
      }
    });
  }
  var splitterParent = this;
  this.components = this.tabBoxs.filter(function(tabBox) {
    return tabBox.hasViews();
  }).reduce(function(arr, col) {
    if (arr.length > 0) {
      // add sep
      var splitter = scout.create('Splitter', {
        parent: splitterParent,
        $anchor: arr[arr.length - 1].$container,
        $root: splitterParent.$container,
        splitHorizontal: false,
        maxRatio: 1
      });
      splitter.render(splitterParent.$container);
      splitter.$container.addClass('line');
      splitter.on('move', splitterParent._onSplitterMove.bind(splitterParent));
      splitter.on('positionChanged', splitterParent._onSplitterPositionChanged.bind(splitterParent));
      arr.push(splitter);
    }
    arr.push(col);
    return arr;
  }, []);
  // well order the dom elements (reduce is used for simple code reasons, the result of reduce is not of interest).
  this.components.filter(function(comp) {
      return comp instanceof scout.SimpleTabBox;
    })
    .reduce(function(c1, c2, index) {
      if (index > 0) {
        c2.$container.insertAfter(c1.$container);
      }
      return c2;
    }, undefined);
};

scout.BenchColumn.prototype._onSplitterMove = function(event) {
  var splitterIndex = this.components.indexOf(event.source);
  if (splitterIndex > 0 /*cannot be 0 since first element is a SimpleTabBox*/ ) {
    var $before = this.components[splitterIndex - 1].$container,
      $after = this.components[splitterIndex + 1].$container,
      diff = event.position - event.source.position;

    if (($before.outerHeight(true) + diff) < scout.DesktopBench.VIEW_MIN_HEIGHT) {
      // set to min
      event.setPosition($before.position().top + scout.DesktopBench.VIEW_MIN_HEIGHT);
    }
    if (($after.position().top + $after.outerHeight(true) - event.position) < scout.DesktopBench.VIEW_MIN_HEIGHT) {
      event.setPosition($after.position().top + $after.outerHeight(true) - scout.DesktopBench.VIEW_MIN_HEIGHT);
    }
  }
};
scout.BenchColumn.prototype._onSplitterPositionChanged = function() {
  this.revalidateLayout();
};

scout.BenchColumn.prototype.addView = function(view, bringToFront) {
  var tabBox = this.getTabBox(view.displayViewId);
  this._widgetToTabBox[view.id] = tabBox;

  tabBox.addView(view, bringToFront);

  if (this.rendered && tabBox.viewCount() === 1) {
    if (!tabBox.rendered) {
      // lazy render if the first view is added.
      tabBox.render(this.$container);
    }
    this._revalidateSplitters(true);
    this.htmlComp.invalidateLayoutTree();
    // Layout immediate to prevent 'laggy' form visualization,
    // but not initially while desktop gets rendered because it will be done at the end anyway
    this.htmlComp.validateLayoutTree();
  }
};

scout.BenchColumn.prototype.getTabBox = function(displayViewId) {
  var tabBox;
  switch (displayViewId) {
    case 'NW':
    case 'N':
    case 'NE':
      tabBox = this.tabBoxs[scout.BenchColumn.TAB_BOX_INDEX.TOP];
      break;
    case 'SW':
    case 'S':
    case 'SE':
      tabBox = this.tabBoxs[scout.BenchColumn.TAB_BOX_INDEX.BOTTOM];
      break;
    default:
      tabBox = this.tabBoxs[scout.BenchColumn.TAB_BOX_INDEX.CENTER];
      break;
  }
  return tabBox;
};

scout.BenchColumn.prototype.removeView = function(view, showSiblingView) {
  var tabBox = this._widgetToTabBox[view.id];
  if (tabBox) {
    this._removeViewInProgress++;
    tabBox.removeView(view, showSiblingView);
    this._removeViewInProgress--;
    delete this._widgetToTabBox[view.id];
    if (this.rendered && tabBox.viewCount() === 0 && this._removeViewInProgress === 0) {
      // remove view area if no view is left.
      tabBox.remove();
      this._revalidateSplitters(true);
      this.htmlComp.invalidateLayoutTree();
      // Layout immediate to prevent 'laggy' form visualization,
      // but not initially while desktop gets rendered because it will be done at the end anyway
      this.htmlComp.validateLayoutTree();
    }
  }
};

scout.BenchColumn.prototype.viewCount = function() {
  return this.tabBoxs.map(function(tabBox) {
    return tabBox.viewCount();
  }).reduce(function(c1, c2) {
    return c1 + c2;
  }, 0);
};

scout.BenchColumn.prototype.hasViews = function() {
  return this.viewCount() > 0;
};
scout.BenchColumn.prototype.getViews = function(displayViewId) {
  return this.tabBoxs.reduce(function(arr, tabBox) {
    scout.arrays.pushAll(arr, tabBox.getViews(displayViewId));
    return arr;
  }, []);
};

scout.BenchColumn.prototype.getComponents = function() {
  return this.components;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BenchColumnLayout = function(benchColumn) {
  scout.BenchColumnLayout.parent.call(this);
  this.benchColumn = benchColumn;
  this.containerSize;
};
scout.inherits(scout.BenchColumnLayout, scout.AbstractLayout);

scout.BenchColumnLayout.prototype.layout = function($container) {
  var htmlContainer = this.benchColumn.htmlComp,
    containerSize = htmlContainer.getAvailableSize(),
    components = this.benchColumn.getComponents(),
    layoutBySplitterPosition;

  if (!components) {
    return;
  }
  containerSize = containerSize.subtract(htmlContainer.getInsets());
  layoutBySplitterPosition = components.filter(function(comp) {
    return comp instanceof scout.Splitter;
  }).map(function(splitter) {
    return $.isNumeric(splitter.position);
  }).reduce(function(b1, b2, index) {
    if (index === 0) {
      return b2;
    }
    return b1 && b2;
  }, false);

  if (!layoutBySplitterPosition) {
    this._layoutInitial(components, containerSize);
  } else if (containerSize.equals(this.containerSize)) {
    this._layoutBySplitterPosition(components, containerSize);
  } else {
    this._layoutByRatio(components, containerSize);
  }
  this.containerSize = containerSize;

};

scout.BenchColumnLayout.prototype._layoutByRatio = function(components, containerSize) {
  // set positions from ratio
  components.forEach(function(comp) {
    if (comp instanceof scout.Splitter) {
      comp.setPosition(Math.floor(comp.getRatio() * containerSize.height));
    }
  });
  this._layoutBySplitterPosition(components, containerSize);
};

scout.BenchColumnLayout.prototype._layoutBySplitterPosition = function(components, containerSize) {
  var y = 0;
  components.forEach(function(comp, index) {
    if (comp instanceof scout.SimpleTabBox) {
      var bounds = new scout.Rectangle(0, y, containerSize.width, 0);
      if ((components.length - 1) > index) {
        bounds.height = components[index + 1].position - y;
        y = y + bounds.height;
      } else {
        bounds.height = containerSize.height - y;
      }
      comp.htmlComp.setBounds(bounds);
    }
  });
};

scout.BenchColumnLayout.prototype._layoutInitial = function(components, containerSize) {
  var rowHeight = containerSize.height;
  var rowCount = components.filter(function(comp) {
    return comp instanceof scout.SimpleTabBox;
  }).length;
  if (rowCount > 0) {
    rowHeight = containerSize.height / rowCount;
  }
  var y = 0;
  components.forEach(function(comp, index) {
    if (comp instanceof scout.Splitter) {
      comp.setPosition(y, true);
    } else {
      var bounds = new scout.Rectangle(0, y, containerSize.width, rowHeight);
      comp.htmlComp.setBounds(bounds);
      y = y + rowHeight;
    }
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Composite keystroke to provide a numeric keystroke to select view tabs.
 */
scout.DesktopTabSelectKeyStroke = function(desktop) {
  scout.DesktopTabSelectKeyStroke.parent.call(this);
  this.field = desktop;

  // modifier
  this.parseAndSetKeyStroke(desktop.selectViewTabsKeyStrokeModifier);

  // range [1..9]
  this.registerRange(
    scout.keys['1'], // range from
    function() {
      return scout.keys[Math.min(this._viewTabs().length, 9)]; // range to
    }.bind(this)
  );

  // rendering hints
  this.renderingHints.hAlign = scout.hAlign.RIGHT;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    var viewIndex = event.which - scout.keys['1'];
    return this._viewTabs()[viewIndex].$container;
  }.bind(this);
};
scout.inherits(scout.DesktopTabSelectKeyStroke, scout.RangeKeyStroke);

/**
 * @override KeyStroke.js
 */
scout.DesktopTabSelectKeyStroke.prototype._isEnabled = function() {
  var enabled = scout.DesktopTabSelectKeyStroke.parent.prototype._isEnabled.call(this);
  return enabled && this.field.selectViewTabsKeyStrokesEnabled && this._viewTabs().length > 0;
};

/**
 * @override KeyStroke.js
 */
scout.DesktopTabSelectKeyStroke.prototype.handle = function(event) {
  var viewIndex = event.which - scout.keys['1'];

  if (this._viewTabs().length && (viewIndex < this._viewTabs().length)) {
    var viewTab = this._viewTabs()[viewIndex];
    if (this.field.bench) {
      this.field.bench.activateView(viewTab.view);
    }
  }
};

scout.DesktopTabSelectKeyStroke.prototype._viewTabs = function() {
  if (this.field.bench) {
    return this.field.bench.getTabs();
  }
  return [];
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * KeyStroke to prevent the browser from switching between browser tabs.
 *
 * See DisableBrowserTabSwitchingKeyStroke.js where switching between views is implemented, but only up to the current number of open views.
 * That means, that if 3 views are open, ctrl-4 is prevented by this keystroke.
 */
scout.DisableBrowserTabSwitchingKeyStroke = function(desktop) {
  scout.DisableBrowserTabSwitchingKeyStroke.parent.call(this);
  this.field = desktop;

  // modifier
  this.parseAndSetKeyStroke(desktop.selectViewTabsKeyStrokeModifier);

  // range [1..9]
  this.registerRange(
    scout.keys['1'], // range from
    scout.keys['9'] // range to
  );

  // rendering hints
  this.renderingHints.render = false;

  this.preventDefault = true;
};
scout.inherits(scout.DisableBrowserTabSwitchingKeyStroke, scout.RangeKeyStroke);

/**
 * @override KeyStroke.js
 */
scout.DisableBrowserTabSwitchingKeyStroke.prototype._isEnabled = function() {
  var enabled = scout.DisableBrowserTabSwitchingKeyStroke.parent.prototype._isEnabled.call(this);
  return enabled && this.field.selectViewTabsKeyStrokesEnabled;
};

/**
 * @override KeyStroke.js
 */
scout.DisableBrowserTabSwitchingKeyStroke.prototype.handle = function(event) {
  // NOOP
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopHeader = function() {
  scout.DesktopHeader.parent.call(this);
  this.tabArea;
  this._desktopPropertyChangeHandler = this._onDesktopPropertyChange.bind(this);
  this._desktopAnimationEndHandler = this._onDesktopAnimationEnd.bind(this);
  this._outlineContentMenuBarPropertyChangeHandler = this._onOutlineContentMenuBarPropertyChange.bind(this);
};
scout.inherits(scout.DesktopHeader, scout.Widget);

scout.DesktopHeader.prototype._init = function(model) {
  scout.DesktopHeader.parent.prototype._init.call(this, model);
  this.desktop = this.session.desktop;
  this.toolBoxVisible = scout.nvl(model.toolBoxVisible, true);
  this.viewButtonBoxVisible = scout.nvl(model.viewButtonBoxVisible, false);
  this.updateViewButtonBoxVisibility();
  // create view tab box
  this.tabArea = scout.create('SimpleTabArea', {
    parent: this
  });
};

scout.DesktopHeader.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('desktop-header');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.DesktopHeaderLayout(this));
  this._renderViewButtonBoxVisible();
  this._renderViewTabs();
  this._renderToolBoxVisible();
  this._renderLogoUrl();
  this.desktop.on('propertyChange', this._desktopPropertyChangeHandler);
  this.desktop.on('animationEnd', this._desktopAnimationEndHandler);
  if (this.desktop.bench) {
    this.outlineContent = this.desktop.bench.outlineContent;
  }
  this._attachOutlineContentMenuBarHandler();
};

scout.DesktopHeader.prototype._remove = function() {
  this.desktop.off('propertyChange', this._desktopPropertyChangeHandler);
  this.desktop.off('animationEnd', this._desktopAnimationEndHandler);
  this._detachOutlineContentMenuBarHandler();
  this.outlineContent = null;
  scout.DesktopHeader.parent.prototype._remove.call(this);
};

scout.DesktopHeader.prototype._renderViewTabs = function() {
   this.tabArea.render(this.$container);
};

scout.DesktopHeader.prototype._renderToolBox = function() {
  if (this.toolBox) {
    return;
  }
  this.toolBox = scout.create('DesktopToolBox', {
    parent: this,
    menus: this.desktop.menus
  });
  this.toolBox.render(this.$container);
};

scout.DesktopHeader.prototype._removeToolBox = function() {
  if (!this.toolBox) {
    return;
  }
  this.toolBox.destroy();
  this.toolBox = null;
};

scout.DesktopHeader.prototype._renderToolBoxVisible = function() {
  if (this.toolBoxVisible) {
    this._renderToolBox();
  } else {
    this._removeToolBox();
  }
  this.invalidateLayoutTree();
};

scout.DesktopHeader.prototype._renderLogoUrl = function() {
  if (this.logoUrl) {
    this._renderLogo();
  } else {
    this._removeLogo();
  }
  this.invalidateLayoutTree();
};

scout.DesktopHeader.prototype._renderLogo = function() {
  if (!this.logo) {
    this.logo = scout.create('DesktopLogo', {
      parent: this,
      url: this.logoUrl
    });
    this.logo.render(this.$container);
  } else {
    this.logo.setUrl(this.logoUrl);
  }
};

scout.DesktopHeader.prototype._removeLogo = function() {
  if (!this.logo) {
    return;
  }
  this.logo.destroy();
  this.logo = null;
};

scout.DesktopHeader.prototype._renderViewButtonBox = function() {
  if (this.viewButtonBox) {
    return;
  }
  this.viewButtonBox = scout.create('ViewButtonBox', {
    parent: this,
    viewButtons: this.desktop.viewButtons
  });
  this.viewButtonBox.render(this.$container);
  this.viewButtonBox.$container.prependTo(this.$container);
  if (this.desktop.inBackground) {
    this.viewButtonBox.sendToBack();
  }
  this.updateViewButtonStyling();
};

scout.DesktopHeader.prototype._removeViewButtonBox = function() {
  if (!this.viewButtonBox) {
    return;
  }
  this.viewButtonBox.destroy();
  this.viewButtonBox = null;
};

scout.DesktopHeader.prototype._renderViewButtonBoxVisible = function() {
  if (this.viewButtonBoxVisible) {
    this._renderViewButtonBox();
  } else {
    this._removeViewButtonBox();
  }
  this.invalidateLayoutTree();
};

scout.DesktopHeader.prototype.sendToBack = function() {
  if (this.viewButtonBox) {
    this.viewButtonBox.sendToBack();
  }
};

scout.DesktopHeader.prototype.bringToFront = function() {
  if (this.viewButtonBox) {
    this.viewButtonBox.bringToFront();
  }
};

scout.DesktopHeader.prototype.setLogoUrl = function(logoUrl) {
  this.setProperty('logoUrl', logoUrl);
};

scout.DesktopHeader.prototype.setToolBoxVisible = function(visible) {
  this.setProperty('toolBoxVisible', visible);
};

scout.DesktopHeader.prototype.setViewButtonBoxVisible = function(visible) {
  this.setProperty('viewButtonBoxVisible', visible);
};

scout.DesktopHeader.prototype.setMenus = function(menus) {
  if (this.toolBox) {
    this.toolBox.setMenus(menus);
  }
};

scout.DesktopHeader.prototype.updateViewButtonBoxVisibility = function() {
  // View buttons are visible in the header if the navigation is not visible
  // If there are no view buttons at all, don't show the box
  // With displayStyle is set to compact, the view buttons should never be visible in the header
  this.setViewButtonBoxVisible(this.desktop.viewButtons && this.desktop.viewButtons.length > 0 && !this.desktop.navigationVisible && this.desktop.displayStyle !== scout.Desktop.DisplayStyle.COMPACT);
};

scout.DesktopHeader.prototype._attachOutlineContentMenuBarHandler = function() {
  if (!this.outlineContent) {
    return;
  }
  var menuBar = this._outlineContentMenuBar(this.outlineContent);
  if (menuBar) {
    menuBar.on('propertyChange', this._outlineContentMenuBarPropertyChangeHandler);
  }
};

scout.DesktopHeader.prototype._detachOutlineContentMenuBarHandler = function() {
  if (!this.outlineContent) {
    return;
  }
  var menuBar = this._outlineContentMenuBar(this.outlineContent);
  if (menuBar) {
    menuBar.off('propertyChange', this._outlineContentMenuBarPropertyChangeHandler);
  }
};

scout.DesktopHeader.prototype._outlineContentMenuBar = function(outlineContent) {
  if (outlineContent instanceof scout.Form) {
    return outlineContent.rootGroupBox.menuBar;
  }
  return outlineContent.menuBar;
};

scout.DesktopHeader.prototype.updateViewButtonStyling = function() {
  if (!this.viewButtonBoxVisible || !this.desktop.bench || !this.desktop.bench.outlineContentVisible) {
    return;
  }
  var outlineContent = this.desktop.bench.outlineContent;
  if (!outlineContent) {
    // Outline content not available yet (-> needs to be loaded first)
    return;
  }
  var hasMenuBar = false;
  if (outlineContent instanceof scout.Form) {
    var rootGroupBox = outlineContent.rootGroupBox;
    hasMenuBar = rootGroupBox.menuBar && rootGroupBox.menuBarVisible && rootGroupBox.menuBar.visible;
  } else {
    hasMenuBar = outlineContent.menuBar && outlineContent.menuBar.visible;
  }
  this.viewButtonBox.viewTabs.forEach(function(tab) {
    tab.$container.toggleClass('outline-content-has-menubar', !!hasMenuBar);
  }, this);
  this.viewButtonBox.viewMenuTab.$container.toggleClass('outline-content-has-menubar', !!hasMenuBar);
};

scout.DesktopHeader.prototype._onDesktopNavigationVisibleChange = function(event) {
  // If navigation gets visible: Hide view buttons immediately
  // If navigation gets hidden using animation: Show view buttons when animation ends
  if (this.desktop.navigationVisible) {
    this.updateViewButtonBoxVisibility();
  }
};

scout.DesktopHeader.prototype._onDesktopAnimationEnd = function(event) {
  this.updateViewButtonBoxVisibility();
};

scout.DesktopHeader.prototype.onBenchOutlineContentChange = function(content) {
  this._detachOutlineContentMenuBarHandler();
  this.outlineContent = content;
  this.updateViewButtonStyling();
  this._attachOutlineContentMenuBarHandler();
};

scout.DesktopHeader.prototype._onDesktopPropertyChange = function(event) {
  if (event.changedProperties.indexOf('navigationVisible') !== -1) {
    this._onDesktopNavigationVisibleChange();
  }
};

scout.DesktopHeader.prototype._onOutlineContentMenuBarPropertyChange = function(event) {
  if (event.changedProperties.indexOf('visible') !== -1) {
    this.updateViewButtonStyling();
  }
};

/*******************************************************************************

* Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * The {@link {@link scout.HeaderViewTabAreaController}} is used to link the center {@link {@link scout.SimpleTabBox}} (all forms with displayViewId='C')
 * with a {@link {@link scout.SimpleTabArea}} placed in the header.
 * It is an extension of {@link {@link scout.SimpleTabBoxController}}.
 *
 * @see scout.SimpleTabBoxController
 */
scout.HeaderTabBoxController = function(bench, tabArea) {
  this.bench = bench;

  // event listeners
  this._tabBoxChangedHandler = this._onViewsChanged.bind(this);

  scout.HeaderTabBoxController.parent.call(this, bench.getTabBox('C'), tabArea);

  this.tabAreaCenter = bench.getTabBox('C').tabArea;
  this.tabAreaInHeader;

};
scout.inherits(scout.HeaderTabBoxController, scout.SimpleTabBoxController);

scout.HeaderTabBoxController.prototype._installListeners = function() {
  scout.HeaderTabBoxController.parent.prototype._installListeners.call(this);
  this.bench.on('viewAdded', this._tabBoxChangedHandler);
  this.bench.on('viewRemoved', this._tabBoxChangedHandler);
};

scout.HeaderTabBoxController.prototype._onViewsChanged = function() {
  if (this.bench.getViews().some(function(view) {
      return 'C' !== view.displayViewId;
    })) {
    // has views in other view stacks
    this._setViewTabAreaInHeader(false);
  } else {
    // has only views in center
    this._setViewTabAreaInHeader(true);
  }
};

scout.HeaderTabBoxController.prototype._setViewTabAreaInHeader = function(inHeader) {
  if (this.tabAreaInHeader === inHeader) {
    return;
  }
  this.tabAreaInHeader = inHeader;
  this.tabAreaCenter.setVisible(!inHeader);
  this.tabArea.setVisible(inHeader);
};


scout.HeaderTabBoxController.prototype.getTabs = function() {
  if(this.tabAreaInHeader){
    return this.tabArea.getTabs();
  }
  return this.tabAreaCenter.getTabs();

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopHeaderLayout = function(header) {
  scout.DesktopHeaderLayout.parent.call(this);
  this.header = header;
  this.desktop = header.desktop;
};
scout.inherits(scout.DesktopHeaderLayout, scout.AbstractLayout);

/**
 * @override AbstractLayout.js
 */
scout.DesktopHeaderLayout.prototype.layout = function($container) {
  var viewButtonBoxPrefSize, toolBoxPrefSize,
    htmlContainer = this.header.htmlComp,
    containerSize = htmlContainer.getSize(),
    toolBox = this.header.toolBox,
    viewButtonBox = this.header.viewButtonBox,
    tabArea = this.header.tabArea,
    smallTabsPrefSize = tabArea.htmlComp.layout.smallPrefSize(),
    tabsPrefSize = tabArea.htmlComp.getPreferredSize(),
    tabsWidth = 0, // = available width for tabs
    logoWidth = 0,
    viewButtonBoxWidth = 0,
    toolBoxWidth = 0;

  containerSize = containerSize.subtract(htmlContainer.getInsets());

  if (this.header.logo) {
    logoWidth = scout.graphics.getSize(this.header.logo.$container, true).width;
  }

  if (viewButtonBox) {
    viewButtonBoxPrefSize = viewButtonBox.htmlComp.getPreferredSize();
    viewButtonBoxWidth = viewButtonBoxPrefSize.width;
    viewButtonBox.htmlComp.setSize(viewButtonBoxPrefSize.subtract(viewButtonBox.htmlComp.getMargins()));
  }
  tabArea.htmlComp.$comp.cssLeft(viewButtonBoxWidth);

  if (toolBox) {
    toolBoxPrefSize = toolBox.htmlComp.getPreferredSize();
    toolBoxWidth = toolBoxPrefSize.width;
    setToolBoxSize();
    setToolBoxLocation();
  }

  tabsWidth = calcTabsWidth();
  if (tabsWidth >= smallTabsPrefSize.width) {
    // All tabs fit when they have small size -> use available size but max the pref size -> prefSize = size of maximumtabs if tabs use their large (max) size
    tabsWidth = Math.min(tabsPrefSize.width, tabsWidth);
    tabArea.htmlComp.setSize(new scout.Dimension(tabsWidth, tabsPrefSize.height));
    return;
  }

  // 1st try to minimize padding around tool-bar items -> compact mode
  if (toolBox) {
    toolBoxPrefSize = toolBox.htmlComp.layout.compactPrefSize();
    toolBoxWidth = toolBoxPrefSize.width;
    setToolBoxSize();
    setToolBoxLocation();
  }

  tabsWidth = calcTabsWidth();
  if (tabsWidth >= smallTabsPrefSize.width) {
    tabArea.htmlComp.setSize(smallTabsPrefSize);
    setTabsSize();
    return;
  }

  // 2nd remove text from tool-bar items, only show icon
  if (toolBox) {
    toolBoxPrefSize = toolBox.htmlComp.layout.shrinkPrefSize();
    toolBoxWidth = toolBoxPrefSize.width;
    setToolBoxSize();
    setToolBoxLocation();
  }

  tabsWidth = calcTabsWidth();
  tabsWidth = Math.min(smallTabsPrefSize.width, tabsWidth);
  // Ensure minimum with for the the overflow menu - expect if there are no tabs at all (in that case ensure min width of 0)
  tabsWidth = Math.max(tabsWidth, (tabArea.tabs.length ? scout.SimpleTabAreaLayout.OVERFLOW_MENU_WIDTH : 0));
  setTabsSize();

  // 3rd if only the overflow menu is shown make toolBox smaller so that ellipsis may be displayed
  if (toolBox && tabsWidth <= scout.SimpleTabAreaLayout.OVERFLOW_MENU_WIDTH) {
    // layout toolBox, now an ellipsis menu may be shown
    toolBoxWidth = containerSize.width - tabsWidth - logoWidth - viewButtonBoxWidth;
    setToolBoxSize();

    // update size of the toolBox again with the actual width to make it correctly right aligned
    toolBoxWidth = toolBox.htmlComp.layout.actualPrefSize().width;
    setToolBoxSize();
    setToolBoxLocation();
  }

  function calcTabsWidth() {
    return containerSize.width - toolBoxWidth - logoWidth - viewButtonBoxWidth;
  }

  function setTabsSize() {
    tabArea.htmlComp.setSize(new scout.Dimension(tabsWidth, tabsPrefSize.height));
  }

  function setToolBoxSize() {
    toolBox.htmlComp.setSize(new scout.Dimension(toolBoxWidth, toolBoxPrefSize.height).subtract(toolBox.htmlComp.getMargins()));
  }

  function setToolBoxLocation() {
    var horizontalAlignment = scout.nvl(toolBox.horizontalAlignment, 1);
    if (horizontalAlignment === 1) {
      toolBox.htmlComp.$comp.cssLeft(containerSize.width - toolBoxWidth - logoWidth);
    } else {
      toolBox.htmlComp.$comp.cssLeft(0);
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopNavigation = function() {
  scout.DesktopNavigation.parent.call(this);
  this.$container;
  this.$body;
  this.viewButtonBox;
  this._outlinePropertyChangeHandler = this._onOutlinePropertyChange.bind(this);
  this._desktopPropertyChangeHandler = this._onDesktopPropertyChange.bind(this);
};
scout.inherits(scout.DesktopNavigation, scout.Widget);

scout.DesktopNavigation.DEFAULT_STYLE_WIDTH; // Configured in sizes.css
scout.DesktopNavigation.BREADCRUMB_STYLE_WIDTH; // Configured in sizes.css
scout.DesktopNavigation.MIN_WIDTH; // Configured in sizes.css

scout.DesktopNavigation.prototype._init = function(model) {
  scout.DesktopNavigation.parent.prototype._init.call(this, model);
  scout.DesktopNavigation.MIN_WIDTH = $.pxToNumber(scout.styles.get('desktop-navigation', 'min-width').minWidth);
  scout.DesktopNavigation.DEFAULT_STYLE_WIDTH = $.pxToNumber(scout.styles.get('desktop-navigation', 'width').width);
  scout.DesktopNavigation.BREADCRUMB_STYLE_WIDTH = $.pxToNumber(scout.styles.get('desktop-navigation-breadcrumb', 'width').width);
  this.desktop = this.parent;
  this.layoutData = model.layoutData || {};
  this.toolBoxVisible = scout.nvl(model.toolBoxVisible, false);
  this.updateHandleVisibility();
  this._syncOutline(model.outline);
};

scout.DesktopNavigation.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('desktop-navigation');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.DesktopNavigationLayout(this));
  this.htmlComp.layoutData = this.layoutData;

  this.$body = this.$container.appendDiv('navigation-body')
    .on('mousedown', this._onNavigationBodyMousedown.bind(this));
  this.htmlCompBody = scout.HtmlComponent.install(this.$body, this.session);
  this.htmlCompBody.setLayout(new scout.SingleLayout());

  this.desktop.on('propertyChange', this._desktopPropertyChangeHandler);
};

scout.DesktopNavigation.prototype._remove = function() {
  this.desktop.off('propertyChange', this._desktopPropertyChangeHandler);
  scout.DesktopNavigation.parent.prototype._remove.call(this);
};

scout.DesktopNavigation.prototype._renderProperties = function() {
  scout.DesktopNavigation.parent.prototype._renderProperties.call(this);
  this._renderViewButtonBox();
  this._renderToolBoxVisible();
  this._renderOutline();
  this._renderHandleVisible();
};

scout.DesktopNavigation.prototype._renderViewButtonBox = function() {
  if (this.desktop.viewButtons.length === 0) {
    return;
  }

  this.viewButtonBox = scout.create('ViewButtonBox', {
    parent: this,
    viewButtons: this.desktop.viewButtons
  });
  this.viewButtonBox.render(this.$container);
};

scout.DesktopNavigation.prototype._removeOutline = function() {
  if (!this.outline) {
    return;
  }
  this.outline.remove();
};

scout.DesktopNavigation.prototype._renderOutline = function() {
  if (!this.outline) {
    return;
  }
  this.outline.render(this.$body);
  this.outline.invalidateLayoutTree();
  // Layout immediate to prevent flickering when breadcrumb mode is enabled
  // but not initially while desktop gets rendered because it will be done at the end anyway
  if (this.rendered) {
    this.outline.validateLayoutTree();
    this.outline.validateFocus();
  }
};

scout.DesktopNavigation.prototype.setOutline = function(outline) {
  this.setProperty('outline', outline);
};

scout.DesktopNavigation.prototype._syncOutline = function(outline) {
  var currentDisplayStyle;
  if (this.outline) {
    currentDisplayStyle = this.outline.displayStyle;
  }
  if (this.rendered) {
    this._removeOutline();
  }
  this.outline = outline;
  if (this.outline) {
    this.outline.setParent(this);
    this.outline.setBreadcrumbTogglingThreshold(scout.DesktopNavigation.BREADCRUMB_STYLE_WIDTH);
    // Make sure new outline uses same display style as old
    if (currentDisplayStyle && this.outline.autoToggleBreadcrumbStyle) {
      this.outline.setDisplayStyle(currentDisplayStyle);
    }
    this.outline.inBackground = this.desktop.inBackground;
    this.outline.on('propertyChange', this._outlinePropertyChangeHandler);
    this._updateHandle();
  }
};

scout.DesktopNavigation.prototype.sendToBack = function() {
  if(this.viewButtonBox){
    this.viewButtonBox.sendToBack();
  }
  if (this.outline) {
    this.outline.sendToBack();
  }
};

scout.DesktopNavigation.prototype.bringToFront = function() {
  if(this.viewButtonBox){
    this.viewButtonBox.bringToFront();
  }
  if (this.outline) {
    this.outline.bringToFront();
  }
};

scout.DesktopNavigation.prototype.setToolBoxVisible = function(toolBoxVisible) {
  this.setProperty('toolBoxVisible', toolBoxVisible);
};

scout.DesktopNavigation.prototype.setHandleVisible = function(visible) {
  this.setProperty('handleVisible', visible);
};

scout.DesktopNavigation.prototype._updateHandle = function() {
  if (this.handle) {
    this.handle.setRightVisible(this.desktop.outlineDisplayStyle() === scout.Tree.DisplayStyle.BREADCRUMB);
  }
};

scout.DesktopNavigation.prototype.updateHandleVisibility = function() {
  // Don't show handle if desktop says handle must not be visible
  this.setHandleVisible(this.desktop.navigationHandleVisible);
};

scout.DesktopNavigation.prototype._renderToolBoxVisible = function() {
  if (this.toolBoxVisible) {
    this._renderToolBox();
  } else {
    this._removeToolBox();
  }
};

scout.DesktopNavigation.prototype._renderToolBox = function() {
  if (this.toolBox) {
    return;
  }
  this.toolBox = scout.create('DesktopToolBox', {
    parent: this,
    menus: this.desktop.menus
  });
  this.toolBox.render(this.$container);
};

scout.DesktopNavigation.prototype._removeToolBox = function() {
  if (!this.toolBox) {
    return;
  }
  this.toolBox.destroy();
  this.toolBox = null;
};

scout.DesktopNavigation.prototype._renderHandleVisible = function() {
  if (this.handleVisible) {
    this._renderHandle();
  } else {
    this._removeHandle();
  }
};

scout.DesktopNavigation.prototype._renderHandle = function() {
  if (this.handle) {
    return;
  }
  this.handle = scout.create('DesktopNavigationHandle', {
    parent: this
  });
  this.handle.render(this.$container);
  this.handle.$container.addClass('navigation-open');
  this.handle.on('action', this._onHandleAction.bind(this));
  this._updateHandle();
};

scout.DesktopNavigation.prototype._removeHandle = function() {
  if (!this.handle) {
    return;
  }
  this.handle.destroy();
  this.handle = null;
};

scout.DesktopNavigation.prototype._onNavigationBodyMousedown = function(event) {
  this.desktop.bringOutlineToFront();
};

scout.DesktopNavigation.prototype._onOutlinePropertyChange = function(event) {
  if (event.changedProperties.indexOf('displayStyle') !== -1) {
    this._updateHandle();
  }
};

scout.DesktopNavigation.prototype._onDesktopPropertyChange = function(event) {
  if (event.changedProperties.indexOf('navigationHandleVisible') !== -1) {
    this.updateHandleVisibility();
  }
};

scout.DesktopNavigation.prototype._onHandleAction = function(event) {
  if (event.left) {
    this.desktop.shrinkNavigation();
  } else {
    this.desktop.enlargeNavigation();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopNavigationHandle = function() {
  scout.DesktopNavigationHandle.parent.call(this);
};
scout.inherits(scout.DesktopNavigationHandle, scout.CollapseHandle);

scout.DesktopNavigationHandle.prototype._initKeyStrokeContext = function() {
  scout.DesktopNavigationHandle.parent.prototype._initKeyStrokeContext.call(this);

  // Bound to desktop
  this.desktopKeyStrokeContext = new scout.KeyStrokeContext();
  this.desktopKeyStrokeContext.invokeAcceptInputOnActiveValueField = true;
  this.desktopKeyStrokeContext.$bindTarget = this.session.desktop.$container;
  this.desktopKeyStrokeContext.$scopeTarget = this.$container;
  this.desktopKeyStrokeContext.registerKeyStroke([
    new scout.ShrinkNavigationKeyStroke(this),
    new scout.EnlargeNavigationKeyStroke(this)
  ]);
};

scout.DesktopNavigationHandle.prototype._render = function($parent) {
  scout.DesktopNavigationHandle.parent.prototype._render.call(this, $parent);
  this.$container.addClass('desktop-navigation-handle');
  this.session.keyStrokeManager.installKeyStrokeContext(this.desktopKeyStrokeContext);
};

scout.DesktopNavigationHandle.prototype._remove = function() {
  scout.DesktopNavigationHandle.parent.prototype._remove.call(this);
  this.session.keyStrokeManager.uninstallKeyStrokeContext(this.desktopKeyStrokeContext);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopNavigationLayout = function(navigation) {
  scout.DesktopNavigationLayout.parent.call(this);
  this.navigation = navigation;
};
scout.inherits(scout.DesktopNavigationLayout, scout.AbstractLayout);

scout.DesktopNavigationLayout.prototype.layout = function($container) {
  var bodySize, viewButtonBoxSize, viewButtonBoxPrefSize,
    htmlContainer = this.navigation.htmlComp,
    containerSize = htmlContainer.getSize(),
    htmlBody = this.navigation.htmlCompBody,
    toolBox = this.navigation.toolBox,
    viewButtonBox = this.navigation.viewButtonBox,
    viewButtonBoxHeight = 0,
    viewButtonBoxWidth = 0;

  containerSize = containerSize.subtract(htmlContainer.getInsets());

  if (viewButtonBox) {
    viewButtonBoxPrefSize = viewButtonBox.htmlComp.getPreferredSize();
    viewButtonBoxHeight = viewButtonBoxPrefSize.height;
    viewButtonBoxWidth = containerSize.width;
    if (toolBox) {
      viewButtonBoxWidth = viewButtonBoxPrefSize.width;
    }

    viewButtonBoxSize = new scout.Dimension(viewButtonBoxWidth, viewButtonBoxHeight)
      .subtract(viewButtonBox.htmlComp.getMargins());
    viewButtonBox.htmlComp.setSize(viewButtonBoxSize);
  }

  if (toolBox) {
    toolBox.$container.cssLeft(viewButtonBoxWidth);
    toolBox.htmlComp.setSize(new scout.Dimension(containerSize.width - viewButtonBoxWidth, viewButtonBoxHeight));
  }

  bodySize = new scout.Dimension(containerSize.width, containerSize.height - viewButtonBoxHeight)
    .subtract(htmlBody.getMargins());
  htmlBody.setSize(bodySize);
  htmlBody.$comp.cssTop(viewButtonBoxHeight);
};

// FIXME [6.1] BSH Add "options" argument
scout.DesktopNavigationLayout.prototype.preferredLayoutSize = function($container) {
  var htmlContainer = this.navigation.htmlComp,
    htmlBody = this.navigation.htmlCompBody,
    toolBox = this.navigation.toolBox,
    viewButtonBox = this.navigation.viewButtonBox;

  var prefSize = htmlBody.getPreferredSize();

  var prefSizeBoxes = new scout.Dimension(0, 0);
  if (viewButtonBox) {
    var prefSizeViewButtonBox = viewButtonBox.htmlComp.getPreferredSize();
    prefSizeBoxes.width += prefSizeViewButtonBox.width;
    prefSizeBoxes.height = Math.max(prefSizeBoxes.height, prefSizeViewButtonBox.height);
  }
  if (toolBox) {
    var prefSizeToolBox = toolBox.htmlComp.getPreferredSize();
    prefSizeBoxes.width += prefSizeToolBox.width;
    prefSizeBoxes.height = Math.max(prefSizeBoxes.height, prefSizeToolBox.height);
  }

  prefSize.height += prefSizeBoxes.height;
  prefSize.width = Math.max(prefSize.width, prefSizeBoxes.width);
  prefSize = prefSize.add(htmlContainer.getInsets());

  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ShrinkNavigationKeyStroke = function(handle) {
  scout.ShrinkNavigationKeyStroke.parent.call(this);
  this.field = handle;
  this.desktop = handle.session.desktop;
  this.ctrl = true;
  this.which = [scout.keys.ANGULAR_BRACKET];
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.desktop.$container;
  }.bind(this);
};
scout.inherits(scout.ShrinkNavigationKeyStroke, scout.KeyStroke);

scout.ShrinkNavigationKeyStroke.prototype._isEnabled = function() {
  var enabled = scout.ShrinkNavigationKeyStroke.parent.prototype._isEnabled.call(this);
  return enabled && this.field.leftVisible;
};

scout.ShrinkNavigationKeyStroke.prototype.handle = function(event) {
  this.desktop.shrinkNavigation();
};

scout.ShrinkNavigationKeyStroke.prototype._postRenderKeyBox = function($drawingArea, $keyBox) {
  var handleOffset, keyBoxLeft, keyBoxTop,
    handle = this.field;

  $keyBox.addClass('navigation-handle-key-box left');

  handleOffset = handle.$left.offsetTo(this.desktop.$container);
  keyBoxLeft = handleOffset.left - $keyBox.outerWidth(true);
  keyBoxTop = handleOffset.top;

  $keyBox.cssLeft(keyBoxLeft)
    .cssTop(keyBoxTop);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.EnlargeNavigationKeyStroke = function(handle) {
  scout.EnlargeNavigationKeyStroke.parent.call(this);
  this.field = handle;
  this.desktop = handle.session.desktop;
  this.ctrl = true;
  this.shift = true;
  this.which = [scout.keys.ANGULAR_BRACKET];
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.desktop.$container;
  }.bind(this);
};
scout.inherits(scout.EnlargeNavigationKeyStroke, scout.KeyStroke);

scout.EnlargeNavigationKeyStroke.prototype._isEnabled = function() {
  var enabled = scout.EnlargeNavigationKeyStroke.parent.prototype._isEnabled.call(this);
  return enabled && this.field.rightVisible;
};

scout.EnlargeNavigationKeyStroke.prototype.handle = function(event) {
  this.desktop.enlargeNavigation();
};

scout.EnlargeNavigationKeyStroke.prototype._postRenderKeyBox = function($drawingArea, $keyBox) {
  var handleOffset, keyBoxLeft, keyBoxTop,
    handle = this.field;

  $keyBox.addClass('navigation-handle-key-box right');

  handleOffset = handle.$right.offsetTo(this.desktop.$container);
  keyBoxLeft = handleOffset.left + handle.$right.outerWidth();
  keyBoxTop = handleOffset.top;

  $keyBox.cssLeft(keyBoxLeft)
    .cssTop(keyBoxTop);
};

scout.DesktopNotification = function() {
  scout.DesktopNotification.parent.call(this);
  this.closable = true;
  this.status = scout.Status.info();
  this.duration;
  this._removeTimeout;
  this._removing = false;
};
scout.inherits(scout.DesktopNotification, scout.Widget);

/**
 * When duration is set to INFINITE, the notification is not removed automatically.
 */
scout.DesktopNotification.INFINITE = -1;

scout.DesktopNotification.prototype._init = function(model) {
  scout.DesktopNotification.parent.prototype._init.call(this, model);
  this.desktop = model.desktop || this.session.desktop;
};

scout.DesktopNotification.prototype._render = function($parent) {
  this.$container = $parent.prependDiv('notification');
  this.$content = this.$container.appendDiv('notification-content');
  this.$messageText = this.$content.appendDiv('notification-message');
  this.$loader = this.$content.appendDiv('notification-loader');

  if (scout.device.supportsCssAnimation()) {
    this.$loader.addClass('animated');
  }
};

scout.DesktopNotification.prototype._remove = function() {
  scout.DesktopNotification.parent.prototype._remove.call(this);
  this._removeCloser();
};

scout.DesktopNotification.prototype._renderProperties = function() {
  scout.DesktopNotification.parent.prototype._renderProperties.call(this);
  this._renderStatus();
  this._renderClosable();
};

scout.DesktopNotification.prototype.setStatus = function(status) {
  this.setProperty('status', status);
};

scout.DesktopNotification.prototype._syncStatus = function(status) {
  if (this.rendered) {
    this._removeStatus();
  }
  this._setProperty('status', status);
};

scout.DesktopNotification.prototype._removeStatus = function() {
  this.$container.removeClass(scout.DesktopNotification.cssClassForSeverity(this.status));
};

scout.DesktopNotification.prototype._renderStatus = function() {
  this.$container.addClass(scout.DesktopNotification.cssClassForSeverity(this.status));
  this._renderMessage();
};

scout.DesktopNotification.prototype._renderMessage = function() {
  var message = scout.nvl(scout.strings.nl2br(this.status.message), '');
  this.$messageText.html(message);
};

/**
 * @override
 */
scout.DesktopNotification.prototype._renderLoading = function() {
  this.$container.toggleClass('loading', this.loading);
  this.$loader.setVisible(this.loading);
};

scout.DesktopNotification.prototype.setClosable = function(closable) {
  this.setProperty('closable', closable);
};

scout.DesktopNotification.prototype._renderClosable = function() {
  this.$content.toggleClass('closable', this.closable);
  if (!this.closable) {
    this._removeCloser();
  } else {
    this._renderCloser();
  }
};

scout.DesktopNotification.prototype._removeCloser = function() {
  if (!this.$closer) {
    return;
  }
  this.$closer.remove();
  this.$closer = null;
};

scout.DesktopNotification.prototype._renderCloser = function() {
  if (this.$closer) {
    return;
  }
  this.$closer = this.$content
    .appendDiv('closer')
    .on('click', this._onCloseIconClick.bind(this));
};

scout.DesktopNotification.prototype._onCloseIconClick = function() {
  this.hide();
};

scout.DesktopNotification.prototype.show = function() {
  var desktop = this.desktop;
  desktop.addNotification(this);
  if (this.duration > 0) {
    this._removeTimeout = setTimeout(desktop.removeNotification.bind(desktop, this), this.duration);
  }
};

scout.DesktopNotification.prototype.hide = function() {
  clearTimeout(this._removeTimeout);
  this.desktop.removeNotification(this);
};

scout.DesktopNotification.prototype.fadeIn = function($parent) {
  this.render($parent);
  var $container = this.$container,
    animationCssClass = 'notification-slide-in';
  $container.addClass(animationCssClass);
  // The timeout used here is in-sync with the animation duration used in DesktopNotification.css
  setTimeout(function() {
    $container.removeClass(animationCssClass);
  }, 300);
};

scout.DesktopNotification.prototype.fadeOut = function(callback) {
  // prevent fadeOut from running more than once (for instance from setTimeout
  // in show and from the click of a user).
  if (this._removing) {
    return;
  }
  this._removing = true;
  var $container = this.$container;
  $container.addClass('notification-fade-out');
  // The timeout used here is in-sync with the animation duration used in DesktopNotification.css
  setTimeout(function() {
    $container.remove();
    if (callback) {
      callback();
    }
  }, 300);
};

scout.DesktopNotification.cssClassForSeverity = function(status) {
  var cssSeverity,
    severity = scout.Status.Severity;

  switch (status.severity) {
    case severity.OK:
      cssSeverity = 'ok';
      break;
    case severity.INFO:
      cssSeverity = 'info';
      break;
    case severity.WARNING:
      cssSeverity = 'warning';
      break;
    case severity.ERROR:
      cssSeverity = 'error';
      break;
  }
  return cssSeverity;
};

scout.OfflineDesktopNotification = function() {
  scout.OfflineDesktopNotification.parent.call(this);
};
scout.inherits(scout.OfflineDesktopNotification, scout.DesktopNotification);

scout.OfflineDesktopNotification.prototype._init = function(model) {
  scout.OfflineDesktopNotification.parent.prototype._init.call(this, model);
  this.closable = false;
  this.duration = scout.DesktopNotification.INFINITE;
  this.status = new scout.Status({
    message: this.session.text('ui.ConnectionInterrupted'),
    severity: scout.Status.Severity.ERROR
  });
};

scout.OfflineDesktopNotification.prototype._render = function($parent) {
  scout.OfflineDesktopNotification.parent.prototype._render.call(this, $parent);
  this.$content.addClass('offline-message');
  this.$messageText.addClass('offline-message-text');
  this.$loader.text(this.session.text('ui.Reconnecting_'));
};

scout.OfflineDesktopNotification.prototype.reconnect = function() {
  this.setLoading(true);
  this.$messageText.hide();
};

scout.OfflineDesktopNotification.prototype.reconnectFailed = function() {
  this.setLoading(false);
  this.$messageText.show();
};

scout.OfflineDesktopNotification.prototype.reconnectSucceeded = function() {
  this.setLoading(false);
  this.setStatus({
    message: this.session.text('ui.ConnectionReestablished'),
    severity: scout.Status.Severity.OK
  });
  this.$messageText.show();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PopupBlockerHandler = function(session) {
  this.session = session;
};

scout.PopupBlockerHandler.prototype.openWindow = function(uri, windowName, windowSpecs) {
  var popup;

  windowSpecs = windowSpecs || 'location=no,toolbar=no,menubar=no,resizable=yes,scrollbars=yes';
  windowName = windowName || 'scout_' + new Date().getTime();

  if (scout.device.browser === scout.Device.Browser.INTERNET_EXPLORER) {
    // Workaround for IE: When in "protected mode", window.open() returns null for external URLs, even when
    // the popup was successfully opened! To check if a popup blocker is active, we first open an empty
    // popup with no URL, which will return null when the popup was blocked. If the popup was successful,
    // we change the location to the target URI.
    popup = window.open('', windowName, windowSpecs);
    if (popup) {
      popup.window.location.href = uri;
    }
  } else {
    // Chrome returns undefined, FF null when popup is blocked
    popup = window.open(uri, windowName, windowSpecs);
  }
  return popup;
};

// Shows a notfication when popup blocker has been detected
scout.PopupBlockerHandler.prototype.showNotification = function(vararg) {
  var notification, linkUrl,
    desktop = this.session.desktop;

  if (typeof vararg === 'string') {
    linkUrl = vararg;
  }

  notification = scout.create('DesktopNotification:PopupBlocker', {
    parent: desktop,
    linkUrl: linkUrl
  });

  if (!linkUrl && $.isFunction(vararg)) {
    notification.on('linkClick', vararg);
  }
  notification.show();
};

scout.PopupBlockerDesktopNotification = function() {
  scout.PopupBlockerDesktopNotification.parent.call(this);
  this.linkUrl;
};
scout.inherits(scout.PopupBlockerDesktopNotification, scout.DesktopNotification);

scout.PopupBlockerDesktopNotification.prototype._init = function(model) {
  scout.PopupBlockerDesktopNotification.parent.prototype._init.call(this, model);
  this.linkText = this.session.text('ui.OpenManually');
  this.closable = true;
  this.duration = scout.DesktopNotification.INFINITE;
  this.status = {
    message: this.session.text('ui.PopupBlockerDetected'),
    severity: scout.Status.Severity.WARN
  };
};

scout.PopupBlockerDesktopNotification.prototype._render = function($parent) {
  scout.PopupBlockerDesktopNotification.parent.prototype._render.call(this, $parent);

  this.$messageText.addClass('popup-blocked-title');
  this.$link = this.$content.appendElement('<a>', 'popup-blocked-link')
    .text(this.linkText)
    .on('click', this._onLinkClick.bind(this));
};

scout.PopupBlockerDesktopNotification.prototype._renderProperties = function() {
  scout.PopupBlockerDesktopNotification.parent.prototype._renderProperties.call(this);
  this._renderLinkUrl();
};

scout.PopupBlockerDesktopNotification.prototype._renderLinkUrl = function() {
  if (this.linkUrl) {
    this.$link.attr('href', this.linkUrl)
      .attr('target', '_blank');
  } else {
    this.$link.removeAttr('href')
      .removeAttr('target');
  }
};

scout.PopupBlockerDesktopNotification.prototype._onLinkClick = function() {
  this.trigger('linkClick');
  this.hide();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopToolBox = function(menuBar) {
  scout.DesktopToolBox.parent.call(this);
};
scout.inherits(scout.DesktopToolBox, scout.MenuBox);

scout.DesktopToolBox.prototype._init = function(options) {
  options.uiMenuCssClass = scout.strings.join(' ', options.uiMenuCssClass, 'desktop-tool-box-item');
  scout.DesktopToolBox.parent.prototype._init.call(this, options);
};

/**
 * @override
 */
scout.DesktopToolBox.prototype._initMenu = function(menu) {
  scout.DesktopToolBox.parent.prototype._initMenu.call(this, menu);
  menu.popupOpeningDirectionX = 'left';
};

/**
 * @override
 */
scout.DesktopToolBox.prototype._render = function($parent) {
  scout.DesktopToolBox.parent.prototype._render.call(this, $parent);
  this.$container.addClass('desktop-tool-box');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ViewButton = function() {
  scout.ViewButton.parent.call(this);
  this.inBackground = false;
};
scout.inherits(scout.ViewButton, scout.Action);

scout.ViewButton.prototype._render = function($parent) {
  if (this._isMenu()) {
    this._renderAsMenuItem($parent);
  } else {
    this._renderAsTab($parent);
  }
};

scout.ViewButton.prototype._renderProperties = function() {
  scout.ViewButton.parent.prototype._renderProperties.call(this);

  this._renderInBackground();
};

scout.ViewButton.prototype._isMenu = function() {
  return this.displayStyle === 'MENU';
};

scout.ViewButton.prototype._isTab = function() {
  return this.displayStyle === 'TAB';
};

scout.ViewButton.prototype._renderAsMenuItem = function($parent) {
  this.$container = $parent.appendDiv('view-menu-item')
    .on('click', this._onMouseEvent.bind(this));
};

scout.ViewButton.prototype._renderAsTab = function($parent) {
  this.$container = $parent.appendDiv('view-button-tab')
    .on('mousedown', this._onMouseEvent.bind(this));
};

/**
 * @override Action.js
 */
scout.ViewButton.prototype._renderText = function() {
  if (this._isMenu()) {
    scout.ViewButton.parent.prototype._renderText.call(this);
  }
};

/**
 * Use a default icon, when view-tab doesn't define one.
 * @override Action.js
 */
scout.ViewButton.prototype._renderIconId = function() {
  if (this._isTab()) {
    this.$container.icon(this.iconId);
  }
};

scout.ViewButton.prototype._renderInBackground = function() {
  this.$container.toggleClass('in-background', this.inBackground);
};

scout.ViewButton.prototype.last = function() {
  this.$container.addClass('last');
};

scout.ViewButton.prototype.sendToBack = function() {
  this.inBackground = true;
  if (this.rendered) {
    this._renderInBackground();
  }
};

scout.ViewButton.prototype.bringToFront = function() {
  this.inBackground = false;
  if (this.rendered) {
    this._renderInBackground();
  }
};

scout.ViewButton.prototype._onMouseEvent = function(event) {
  this.doAction();
};

/**
 * @override Action.js
 */
scout.ViewButton.prototype._createActionKeyStroke = function() {
  return new scout.ViewButtonActionKeyStroke(this);
};

/**
 * ViewButtonActionKeyStroke
 */
scout.ViewButtonActionKeyStroke = function(action) {
  scout.ViewButtonActionKeyStroke.parent.call(this, action);

};
scout.inherits(scout.ViewButtonActionKeyStroke, scout.ActionKeyStroke);

scout.ViewButtonActionKeyStroke.prototype._postRenderKeyBox = function($drawingArea) {
  if (this.field.iconId && this.field._isTab()) {
    var width = $drawingArea.outerWidth();
    var wKeybox = $drawingArea.find('.key-box').outerWidth();
    var leftKeyBox = width / 2 - wKeybox / 2;
    $drawingArea.find('.key-box').css('left', leftKeyBox + 'px');
  }
};

scout.ViewButtonActionKeyStroke.prototype.renderKeyBox = function($drawingArea, event) {
  if (this.field._isMenu()) {
    this.renderingHints.hAlign = scout.hAlign.RIGHT;
  }
  return scout.ViewButtonActionKeyStroke.parent.prototype.renderKeyBox.call(this, $drawingArea, event);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ViewButtonAdapter = function() {
  scout.ViewButtonAdapter.parent.call(this);
};
scout.inherits(scout.ViewButtonAdapter, scout.ActionAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ViewButtonBox = function() {
  scout.ViewButtonBox.parent.call(this);
  this.viewMenuTab;
  this.viewTabs;
  this.viewButtons = [];
  this._desktopOutlineChangedHandler = this._onDesktopOutlineChanged.bind(this);
  this._viewButtonPropertyChangeHandler = this._onViewButtonPropertyChange.bind(this);
  this._addAdapterProperties(['viewButtons']);
};
scout.inherits(scout.ViewButtonBox, scout.Widget);

scout.ViewButtonBox.prototype._init = function(model) {
  scout.ViewButtonBox.parent.prototype._init.call(this, model);
  this.desktop = this.session.desktop;
};

scout.ViewButtonBox.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('view-button-box');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.ViewButtonBoxLayout(this));
  this.viewMenuTab = scout.create('ViewMenuTab', {parent: this,
    viewMenus: this._viewButtons('MENU')
  });
  this.viewMenuTab.render(this.$container);

  this.viewTabs = this._viewButtons('TAB');
  this.viewTabs.forEach(function(viewTab, i) {
    viewTab.render(this.$container);
    if (i === this.viewTabs.length - 1) {
      viewTab.last();
    }
  }, this);

  this._onDesktopOutlineChanged();
  this.viewButtons.forEach(function(viewButton) {
    viewButton.on('propertyChange', this._viewButtonPropertyChangeHandler);
  }, this);
  this.desktop.on('outlineChanged', this._desktopOutlineChangedHandler);
};

scout.ViewButtonBox.prototype._remove = function() {
  this.desktop.off('outlineChanged', this._desktopOutlineChangedHandler);
  this.viewButtons.forEach(function(viewButton) {
    viewButton.off('selected', this._viewButtonPropertyChangeHandler);
  }, this);

  scout.ViewButtonBox.parent.prototype._remove.call(this);
};

scout.ViewButtonBox.prototype._viewButtons = function(displayStyle) {
  var viewButtons = [];
  this.viewButtons.forEach(function(viewButton) {
    if (displayStyle === undefined ||
      displayStyle === viewButton.displayStyle) {
      viewButtons.push(viewButton);
    }
  });
  return viewButtons;
};

scout.ViewButtonBox.prototype.sendToBack = function() {
  this.viewMenuTab.sendToBack();
  this.viewTabs.forEach(function(button) {
    button.sendToBack();
  }, this);
};

scout.ViewButtonBox.prototype.bringToFront = function() {
  this.viewMenuTab.bringToFront();
  this.viewTabs.forEach(function(button) {
    button.bringToFront();
  }, this);
};

/**
 * This method updates the state of the view-menu-tab and the selected state of outline-view-button-box.
 * This method must also work in offline mode.
 */
scout.ViewButtonBox.prototype._onDesktopOutlineChanged = function(event) {
  var outline = this.desktop.outline;
  this._viewButtons().forEach(function(viewTab) {
    if (viewTab instanceof scout.OutlineViewButton) {
      viewTab.onOutlineChanged(outline);
    }
  });
};

scout.ViewButtonBox.prototype._onViewButtonSelected = function(event) {
  // Deselect other togglable view buttons
  this.viewButtons.forEach(function(viewButton) {
    if (viewButton !== event.source && viewButton.isToggleAction()) {
      viewButton.setSelected(false);
    }
  }, this);

  // Inform viewMenu tab about new selection
  this.viewMenuTab.onViewButtonSelected();
};

scout.ViewButtonBox.prototype._onViewButtonPropertyChange = function(event) {
  if (event.changedProperties.indexOf('selected') !== -1) {
    this._onViewButtonSelected(event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ViewButtonBoxLayout = function(viewButtonBox) {
  scout.ViewButtonBoxLayout.parent.call(this);
  this.viewButtonBox = viewButtonBox;
};
scout.inherits(scout.ViewButtonBoxLayout, scout.AbstractLayout);

scout.ViewButtonBoxLayout.prototype.layout = function($container) {
  var htmlComp = this.viewButtonBox.htmlComp,
    containerBounds = htmlComp.getBounds(),
    $visibleTabs = $container.children(':visible'),
    tabCount = $visibleTabs.length,
    tabWidth = (containerBounds.width / tabCount);

  $visibleTabs.each(function() {
    var $tab = $(this);
    // only set width, use css height
    $tab.cssWidth(tabWidth);
  });
};

scout.ViewButtonBoxLayout.prototype.preferredLayoutSize = function($container) {
  // View buttons have an absolute css height set -> useCssSize = true
  return scout.graphics.prefSize($container, {
    useCssSize: true
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Keystroke to open the 'ViewMenuPopup' on 'F2'.
 */
scout.ViewMenuOpenKeyStroke = function(viewMenuTab) {
  scout.ViewMenuOpenKeyStroke.parent.call(this);
  this.field = viewMenuTab;

  this.which = [scout.keys.F2];
  this.stopPropagation = true;

  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.field.$container;
  }.bind(this);
};
scout.inherits(scout.ViewMenuOpenKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.ViewMenuOpenKeyStroke.prototype.handle = function(event) {
  this.field.togglePopup();
};

scout.ViewMenuOpenKeyStroke.prototype._postRenderKeyBox = function($drawingArea) {
  var width = $drawingArea.outerWidth();
  var wKeybox = $drawingArea.find('.key-box').outerWidth();
  var leftKeyBox = width / 2 - wKeybox / 2;
  $drawingArea.find('.key-box').css('left', leftKeyBox + 'px');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Popup menu to switch between outlines.
 */
scout.ViewMenuPopup = function() {
  scout.ViewMenuPopup.parent.call(this);
  this.$tab;
  this.$headBlueprint;
  this.viewMenus;
  this.viewButtonBoxBounds;
  this._tooltip;
  this._addAdapterProperties('viewMenus');
  this._viewMenuDoActionHandler = this._onViewMenuDoAction.bind(this);
};
scout.inherits(scout.ViewMenuPopup, scout.PopupWithHead);

scout.ViewMenuPopup.MAX_MENU_WIDTH = 300;

scout.ViewMenuPopup.prototype._init = function(options) {
  options.focusableContainer = true;
  scout.ViewMenuPopup.parent.prototype._init.call(this, options);

  this.$tab = options.$tab;
  this.$headBlueprint = this.$tab;
  this.viewButtonBoxBounds = options.naviBounds;
};

scout.ViewMenuPopup.prototype._createLayout = function() {
  return new scout.ViewMenuPopupLayout(this);
};

/**
 * @override Popup.js
 */
scout.ViewMenuPopup.prototype._initKeyStrokeContext = function() {
  scout.ViewMenuPopup.parent.prototype._initKeyStrokeContext.call(this);

  scout.menuNavigationKeyStrokes.registerKeyStrokes(this.keyStrokeContext, this, 'view-menu-item');
};

scout.ViewMenuPopup.prototype._render = function($parent) {
  scout.ViewMenuPopup.parent.prototype._render.call(this, $parent);

  this.viewMenus.forEach(function(viewMenu) {
    viewMenu.render(this.$body);
    viewMenu.on('doAction', this._viewMenuDoActionHandler);
  }, this);

  // Add last marker to last visible item
  var lastVisibleMenu = scout.arrays.findFromPrev(this.viewMenus, this.viewMenus.length - 1, function(viewMenu) {
    return viewMenu.visible;
  }, this);
  lastVisibleMenu.$container.addClass('last');

  scout.scrollbars.install(this.$body, {
    parent: this,
    axis: 'y'
  });
};

scout.ViewMenuPopup.prototype._remove = function() {
  this.viewMenus.forEach(function(viewMenu) {
    viewMenu.off('doAction', this._viewMenuDoActionHandler);
  }, this);

  scout.ViewMenuPopup.parent.prototype._remove.call(this);
};

/**
 * @override PopupWithHead.js
 */
scout.ViewMenuPopup.prototype._renderHead = function() {
  scout.ViewMenuPopup.parent.prototype._renderHead.call(this);

  this._copyCssClassToHead('view-button-tab');
  this._copyCssClassToHead('unfocusable');
  this.$head.removeClass('popup-head menu-item');
  this.$head.addClass('view-menu-popup-head');
};

/**
 * @override PopupWithHead.js
 */
scout.ViewMenuPopup.prototype._modifyBody = function() {
  this.$body.removeClass('popup-body');
  this.$body.addClass('view-menu-popup-body');
};

/**
 * @override PopupWithHead.js
 */
scout.ViewMenuPopup.prototype._modifyHeadChildren = function() {
  this.$head.find('.arrow-icon').addClass('menu-open');
};

scout.ViewMenuPopup.prototype.position = function() {
  var pos = this.$tab.offset(),
    headSize = scout.graphics.getSize(this.$tab, true),
    bodyTop = headSize.height;

  scout.graphics.setBounds(this.$head, pos.left, pos.top, headSize.width, headSize.height);

  this.$deco.cssLeft(pos.left);
  this.$deco.cssTop(0);
  this.$deco.cssWidth(headSize.width - 1);

  this.$head.cssTop(-bodyTop);
  this.$body.cssTop(0);
  this.$container.cssMarginTop(headSize.height);

  this.setLocation(new scout.Point(0, 0));
};

scout.ViewMenuPopup.prototype._onViewMenuDoAction = function(event) {
  this.close();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ViewMenuPopupLayout = function(popup) {
  scout.ViewMenuPopupLayout.parent.call(this, popup);
};
scout.inherits(scout.ViewMenuPopupLayout, scout.PopupWithHeadLayout);

scout.ViewMenuPopupLayout.prototype.preferredLayoutSize = function($container) {
  var prefSize = scout.ViewMenuPopupLayout.parent.prototype.preferredLayoutSize.call(this, $container);

  // Always use pref size if it is larger than view button box so that the menu items are fully readable
  if (prefSize.width >= this.popup.viewButtonBoxBounds.width) {
    return prefSize;
  }

  // Otherwise make popup as width as the view button box or MAX_MENU_WIDTH at max
  prefSize.width = Math.min(scout.ViewMenuPopup.MAX_MENU_WIDTH, this.popup.viewButtonBoxBounds.width);
  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Shows a list of view buttons with displayStyle=MENU
 * and shows the title of the active view button, if the view button is one
 * of the view buttons contained in the menu.
 */
scout.ViewMenuTab = function() {
  scout.ViewMenuTab.parent.call(this);
  this.$container;
  this.$arrowIcon; // small "arrow down" icon at the right side of the icon

  this.viewButton = null;
  this.viewMenus = [];
  this.selected = false;
  this.iconId;
  this.inBackground = false;
  this.visible = true;

  this.defaultIconId = scout.icons.OUTLINE;
  this._viewMenuPropertyChangeHandler = this._onViewMenuPropertyChange.bind(this);
  this._addAdapterProperties('viewMenus');
};
scout.inherits(scout.ViewMenuTab, scout.Widget);

scout.ViewMenuTab.prototype._init = function(model) {
  scout.ViewMenuTab.parent.prototype._init.call(this, model);
  this.viewMenus.forEach(function(viewMenu) {
    viewMenu.on('propertyChange', this._viewMenuPropertyChangeHandler);
  }, this);
  this._update();
  this.updateVisibility();
};

scout.ViewMenuTab.prototype._initKeyStrokeContext = function() {
  scout.ViewMenuTab.parent.prototype._initKeyStrokeContext.call(this);

  // Bound to desktop
  this.desktopKeyStrokeContext = new scout.KeyStrokeContext();
  this.desktopKeyStrokeContext.invokeAcceptInputOnActiveValueField = true;
  this.desktopKeyStrokeContext.$bindTarget = this.session.desktop.$container;
  this.desktopKeyStrokeContext.$scopeTarget = this.$container;
  this.desktopKeyStrokeContext.registerKeyStroke([
    new scout.ViewMenuOpenKeyStroke(this)
  ]);
};

/**
 * 1. look for a selected view-button
 * 2. look for any view-button
 * 3. if there is no view-button menu should not be visible
 */
scout.ViewMenuTab.prototype._update = function() {
  var viewButton = this._findSelectedViewButton();
  if (viewButton) {
    this.selected = true;
  } else {
    viewButton = this.viewMenus[0];
    this.selected = false;
  }
  this.viewButton = viewButton;

  // Use iconId from outline view button (defaultIconId as fallback)
  this.iconId = (this.outlineViewButton && this.outlineViewButton.iconId) || this.defaultIconId;
};

scout.ViewMenuTab.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('view-button-tab')
    .unfocusable()
    .on('mousedown', this.togglePopup.bind(this));
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);

  this.$arrowIcon = this.$container
    .appendSpan('arrow-icon')
    .on('mousedown', this.togglePopup.bind(this));

  this.session.keyStrokeManager.installKeyStrokeContext(this.desktopKeyStrokeContext);
};

scout.ViewMenuTab.prototype._remove = function() {
  this.session.keyStrokeManager.uninstallKeyStrokeContext(this.desktopKeyStrokeContext);
  scout.ViewMenuTab.parent.prototype._remove.call(this);
};

scout.ViewMenuTab.prototype._renderProperties = function() {
  scout.ViewMenuTab.parent.prototype._renderProperties.call(this);
  this._renderIconId();
  this._renderSelected();
  this._renderInBackground();
};

/**
 * @override
 */
scout.ViewMenuTab.prototype._renderVisible = function() {
  this.$container.setVisible(this.visible);
  this.invalidateLayoutTree();
};

scout.ViewMenuTab.prototype._renderSelected = function() {
  this.$container.select(this.selected);
  this._updateArrowIconVisibility();
};

scout.ViewMenuTab.prototype._renderIconId = function() {
  this.$container.icon(this.iconId);
};

scout.ViewMenuTab.prototype._renderInBackground = function() {
  this.$container.toggleClass('in-background', this.inBackground);
};

scout.ViewMenuTab.prototype._updateArrowIconVisibility = function() {
  this.$arrowIcon.toggleClass('hidden', !this.selected || this.inBackground);
};

scout.ViewMenuTab.prototype._findSelectedViewButton = function() {
  var viewMenu;
  for (var i = 0; i < this.viewMenus.length; i++) {
    viewMenu = this.viewMenus[i];
    if (viewMenu.selected) {
      return viewMenu;
    }
  }
  return null;
};

/**
 * Toggles the 'view menu popup', or brings the outline content to the front if in background.
 */
scout.ViewMenuTab.prototype.togglePopup = function() {
  if (this.selected) {
    if (this.inBackground) {
      this.session.desktop.bringOutlineToFront(this.viewButton.outline);
    } else {
      // Open or close the popup.
      if (this.popup) {
        this._closePopup();
      } else {
        this._openPopup();
      }
      return false; // menu won't open if we didn't abort the mousedown-event
    }
  } else {
    this.viewButton.doAction();
  }
};

scout.ViewMenuTab.prototype._openPopup = function() {
  if (this.popup) {
    // already open
    return;
  }
  var naviBounds = scout.graphics.bounds(this.$container.parent(), true);
  this.popup = scout.create('ViewMenuPopup', {
    parent: this,
    $tab: this.$container,
    viewMenus: this.viewMenus,
    naviBounds: naviBounds
  });
  // The class needs to be added to the container before the popup gets opened so that the modified style may be copied to the head.
  this.$container.addClass('popup-open');
  this.popup.headText = this.text;
  this.popup.open();
  this.popup.on('remove', function(event) {
    this.$container.removeClass('popup-open');
    this.popup = null;
  }.bind(this));
};

scout.ViewMenuTab.prototype._closePopup = function() {
  if (this.popup) {
    this.popup.close();
  }
};

scout.ViewMenuTab.prototype.setSelected = function(selected) {
  this.setProperty('selected', selected);
};

scout.ViewMenuTab.prototype.setIconId = function(iconId) {
  this.setProperty('iconId', iconId);
};

scout.ViewMenuTab.prototype.updateVisibility = function() {
  this.setVisible(this.viewMenus.some(function(viewMenu) {
    return viewMenu.visible;
  }));
};

scout.ViewMenuTab.prototype.sendToBack = function() {
  this.inBackground = true;
  this._renderInBackground();
  this._renderSelected();
  this._closePopup();
};

scout.ViewMenuTab.prototype.bringToFront = function() {
  this.inBackground = false;
  this._renderInBackground();
  this._renderSelected();
};

scout.ViewMenuTab.prototype._onViewMenuPropertyChange = function(event) {
  if (event.changedProperties.indexOf('visible') !== -1) {
    this.updateVisibility();
  }
};

scout.ViewMenuTab.prototype.onViewButtonSelected = function() {
  var viewButton = this._findSelectedViewButton();
  if (viewButton) {
    // only change if a new viewMenu was selected, otherwise keep old viewButton in order to reselect it when the viewMenu gets selected again
    this.viewButton = viewButton;
    // Use iconId from selected view button or defaultIconId as fallback
    this.setIconId(this.viewButton.iconId || this.defaultIconId);
    this.setSelected(true);
  } else {
    this.setSelected(false);
  }
  this._closePopup();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * This class is used differently in online and JS-only case. In the online case we only have instances
 * of Page in an outline. The server sets the property <code>nodeType</code> which is used to distinct
 * between pages with tables and pages with nodes in some cases. In the JS only case, Page is an abstract
 * class and is never instantiated directly, instead we always use subclasses of PageWithTable or PageWithNodes.
 * Implementations of these classes contain code which loads table data or child nodes.
 *
 * @extends {scout.TreeNode}
 * @class
 * @constructor
 */
scout.Page = function() {
  scout.Page.parent.call(this);

  /**
   * This property is set by the server, see: JsonOutline#putNodeType.
   */
  this.nodeType;
  this.detailTable;
  this.detailTableVisible = true;
  this.detailForm;
  this.detailFormVisible = true;
  this.detailFormVisibleByUi = true

  /**
   * This property contains the class-name of the form to be instantiated, when createDetailForm() is called.
   */
  this.detailFormType = null;
  this.tableStatusVisible = true;
};
scout.inherits(scout.Page, scout.TreeNode);

/**
 * This enum defines a node-type. This is basically used for the online case where we only have instances
 * of scout.Page, but never instances of PageWithTable or PageWithNodes. The server simply sets a nodeType
 * instead.
 *
 * @type {{NODES: string, TABLE: string}}
 */
scout.Page.NodeType = {
  NODES: 'nodes',
  TABLE: 'table'
};

/**
 * Override this function to return a detail form which is displayed in the outline when this page is selected.
 * The default impl. returns null.
 */
scout.Page.prototype.createDetailForm = function() {
  return null;
};

/**
 * @override TreeNode.js
 */
scout.Page.prototype._init = function(model) {
  scout.Page.parent.prototype._init.call(this, model);
  this._internalInitTable();
  this._internalInitDetailForm();
};

scout.Page.prototype._internalInitTable = function() {
  var table = this.detailTable;
  if (table) {
    // this case is used for Scout classic
    table = this.getOutline()._createChild(table);
  } else {
    table = this._createTable();
  }

  if (table) {
    this._initTable(table);
    table.setTableStatusVisible(this.tableStatusVisible);
  }
  this.detailTable = table;
};

scout.Page.prototype._internalInitDetailForm = function() {
  var detailForm = this.detailForm;
  if (detailForm) {
    detailForm = this.getOutline()._createChild(detailForm);
  }
  this.detailForm = detailForm;
};

/**
 * Override this function to create the internal table. Default impl. returns null.
 */
scout.Page.prototype._createTable = function() {
  return null;
};

/**
 * Override this function to initialize the internal (detail) table. Default impl. delegates
 * <code>rowsFiltered</code> events to the outline mediator.
 */
scout.Page.prototype._initTable = function(table) {
  table.on('rowsFiltered', this._onTableRowsFiltered.bind(this));
};

scout.Page.prototype._onTableRowsFiltered = function(event) {
  this.getOutline().mediator.onTableRowsFiltered(event, this);
};

scout.Page.prototype._ensureDetailForm = function() {
  if (this.detailForm) {
    return;
  }
  this.detailForm = this.createDetailForm();
};

// see Java: AbstractPage#pageActivatedNotify
scout.Page.prototype.activate = function() {
  this._ensureDetailForm();
};

// see Java: AbstractPage#pageDeactivatedNotify
scout.Page.prototype.deactivate = function() {
};

/**
 * @returns The tree / outline / parent instance. it's all the same, but it's more
 *     intuitive to work with the 'outline' when we deal with pages.
 */
scout.Page.prototype.getOutline = function() {
  return this.parent;
};

/**
 * @returns {Array} an array of child pages for the given table rows. The order of the returned
 *   child pages will be the same as the order of the rows.
 */
scout.Page.prototype.pagesForTableRows = function(rows) {
  return rows.map(this.pageForTableRow);
};

scout.Page.prototype.pageForTableRow = function(row) {
  if (!row.page) {
    throw new Error('Table-row is not linked to a page');
  }
  return row.page;
};

/**
 * @returns a page parameter object used to pass to newly created child pages. Sets the parent
 *     to our outline instance and adds optional other properties. Typically you'll pass an
 *     object (entity-key or arbitrary data) to a child page.
 */
scout.Page.prototype._pageParam = function(paramProperties) {
  var param = {
    parent: this.getOutline()
  };
  $.extend(param, paramProperties);
  return param;
};

scout.Page.prototype.reloadPage = function () {
  var outline = this.getOutline();
  if (outline) {
    this.loadChildren();
  }
};

/**
 * @static
 */
scout.Page.linkRowWithPage = function(row, page) {
  row.page = page;
  page.row = row;
};

/**
 * @static
 */
scout.Page.unlinkRowWithPage = function(row, page) {
  delete row.page;
  delete page.row;
};
/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PageWithNodes = function() {
  scout.PageWithNodes.parent.call(this);

  this.nodeType = scout.Page.NodeType.NODES;
};
scout.inherits(scout.PageWithNodes, scout.Page);

/**
 * @override Page.js
 */
scout.PageWithNodes.prototype._createTable = function() {
  var nodeColumn = scout.create('Column', {
    index: 0,
    id: 'NodeColumn',
    session: this.session
  });
  var table = scout.create('Table', {
    parent: this.parent,
    id: 'PageWithNodesTable',
    autoResizeColumns: true,
    headerVisible: false,
    columns: [nodeColumn]
  });
  table.on('rowAction', this._onDetailTableRowAction.bind(this));
  return table;
};

scout.PageWithNodes.prototype._onDetailTableRowAction = function(event) {
  var clickedRow = event.source.rowsMap[event.row.id];
  var nodeToSelect = clickedRow.node;
  this.getOutline().selectNode(nodeToSelect);
};

scout.PageWithNodes.prototype._rebuildDetailTable = function(childPages) {
  var table = this.detailTable;
  this._unlinkAllTableRows(table.rows);
  table.deleteAllRows();
  var rows = this._createTableRowsForChildPages(childPages);
  table.insertRows(rows);
};

scout.PageWithNodes.prototype._unlinkAllTableRows = function(rows) {
  rows.forEach(function(row) {
    scout.Page.unlinkRowWithPage(row);
  });
};

scout.PageWithNodes.prototype._createTableRowsForChildPages = function(childPages) {
  return childPages.map(function(childPage) {
    var row = scout.create('TableRow', {
      parent: this.detailTable,
      cells: [childPage.text]}
    );
    scout.Page.linkRowWithPage(row, childPage);
    return row;
  }, this);
};

/**
 * @override TreeNode.js
 */
scout.PageWithNodes.prototype.loadChildren = function() {
  this.childrenLoaded = false;
  return this._createChildPages().done(function(childPages) {
    this._rebuildDetailTable(childPages);
    if (childPages.length > 0) {
      this.getOutline().insertNodes(childPages, this);
    }
    this.childrenLoaded = true;
  }.bind(this));
};

/**
 * Override this method to create child pages for this page. The default impl. returns an empty array.
 * @return {$.Deferred}
 */
scout.PageWithNodes.prototype._createChildPages = function() {
  return $.resolvedDeferred();
};


/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PageWithTable = function() {
  scout.PageWithTable.parent.call(this);

  this.nodeType = scout.Page.NodeType.TABLE;
  this.alwaysCreateChildPage = false;
};
scout.inherits(scout.PageWithTable, scout.Page);

/**
 * @override scout.Page
 */
scout.PageWithTable.prototype._initTable = function(table) {
  scout.PageWithTable.parent.prototype._initTable.call(this, table);
  table.on('rowsDeleted allRowsDeleted', this._onTableRowsDeleted.bind(this));
  table.on('rowsInserted', this._onTableRowsInserted.bind(this));
  table.on('rowAction', this._onTableRowAction.bind(this));
  table.on('rowOrderChanged', this._onTableRowOrderChanged.bind(this));
};

scout.PageWithTable.prototype._onTableRowsDeleted = function(event) {
  if (this.leaf) { // when page is a leaf we do nothing at all
    return;
  }
  var rows = scout.arrays.ensure(event.rows),
    childPages = rows.map(function(row) {
      var childPage = row.page;
      scout.Page.unlinkRowWithPage(row, childPage);
      return childPage;
    }, this);

  this.getOutline().mediator.onTableRowsDeleted(rows, childPages, this);
};

/**
 * We must set childNodeIndex on each created childPage because it is required to
 * determine the order of nodes in the tree.
 */
scout.PageWithTable.prototype._onTableRowsInserted = function(event) {
  if (this.leaf) { // when page is a leaf we do nothing at all
    return;
  }

  var rows = scout.arrays.ensure(event.rows),
    childPages = rows.map(function(row) {
      return this._createChildPageInternal(row);
    }, this);

  this.getOutline().mediator.onTableRowsInserted(rows, childPages, this);
};

scout.PageWithTable.prototype._onTableRowAction = function(event) {
  this.getOutline().mediator.onTableRowAction(event, this);
};

scout.PageWithTable.prototype._onTableRowOrderChanged = function(event) {
  if (event.animating) { // do nothing while row order animation is in progress
    return;
  }
  this.getOutline().mediator.onTableRowOrderChanged(event, this);
};

scout.PageWithTable.prototype._createChildPageInternal = function(row) {
  var childPage = this.createChildPage(row);
  if (childPage === null && this.alwaysCreateChildPage) {
    childPage = this.createDefaultChildPage(row);
  }
  scout.Page.linkRowWithPage(row, childPage);
  return childPage;
};

/**
 * Override this method to return a specific Page instance for the given table-row.
 * The default impl. returns null, which means a AutoLeaftPageWithNodes instance will be created for the table-row.
 */
scout.PageWithTable.prototype.createChildPage = function(row) {
  return null;
};

scout.PageWithTable.prototype.createDefaultChildPage = function(row) {
  return scout.create('AutoLeafPageWithNodes', {
    parent: this.getOutline(),
    row: row
  });
};

/**
 * @override TreeNode.js
 */
scout.PageWithTable.prototype.loadChildren = function() {
  // It's allowed to have no table - but we don't have to load data in that case
  if (!this.detailTable) {
    return $.resolvedDeferred();
  }
  return this.loadTableData();
};

// see Java: AbstractPageWithTable#loadChildren that's where the table is reloaded and the tree is rebuilt, called by AbstractTree#P_UIFacade
scout.PageWithTable.prototype.loadTableData = function () {
  this.detailTable.deleteAllRows();
  return this._loadTableData()
    .done(this._onLoadTableDataDone.bind(this))
    .fail(this._onLoadTableDataFail.bind(this))
    .always(this._onLoadTableDataAlways.bind(this));
};

/**
 * Override this method to load table data (rows to be added to table).
 * This is an asynchronous operation working with a Deferred. When table data load is successful
 * <code>_onLoadTableData(data)</code> will be called. When a failure occurs while loading table
 * data <code>_onLoadTableFail(data)</code> will be called.
 * <p>
 * When you want to return static data you still need a deferred. But you can resolve it
 * immediately. Example code:
 * <code>
 *   var deferred = $.Deferred();
 *   deferred.resolve([{...},{...}]);
 *   return deferred;
 * </code>
 *
 * @return {$.Deferred}
 */
scout.PageWithTable.prototype._loadTableData = function() {
  return $.resolvedDeferred();
};

/**
 * This method is called when table data load is successful. It should transform the table data
 * object to table rows.
 *
 * @param tableData data loaded by <code>_loadTableData</code>
 */
scout.PageWithTable.prototype._onLoadTableDataDone = function(tableData) {
  var rows = this._transformTableDataToTableRows(tableData);
  if (rows && rows.length > 0) {
    this.detailTable.insertRows(rows);
  }
};

scout.PageWithTable.prototype._onLoadTableDataFail = function(error) {
  $.log.error('Failed to load tableData. error=', error);
};

scout.PageWithTable.prototype._onLoadTableDataAlways = function() {
  this.childrenLoaded = true;
};

/**
 * This method converts the loaded table data, which can be any object, into table rows.
 * You must override this method unless tableData is already an array of table rows.
 *
 * @param tableData
 * @returns
 */
scout.PageWithTable.prototype._transformTableDataToTableRows = function(tableData) {
  return tableData;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AutoLeafPageWithNodes = function() {
  scout.AutoLeafPageWithNodes.parent.call(this);

  this.leaf = true;
};
scout.inherits(scout.AutoLeafPageWithNodes, scout.Page);

/**
 * @override Page.js
 */
scout.AutoLeafPageWithNodes.prototype._init = function(model) {
  scout.assertParameter('row', model.row, scout.TableRow);
  scout.AutoLeafPageWithNodes.parent.prototype._init.call(this, model);
  this.text = this.row.cells[0];
};

/*******************************************************************************

* Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SimpleTab = function() {
  scout.SimpleTab.parent.call(this);

  this.title;
  this.subTitle;
  this.iconId;

  this._mouseListener;

  // Container for the _Tab_ (not for the view).
  this.$container;
};
scout.inherits(scout.SimpleTab, scout.Widget);

scout.SimpleTab.prototype._init = function(options) {
  scout.SimpleTab.parent.prototype._init.call(this, options);
  this.title = options.title;
  this.subTitle = options.subTitle;
  this.iconId = options.iconId;
  this.selected = false;
};

scout.SimpleTab.prototype.renderAfter = function($parent, sibling) {
  this.render($parent);
  if (sibling) {
    this.$container.insertAfter(sibling.$container);
  }
};

scout.SimpleTab.prototype._render = function($parent) {
  this.$container = $parent.prependDiv('desktop-view-tab');
  this._mouseListener = this._onMouseDown.bind(this);
  this.$container.on('mousedown', this._mouseListener);
  this._$title = this.$container.appendDiv('title');
  this._$subTitle = this.$container.appendDiv('sub-title');
  this._titlesUpdated();
  this._renderSelection();
  this._cssClassUpdated(this.view.cssClass, null);
};

scout.SimpleTab.prototype._renderSelection = function() {
  if (this.$container) {
    if (this.$container.select() === this.selected) {
      return;
    }
    this.$container.select(this.selected);
  }
};

scout.SimpleTab.prototype.select = function() {
  this.selected = true;
  this._renderSelection();
};

scout.SimpleTab.prototype.deselect = function() {
  this.selected = false;
  this._renderSelection();
};

scout.SimpleTab.prototype._onMouseDown = function(event) {
  this.trigger('tabClicked');
};

scout.SimpleTab.prototype.setTitle = function(title) {
  if (this.title === title) {
    return;
  }
  this._setProperty('title', title);
  this._titlesUpdated();
};

scout.SimpleTab.prototype.setSubTitle = function(subTitle) {
  if (this.subTitle === subTitle) {
    return;
  }
  this.subTitle = subTitle;
  this._setProperty('subTitle', subTitle);
  this._titlesUpdated();
};

scout.SimpleTab.prototype.setIconId = function(iconId) {
  if (this.iconId === iconId) {
    return;
  }
  this._setProperty('iconId', iconId);
  this._titlesUpdated();
};

scout.SimpleTab.prototype._titlesUpdated = function() {
  if (!this.$container) {
    return;
  }

  // Titles
  setTitle(this._$title, this.title);
  setTitle(this._$subTitle, this.subTitle);

  // Icon
  this.$container.icon(this.view.iconId);

  // ----- Helper functions -----

  function setTitle($titleElement, title) {
    $titleElement.textOrNbsp(title);
  }
};

scout.SimpleTab.prototype.getMenuText = function() {
  var text = this.title;
  if (this.subTitle) {
    text += ' (' + this.subTitle + ')';
  }
  return text;
};

/*******************************************************************************

* Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopTab = function() {
  scout.DesktopTab.parent.call(this);

  this.view;

  this._propertyChangeListener = function(event) {
    if (scout.arrays.containsAny(event.changedProperties, ['title'])) {
      this.setTitle(this.view.title);
    } else if (scout.arrays.containsAny(event.changedProperties, ['subTitle'])) {
      this.setSubTitle(this.view.subTitle);
    } else if (scout.arrays.containsAny(event.changedProperties, ['iconId'])) {
      this.setIconId(this.view.iconId);
    } else if (scout.arrays.containsAny(event.changedProperties, ['cssClass'])) {
      this._cssClassUpdated(event.newProperties.cssClass, event.oldProperties.cssClass);
    }
  }.bind(this);

  // FIXME awe: problem ist, dass Widegt#remove prft ob rendered ist
  // im bench mode ist der DesktopTab nicht gerendet, _remove wird
  // darum nicht aufgerufen und das 'remove event vom tab nie getriggert
  this._removeListener = this._onViewRemoved.bind(this);
};

scout.inherits(scout.DesktopTab, scout.SimpleTab);

scout.DesktopTab.prototype._init = function(options) {
  this.view = options.view;
  options.title = this.view.title;
  options.subTitle = this.view.subTitle;
  options.iconId = this.view.iconId;

  scout.DesktopTab.parent.prototype._init.call(this, options);


  this._installListeners();
};

scout.DesktopTab.prototype._installListeners = function() {
  this.view.on('propertyChange', this._propertyChangeListener);
  this.view.on('remove', this._removeListener);
};

scout.DesktopTab.prototype._uninstallListeners = function() {
  this.view.off('propertyChange', this._propertyChangeListener);
  this.view.off('remove', this._removeListener);
};

scout.DesktopTab.prototype._cssClassUpdated = function(cssClass, oldCssClass) {
  if (!this.$container) {
    return;
  }
  this.$container.removeClass(oldCssClass);
  this.$container.addClass(cssClass);
};

/**
 * We cannot not bind the 'remove' event of the view to the remove function
 * of the this tab, because in bench-mode the tab is never rendered
 * and thus the _remove function is never called.
 */
scout.DesktopTab.prototype._onViewRemoved = function() {
  this._uninstallListeners();
  if (this.rendered) {
    this.remove();
  } else {
    this.trigger('remove');
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SimpleTabArea = function() {
  scout.SimpleTabArea.parent.call(this);
  this.tabs = [];
};
scout.inherits(scout.SimpleTabArea, scout.Widget);

scout.SimpleTabArea.prototype._init = function(model) {
  scout.SimpleTabArea.parent.prototype._init.call(this, model);
  this._selectedViewTab;

  this._viewTabSelectionHandler = this._onTabSelection.bind(this);
};

scout.SimpleTabArea.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('simple-tab-area');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.SimpleTabAreaLayout(this));
};

scout.SimpleTabArea.prototype._renderProperties = function() {
  scout.SimpleTabArea.parent.prototype._renderProperties.call(this);
  this._renderTabs();
};

scout.SimpleTabArea.prototype._renderTabs = function() {
  // reverse since tabs rendered without a sibling will be prepended.
  this.tabs.reverse()
    .forEach(function(tab) {
      this._renderTab(tab);
    }.bind(this));
};

scout.SimpleTabArea.prototype._renderTab = function(tab) {
  tab.renderAfter(this.$container);
};

scout.SimpleTabArea.prototype._renderVisible = function() {
  if (this.visible && this.tabs.length > 0) {
    this.attach();
  } else {
    this.detach();
  }
  this.invalidateLayoutTree();
};

scout.SimpleTabArea.prototype._attach = function() {
  this.$parent.prepend(this.$container);
  this.session.detachHelper.afterAttach(this.$container);
  // If the parent was resized while this view was detached, the view has a wrong size.
  this.invalidateLayoutTree(false);
  scout.SimpleTabArea.parent.prototype._attach.call(this);
};

/**
 * @override Widget.js
 */
scout.SimpleTabArea.prototype._detach = function() {
  this.session.detachHelper.beforeDetach(this.$container);
  this.$container.detach();
  scout.SimpleTabArea.parent.prototype._detach.call(this);
  this.invalidateLayoutTree(false);
};

scout.SimpleTabArea.prototype._onTabSelection = function(event) {
  this.selectTab(event.source);
};

scout.SimpleTabArea.prototype.getTabs = function() {
  return this.tabs;
};

scout.SimpleTabArea.prototype.selectTab = function(viewTab) {
  if (this._selectedViewTab === viewTab) {
    return;
  }
  this.deselectTab(this._selectedViewTab);

  this._selectedViewTab = viewTab;
  if (viewTab) {
    // Select the new view tab.
    viewTab.select();
  }
  this.trigger('tabSelected', {
    viewTab: viewTab
  });
};

scout.SimpleTabArea.prototype.deselectTab = function(viewTab) {
  if (!viewTab) {
    return;
  }
  if (this._selectedViewTab !== viewTab) {
    return;
  }
  this._selectedViewTab.deselect();

};

scout.SimpleTabArea.prototype.getSelectedTab = function() {
  return this._selectedViewTab;
};

scout.SimpleTabArea.prototype.addTab = function(tab, sibling) {
  var insertPosition = -1;
  if (sibling) {
    insertPosition = this.tabs.indexOf(sibling);
  }
  this.tabs.splice(insertPosition + 1, 0, tab);
  tab.on('tabClicked', this._viewTabSelectionHandler);
  if (this.rendered) {
    this._renderVisible();
    tab.renderAfter(this.$container, sibling);
    this.invalidateLayoutTree();
  }
};

scout.SimpleTabArea.prototype.destroyTab = function(tab) {
  var index = this.tabs.indexOf(tab);
  if (index > -1) {
    this.tabs.splice(index, 1);
    tab.destroy();
    tab.off('tabClicked', this._viewTabSelectionHandler);
    this._renderVisible();
    this.invalidateLayoutTree();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SimpleTabAreaLayout = function(tabArea) {
  scout.SimpleTabAreaLayout.parent.call(this);
  this.tabArea = tabArea;
  this._$overflowTab;
  this._overflowTabsIndizes = [];
};
scout.inherits(scout.SimpleTabAreaLayout, scout.AbstractLayout);

scout.SimpleTabAreaLayout.TAB_WIDTH_LARGE = 220;
scout.SimpleTabAreaLayout.TAB_WIDTH_SMALL = 130;
scout.SimpleTabAreaLayout.OVERFLOW_MENU_WIDTH = 30;

/**
 * @override AbstractLayout.js
 */
scout.SimpleTabAreaLayout.prototype.layout = function($container) {
  var tabWidth,
    htmlContainer = this.tabArea.htmlComp,
    containerSize = htmlContainer.getSize(),
    $tabs = htmlContainer.$comp.find('.desktop-view-tab'),
    numTabs = this.tabArea.getTabs().length,
    smallPrefSize = this.smallPrefSize();

  containerSize = containerSize.subtract(htmlContainer.getInsets());

  // reset tabs and tool-items
  if (this._$overflowTab) {
    this._$overflowTab.remove();
  }

  $tabs.setVisible(true);
  this._overflowTabsIndizes = [];

  // All tabs in container
  if (smallPrefSize.width <= containerSize.width) {
    tabWidth = Math.min(scout.SimpleTabAreaLayout.TAB_WIDTH_LARGE, Math.floor(containerSize.width / numTabs));
    // 2nd - all Tabs fit when they have small size
    $tabs.each(function() {
      $(this).outerWidth(tabWidth);
    });
    return;
  }

  // Not all tabs fit in container -> put tabs into overflow menu
  containerSize.width -= scout.SimpleTabAreaLayout.OVERFLOW_MENU_WIDTH;

  // check how many tabs fit into remaining containerSize.width
  var numVisibleTabs = Math.floor(containerSize.width / scout.SimpleTabAreaLayout.TAB_WIDTH_SMALL),
    numOverflowTabs = numTabs - numVisibleTabs;

  var i = 0,
    selectedIndex = 0;
  $tabs.each(function() {
    if ($(this).hasClass('selected')) {
      selectedIndex = i;
    }
    i++;
  });

  // determine visible range
  var rightEnd, leftEnd = selectedIndex - Math.floor(numVisibleTabs / 2);
  if (leftEnd < 0) {
    leftEnd = 0;
    rightEnd = numVisibleTabs - 1;
  } else {
    rightEnd = leftEnd + numVisibleTabs - 1;
    if (rightEnd > numTabs - 1) {
      rightEnd = numTabs - 1;
      leftEnd = rightEnd - numVisibleTabs + 1;
    }
  }

  this._$overflowTab = htmlContainer.$comp
    .appendDiv('overflow-tab-item')
    .on('mousedown', this._onMouseDownOverflow.bind(this));
  if (numOverflowTabs > 1) {
    this._$overflowTab.appendDiv('num-tabs').text(numOverflowTabs);
  }

  var that = this;
  tabWidth = scout.SimpleTabAreaLayout.TAB_WIDTH_SMALL;
  i = 0;
  $tabs.each(function() {
    if (i >= leftEnd && i <= rightEnd) {
      $(this).outerWidth(tabWidth);
    } else {
      $(this).setVisible(false);
      that._overflowTabsIndizes.push(i);
    }
    i++;
  });
};

scout.SimpleTabAreaLayout.prototype.smallPrefSize = function() {
  var numTabs = this.tabArea.getTabs().length;
  return new scout.Dimension(numTabs * scout.SimpleTabAreaLayout.TAB_WIDTH_SMALL, this.tabArea.htmlComp.$comp.outerHeight(true));
};

scout.SimpleTabAreaLayout.prototype.preferredLayoutSize = function($container) {
  var numTabs = this.tabArea.getTabs().length;
  return new scout.Dimension(numTabs * scout.SimpleTabAreaLayout.TAB_WIDTH_LARGE, scout.graphics.prefSize(this.tabArea.htmlComp.$comp, {
    includeMargin: true,
    useCssSize: true
  }).height);
};

scout.SimpleTabAreaLayout.prototype._onMouseDownOverflow = function(event) {
  var menu, tab, popup,
    tabArea = this.tabArea,
    overflowMenus = [];

  this._overflowTabsIndizes.forEach(function(i) {
    // FIXME awe: fix bugs in overflow-menu:
    // - 1. menu schliesst nicht
    // - 2. manchmal verschwindet ein (noch offener) Tab - wenn nur einer sichtbar ist
    // - 3. add selenium tests
    tab = this.tabArea.getTabs()[i];
    menu = scout.create('Menu', {
      parent: this.tabArea,
      text: tab.getMenuText(),
      tab: tab
    });
    menu.on('doAction', function() {
      $.log.debug('(SimpleTabAreaLayout#_onMouseDownOverflow) tab=' + this);
      tabArea.selectTab(this);
    }.bind(tab));
    overflowMenus.push(menu);
  }, this);

  popup = scout.create('ContextMenuPopup', {
    parent: this.tabArea,
    menuItems: overflowMenus,
    cloneMenuItems: false,
    location: {
      x: event.pageX,
      y: event.pageY
    }
  });
  popup.open();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DetailTableTreeFilter = function() { //
};

/**
 * Must correspond with logic in P_TableFilterBasedTreeNodeFilter
 */
scout.DetailTableTreeFilter.prototype.accept = function(node) {
  if (!node.parentNode) {
    // top level nodes may not be filtered
    return true;
  }
  if (!node.parentNode.filterAccepted) {
    // hide node if parent node is hidden
    return false;
  }
  if (!node.parentNode.detailTable) {
    // if parent has no detail table, node.row won't be set
    // detailTable may be undefined if node.detailTableVisible is false
    return true;
  }
  if (!node.row) {
    // link not yet established, as soon as row gets inserted and filtered, a refilter will be triggered on the tree
    return true;
  }
  return node.row.filterAccepted;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/

/**
 * @extends {scout.Tree}
 * @class
 * @constructor
 */
scout.Outline = function() {
  scout.Outline.parent.call(this);
  this._addAdapterProperties(['defaultDetailForm', 'views', 'dialogs', 'messageBoxes', 'fileChoosers']);

  this.autoToggleBreadcrumbStyle = true;
  this.navigateButtonsVisible = true;
  this.dialogs = [];
  this.views = [];
  this.messageBoxes = [];
  this.fileChoosers = [];
  this.navigateUpInProgress = false; // see NavigateUpButton.js
  this._additionalContainerClasses += ' outline';
  this._treeItemPaddingLeft = 37;
  this._treeItemPaddingLevel = 20;
  this.inBackground = false;
  this.embedDetailContent = false;
  this.compact = false;
  this.formController;
  this.messageBoxController;
  this.fileChooserController;
  this._scrolldirections = 'y';
  this.titleVisible = true;
  this.mediator;
};
scout.inherits(scout.Outline, scout.Tree);

scout.Outline.prototype._init = function(model) {
  // add filter before first traversal of tree -> tree is only traversed once.
  this.addFilter(new scout.DetailTableTreeFilter(), true);
  scout.Outline.parent.prototype._init.call(this, model);

  this.mediator = this._createMediator();
  this.formController = new scout.FormController(this, this.session);
  this.messageBoxController = new scout.MessageBoxController(this, this.session);
  this.fileChooserController = new scout.FileChooserController(this, this.session);
  this.resolveTextKeys(['title']);
  this._syncDefaultDetailForm(this.defaultDetailForm);
  this._detailContentDestroyHandler = this._onDetailContentDestroy.bind(this);

  // menu bars
  this.titleMenuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.GroupBoxMenuItemsOrder()
  });
  this.nodeMenuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.GroupBoxMenuItemsOrder()
  });
  this.nodeMenuBar.bottom();
  this.detailMenuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.GroupBoxMenuItemsOrder()
  });
  this.detailMenuBar.bottom();

  this._syncDefaultDetailForm(this.defaultDetailForm);
  this._syncOutlineOverviewVisible(this.outlineOverviewVisible);
  this._syncMenus(this.menus);
  this.updateDetailContent();
};

/**
 * This function returns the outline mediator instance. When we're in an online Scout application we must
 * return a null instance here, because mediation is done server-side.
 */
scout.Outline.prototype._createMediator = function() {
  return scout.create('OutlineMediator');
};

/**
 * @override Tree.js
 */
scout.Outline.prototype._createTreeNode = function(nodeModel) {
  nodeModel.parent = this;
  return scout.create('Page', nodeModel);
};

scout.Outline.prototype._applyNodeDefaultValues = function(node) {
  scout.defaultValues.applyTo(node, 'Page');
};

scout.Outline.prototype._createKeyStrokeContext = function() {
  return new scout.OutlineKeyStrokeContext(this);
};

scout.Outline.prototype._filterMenus = function(menus, destination, onlyVisible, enableDisableKeyStroke) {
  //show no contextmenues
  return [];
};

/**
 * @override Tree.js
 */
scout.Outline.prototype._initTreeKeyStrokeContext = function() {
  var modifierBitMask = scout.keyStrokeModifier.CTRL | scout.keyStrokeModifier.SHIFT; // NOSONAR

  this.keyStrokeContext.registerKeyStroke([
    new scout.TreeNavigationUpKeyStroke(this, modifierBitMask),
    new scout.TreeNavigationDownKeyStroke(this, modifierBitMask),
    new scout.OutlineNavigateToTopKeyStroke(this, modifierBitMask),
    new scout.TreeNavigationEndKeyStroke(this, modifierBitMask),
    new scout.TreeCollapseOrDrillUpKeyStroke(this, modifierBitMask),
    new scout.TreeExpandOrDrillDownKeyStroke(this, modifierBitMask)
  ]);

  this.keyStrokeContext.$bindTarget = function() {
    return this.session.$entryPoint;
  }.bind(this);
};

/**
 * @override
 */
scout.Outline.prototype._render = function($parent) {
  scout.Outline.parent.prototype._render.call(this, $parent);

  // Override layout
  this.htmlComp.setLayout(new scout.OutlineLayout(this));
  this._renderCompact();
  this._renderEmbedDetailContent();
  this._renderDetailContent();
  this._renderDetailMenuBarVisible();
  this._renderNodeMenuBarVisible();
};

scout.Outline.prototype._renderProperties = function() {
  scout.Outline.parent.prototype._renderProperties.call(this);
  this._renderTitle();
  this._renderTitleMenuBar();
};

/**
 * @override Tree.js
 */
scout.Outline.prototype._remove = function() {
  scout.Outline.parent.prototype._remove.call(this);
  this._removeTitle();
};

scout.Outline.prototype._renderTitle = function() {
  if (this.titleVisible) {
    if (!this.$title) {
    this.$title = this.$container.prependDiv('outline-title');

    // Listener is added to the text instead of the title to not get the clicks on the title menubar
    this.$titleText = this.$title.prependDiv('outline-title-text')
        .on('click', this._onTitleClick.bind(this));
    }
    this.$titleText.text(this.title);
  }
};

scout.Outline.prototype._removeTitle = function() {
  if (this.titleVisible) {
    this.$title.remove();
    this.$title = null;
  }
};

scout.Outline.prototype._renderTitleMenuBar = function() {
  if (this.titleVisible) {
    this.titleMenuBar.render(this.$title);
    this.titleMenuBar.$container.addClass('prevent-initial-focus');
  }
};

/**
 * @override
 */
scout.Outline.prototype._renderEnabled = function() {
  scout.Outline.parent.prototype._renderEnabled.call(this);
  this.$container.setTabbable(false);
};

/**
 * @override
 */
scout.Outline.prototype._initTreeNodeInternal = function(node, parentNode) {
  scout.Outline.parent.prototype._initTreeNodeInternal.call(this, node, parentNode);
  this._initDetailTableAndForm(node);
  this.trigger('initPage', {page: node});
};

scout.Outline.prototype._initDetailTableAndForm = function(node) {
  if (node.detailTable) {
    this._initDetailTable(node);
  }
  if (node.detailForm) {
    this._initDetailForm(node);
  }
};

scout.Outline.prototype._initDetailTable = function(node) {
  if (this.navigateButtonsVisible) {
    this._appendNavigateButtonsForDetailTable(node);
  }
};

scout.Outline.prototype._initDetailForm = function(node) {
  if (this.navigateButtonsVisible) {
    this._appendNavigateButtonsForDetailForm(node);
  }

  // Mark form as detail form
  node.detailForm.detailForm = true;
  node.detailForm.one('destroy', function() {
    // Unlink detail form if it was closed. May happen in the following case:
    // The form gets closed on execPageDeactivated. No pageChanged event will
    // be fired because the deactivated page is not selected anymore.
    node.detailForm = null;
    // Also make sure other objects hold no reference to a destroyed form (e.g. bench)
    this._triggerPageChanged(node);
  }.bind(this));
};

/**
 * @override
 */
scout.Outline.prototype._decorateNode = function(node) {
  scout.Outline.parent.prototype._decorateNode.call(this, node);
  if (this.session.inspector) {
    scout.inspector.applyInfo(node, node.$node);
  }
};

scout.Outline.prototype._createNavigateButtons = function(node, staticMenus) {
  var menus = scout.arrays.ensure(staticMenus);
  if (!this._hasMenu(menus, scout.NavigateUpButton)) {
    var upButton = scout.create('NavigateUpButton', {
      parent: this,
      outline: this,
      node: node
    });
    menus.push(upButton);
  }
  if (!this._hasMenu(menus, scout.NavigateDownButton)) {
    var downButton = scout.create('NavigateDownButton', {
      parent: this,
      outline: this,
      node: node
    });
    menus.push(downButton);
  }
  return menus;
};

scout.Outline.prototype._getMenu = function(menus, menuClass) {
  for (var i = 0; i < menus.length; i++) {
    if (menus[i] instanceof menuClass) {
      return menus[i];
    }
  }
  return null;
};

scout.Outline.prototype._hasMenu = function(menus, menuClass) {
  return this._getMenu(menus, menuClass) !== null;
};

scout.Outline.prototype._onTitleClick = function(event) {
  this.navigateToTop();
};

scout.Outline.prototype.navigateToTop = function() {
  this.deselectAll();
  this.collapseAll();
  this.handleInitialExpanded();
};

scout.Outline.prototype.handleInitialExpanded = function() {
  this._visitNodes(this.nodes, function(node) {
    if (node.initialExpanded) {
      this.expandNode(node, {
        renderExpansion: true
      });
    }
  }.bind(this));
};

scout.Outline.prototype._onNodeDeleted = function(node) {
  // Destroy table, which is attached at the root adapter. Form gets destroyed by form close event
  if (node.detailTable) {
    node.detailTable.off('rowInitialized', this._detailTableRowHandler);
    node.detailTable.destroy();
    node.detailTable = null;
  }
  // If last node is removed, navigate back to top
  if (this.nodes.length === 0) {
    this.navigateToTop();
  }
};

scout.Outline.prototype.selectNodes = function(nodes, debounceSend) {
  nodes = scout.arrays.ensure(nodes);
  if (nodes.length > 0 && this.isNodeSelected(nodes[0])) {
    // Already selected, do nothing
    return;
  }
  if (nodes.length === 0 && this.selectedNodes.length === 0) {
    // Already unselected, do nothing
    return;
  }
  if (this.navigateUpInProgress) {
    this.navigateUpInProgress = false;
  } else {
    if (nodes.length === 1) {
      // When a node is selected, the detail form should never be hidden
      this.setDetailFormVisibleByUi(nodes[0], true);
    }
  }
  scout.Outline.parent.prototype.selectNodes.call(this, nodes, debounceSend);
  // FIXME XXX hier wurde frher noch updateDetailContent (nochmals) aufgerufen, das ist aber unntig
  // da dies schon als folge vom nodesSelectedInternal passiert. Allerdings hatte es auch den neben
  // effekt dass attachDetailsMenuListener nochmals ausgefhrt wurde und so das "versehentliche" entfernen
  // vom changeListener behoben hat
  this.updateDetailContent();
};

scout.Outline.prototype._syncDefaultDetailForm = function(defaultDetailForm) {
  this._setProperty('defaultDetailForm', defaultDetailForm);
  this._updateDetailForm();
};

scout.Outline.prototype._syncOutlineOverviewVisible = function(outlineOverviewVisible) {
  this._setProperty('outlineOverviewVisible', outlineOverviewVisible);
  this._updateDetailForm();
};

scout.Outline.prototype._updateDetailForm = function() {
  if (this.defaultDetailForm) {
    if (this.outlineOverview) {
      this.outlineOverview.destroy();
      this._setProperty('outlineOverview', null);
    }
  } else {
    if (this.outlineOverviewVisible) {
      if (!this.outlineOverview) {
        // Create outlineOverview if no defaultDetailForm is available
        this._setProperty('outlineOverview', scout.create('OutlineOverview', {
          parent: this,
          outline: this
        }));
      }
    } else {
      if (this.outlineOverview) {
        this.outlineOverview.destroy();
        this._setProperty('outlineOverview', null);
      }
    }

  }
};

scout.Outline.prototype._syncNavigateButtonsVisible = function(navigateButtonsVisible) {
  this._setProperty('navigateButtonsVisible', navigateButtonsVisible);
  this._visitNodes(this.nodes, this._syncNavigateButtonsVisibleForNode.bind(this));
};

scout.Outline.prototype._syncNavigateButtonsVisibleForNode = function(node, parentNode) {
  if (this.navigateButtonsVisible) {
    if (node.detailForm) {
      this._appendNavigateButtonsForDetailForm(node);
    }
    if (node.detailTable) {
      this._appendNavigateButtonsForDetailTable(node);
    }
  } else {
    if (node.detailForm) {
      this._removeNavigateButtonsForDetailForm(node);
    }
    if (node.detailTable) {
      this._removeNavigateButtonsForDetailTable(node);
    }
  }
};

scout.Outline.prototype._appendNavigateButtonsForDetailForm = function(node) {
  var menus = this._createNavigateButtons(node, node.detailForm.staticMenus);
  node.detailForm.rootGroupBox.setStaticMenus(menus);
};

scout.Outline.prototype._appendNavigateButtonsForDetailTable = function(node) {
  var menus = this._createNavigateButtons(node, node.detailTable.staticMenus);
  node.detailTable.setStaticMenus(menus);
};

scout.Outline.prototype._removeNavigateButtonsForDetailForm = function(node) {
  var staticMenus = [];
  node.detailForm.rootGroupBox.staticMenus.forEach(function(menu) {
    if (menu instanceof scout.NavigateUpButton || menu instanceof scout.NavigateDownButton) {
      menu.destroy();
    } else {
      staticMenus.push(menu);
    }
  });
  node.detailForm.rootGroupBox.setStaticMenus(staticMenus);
};

scout.Outline.prototype._removeNavigateButtonsForDetailTable = function(node) {
  var staticMenus = [];
  node.detailTable.staticMenus.forEach(function(menu) {
    if (menu instanceof scout.NavigateUpButton || menu instanceof scout.NavigateDownButton) {
      menu.destroy();
    } else {
      staticMenus.push(menu);
    }
  });
  node.detailTable.setStaticMenus(staticMenus);
};

/**
 * @returns {scout.TableRow} the selected row or null when no row is selected. When multiple rows are selected
 *    the first selected row is returned.
 */
scout.Outline.prototype.selectedRow = function() {
  var node = this.selectedNode();
  if (!node || !node.detailTable) {
    return null;
  }
  return node.detailTable.selectedRow();
};

scout.Outline.prototype._applyUpdatedNodeProperties = function(oldNode, updatedNode) {
  var propertiesChanged = scout.Outline.parent.prototype._applyUpdatedNodeProperties.call(this, oldNode, updatedNode);
  if (oldNode.modelClass !== updatedNode.modelClass) {
    oldNode.modelClass = updatedNode.modelClass;
    propertiesChanged = true;
  }
  if (oldNode.classId !== updatedNode.classId) {
    oldNode.classId = updatedNode.classId;
    propertiesChanged = true;
  }
  if (oldNode.nodeType !== updatedNode.nodeType) {
    oldNode.nodeType = updatedNode.nodeType;
    propertiesChanged = true;
  }
  return propertiesChanged;
};

/**
 * Called by updateItemPath.
 *
 * @override
 */
scout.Outline.prototype._isGroupingEnd = function(node) {
  return node.nodeType === scout.Page.NodeType.TABLE;
};

/**
 * Disabled for outlines because outline may be resized.
 */
scout.Outline.prototype._isTruncatedNodeTooltipEnabled = function() {
  return false;
};

scout.Outline.prototype.setDetailFormVisibleByUi = function(node, visible) {
  node.detailFormVisibleByUi = visible;
  this._triggerPageChanged(node);
};

scout.Outline.prototype.validateFocus = function() {
  this.session.focusManager.validateFocus();
};

scout.Outline.prototype.sendToBack = function() {
  this.inBackground = true;
  this._renderInBackground();

  // Detach child dialogs, message boxes and file choosers, not views.
  this.formController.detachDialogs();
  this.messageBoxController.detach();
  this.fileChooserController.detach();
};

scout.Outline.prototype.bringToFront = function() {
  this.inBackground = false;
  this._renderInBackground();

  // Attach child dialogs, message boxes and file choosers.
  this.formController.attachDialogs();
  this.messageBoxController.attach();
  this.fileChooserController.attach();
};

scout.Outline.prototype._renderInBackground = function() {
  this.$container.toggleClass('in-background', this.inBackground);
};

scout.Outline.prototype._renderCompact = function() {
  this.$container.toggleClass('compact', this.compact);
  this.invalidateLayoutTree();
};

scout.Outline.prototype._renderEmbedDetailContent = function() {
  this.$data.toggleClass('has-detail-content', this.embedDetailContent);
  this.invalidateLayoutTree();
};

scout.Outline.prototype._renderDetailContent = function() {
  if (!this.detailContent || this.detailContent.rendered) {
    return;
  }
  var page = this.selectedNode();
  if (!page.rendered) {
    return;
  }

  this.detailContent.render(page.$node);
  if (this.detailContent.htmlComp) {
    this.detailContent.htmlComp.validateRoot = false;
    this.detailContent.htmlComp.pixelBasedSizing = true;
  }
  this._ensurePageLayout(page);
  this.$data.addClass('detail-content-visible');
};

scout.Outline.prototype._ensurePageLayout = function(page) {
  // selected page now has content (menubar and form) -> needs a layout
  // always create new htmlComp, otherwise we would have to remove them when $node or outline gets remvoed
  page.htmlComp = scout.HtmlComponent.install(page.$node, this.session);
  page.htmlComp.setLayout(new scout.PageLayout(this, page));
};

scout.Outline.prototype._removeDetailContent = function() {
  if (!this.detailContent) {
    return;
  }
  this.detailContent.remove();
  this.$data.removeClass('detail-content-visible');
};

scout.Outline.prototype._postRenderViewRange = function() {
  scout.Outline.parent.prototype._postRenderViewRange.call(this);
  this._renderDetailContent();
  this._renderDetailMenuBarVisible();
  this._renderNodeMenuBarVisible();
};

scout.Outline.prototype.setCompact = function(compact) {
  this.setProperty('compact', compact);
};

scout.Outline.prototype.setEmbedDetailContent = function(embedDetailContent) {
  this.setProperty('embedDetailContent', embedDetailContent);
  this.updateDetailContent();
};

scout.Outline.prototype._onDetailContentDestroy = function(event) {
  this.setDetailContent(null);
  this.updateDetailMenus();
};

scout.Outline.prototype.setDetailContent = function(content) {
  if (this.detailContent === content) {
    return;
  }
  if (this.rendered) {
    this._removeDetailContent();
  }
  if (this.detailContent) {
    this.detailContent.off('destroy', this._detailContentDestroyHandler);
  }
  this._setProperty('detailContent', content);
  if (content) {
    content.on('destroy', this._detailContentDestroyHandler);
  }
  if (this.rendered) {
    this._renderDetailContent();
  }
  this.invalidateLayoutTree();
};

scout.Outline.prototype.updateDetailContent = function() {
  if (!this.embedDetailContent) {
    this.setDetailContent(null);
    this.setDetailMenus([]);
    return;
  }

  this.setDetailMenuBarVisible(false);
  this.setNodeMenuBarVisible(false);
  this.setDetailContent(this._computeDetailContent());
  this.updateDetailMenus();

  // Layout immediate to prevent 'laggy' form visualization,
  // but not initially while desktop gets rendered because it will be done at the end anyway
  if (this.rendered) {
    this.validateLayoutTree();
  }
};

scout.Outline.prototype._computeDetailContent = function() {
  var selectedPage = this.selectedNode();
  if (!selectedPage) {
    // Detail content is shown for the selected node only
    return null;
  }

  // if there is a detail form, use this
  if (selectedPage.detailForm && selectedPage.detailFormVisible && selectedPage.detailFormVisibleByUi) {
    return selectedPage.detailForm;
    // otherwise show the content of the table row
    // but never if parent is a node page -> the table contains only one column with no essential information
  } else if (selectedPage.row && selectedPage.parentNode.nodeType === scout.Page.NodeType.TABLE) {
    return scout.create('TableRowDetail', {
      parent: this,
      table: selectedPage.parentNode.detailTable,
      row: selectedPage.row
    });
  }
  return null;
};

/**
 * Updates node and detail menubar.
 * Node menubar: Contains the table controls and right aligned menus.
 * Detail menubar: Contains the other menus.
 *
 * The menu items are gathered from various sources:
 * If the selected page has a detailForm, the menus are taken from there. Otherwise the detail table and the parent detail table provide the menus.
 * The detail table contributes the empty space menus and the parent detail the the single selection menus.
 *
 * The menus of the outline itself are not displayed. In fact the server won't deliver any.
 * One reason is that no menus are displayed in regular mode, so when switching to compact mode no menus would be available.
 * Another reason is that it would flicker because the menus are sent anew from the server every time a node gets selected because the menus are added to the outline and not to the node and are therefore not cached.
 */
scout.Outline.prototype.updateDetailMenus = function() {
  if (!this.embedDetailContent) {
    return;
  }
  var selectedPages = this.selectedNodes,
    selectedPage = selectedPages[0],
    menuItems = [],
    tableControls = [],
    nodeMenus = [],
    detailTable,
    detailMenus = [];

  if (this.detailContent && this.detailContent instanceof scout.Form) {
    // get menus from detail form
    var rootGroupBox = this.detailContent.rootGroupBox;
    menuItems = rootGroupBox.processMenus.concat(rootGroupBox.menus);
    rootGroupBox.setMenuBarVisible(false);
  } else if (selectedPage) {
    // get empty space menus and table controls from detail table
    if (selectedPage.detailTable) {
      detailTable = selectedPage.detailTable;
      menuItems = scout.menus.filter(detailTable.menus, ['Table.EmptySpace'], false, true);
      tableControls = detailTable.tableControls;
      this._attachDetailMenusListener(detailTable);
    }
    // get single selection menus from parent detail table
    var parentPage = selectedPage.parentNode;
    if (parentPage && parentPage.detailTable) {
      detailTable = parentPage.detailTable;
      menuItems = menuItems.concat(scout.menus.filter(detailTable.menus, ['Table.SingleSelection'], false, true));
      this._attachDetailMenusListener(detailTable);
    }
  }

  // Add table controls to nodeMenus
  tableControls.forEach(function(tableControl) {
    var menu = scout.create('TableControlAdapterMenu',
      scout.TableControlAdapterMenu.adaptTableControlProperties(tableControl, {
        parent: this,
        tableControl: tableControl,
        horizontalAlignment: 1
      }));
    nodeMenus.push(menu);
  }, this);

  // Add right aligned menus to node menus, other to detail menus
  menuItems.forEach(function(menuItem) {
    if (menuItem.horizontalAlignment === 1) {
      nodeMenus.push(menuItem);
    } else {
      detailMenus.push(menuItem);
    }
  }, this);

  this.setNodeMenus(nodeMenus);
  this.setDetailMenus(detailMenus);
};

/**
 * Attaches a listener to the given menu container (which is the detail table or the detail table of the parent node)
 * in order to get dynamic menu changes and update the detailMenus on such a change event.
 * The impl. is lazy because it is only used in mobile mode.
 */
scout.Outline.prototype._attachDetailMenusListener = function(menuContainer) {
  if (!this._detailMenusChangeHandler) {
    this._detailMenusChangeHandler = function(event) {
      if (scout.arrays.containsAny(event.changedProperties, ['menus', 'tableControls'])) {
        this.updateDetailMenus();
      }
    }.bind(this);
  }
  if (!this._detailMenusDestroyHandler) {
    this._detailMenusDestroyHandler = function() {
      menuContainer.off('propertyChange', this._detailMenusChangeHandler);
    }.bind(this);
  }

  menuContainer.off('propertyChange', this._detailMenusChangeHandler);
  menuContainer.on('propertyChange', this._detailMenusChangeHandler);
  menuContainer.off('destroy', this._detailMenusDestroyHandler);
  menuContainer.one('destroy', this._detailMenusDestroyHandler);

  if (!this._detailMenusNodesSelectedHandler) {
    // This nodes selection listener removes the property change listeners from the old menu containers (detail content) whenever a node gets selected
    // updateDetailMenus() is called afterwards and attaches the property change listeners to the new detail content
    // This guarantees that no events are fired for non selected nodes
    this._detailMenusNodesSelectedHandler = {
      outline: this,
      menuContainers: [],
      addMenuContainer: function(container) {
        if (this.menuContainers.indexOf(container) > -1) {
          return;
        }
        this.menuContainers.push(container);
      },
      func: function(event) {
        if (event.type !== 'nodesSelected') {
          return;
        }
        this.menuContainers.forEach(function(container) {
          container.off('propertyChange', this.outline._detailMenusChangeHandler);
          container.off('destroy', this.outline._detailMenusDestroyHandler);
        }, this);
        this.menuContainers = [];
      }
    };
    this.events.addListener(this._detailMenusNodesSelectedHandler);
  }
  this._detailMenusNodesSelectedHandler.addMenuContainer(menuContainer);
};

scout.Outline.prototype.setDetailMenus = function(detailMenus) {
  this.detailMenuBar.setMenuItems(detailMenus);
  this.setDetailMenuBarVisible(this.detailMenuBar.menuItems.length > 0);
};

scout.Outline.prototype._renderDetailMenuBarVisible = function() {
  if (this.detailMenuBarVisible) {
    this._renderDetailMenuBar();
  } else {
    this._removeDetailMenuBar();
  }
};

scout.Outline.prototype._renderDetailMenuBar = function() {
  if (this.detailMenuBar.rendered) {
    return;
  }
  var node = this.selectedNode();
  if (!node || !node.rendered) {
    return;
  }

  this.detailMenuBar.render(node.$node);
  this.detailMenuBar.$container.addClass('detail-menubar');
  if (this.detailContent && this.detailContent.rendered) {
    // move before content (e.g. form)
    this.detailMenuBar.$container.insertBefore(this.detailContent.$container);
  }
  this._ensurePageLayout(node);
  this.invalidateLayoutTree();
};

scout.Outline.prototype._removeDetailMenuBar = function() {
  if (!this.detailMenuBar.rendered) {
    return;
  }
  this.detailMenuBar.remove();
  this.invalidateLayoutTree();
};

scout.Outline.prototype.setDetailMenuBarVisible = function(visible) {
  this.setProperty('detailMenuBarVisible', visible);
};

scout.Outline.prototype.setNodeMenus = function(nodeMenus) {
  this.nodeMenuBar.setMenuItems(nodeMenus);
  this.setNodeMenuBarVisible(this.nodeMenuBar.menuItems.length > 0);
};

scout.Outline.prototype._renderNodeMenuBarVisible = function() {
  if (this.nodeMenuBarVisible) {
    this._renderNodeMenuBar();
  } else {
    this._removeNodeMenuBar();
  }
};

scout.Outline.prototype._renderNodeMenuBar = function() {
  if (this.nodeMenuBar.rendered) {
    return;
  }
  var node = this.selectedNode();
  if (!node || !node.rendered) {
    return;
  }

  var $text = node.$node.children('.text');
  this.nodeMenuBar.render(node.$node);
  this.nodeMenuBar.$container.addClass('node-menubar');
  this.nodeMenuBar.$container.insertAfter($text);
  this.invalidateLayoutTree();
};

scout.Outline.prototype._removeNodeMenuBar = function() {
  if (!this.nodeMenuBar.rendered) {
    return;
  }
  this.nodeMenuBar.remove();
  this.invalidateLayoutTree();
};

scout.Outline.prototype.setNodeMenuBarVisible = function(visible) {
  this.setProperty('nodeMenuBarVisible', visible);
};

scout.Outline.prototype._glassPaneTargets = function() {
  var desktop = this.session.desktop;
  var elements = [];
  if (desktop.navigation) {
    elements.push(desktop.navigation.$body);
  }
  if (desktop.bench && desktop.bench.outlineContent) {
    scout.arrays.pushAll(elements, desktop.bench.outlineContent.glassPaneTargets());
  }
  return elements;
};

/**
 * === Method required for objects that act as 'displayParent' ===
 *
 * Returns true if this outline is active and not in background.
 */
scout.Outline.prototype.inFront = function() {
  return this.session.desktop.outline === this && !this.inBackground;
};

/**
 * Called if outline acts as display parent.<p>
 * Returns true if outline is active, even if it is not rendered (e.g. when navigation is invisible)
 */
scout.Outline.prototype.acceptDialog = function(dialog) {
  return this.session.desktop.outline === this;
};

/**
 * Called if outline acts as display parent.<p>
 * Returns true if outline is active, even if it is not rendered (e.g. when navigation is invisible)
 */
scout.Outline.prototype.acceptView = function(view) {
  return this.session.desktop.outline === this;
};

// see Java: AbstractOutline#makeActivePageToContextPage
scout.Outline.prototype.activateCurrentPage = function() {
  var activePage = this.activePage();
  if (activePage) {
    activePage.activate();
  }
};

scout.Outline.prototype.activePage = function() {
  return this.selectedNode();
};

/**
 * @override Tree.js (don't call parent)
 */
scout.Outline.prototype._syncMenus = function(menus) {
  var oldMenus = this.menus;
  this.updateKeyStrokes(menus, oldMenus);
  this._setProperty('menus', menus);
  if (this.titleMenuBar) { // _syncMenus is called by parent class Tree.js, at this time titleMenuBar is not yet initialized
    var menuItems = scout.menus.filter(this.menus, ['Tree.Header']);
    this.titleMenuBar.setMenuItems(menuItems);
  }
};

scout.Outline.prototype._triggerPageChanged = function(page) {
  this.trigger('pageChanged', {
    page: page
  });
};

/**
 * @override Tree.js
 */
scout.Outline.prototype._nodesSelectedInternal = function() {
  var activePage = this.activePage();
  // This block here is similar to what's done in Java's DefaultPageChangeStrategy
  if (activePage) {
    activePage.activate();
    activePage.ensureLoadChildren().done(
      this._onLoadChildrenDone.bind(this, activePage));
  }
};

scout.Outline.prototype._onLoadChildrenDone = function(activePage) {
  if (activePage) {
    this._initDetailTableAndForm(activePage);
  }
};

scout.Outline.prototype.pageChanged = function(page) {
  if (page) {
    this._initDetailTableAndForm(page);
  }

  var selectedPage = this.selectedNode();
  if (!page && !selectedPage || page === selectedPage) {
    this.updateDetailContent();
  }

  this._triggerPageChanged(page);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineAdapter = function() {
  scout.OutlineAdapter.parent.call(this);
  this._addAdapterProperties(['defaultDetailForm', 'views', 'dialogs', 'messageBoxes', 'fileChoosers']);
  this._nodeIdToRowMap = {};
  this._detailTableRowHandler = this._onDetailTableRowInitialized.bind(this);
};
scout.inherits(scout.OutlineAdapter, scout.TreeAdapter);

scout.OutlineAdapter.prototype._init = function(model) {
  scout.OutlineAdapter.parent.prototype._init.call(this, model);
};

/**
 * We must call onWidgetInitPage because this adapter cannot process the 'initPage' event
 * while the widget is initialized, since the listener is not attached until the widget
 * is created completely.
 */
scout.OutlineAdapter.prototype._postCreateWidget = function() {
  var outline = this.widget;
  outline._visitNodes(outline.nodes, this._onWidgetInitPage.bind(this));
};
scout.OutlineAdapter.prototype._onPageChanged = function(event) {
  var page;
  if (event.nodeId) {
    page = this.widget._nodeById(event.nodeId);

    page.detailFormVisible = event.detailFormVisible;
    page.detailForm = this.session.getOrCreateWidget(event.detailForm, this.widget);

    page.detailTableVisible = event.detailTableVisible;
    page.detailTable = this.session.getOrCreateWidget(event.detailTable, this.widget);
  } else {
    this.widget.defaultDetailForm = this.session.getOrCreateWidget(event.detailForm, this.widget);
  }

  this.widget.pageChanged(page);
};

scout.OutlineAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'initPage') {
    this._onWidgetInitPage(event.page);
  } else {
    scout.OutlineAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

scout.OutlineAdapter.prototype.onModelAction = function(event) {
  if (event.type === 'pageChanged') {
    this._onPageChanged(event);
  } else {
    scout.OutlineAdapter.parent.prototype.onModelAction.call(this, event);
  }
};

scout.OutlineAdapter.prototype._onWidgetInitPage = function(page) {
  if (page.detailTable) {
    this._initDetailTable(page);
  }
  this._linkNodeWithRowLater(page);
};

scout.OutlineAdapter.prototype._initDetailTable = function(page) {
  // link already existing rows now
  page.detailTable.rows.forEach(this._linkNodeWithRow.bind(this));
  // rows which are inserted later are linked by _onDetailTableRowInitialized
  page.detailTable.on('rowInitialized', this._detailTableRowHandler);
};

scout.OutlineAdapter.prototype._linkNodeWithRow = function(row) {
  scout.assertParameter('row', row);
  var nodeId = row.nodeId,
    node = this.widget.nodesMap[nodeId];
  if (node) {
    scout.Page.linkRowWithPage(row, node);
  } else {
    // Prepare for linking later because node has not been inserted yet
    // see: #_linkNodeWithRowLater
    this._nodeIdToRowMap[nodeId] = row;
  }
};

scout.OutlineAdapter.prototype._onDetailTableRowInitialized = function(event) {
  var node,
    outline = this.widget,
    nodeId = event.row.nodeId;
  this._linkNodeWithRow(event.row);
  node = this.widget.nodesMap[nodeId];

  // If a row, which was already linked to a node, gets initialized again, re-apply the filter to make sure the node has the correct state
  if (outline.rendered && node && outline._applyFiltersForNode(node)){
    if (node.isFilterAccepted()) {
      outline._addToVisibleFlatList(node, false);
    } else {
      outline._removeFromFlatList(node, false);
    }
  }
};

/**
 * Link node with row, if it hasn't been linked yet.
 */
scout.OutlineAdapter.prototype._linkNodeWithRowLater = function(page) {
  if (!page.parentNode || !page.parentNode.detailTable) {
    return;
  }
  if (!this._nodeIdToRowMap.hasOwnProperty(page.id)) {
    return;
  }
  var row = this._nodeIdToRowMap[page.id];
  scout.Page.linkRowWithPage(row, page);
  delete this._nodeIdToRowMap[page.id];
};


/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineMediator = function() {
};

scout.OutlineMediator.prototype.init = function(model) {
};

scout.OutlineMediator.prototype._skipEvent = function(page) {
  return page === null || page.getOutline() === null || page.leaf;
};

scout.OutlineMediator.prototype.onTableRowsInserted = function(rows, childPages, pageWithTable) {
  if (this._skipEvent(pageWithTable)) {
    return;
  }
  pageWithTable.getTree().insertNodes(childPages, pageWithTable);
};

scout.OutlineMediator.prototype.onTableRowsDeleted = function(rows, childPages, pageWithTable) {
  if (this._skipEvent(pageWithTable)) {
    return;
  }
  pageWithTable.getTree().deleteNodes(childPages, pageWithTable);
};

scout.OutlineMediator.prototype.onTableRowAction = function(event, page) {
  var childPage = event.row.page;
  if (!childPage) {
    return;
  }

  var outline = childPage.getOutline();
  if (!outline) {
    return;
  }

  outline.selectNode(childPage);
  outline.setNodeExpanded(childPage, true);
};

scout.OutlineMediator.prototype.onTableRowOrderChanged = function(event, pageWithTable) {
  if (this._skipEvent(pageWithTable)) {
    return;
  }

  var table = event.source;
  var childPages = pageWithTable.pagesForTableRows(table.rows);
  pageWithTable.getOutline().updateNodeOrder(childPages, pageWithTable);
};

scout.OutlineMediator.prototype.onTableRowsFiltered = function(event, page) {
  page.getOutline().filter();
};

//public void mediateTableRowsUpdated(TableEvent e, IPageWithTable<?> pageWithTable) {

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineOverview = function() {
  scout.OutlineOverview.parent.call(this);
  this.outline;
};
scout.inherits(scout.OutlineOverview, scout.Widget);

scout.OutlineOverview.prototype._init = function(options) {
  scout.OutlineOverview.parent.prototype._init.call(this, options);

  this.outline = options.outline;
  this.id = options.id; // actually only necessary for a spec...
};

scout.OutlineOverview.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('outline-overview');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.$content = this.$container.appendDiv('outline-overview-content');
  this.$content.appendDiv('outline-overview-icon').icon(this.outline.iconId);
  this.$content.appendDiv('outline-overview-title').text(this.outline.title);
};

/**
 * @override Widget.js
 */
scout.OutlineOverview.prototype._attach = function() {
  this.$parent.append(this.$container);
  var htmlParent = this.htmlComp.getParent();
  this.htmlComp.setSize(htmlParent.getSize());
  this.session.detachHelper.afterAttach(this.$container);
  scout.OutlineOverview.parent.prototype._attach.call(this);
};

/**
 * @override Widget.js
 */
scout.OutlineOverview.prototype._detach = function() {
  this.session.detachHelper.beforeDetach(this.$container);
  this.$container.detach();
  scout.OutlineOverview.parent.prototype._detach.call(this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineLayout = function(outline) {
  scout.OutlineLayout.parent.call(this, outline);
  this.outline = outline;
};
scout.inherits(scout.OutlineLayout, scout.TreeLayout);

scout.OutlineLayout.prototype._layout = function($container) {
  var containerSize,
    htmlContainer = this.outline.htmlComp;

  scout.OutlineLayout.parent.prototype._layout.call(this, $container);

  containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  if (this.outline.embedDetailContent) {
    var selectedNode = this.outline.selectedNodes[0];
    if (selectedNode && selectedNode.rendered) {
      var pageHtmlComp = selectedNode.htmlComp;
      // pageHtmlComp is null if there is no detail form and no detail menubar
      if (pageHtmlComp) {
        // Fix width so that prefSize returns the appropriate height (necessary for elements with text wrap)
        pageHtmlComp.$comp.cssWidth(containerSize.width);

        var prefSize = pageHtmlComp.getPreferredSize();
        pageHtmlComp.setSize(new scout.Dimension(containerSize.width, prefSize.height));
        selectedNode.height = prefSize.height + pageHtmlComp.getMargins().vertical();
      }
    }

    // Remove width and height from non selected nodes (at this point we don't know the previously selected node anymore, so we need to process all visible nodes)
    // It is not enough to only process rendered nodes, we need to update the detached nodes as well
    this.outline.visibleNodesFlat.forEach(function(node) {
      var $node = node.$node;
      if (!$node) {
        // Do nothing if node has never been rendered
        return;
      }
      // check for style.height to prevent unnecessary updates, no need to update nodes without a fixed height
      if ($node.isSelected() || !$node[0].style.height || $node[0].style.height === 'auto') {
        return;
      }

      $node.css('height', 'auto')
        .css('width', 'auto');
      node.height = $node.outerHeight(true);
    });
  }
};

scout.OutlineLayout.prototype._setDataHeight = function(heightOffset) {
  var titleSize = null;
  if (this.outline.titleVisible) {
    titleSize = scout.graphics.getSize(this.outline.$title, true);
  }
  scout.OutlineLayout.parent.prototype._setDataHeight.call(this, heightOffset + (titleSize === null ? 0 : titleSize.height));
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineViewButton = function() {
  scout.OutlineViewButton.parent.call(this);
  this._addAdapterProperties('outline');
};
scout.inherits(scout.OutlineViewButton, scout.ViewButton);

/**
 * @override
 */
scout.OutlineViewButton.prototype._doAction = function() {
  scout.OutlineViewButton.parent.prototype._doAction.call(this);
  if (this.outline) {
    this.session.desktop.bringOutlineToFront(this.outline);
  }
};

scout.OutlineViewButton.prototype.onOutlineChanged = function(outline) {
  var selected = !!outline && this.outline === outline;
  this.setSelected(selected);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineViewButtonAdapter = function() {
  scout.OutlineViewButtonAdapter.parent.call(this);
  this._addAdapterProperties('outline');
};
scout.inherits(scout.OutlineViewButtonAdapter, scout.ViewButtonAdapter);

scout.OutlineViewButtonAdapter.prototype._goOffline = function() {
  // Disable only if outline has not been loaded yet
  if (this.widget.outline) {
    return;
  }
  this._enabledBeforeOffline = this.widget.enabled;
  this.widget.setEnabled(false);
};

scout.OutlineViewButtonAdapter.prototype._goOnline = function() {
  this.widget.setEnabled(this._enabledBeforeOffline);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PageLayout = function(outline, page) {
  scout.PageLayout.parent.call(this);
  this.outline = outline;
  this.page = page;
};
scout.inherits(scout.PageLayout, scout.AbstractLayout);

scout.PageLayout.prototype.layout = function($container) {
  var containerSize, detailMenuBarSize,
    htmlContainer = this.page.htmlComp,
    $text = this.page.$node.children('.text'),
    titleHeight = 0,
    nodeMenuBar = this.outline.nodeMenuBar,
    nodeMenuBarWidth = 0,
    detailMenuBar = this.outline.detailMenuBar,
    detailMenuBarHeight = 0;

  containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  if (nodeMenuBar.visible) {
    nodeMenuBarWidth = nodeMenuBar.htmlComp.getPreferredSize().width;
    $text.cssWidth(containerSize.width - nodeMenuBarWidth);
  }

  if (detailMenuBar.visible) {
    detailMenuBarHeight = detailMenuBar.htmlComp.getPreferredSize().height;
    detailMenuBarSize = new scout.Dimension(containerSize.width, detailMenuBarHeight)
      .subtract(detailMenuBar.htmlComp.getMargins());
    detailMenuBar.htmlComp.setSize(detailMenuBarSize);
  }

  if (this.outline.detailContent) {
    titleHeight = $text.outerHeight(true);
    this.outline.detailContent.htmlComp.setSize(new scout.Dimension(containerSize.width, containerSize.height - titleHeight - detailMenuBarHeight));
  }
};

scout.PageLayout.prototype.preferredLayoutSize = function($container) {
  var prefSize, containerSize,
    htmlContainer = this.page.htmlComp,
    detailContentPrefSize = new scout.Dimension(),
    $text = this.page.$node.children('.text'),
    titlePrefHeight = 0,
    detailMenuBar = this.outline.detailMenuBar,
    detailMenuBarPrefSize = new scout.Dimension(),
    nodeMenuBar = this.outline.nodeMenuBar,
    nodeMenuBarWidth = 0;

  containerSize = htmlContainer.getSize()
    .subtract(htmlContainer.getInsets());

  if (nodeMenuBar.visible) {
    nodeMenuBarWidth = nodeMenuBar.htmlComp.getPreferredSize().width;
  }

  // needs a width to be able to calculate the pref height -> container width needs to be correct already
  titlePrefHeight = scout.graphics.prefSize($text, {
    includeMargin: true,
    widthHint: containerSize.width - nodeMenuBarWidth
  }).height;

  if (detailMenuBar.visible) {
    detailMenuBarPrefSize = detailMenuBar.htmlComp.getPreferredSize();
  }
  if (this.outline.detailContent) {
    // Table row detail may contain wrapped text as well, but since it uses the full width there is no need to give a width hint
    detailContentPrefSize = this.outline.detailContent.htmlComp.getPreferredSize();
  }

  prefSize = new scout.Dimension(Math.max(detailContentPrefSize.width, detailMenuBarPrefSize.width), titlePrefHeight + detailMenuBarPrefSize.height + detailContentPrefSize.height);
  prefSize = prefSize.add(htmlContainer.getInsets());
  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SearchOutline = function() {
  scout.SearchOutline.parent.call(this);
  this.$searchPanel;
  this.$searchStatus;
  this.$queryField;
};
scout.inherits(scout.SearchOutline, scout.Outline);

/**
 * @override Tree.js
 */
scout.SearchOutline.prototype._initKeyStrokeContext = function() {
  scout.SearchOutline.parent.prototype._initKeyStrokeContext.call(this);

  this.searchFieldKeyStrokeContext = this._createKeyStrokeContextForSearchField();
};

scout.SearchOutline.prototype._createKeyStrokeContextForSearchField = function() {
  var keyStrokeContext = new scout.InputFieldKeyStrokeContext();
  keyStrokeContext.$scopeTarget = function() {
    return this.$searchPanel;
  }.bind(this);
  keyStrokeContext.$bindTarget = function() {
    return this.$queryField;
  }.bind(this);
  keyStrokeContext.registerStopPropagationKeys(scout.keyStrokeModifier.NONE, [
    scout.keys.ENTER, scout.keys.BACKSPACE
  ]);
  return keyStrokeContext;
};

scout.SearchOutline.prototype._render = function($parent) {
  scout.SearchOutline.parent.prototype._render.call(this, $parent);

  // Override layout
  this.htmlComp.setLayout(new scout.SearchOutlineLayout(this));

  this.$container.addClass('search-outline');
  this.$searchPanel = this.$container.prependDiv('search-outline-panel');
  this.$queryField = this.$searchPanel.appendElement('<input>', 'search-outline-field')
    .on('input', $.debounce(this._onQueryFieldInput.bind(this)))
    .on('keypress', this._onQueryFieldKeyPress.bind(this));
  this.$searchStatus = this.$searchPanel.appendDiv('search-outline-status')
    .on('click', this._onTitleClick.bind(this));
  this.session.keyStrokeManager.installKeyStrokeContext(this.searchFieldKeyStrokeContext);
};

scout.SearchOutline.prototype._remove = function() {
  this.session.keyStrokeManager.uninstallKeyStrokeContext(this.searchFieldKeyStrokeContext);
  this.$searchPanel.remove();
  scout.SearchOutline.parent.prototype._remove.call(this);
};

scout.SearchOutline.prototype._renderProperties = function() {
  scout.SearchOutline.parent.prototype._renderProperties.call(this);
  this._renderSearchQuery(this.searchQuery);
  this._renderSearchStatus(this.searchStatus);
  this._renderRequestFocusQueryField();
};

scout.SearchOutline.prototype._renderTitle = function() {
  scout.SearchOutline.parent.prototype._renderTitle.call(this);
  // Move before search panel
  if (this.titleVisible) {
    this.$title.insertBefore(this.$searchPanel);
  }
};

scout.SearchOutline.prototype._renderSearchQuery = function(searchQuery) {
  this.$queryField.val(searchQuery);
};

scout.SearchOutline.prototype._renderSearchStatus = function(searchStatus) {
  var animate = this.rendered;

  if (searchStatus && !this.$searchStatus.isVisible()) {
    if (animate) {
      this.$searchStatus.slideDown({
        duration: 200,
        progress: this.revalidateLayout.bind(this)
      });
    } else {
      this.$searchStatus.show();
    }
  } else if (!searchStatus && this.$searchStatus.isVisible()) {
    if (animate) {
      this.$searchStatus.slideUp({
        duration: 200,
        progress: this.revalidateLayout.bind(this)
      });
    } else {
      this.$searchStatus.hide();
    }
  }
  this.$searchStatus.textOrNbsp(searchStatus);
};

scout.SearchOutline.prototype._renderRequestFocusQueryField = function() {
  this.validateFocus();
};

scout.SearchOutline.prototype._triggerSearch = function() {
  this.trigger('search', {
    query: scout.nvl(this.searchQuery, '')
  });
};

scout.SearchOutline.prototype._onQueryFieldInput = function(event) {
  // Don't send query if value did not change (may happen when _onQueryFieldInput is executed after _onQueryFieldKeyPress)
  var searchQuery = this.$queryField.val();
  if (this.searchQuery !== searchQuery) {
    // Store locally so that the value persists when changing the outline without performing the search
    this._setSearchQuery(searchQuery);
    this._triggerSearch();
  }
};

scout.SearchOutline.prototype._onQueryFieldKeyPress = function(event) {
  if (event.which === scout.keys.ENTER) {
    this._setSearchQuery(this.$queryField.val());
    this._triggerSearch();
  }
};

scout.SearchOutline.prototype._setSearchQuery = function(searchQuery) {
  this.searchQuery = searchQuery;
};

/**
 * Focus and select content AFTER the search outline was rendered (and therefore the query field filled).
 *
 * @override Outline.js
 */
scout.SearchOutline.prototype.validateFocus = function() {
  var elementToFocus = this.$queryField[0];
  if (this.session.focusManager.requestFocus(elementToFocus)) {
    elementToFocus.select();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SearchOutlineAdapter = function() {
  scout.SearchOutlineAdapter.parent.call(this);
};
scout.inherits(scout.SearchOutlineAdapter, scout.OutlineAdapter);

scout.SearchOutlineAdapter.prototype._onWidgetSearch = function(event) {
  this._send('search', {
    query: event.query
  }, {
    showBusyIndicator: false
  });
};

scout.SearchOutlineAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'search') {
    this._onWidgetSearch(event);
  } else {
    scout.SearchOutlineAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SearchOutlineLayout = function(outline) {
  scout.SearchOutlineLayout.parent.call(this, outline);
  this.outline = outline;
};
scout.inherits(scout.SearchOutlineLayout, scout.OutlineLayout);

scout.SearchOutlineLayout.prototype._setDataHeight = function(heightOffset) {
  // Add search panel height to heightOffset
  var searchPanelSize = scout.graphics.getSize(this.outline.$searchPanel, true);
  heightOffset += searchPanelSize.height;

  scout.SearchOutlineLayout.parent.prototype._setDataHeight.call(this, heightOffset);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * The outline navigation works mostly browser-side. The navigation logic is implemented in JavaScript.
 * When a navigation button is clicked, we process that click browser-side first and send an event to
 * the server which nodes have been selected. We do that for better user experience. In a first attempt
 * the whole navigation logic was on the server, which caused a lag and flickering in the UI.
 *
 * @abstract
 */
scout.NavigateButton = function() {
  scout.NavigateButton.parent.call(this);

  this.node;
  this.outline;
  this._onClickFunc;
  this.selected = false;
  this.visible = true;
  this.enabled = true;
  this.mandatory = false;
  this.actionStyle = scout.Action.ActionStyle.BUTTON;
  /**
   * Additional CSS class to be applied in _render method.
   */
  this._additionalCssClass = '';
};
scout.inherits(scout.NavigateButton, scout.Menu);

scout.NavigateButton.prototype._init = function(options) {
  scout.NavigateButton.parent.prototype._init.call(this, options);

  this.node = options.node;
  this.outline = options.outline;
};

/**
 * @override
 */
scout.NavigateButton.prototype._render = function($parent) {
  if (this._isDetail()) {
    this._onClickFunc = this._setDetailVisible.bind(this);
  } else {
    this._onClickFunc = this._drill.bind(this);
  }
  if (this.overflow) {
    this.text = this.session.text(this._defaultText);
    this.iconId = null;
  } else {
    this.text = null;
    this.iconId = this._defaultIconId;
  }
  this.enabled = this._buttonEnabled();
  scout.NavigateButton.parent.prototype._render.call(this, $parent);
  this.$container.addClass('navigate-button small');
  this.$container.addClass(this._additionalCssClass);
  this.outline.keyStrokeContext.registerKeyStroke(this);
};

/**
 * @override Action.js
 */
scout.NavigateButton.prototype._remove = function() {
  scout.NavigateButton.parent.prototype._remove.call(this);
  this.outline.keyStrokeContext.unregisterKeyStroke(this);
};

scout.NavigateButton.prototype._setDetailVisible = function() {
  var detailVisible = this._toggleDetail();
  $.log.debug('show detail-' + detailVisible ? 'form' : 'table');
  this.outline.setDetailFormVisibleByUi(this.node, detailVisible);
};

/**
 * @override Menu.js
 */
scout.NavigateButton.prototype.doAction = function() {
  if (!this.prepareDoAction()) {
    return false;
  }
  this._onClickFunc();
  return true;
};

/**
 * Called when enabled state must be re-calculated and probably rendered.
 */
scout.NavigateButton.prototype.updateEnabled = function() {
  this.enabled = this._buttonEnabled();
  if (this.rendered) {
    this._renderEnabled();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.NavigateDownButton = function() {
  scout.NavigateDownButton.parent.call(this);
  this._defaultIconId = scout.icons.ANGLE_DOWN;
  this._defaultText = 'ui.Continue';
  this.iconId = this._defaultIconId;
  this.keyStroke = 'enter';
  this._detailTableRowsSelectedHandler = this._onDetailTableRowsSelected.bind(this);
};
scout.inherits(scout.NavigateDownButton, scout.NavigateButton);

scout.NavigateDownButton.prototype._init = function(options) {
  scout.NavigateDownButton.parent.prototype._init.call(this, options);

  if (this.node.detailTable) {
    this.node.detailTable.on('rowsSelected', this._detailTableRowsSelectedHandler);
  }
};

scout.NavigateDownButton.prototype.destroy = function() {
  if (this.node.detailTable) {
    this.node.detailTable.off('rowsSelected', this._detailTableRowsSelectedHandler);
  }
  scout.NavigateDownButton.parent.prototype.destroy.call(this);
};

scout.NavigateDownButton.prototype._render = function($parent) {
  scout.NavigateDownButton.parent.prototype._render.call(this, $parent);
  this.$container.addClass('down');
};

scout.NavigateDownButton.prototype._isDetail = function() {
  // Button is in "detail mode" if there are both detail form and detail table visible and detail form is _not_ hidden.
  return !!(this.node.detailFormVisible && this.node.detailForm &&
    this.node.detailTableVisible && this.node.detailTable && this.node.detailFormVisibleByUi);
};

scout.NavigateDownButton.prototype._toggleDetail = function() {
  return false;
};

scout.NavigateDownButton.prototype._buttonEnabled = function() {
  if (this._isDetail()) {
    return true;
  }
  if (this.node.leaf) {
    return false;
  }

  // when it's not a leaf and not a detail - the button is only enabled when a single row is selected
  var table = this.node.detailTable;
  if (table) {
    return table.selectedRows.length === 1;
  } else {
    return true;
  }
};

scout.NavigateDownButton.prototype._drill = function() {
  var drillNode;

  if (this.node.detailTable) {
    var row = this.node.detailTable.selectedRow();
    drillNode = this.node.pageForTableRow(row);
  } else {
    drillNode = this.node.childNodes[0];
  }

  if (drillNode) {
    $.log.debug('drill down to node ' + drillNode);
    // Collapse other expanded child nodes
    var parentNode = drillNode.parentNode;
    if (parentNode) {
      parentNode.childNodes.forEach(function(childNode) {
        if (childNode.expanded && childNode !== drillNode) {
          this.outline.collapseNode(childNode, {
            animateExpansion: false
          });
        }
      }.bind(this));
    }

    // Select the target node
    this.outline.selectNodes(drillNode); // this also expands the parent node, if required

    // If the parent node is a table page node, expand the drillNode
    // --> Same logic as in OutlineMediator.mediateTableRowAction()
    if (parentNode && parentNode.nodeType === scout.Page.NodeType.TABLE) {
      this.outline.expandNode(drillNode);
    }
  }
};

scout.NavigateDownButton.prototype._onDetailTableRowsSelected = function(event) {
  this.updateEnabled();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.NavigateUpButton = function() {
  scout.NavigateUpButton.parent.call(this);
  this._defaultIconId = scout.icons.ANGLE_UP;
  this._defaultText = 'ui.Up';
  this._additionalCssClass = 'small-gap';
  this.iconId = this._defaultIconId;
  this.keyStroke = 'backspace';
};
scout.inherits(scout.NavigateUpButton, scout.NavigateButton);

scout.NavigateUpButton.prototype._render = function($parent) {
  scout.NavigateUpButton.parent.prototype._render.call(this, $parent);
  this.$container.addClass('up');
};

scout.NavigateUpButton.prototype._isDetail = function() {
  // Button is in "detail mode" if there are both detail form and detail table visible and detail form _is_ hidden.
  return !!(this.node.detailFormVisible && this.node.detailForm &&
    this.node.detailTableVisible && this.node.detailTable && !this.node.detailFormVisibleByUi);
};

scout.NavigateUpButton.prototype._toggleDetail = function() {
  return true;
};

/**
 * Returns true when current node has either a parentNode or if current node is a
 * top-level node without a parent and the outline has a default detail-form.
 */
scout.NavigateUpButton.prototype._buttonEnabled = function() {
  var parentNode = this.node.parentNode;
  return !!parentNode || !!this.outline.defaultDetailForm || !!this.outline.outlineOverview;
};

scout.NavigateUpButton.prototype._drill = function() {
  var parentNode = this.node.parentNode;
  if (parentNode) {
    $.log.debug('drill up to node ' + parentNode);
    this.outline.navigateUpInProgress = true;
    this.outline.selectNodes(parentNode);
    this.outline.collapseNode(parentNode, {
      collapseChildNodes: true
    });
  } else {
    $.log.debug('drill up to top');
    this.outline.navigateToTop();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineKeyStrokeContext = function(outline) {
  scout.OutlineKeyStrokeContext.parent.call(this);
  this._outline = outline;
};

scout.inherits(scout.OutlineKeyStrokeContext, scout.KeyStrokeContext);

/**
 * Returns true if this event is handled by this context, and if so sets the propagation flags accordingly.
 */
scout.OutlineKeyStrokeContext.prototype.accept = function(event) {
  return !this._outline.inBackground && !this.isFormMenuOpen() && scout.OutlineKeyStrokeContext.parent.prototype.accept.call(this, event);
};

scout.OutlineKeyStrokeContext.prototype.isFormMenuOpen = function() {
  var menus = this._outline.session.desktop.menus;
  return menus.some(function(menu) {
    return menu.popup && menu.popup.$container && menu.popup.$container.isAttached();
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.OutlineNavigateToTopKeyStroke = function(tree, modifierBitMask) {
  scout.OutlineNavigateToTopKeyStroke.parent.call(this, tree, modifierBitMask);
  this.which = [scout.keys.HOME];
  this.renderingHints.hAlign = scout.hAlign.RIGHT;

  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.field.$title || this.field.$data;
  }.bind(this);
};
scout.inherits(scout.OutlineNavigateToTopKeyStroke, scout.AbstractTreeNavigationKeyStroke);

scout.OutlineNavigateToTopKeyStroke.prototype.handle = function(event) {
  this.field.navigateToTop();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.fields = {

  /**
   * @param $parent used to determine which HTML document is used to create the new HTML element
   * @returns an INPUT element as used in Scout forms.
   */
  makeTextField: function($parent, cssClass) {
    return $parent.makeElement('<input>', cssClass)
      .attr('type', 'text')
      .attr('autocomplete', 'false') /* use false instead of off, off is currently ignored in chrome, false should work with all major browsers*/
      .disableSpellcheck();
  },

  appendIcon: function($field, cssClass) {
    var $icon = $field.appendSpan('icon');
    if (cssClass) {
      $icon.addClass(cssClass);
    }
    return $icon;
  },

  initTouch: function(field, model) {
    field.embedded = scout.nvl(model.embedded, false);
    // when 'touch' is not set explicitly, check the device
    field.touch = scout.nvl(model.touch, scout.device.supportsTouch());
  },

  /**
   * Calls JQuery $.text() for touch-devices and $.val() for all other devices, used together with #makeInputOrDiv().
   * Works as setter when called with 3 arguments, works a getter when called with 2 arguments.
   *
   * @return when called with 2 arguments: $field.text() or $field.val()
   */
  valOrText: function(field, $field, text) {
    if (arguments.length === 3) {
      if (field.touch) {
        $field.text(text);
      } else {
        $field.val(text);
      }
    } else {
      return field.touch ? $field.text() : $field.val();
    }
  },

  /**
   * Creates a DIV element for touch-devices and an INPUT element for all other devices.
   */
  makeInputOrDiv: function(field, cssClass) {
    if (field.touch) {
      return field.$container.makeDiv(scout.strings.join(' ', 'input-field', cssClass));
    } else {
      return scout.fields.makeTextField(field.$container, cssClass);
    }
  },

  // note: the INPUT element does not process the click event when the field is disabled
  // however, the DIV element used in touch-mode does process the event anyway, that's
  // why this check is required.
  handleOnClick: function(field) {
    return field.enabledComputed && !field.embedded && !field.popup;
  }

};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AppLinkKeyStroke = function(field, appLinkTriggerFunction) {
  scout.AppLinkKeyStroke.parent.call(this);
  this.field = field;
  this.appLinkTriggerFunction = appLinkTriggerFunction;

  this.which = [scout.keys.SPACE];
  this.renderingHints.render = false;
};
scout.inherits(scout.AppLinkKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.AppLinkKeyStroke.prototype._accept = function(event) {
  var accepted = scout.AppLinkKeyStroke.parent.prototype._accept.call(this, event);
  return accepted && $(event.target).hasClass('app-link');
};

/**
 * @override KeyStroke.js
 */
scout.AppLinkKeyStroke.prototype.handle = function(event) {
  this.appLinkTriggerFunction.call(this.field, event);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Abstract class for all form-fields.
 * @abstract
 */
scout.FormField = function() {
  scout.FormField.parent.call(this);
  this.keyStrokes = [];
  this.labelVisible = true;
  this.labelPosition = scout.FormField.LABEL_POSITION_DEFAULT;
  this.labelWidthInPixel = 0;
  this.mandatory = false;
  this.statusVisible = true;
  this.statusPosition = scout.FormField.STATUS_POSITION_DEFAULT;
  this.menus = [];
  this.menusVisible = false;
  this.gridData;
  this.$label;

  /**
   * Note the difference between $field and $fieldContainer:
   * - $field points to the input-field (typically a browser-text field)
   * - $fieldContainer could point to the same input-field or when the field is a composite,
   *   to the parent DIV of that composite. For instance: the multi-line-smartfield is a
   *   composite with a input-field and a DIV showing the additional lines. In that case $field
   *   points to the input-field and $fieldContainer to the parent DIV of the input-field.
   *   This property should be used primarily for layout-functionality.
   */
  this.$field;
  this.$fieldContainer;

  /**
   * The computed enabled state. The difference to the 'enabled' property is that this member also considers the enabled-states of the parent widgets.
   */
  this.enabledComputed = true;

  /**
   * The status label is used for error-status, tooltip-icon and menus.
   */
  this.$status;
  this._addAdapterProperties(['keyStrokes', 'menus']);
  this._addCloneProperties(['displayText']);
  this.mode = scout.FormField.MODE_DEFAULT;
  this.touched = false;
  this.requiresSave = false;
  this.empty = true;
  this.preventInitialFocus = false;

  /**
   * Some browsers don't support copying text from disabled input fields. If such a browser is detected
   * and this flag is true (defaul is false), an overlay DIV is rendered over disabled fields which
   * provides a custom copy context menu that opens the ClipboardForm.
   */
  this.disabledCopyOverlay = false;
  this.$disabledCopyOverlay;
};
scout.inherits(scout.FormField, scout.Widget);

scout.FormField.LABEL_POSITION_DEFAULT = 0;
scout.FormField.LABEL_POSITION_LEFT = 1;
scout.FormField.LABEL_POSITION_ON_FIELD = 2;
scout.FormField.LABEL_POSITION_RIGHT = 3;
scout.FormField.LABEL_POSITION_TOP = 4;

scout.FormField.STATUS_POSITION_DEFAULT = 'default';
scout.FormField.STATUS_POSITION_TOP = 'top';

// see org.eclipse.scout.rt.client.ui.form.fields.IFormField.FULL_WIDTH
scout.FormField.FULL_WIDTH = 0;

/**
 * Indicates the field to be used in default mode, e.g. in a Form.
 */
scout.FormField.MODE_DEFAULT = 'default';

/**
 * Indicates the field to be used within a cell editor.
 */
scout.FormField.MODE_CELLEDITOR = 'celleditor';

/**
 * @override
 */
scout.FormField.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.FormField.prototype._createLoadingSupport = function() {
  return new scout.LoadingSupport({
    widget: this
  });
};

scout.FormField.prototype._init = function(model) {
  scout.FormField.parent.prototype._init.call(this, model);
  this.resolveTextKeys(['label']);
  this._syncKeyStrokes(this.keyStrokes);
  this._syncMenus(this.menus);
  this._syncErrorStatus(this.errorStatus);
  this._syncGridData(this.gridData);
  this._syncEnabled(this.enabled);
  this._updateEmpty();
};

/**
 * All sub-classes of scout.FormField must implement a _render method. The default implementation
 * will throw an Error when _render is called. The _render method should call the various add*
 * methods provided by the FormField class. A possible _render implementation could look like this.
 *
 * <pre>
 * this.addContainer($parent, 'form-field');
 * this.addLabel();
 * this.addField($parent.makeDiv('foo', 'bar'));
 * this.addMandatoryIndicator();
 * this.addStatus();
 * </pre>
 */
scout.FormField.prototype._render = function($parent) {
  throw new Error('sub-classes of scout.FormField must implement a _render method');
};

scout.FormField.prototype._renderProperties = function() {
  scout.FormField.parent.prototype._renderProperties.call(this);
  this._renderMandatory();
  this._renderTooltipText();
  this._renderErrorStatus();
  this._renderMenus();
  this._renderLabel();
  this._renderLabelVisible();
  this._renderStatusVisible();
  this._renderStatusPosition();
  this._renderFont();
  this._renderForegroundColor();
  this._renderBackgroundColor();
  this._renderLabelFont();
  this._renderLabelForegroundColor();
  this._renderLabelBackgroundColor();
  this._renderGridData();
  this._renderPreventInitialFocus();
};

scout.FormField.prototype._remove = function() {
  scout.FormField.parent.prototype._remove.call(this);
  this._removeField();
  this._removeStatus();
  this._removeLabel();
  this._removeDisabledCopyOverlay();
  this._uninstallDragAndDropHandler();
};

scout.FormField.prototype._renderMandatory = function() {
  this.$container.toggleClass('mandatory', this.mandatory);
};

scout.FormField.prototype._renderErrorStatus = function() {
  var hasStatus = !!this.errorStatus,
    statusClass = hasStatus ? this.errorStatus.cssClass() : '';

  this.$container.removeClass(scout.Status.cssClasses);
  this.$container.addClass(statusClass, hasStatus);
  if (this.$field) {
    this.$field.removeClass(scout.Status.cssClasses);
    this.$field.addClass(statusClass, hasStatus);
  }

  this._updateStatusVisible();
  if (hasStatus) {
    this._showStatusMessage();
  } else {
    this._hideStatusMessage();
  }
};

scout.FormField.prototype._renderTooltipText = function() {
  var tooltipText = this.tooltipText;
  var hasTooltipText = scout.strings.hasText(tooltipText);
  this.$container.toggleClass('has-tooltip', hasTooltipText);
  if (this.$field) {
    this.$field.toggleClass('has-tooltip', hasTooltipText);
  }
  this._updateStatusVisible();
};

/**
 * @override
 */
scout.FormField.prototype._renderVisible = function() {
  this.$container.setVisible(this.visible);
  if (this.rendered) {
    var htmlCompParent = this.htmlComp.getParent();
    if (htmlCompParent) { // may be null if $container is detached
      htmlCompParent.invalidateLayoutTree();
    }
  }
};

scout.FormField.prototype._renderLabel = function() {
  var label = this.label;
  if (this.labelPosition === scout.FormField.LABEL_POSITION_ON_FIELD) {
    this._renderPlaceholder();
    if (this.$label) {
      this.$label.text('');
    }
  } else if (this.$label) {
    this._removePlaceholder();
    // Make sure an empty label is as height as the other labels, especially important for top labels
    this.$label.textOrNbsp(label, 'empty');

    // Invalidate layout if label width depends on its content
    if (this.labelUseUiWidth) {
      this.invalidateLayoutTree();
    }
  }
};

scout.FormField.prototype._renderPlaceholder = function($field) {
  $field = scout.nvl($field, this.$field);
  if ($field) {
    $field.placeholder(this.label);
  }
};

/**
 * @param $field (optional) argument is required by DateField.js, when not set this.$field is used
 */
scout.FormField.prototype._removePlaceholder = function($field) {
  $field = scout.nvl($field, this.$field);
  if ($field) {
    $field.placeholder('');
  }
};

scout.FormField.prototype._renderLabelVisible = function() {
  var visible = this.labelVisible;
  this._renderChildVisible(this.$label, visible);
  this.$container.toggleClass('label-hidden', !visible);
};

scout.FormField.prototype._renderStatusVisible = function() {
  var statusVisible = this.statusVisible;
  this._renderChildVisible(this.$status, this._computeStatusVisible());
  // Pseudo status is only for layouting purpose, therefore tooltip, errorStatus etc. must not influence its visibility -> not necessary to use _computeStatusVisible
  this._renderChildVisible(this.$pseudoStatus, statusVisible);

  // Make sure tooltip gets destroyed if there is no status anymore (tooltip points to the status)
  if (this.$status && !this.$status.isVisible() && this.tooltip) {
    this.tooltip.destroy();
  }
};

scout.FormField.prototype._renderStatusPosition = function() {
  this.invalidateLayoutTree();
};

/**
 * Visibility of the status not only depends on this.statusVisible but on other attributes as well, computed by _computeStatusVisible.
 * Call this method if any of the conditions change to recompute the status visibility.
 */
scout.FormField.prototype._updateStatusVisible = function() {
  if (!this.statusVisible) {
    this._renderStatusVisible();
  }
};

/**
 * Computes whether the $status should be visible based on statusVisible, errorStatus and tooltip.
 * -> errorStatus and tooltip override statusVisible, so $status may be visible event though statusVisible is set to false
 */
scout.FormField.prototype._computeStatusVisible = function() {
  var statusVisible = this.statusVisible,
    hasStatus = !!this.errorStatus,
    hasTooltip = !!this.tooltipText;

  return !this.suppressStatus && (statusVisible || hasStatus || hasTooltip || (this._hasMenus() && this.menusVisible));
};

scout.FormField.prototype._renderChildVisible = function($child, visible) {
  if (!$child) {
    return;
  }
  if ($child.isVisible() !== visible) {
    $child.setVisible(visible);
    this.invalidateLayoutTree();
    return true;
  }
};

// Don't include in renderProperties, it is not necessary to execute it initially because the positioning is done by _renderLabel
scout.FormField.prototype._renderLabelPosition = function(position) {
  this._renderLabel();
};

scout.FormField.prototype._syncEnabled = function(enabled) {
  this._setProperty('enabled', enabled);
  var parentEnabled = enabled;
  if (this.parent.initialized && this.parent.enabledComputed !== undefined) {
    parentEnabled = this.parent.enabledComputed;
  }
  this.recomputeEnabled(parentEnabled);
};

/**
 * @override
 */
scout.FormField.prototype._renderEnabled = function() {
  scout.FormField.parent.prototype._renderEnabled.call(this);
  this._updateDisabledCopyOverlay();
  if (this.$field) {
    this.$field.setEnabled(this.enabledComputed);
  }
};

/**
 * @override Wigdet.js
 */
scout.FormField.prototype._renderDisabledStyle = function() {
  this._renderDisabledStyleInternal(this.$field);
  this._renderDisabledStyleInternal(this.$mandatory);
};

scout.FormField.prototype._renderFont = function() {
  scout.styles.legacyStyle(this, this.$field);
};

scout.FormField.prototype._renderForegroundColor = function() {
  scout.styles.legacyStyle(this, this.$field);
};

scout.FormField.prototype._renderBackgroundColor = function() {
  scout.styles.legacyStyle(this, this.$field);
};

scout.FormField.prototype._renderLabelFont = function() {
  scout.styles.legacyStyle(this, this.$label, 'label');
};

scout.FormField.prototype._renderLabelForegroundColor = function() {
  scout.styles.legacyStyle(this, this.$label, 'label');
};

scout.FormField.prototype._renderLabelBackgroundColor = function() {
  scout.styles.legacyStyle(this, this.$label, 'label');
};

scout.FormField.prototype._renderGridData = function() {
  this.invalidateLayoutTree();
};

scout.FormField.prototype._renderMenus = function() {
  this._updateMenus();
};

scout.FormField.prototype._renderMenusVisible = function() {
  this._updateMenus();
};

scout.FormField.prototype._renderPreventInitialFocus = function() {
  this.$container.toggleClass('prevent-initial-focus', !!this.preventInitialFocus);
};

scout.FormField.prototype._getCurrentMenus = function() {
  var menuTypes;
  if (this.currentMenuTypes) {
    menuTypes = [];
    this.currentMenuTypes.forEach(function(elem) {
      menuTypes.push('ValueField.' + elem);
    }, this);
  }
  return menuTypes ? scout.menus.filter(this.menus, menuTypes) : this.menus.filter(function(menu) {
    return menu.visible;
  });
};

scout.FormField.prototype._hasMenus = function() {
  return !!(this.menus && this._getCurrentMenus().length > 0);
};

scout.FormField.prototype._updateMenus = function() {
  this._updateStatusVisible();
  this.$container.toggleClass('has-menus', this._hasMenus() && this.menusVisible);
};

scout.FormField.prototype._syncGridData = function(gridData) {
  this._setProperty('gridData', new scout.GridData(gridData));
};

scout.FormField.prototype._syncKeyStrokes = function(keyStrokes) {
  this.updateKeyStrokes(keyStrokes, this.keyStrokes);
  this._setProperty('keyStrokes', keyStrokes);
};

scout.FormField.prototype._syncMenus = function(menus) {
  this.updateKeyStrokes(menus, this.menus);
  this._setProperty('menus', menus);
};

scout.FormField.prototype._syncErrorStatus = function(errorStatus) {
  errorStatus = scout.Status.ensure(errorStatus);
  this._setProperty('errorStatus', errorStatus);
};

scout.FormField.prototype.setLabel = function(label) {
  this.setProperty('label', label);
};

scout.FormField.prototype.setTooltipText = function(tooltipText) {
  this.setProperty('tooltipText', tooltipText);
};

/**
 * Changes the enabled property of this form field to the given value.
 * @param enabled
 *          Required. The new enabled value
 * @param updateParents
 *          (optional) If true the enabled property of all parent form fields are updated to same value as well.
 * @param updateChildren
 *          (optional) If true the enabled property of all child form fields (recursive) are updated to same value as well.
 */
scout.FormField.prototype.setEnabled = function(enabled, updateParents, updateChildren) {
  scout.FormField.parent.prototype.setEnabled.call(this, enabled);

  if (enabled && updateParents) {
    this.visitParents(function(field) {
      field.setEnabled(true);
    });
  }

  if (updateChildren) {
    this.visit(function(field) {
      field.setEnabled(enabled);
    });
  }
};

scout.FormField.prototype.setErrorStatus = function(errorStatus) {
  this.setProperty('errorStatus', errorStatus);
};

scout.FormField.prototype.setMenus = function(menus) {
  this.setProperty('menus', menus);
};

scout.FormField.prototype.setMenusVisible = function(menusVisible) {
  this.setProperty('menusVisible', menusVisible);
};

scout.FormField.prototype.setMandatory = function(mandatory) {
  this.setProperty('mandatory', mandatory);
};

/**
 * Sets the focus on this field if the field is rendered.
 */
scout.FormField.prototype.focus = function() {
  if (!this.rendered) {
    return;
  }
  if (this.$field) {
    this.session.focusManager.requestFocus(this.$field[0]);
  } else {
    var element = this.session.focusManager.findFirstFocusableElement(this.$container);
    this.session.focusManager.requestFocus(element);
  }
};

scout.FormField.prototype.recomputeEnabled = function(parentEnabled) {
  this.enabledComputed = this.enabled && parentEnabled;

  if (this.rendered) {
    this._renderEnabled(); // refresh
  }
};

scout.FormField.prototype._onStatusMousedown = function(event) {
  // showing menus is more important than showing tooltips
  if (this.menusVisible && this._hasMenus()) {
    var func = function func(event) {
      var menus = this._getCurrentMenus();
      // Toggle menu
      if (this.contextPopup && this.contextPopup.rendered) {
        this.contextPopup.close();
        this.contextPopup = null;
      } else {
        if (!menus.some(function(menuItem) {
            return menuItem.visible;
          })) {
          return; // at least one menu item must be visible
        }
        this.contextPopup = scout.create('ContextMenuPopup', {
          parent: this,
          $anchor: this.$status,
          menuItems: menus,
          cloneMenuItems: false,
          closeOnAnchorMousedown: false
        });
        this.contextPopup.open();
      }
    }.bind(this);

    scout.menus.showContextMenuWithWait(this.session, func, event);
  } else {
    // Toggle tooltip
    if (this.tooltip) {
      this._hideStatusMessage();
    } else {
      this._showStatusMessage();
    }
  }
};

scout.FormField.prototype._showStatusMessage = function() {
  // Don't show a tooltip if there is no visible $status (tooltip points to the status)
  if (!this.$status || !this.$status.isVisible()) {
    return;
  }

  var opts,
    text = this.tooltipText,
    severity = scout.Status.OK,
    autoRemove = true;

  if (this.errorStatus) {
    text = this.errorStatus.message;
    severity = this.errorStatus.severity;
    autoRemove = !(this.errorStatus && this.errorStatus.isError());
    if (this.tooltip && this.tooltip.autoRemove !== autoRemove) {
      // AutoRemove may not be changed dynamically -> Remove and reopen tooltip
      this.tooltip.destroy();
    }

    // If the field is used as a cell editor in a editable table, then no validation errors should be shown.
    // (parsing and validation will be handled by the cell/column itself)
    if (this.mode === scout.FormField.MODE_CELLEDITOR) {
      return;
    }
  }

  if (scout.strings.empty(text)) {
    // Refuse to show empty tooltip
    return;
  }

  if (this.tooltip) {
    // update existing tooltip
    this.tooltip.setText(text);
    this.tooltip.setSeverity(severity);
  } else {
    // create new tooltip
    opts = {
      parent: this,
      text: text,
      severity: severity,
      autoRemove: autoRemove,
      $anchor: this.$status
    };
    this.tooltip = scout.create('Tooltip', opts);
    this.tooltip.one('destroy', function() {
      this.tooltip = null;
    }.bind(this));
    this.tooltip.render();
  }
};

scout.FormField.prototype._hideStatusMessage = function() {
  if (this.tooltip) {
    this.tooltip.destroy();
  }
};

/**
 * This method returns the HtmlElement to be used as initial focus element.
 * It can be overridden, in case the FormField needs to return something other than this.$field[0].
 */
scout.FormField.prototype.getFocusableElement = function() {
  if (this.rendered) {
    return this.$field[0];
  }
  return null;
};

scout.FormField.prototype.getForm = function() {
  var parent = this.parent;
  while (parent && !(parent instanceof scout.Form)) {
    parent = parent.parent;
  }
  return parent;
};

scout.FormField.prototype.getParentGroupBox = function() {
  var parent = this.parent;
  while (parent && !(parent instanceof scout.GroupBox)) {
    parent = parent.parent;
  }
  return parent;
};

scout.FormField.prototype.getParentField = function() {
  return this.parent;
};

/**
 * Appends a LABEL element to this.$container and sets the this.$label property.
 */
scout.FormField.prototype.addLabel = function() {
  this.$label = this.$container.appendElement('<label>');
  scout.tooltips.installForEllipsis(this.$label, {
    parent: this
  });
};

scout.FormField.prototype._removeLabel = function() {
  if (!this.$label) {
    return;
  }
  this.$label.remove();
  this.$label = null;
};

/**
 * Appends the given field to the this.$container and sets the property this.$field.
 * The $field is used as $fieldContainer as long as you don't explicitly call addFieldContainer before calling addField.
 */
scout.FormField.prototype.addField = function($field) {
  if (!this.$fieldContainer) {
    this.addFieldContainer($field);
  }
  this.$field = $field;
};

/**
 * Call this method before addField if you'd like to have a different field container than $field.
 */
scout.FormField.prototype.addFieldContainer = function($fieldContainer) {
  this.$fieldContainer = $fieldContainer
    .addClass('field')
    .appendTo(this.$container);
};

/**
 * Removes this.$field and this.$fieldContainer and sets the properties to null.
 */
scout.FormField.prototype._removeField = function() {
  if (this.$field) {
    this.$field.remove();
    this.$field = null;
  }
  if (this.$fieldContainer) {
    this.$fieldContainer.remove();
    this.$fieldContainer = null;
  }
};

/**
 * Appends a SPAN element for form-field status to this.$container and sets the this.$status property.
 */
scout.FormField.prototype.addStatus = function() {
  if (this.$status) {
    return;
  }
  this.$status = this.$container
    .appendSpan('status')
    .on('mousedown', this._onStatusMousedown.bind(this));
};

scout.FormField.prototype._removeStatus = function() {
  this._hideStatusMessage();
  if (!this.$status) {
    return;
  }
  this.$status.remove();
  this.$status = null;
};

/**
 * Appends a SPAN element to this.$container and sets the this.$pseudoStatus property.
 * The purpose of a pseudo status is to consume the space an ordinary status would.
 * This makes it possible to make components without a status as width as components with a status.
 */
scout.FormField.prototype.addPseudoStatus = function() {
  this.$pseudoStatus = this.$container.appendSpan('status');
};

scout.FormField.prototype.addMandatoryIndicator = function() {
  this.$mandatory = this.$container.appendSpan('mandatory-indicator');
};

scout.FormField.prototype.removeMandatoryIndicator = function() {
  this.$mandatory.remove();
  this.$mandatory = null;
};

/**
 * Adds a SPAN element with class 'icon' the the given optional $parent.
 * When $parent is not set, the element is added to this.$container.
 * @param $parent (optional)
 */
scout.FormField.prototype.addIcon = function($parent) {
  if (!$parent) {
    $parent = this.$container;
  }
  this.$icon = scout.fields.appendIcon($parent)
    .click(this._onIconClick.bind(this));
};

scout.FormField.prototype._onIconClick = function(event) {
  this.$field.focus();
};

/**
 * Appends a DIV element as form-field container to $parent and sets the this.$container property.
 * Applies FormFieldLayout to this.$container (if container does not define another layout).
 * Sets this.htmlComp to the HtmlComponent created for this.$container.
 *
 * @param $parent to which container is appended
 * @param cssClass cssClass to add to the new container DIV
 * @param layout when layout is undefined, scout.FormFieldLayout() is set
 *
 */
scout.FormField.prototype.addContainer = function($parent, cssClass, layout) {
  this.$container = $parent.appendDiv('form-field');
  if (cssClass) {
    this.$container.addClass(cssClass);
  }
  var htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  htmlComp.setLayout(layout || new scout.FormFieldLayout(this));
  this.htmlComp = htmlComp;
};

/**
 * Updates the "inner alignment" of a field. Usually, the GridData hints only have influence on the
 * LogicalGridLayout. However, the properties "horizontalAlignment" and "verticalAlignment" are
 * sometimes used differently. Instead of controlling the field alignment in case fillHorizontal/
 * fillVertical is false, the developer expects the _contents_ of the field to be aligned correspondingly
 * inside the field. Technically, this is not correct, but is supported for legacy and convenience
 * reasons for some of the Scout fields. Those who support the behavior may override _renderGridData()
 * and call this method. Some CSS classes are then added to the field.
 *
 * opts:
 *   useHorizontalAlignment:
 *     When this option is true, "halign-" classes are added according to gridData.horizontalAlignment.
 *   useVerticalAlignment:
 *     When this option is true, "valign-" classes are added according to gridData.verticalAlignment.
 *   $fieldContainer:
 *     Specifies the div where the classes should be added. If omitted, this.$fieldContainer is used.
 */
scout.FormField.prototype.updateInnerAlignment = function(opts) {
  opts = opts || {};
  var useHorizontalAlignment = scout.nvl(opts.useHorizontalAlignment, true);
  var useVerticalAlignment = scout.nvl(opts.useVerticalAlignment, true);
  var $fieldContainer = opts.$fieldContainer || this.$fieldContainer;

  if ($fieldContainer) {
    $fieldContainer.removeClass('has-inner-alignment halign-left halign-center halign-right valign-top valign-middle valign-bottom');
    if (useHorizontalAlignment || useVerticalAlignment) {
      // Set horizontal and vertical alignment (from gridData)
      $fieldContainer.addClass('has-inner-alignment');
      if (useHorizontalAlignment) {
        var hAlign = this.gridData.horizontalAlignment;
        $fieldContainer.addClass(hAlign < 0 ? 'halign-left' : (hAlign > 0 ? 'halign-right' : 'halign-center'));
      }
      if (useVerticalAlignment) {
        var vAlign = this.gridData.verticalAlignment;
        $fieldContainer.addClass(vAlign < 0 ? 'valign-top' : (vAlign > 0 ? 'valign-bottom' : 'valign-middle'));
      }
    }
  }
};

scout.FormField.prototype.prepareForCellEdit = function(opts) {
  opts = opts || {};

  // remove mandatory and status indicators (popup should 'fill' the whole cell)
  if (this.$mandatory) {
    this.removeMandatoryIndicator();
  }
  if (this.$status) {
    this.$status.remove();
    this.$status = null;
  }
  if (this.$container) {
    this.$container.addClass('cell-editor-form-field');
  }
  if (this.$field) {
    this.$field.addClass('cell-editor-field');
    if (opts.firstCell) {
      this.$field.addClass('first');
    }
  }
};

scout.FormField.prototype._renderDropType = function() {
  if (this.dropType) {
    this._installDragAndDropHandler();
  } else {
    this._uninstallDragAndDropHandler();
  }
};

scout.FormField.prototype._createDragAndDropHandler = function() {
  return scout.dragAndDrop.handler(this, {
    supportedScoutTypes: scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,
    dropType: function() {
      return this.dropType;
    }.bind(this),
    dropMaximumSize: function() {
      return this.dropMaximumSize;
    }.bind(this)
  });
};

scout.FormField.prototype._installDragAndDropHandler = function(event) {
  if (this.dragAndDropHandler) {
    return;
  }
  this.dragAndDropHandler = this._createDragAndDropHandler();
  this.dragAndDropHandler.install(this.$field);
};

scout.FormField.prototype._uninstallDragAndDropHandler = function(event) {
  if (!this.dragAndDropHandler) {
    return;
  }
  this.dragAndDropHandler.uninstall();
  this.dragAndDropHandler = null;
};

scout.FormField.prototype._updateDisabledCopyOverlay = function() {
  if (this.disabledCopyOverlay && !scout.device.supportsCopyFromDisabledInputFields()) {
    if (this.enabledComputed) {
      this._removeDisabledCopyOverlay();
    } else {
      this._renderDisabledCopyOverlay();
      this.revalidateLayout(); // because bounds of overlay is set in FormFieldLayout
    }
  }
};

scout.FormField.prototype._renderDisabledCopyOverlay = function() {
  if (!this.$disabledCopyOverlay) {
    this.$disabledCopyOverlay = this.$container
      .appendDiv('disabled-overlay')
      .on('contextmenu', this._createCopyContextMenu.bind(this));
  }
};

scout.FormField.prototype._removeDisabledCopyOverlay = function() {
  if (this.$disabledCopyOverlay) {
    this.$disabledCopyOverlay.remove();
    this.$disabledCopyOverlay = null;
  }
};

scout.FormField.prototype._createCopyContextMenu = function(event) {
  if (!this.visible || scout.strings.empty(this.displayText)) {
    return;
  }

  var field = this;
  var menu = scout.create('Menu', {
    parent: this,
    text: this.session.text('ui.Copy')
  });
  menu.on('doAction', function(event) {
    if (field instanceof scout.ValueField) {
      // FIXME CGU [6.1] offline?
      field.trigger('exportToClipboard');
    }
  });

  var popup = scout.create('ContextMenuPopup', {
    parent: this,
    menuItems: [menu],
    cloneMenuItems: false,
    location: {
      x: event.pageX,
      y: event.pageY
    },
    $anchor: this._$disabledOverlay
  });
  popup.open();
};

scout.FormField.prototype.visit = function(visitor) {
  visitor(this);
};

/**
 * Visit all parent form fields. The visit stops if the parent is no form field anymore (e.g. a form, desktop or session).
 */
scout.FormField.prototype.visitParents = function(visitor) {
  var curParent = this.parent;
  while (curParent instanceof scout.FormField) {
    visitor(curParent);
    curParent = curParent.parent;
  }
};

scout.FormField.prototype.markAsSaved = function() {
  this.touched = false;
  this.updateRequiresSave();
};

/**
 * Updates the requiresSave property by checking if the field is touched or if computeRequiresSave() returns true.
 */
scout.FormField.prototype.updateRequiresSave = function() {
  if (!this.initialized) {
    return;
  }
  this.requiresSave = this.touched || this.computeRequiresSave();
};

/**
 * Override this function in order to return whether or not this field requires to be saved.
 * The default impl. returns false.
 *
 * @returns {boolean}
 */
scout.FormField.prototype.computeRequiresSave = function() {
  return false;
};

scout.FormField.prototype.validate = function() {
  var validByErrorStatus = !this.errorStatus;
  var validByMandatory = !this.mandatory || !this.empty;
  var valid = validByErrorStatus && validByMandatory;
  return {
    valid: valid,
    validByErrorStatus: validByErrorStatus,
    validByMandatory: validByMandatory
  };
};

scout.FormField.prototype._updateEmpty = function() {
  // NOP
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FormFieldAdapter = function() {
  scout.FormFieldAdapter.parent.call(this);

  /**
   * Set this property to true when the form-field should stay enabled in offline case.
   * By default the field will be disabled.
   */
  this.enabledWhenOffline = false;

  this._addAdapterProperties(['keyStrokes', 'menus']);
};
scout.inherits(scout.FormFieldAdapter, scout.ModelAdapter);

scout.FormFieldAdapter.prototype._goOffline = function() {
  if (this.enabledWhenOffline) {
    return;
  }
  this._enabledBeforeOffline = this.widget.enabled;
  this.widget.setEnabled(false);
};

scout.FormFieldAdapter.prototype._goOnline = function() {
  if (this.enabledWhenOffline) {
    return;
  }
  this.widget.setEnabled(this._enabledBeforeOffline);
};

scout.FormFieldAdapter.prototype._onWidgetExportToClipboard = function(event) {
  this._send('exportToClipboard');
};

scout.FormFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'exportToClipboard') {
    this._onWidgetExportToClipboard(event);
  } else {
    scout.FormFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Form-Field Layout, for a form-field with label, status, mandatory-indicator and a field.
 * This layout class works with a FormField instance, since we must access properties of the model.
 * Note: we use optGet() here, since some form-fields have only a bare HTML element as field, other
 * (composite) form-fields work with a HtmlComponent which has its own LayoutManager.
 */
scout.FormFieldLayout = function(formField) {
  scout.FormFieldLayout.parent.call(this);
  this.formField = formField;
  this.mandatoryIndicatorWidth = scout.HtmlEnvironment.fieldMandatoryIndicatorWidth;
  this.statusWidth = scout.HtmlEnvironment.fieldStatusWidth;
  this.rowHeight = scout.HtmlEnvironment.formRowHeight;

  // use configured label width in pixel or default label width
  if (scout.FormFieldLayout.LABEL_WIDTH_DEFAULT === formField.labelWidthInPixel) {
    this.labelWidth = scout.HtmlEnvironment.fieldLabelWidth;
  } else {
    this.labelWidth = formField.labelWidthInPixel;
  }
};
scout.inherits(scout.FormFieldLayout, scout.AbstractLayout);

//Minimum field with to normal state, for smaller widths the "compact" style is applied.
scout.FormFieldLayout.MIN_FIELD_WIDTH = 50;

scout.FormFieldLayout.LABEL_WIDTH_DEFAULT = 0;

scout.FormFieldLayout.prototype.layout = function($container) {
  var containerPadding, fieldOffset, fieldSize, fieldBounds, htmlField, labelHasFieldWidth, top, bottom, left, right,
    htmlContainer = scout.HtmlComponent.get($container),
    formField = this.formField,
    labelWidth = this.labelWidth,
    statusWidth = this.statusWidth;

  // Note: Position coordinates start _inside_ the border, therefore we only use the padding
  containerPadding = htmlContainer.getInsets({
    includeBorder: false
  });
  top = containerPadding.top;
  right = containerPadding.right;
  bottom = containerPadding.bottom;
  left = containerPadding.left;

  if (this._isLabelVisible()) {
    // currently a gui only flag, necessary for sequencebox
    if (formField.labelUseUiWidth) {
      if (formField.$label.hasClass('empty')) {
        labelWidth = 0;
      } else {
        labelWidth = scout.graphics.prefSize(formField.$label, {
          includeMargin: true
        }).width;
      }
    }
    if (scout.isOneOf(formField.labelPosition, scout.FormField.LABEL_POSITION_DEFAULT, scout.FormField.LABEL_POSITION_LEFT)) {
      scout.graphics.setBounds(formField.$label, top, left, labelWidth, this.rowHeight);
      left += labelWidth;
    } else if (formField.labelPosition === scout.FormField.LABEL_POSITION_TOP) {
      formField.$label.cssHeight(this.rowHeight);
      top += formField.$label.outerHeight(true);
      labelHasFieldWidth = true;
    }
  }
  if (formField.$mandatory) {
    formField.$mandatory
      .cssTop(top)
      .cssLeft(left)
      .cssWidth(this.mandatoryIndicatorWidth);
    left += formField.$mandatory.outerWidth(true);
  }
  if (this._isStatusVisible()) {
    formField.$status
      .cssWidth(statusWidth);
    // If both status and label position is "top", pull status up (without margin on the right side)
    if (formField.statusPosition === scout.FormField.STATUS_POSITION_TOP && labelHasFieldWidth) {
      var statusHeight = scout.graphics.prefSize(formField.$status).height;
      // Vertically center status with label
      var statusTop = containerPadding.top + formField.$label.cssPaddingTop() + (formField.$label.height() / 2) - (statusHeight / 2);
      formField.$status
        .cssTop(statusTop)
        .cssRight(right + formField.$label.cssMarginRight())
        .cssHeight(statusHeight);
      // Add padding to label to prevent overlay of text and status icon
      var w = scout.graphics.getSize(formField.$status, true).width;
      formField.$label.css('padding-right', w + 'px');
    } else {
      // Default status position
      formField.$status
        .cssTop(top)
        .cssRight(right)
        .cssHeight(this.rowHeight)
        .cssLineHeight(this.rowHeight);
      right += statusWidth + formField.$status.cssMarginX();
    }
  }

  if (formField.$fieldContainer) {
    // Calculate the additional field offset (because of label, mandatory indicator etc.) without the containerInset.
    fieldOffset = new scout.Insets(
      top - containerPadding.top,
      right - containerPadding.right,
      bottom - containerPadding.bottom,
      left - containerPadding.left);
    // Calculate field size: "available size" - "insets (border and padding)" - "additional offset" - "field's margin"
    var fieldMargins = scout.graphics.getMargins(formField.$fieldContainer);
    fieldSize = htmlContainer.getAvailableSize()
      .subtract(htmlContainer.getInsets())
      .subtract(fieldOffset)
      .subtract(fieldMargins);
    fieldBounds = new scout.Rectangle(left, top, fieldSize.width, fieldSize.height);
    if (formField.$fieldContainer.css('position') !== 'absolute') {
      fieldBounds.x = 0;
      fieldBounds.y = 0;
    }
    htmlField = scout.HtmlComponent.optGet(formField.$fieldContainer);
    if (htmlField) {
      htmlField.setBounds(fieldBounds);
    } else {
      scout.graphics.setBounds(formField.$fieldContainer, fieldBounds);
    }
    formField.$field.toggleClass('compact', fieldBounds.width < scout.FormFieldLayout.MIN_FIELD_WIDTH);

    if (labelHasFieldWidth) {
      formField.$label.cssWidth(fieldSize.add(fieldMargins).width - formField.$label.cssMarginX());
    }
  }

  // Icon is placed inside the field (as overlay)
  if (formField.$icon && formField.$field) {
    this._layoutIcon(formField, fieldBounds, right, top);
  }

  // Make sure tooltip is at correct position after layouting, if there is one
  if (formField.tooltip && formField.tooltip.rendered) {
    formField.tooltip.position();
  }

  // Check for scrollbars, update them if neccessary
  if (formField.$field) {
    scout.scrollbars.update(formField.$field);
  }

  this._layoutDisabledCopyOverlay();
};

scout.FormFieldLayout.prototype._layoutDisabledCopyOverlay = function() {
  if (this.formField.$field && this.formField.$disabledCopyOverlay) {
    var $overlay = this.formField.$disabledCopyOverlay;
    var $field = this.formField.$field;

    var pos = $field.position();
    var padding = scout.graphics.getInsets($field, {
        includePadding: true
      });

    // subtract scrollbars sizes from width and height so overlay does not block scrollbars
    // we read the size from the scrollbar from our device, because we already determined
    // it on startup
    var elem = $field[0];
    var scrollHorizontal = (elem.scrollWidth - elem.clientWidth) > 0;
    var scrollVertical = (elem.scrollHeight - elem.clientHeight) > 0;
    var scrollbarSize = scout.device.scrollbarWidth;

    $overlay
      .css('top', pos.top)
      .css('left', pos.left)
      .width($field.width() + padding.horizontal() - (scrollVertical ? scrollbarSize : 0))
      .height($field.height() + padding.vertical() - (scrollHorizontal ? scrollbarSize : 0));
  }
};

scout.FormFieldLayout.prototype._isLabelVisible = function() {
  return this.formField.$label && this.formField.labelVisible;
};

scout.FormFieldLayout.prototype._isStatusVisible = function() {
  return this.formField.$status && (this.formField.statusVisible || this.formField.$status.isVisible());
};

scout.FormFieldLayout.prototype.preferredLayoutSize = function($container) {
  var prefSize, htmlField, labelPositionLeft,
    width = 0,
    htmlContainer = scout.HtmlComponent.get($container),
    height = scout.HtmlEnvironment.formRowHeight,
    labelWidth = this.labelWidth,
    topLabelHeight = 0, // only set when label is on top
    statusWidth = this.statusWidth,
    formField = this.formField;

  if (this._isLabelVisible()) {
    if (formField.labelUseUiWidth) {
      if (formField.$label.hasClass('empty')) {
        labelWidth = 0;
      } else {
        labelWidth = scout.graphics.prefSize(formField.$label, {
          includeMargin: true
        }).width;
      }
    }
    labelPositionLeft = formField.labelPosition === scout.FormField.LABEL_POSITION_DEFAULT ||
      formField.labelPosition === scout.FormField.LABEL_POSITION_LEFT;
    if (labelPositionLeft) {
      width += labelWidth;
    } else if (formField.labelPosition === scout.FormField.LABEL_POSITION_TOP) {
      topLabelHeight = formField.$label.outerHeight(true);
      height += topLabelHeight;
    }
  }
  if (formField.$mandatory) {
    width += formField.$mandatory.outerWidth(true);
  }
  if (this._isStatusVisible()) {
    width += statusWidth + formField.$status.cssMarginX();
  }

  if (formField.$fieldContainer) {
    htmlField = scout.HtmlComponent.optGet(formField.$fieldContainer);
    if (htmlField) {
      prefSize = htmlField.getPreferredSize()
        .add(htmlContainer.getInsets())
        .add(htmlField.getMargins());
      prefSize.height += topLabelHeight;
    } else {
      prefSize = this.naturalSize(formField);
    }
  } else {
    prefSize = new scout.Dimension(0, 0);
  }
  width += prefSize.width;
  height = Math.max(height, prefSize.height);

  return new scout.Dimension(width, height);
};

scout.FormFieldLayout.prototype._layoutIcon = function(formField, fieldBounds, right, top) {
  var height = this.rowHeight;
  if (fieldBounds) {
    // If field is bigger than rowHeight (e.g. if used in desktop cell editor), make sure icon is as height as field
    height = fieldBounds.height;
  }
  formField.$icon
    .cssRight(formField.$field.cssBorderRightWidth() + right)
    .cssTop(top)
    .cssHeight(height)
    .cssLineHeight(height);
};

/**
 * Returns the 'natural' size of the field - which means the current size of the field in the browser.
 * By default we return the size of the $fieldContainer. Override this method when you must return
 * another size (which is required when the field-content is scrollable).
 */
scout.FormFieldLayout.prototype.naturalSize = function(formField) {
  return scout.graphics.prefSize(formField.$fieldContainer, {
    includeMargin: true
  });
};

scout.GridData = function(model) {
  model = model || {};
  this.x = -1;
  this.y = -1;
  this.w = 1;
  this.h = 1;
  this.weightX = -1;
  this.weightY = -1;
  this.useUiWidth = false;
  this.useUiHeight = false;
  this.horizontalAlignment = -1;
  this.verticalAlignment = -1;
  this.fillHorizontal = true;
  this.fillVertical = true;
  this.widthInPixel = 0;
  this.heightInPixel = 0;

  $.extend(this, model);
};

scout.GridData.createFromHints = function(field, gridColumnCount) {
  var data = new scout.GridData(field.gridDataHints);
  if (data.w === scout.FormField.FULL_WIDTH) {
    data.w = gridColumnCount;
  }
  return data;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CompositeField = function() {
  scout.CompositeField.parent.call(this);
};
scout.inherits(scout.CompositeField, scout.FormField);

/**
 * Returns an array of child-fields.
 */
scout.CompositeField.prototype.getFields = function() {
  throw new Error('Not implemented');
};

scout.CompositeField.prototype.visit = function(visitor) {
  scout.CompositeField.parent.prototype.visit.call(this, visitor);
  this.getFields().forEach(function(field) {
    field.visit(visitor);
  });
};

/**
 * Sets the given displayStyle recursively on all fields of the composite field.
 * @override FormField.js
 */
scout.CompositeField.prototype.setDisabledStyle = function(disabledStyle) {
  this.getFields().forEach(function(field) {
    field.setDisabledStyle(disabledStyle);
  });
  scout.CompositeField.parent.prototype.setDisabledStyle.call(this, disabledStyle);
};

/**
 * @override FormField.js
 */
scout.CompositeField.prototype.recomputeEnabled = function(parentEnabled) {
  scout.CompositeField.parent.prototype.recomputeEnabled.call(this, parentEnabled);
  this.getFields().forEach(function(field) {
    field.recomputeEnabled(this.enabledComputed);
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CompositeFieldAdapter = function() {
  scout.FormFieldAdapter.parent.call(this);
};
scout.inherits(scout.CompositeFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * ValueField assumes $field has a .val() method which returns the value of that field.
 * @abstract
 */
scout.ValueField = function() {
  scout.ValueField.parent.call(this);
  this._initialValue = null;
  this.displayText = '';
};
scout.inherits(scout.ValueField, scout.FormField);

scout.ValueField.prototype._renderProperties = function() {
  scout.ValueField.parent.prototype._renderProperties.call(this);
  this._renderDisplayText();
};

scout.ValueField.prototype._renderDisplayText = function() {
  this.$field.val(this.displayText);
};

scout.ValueField.prototype._readDisplayText = function() {
  return this.$field.val();
};

scout.ValueField.prototype._onFieldBlur = function() {
  this.acceptInput(false);
};

/**
 * Accepts the current input and writes it to the model.
 * <p>
 * This method is typically called by the _onBlur() function of the field, but may actually be called from anywhere (e.g. button, actions, cell editor, etc).
 * It is also called by the _aboutToBlurByMouseDown() function, which is required because our Ok- and Cancel-buttons are not focusable (thus _onBlur() is
 * never called) but changes in the value-field must be sent to the server anyway when a button is clicked.
 * <p>
 * The default reads the display text using this._readDisplayText() and writes it to the model by calling _triggerDisplayTextChanged().
 * If subclasses don't have a display-text or want to write another state to the server, they may override this method.
 */
scout.ValueField.prototype.acceptInput = function(whileTyping) {
  whileTyping = !!whileTyping; // cast to boolean
  var displayText = scout.nvl(this._readDisplayText(), '');

  // trigger only if displayText has really changed
  if (this._checkDisplayTextChanged(displayText, whileTyping)) {
    if (whileTyping) {
      // Don't call setDisplayText() to prevent re-rendering of display text (which is unnecessary and
      // might change the cursor position).
      this._callSetProperty('displayText', displayText);
    } else {
      this._parseAndSetValue(displayText); // this also calls setDisplayText()
    }
    this._triggerDisplayTextChanged(displayText, whileTyping);
  }
};

scout.ValueField.prototype._parseAndSetValue = function(displayText) {
  this.setValue(this._parseValue(displayText));
};

scout.ValueField.prototype._parseValue = function(displayText) {
  // FIXME [awe] 6.1 - this impl. is wrong and far too simple. Check how it is done in Java Scout first, also discuss with J.GU
  // FIXME [awe] 6.1 - durchdenken: was passiert, wenn der server ein execFormatValue macht? abc -> ABC
  // wahrscheinlich kann es keinen cycle geben, wegen unseren filters und weil der remote adapter den value nicht kennt
  // kann es endlos-cycles geben? beispiel von beat: collator AE -  oder so
  return displayText;
};

scout.ValueField.prototype._checkDisplayTextChanged = function(displayText, whileTyping) {
  var oldDisplayText = scout.nvl(this.displayText, '');
  return displayText !== oldDisplayText;
};

/**
 * Method invoked upon a mousedown click with this field as the currently focused control, and is invoked just before the mousedown click will be interpreted.
 * However, the mousedown target must not be this control, but any other control instead.
 *
 * The default implementation checks, whether the click occurred outside this control, and if so invokes 'ValueField.acceptInput'.
 *
 * @param target
 *        the DOM target where the mouse down event occurred.
 */
scout.ValueField.prototype.aboutToBlurByMouseDown = function(target) {
  var eventOnField = this.$field.isOrHas(target);

  if (!eventOnField) {
    this.acceptInput(); // event outside this value field.
  }
};

scout.ValueField.prototype._triggerDisplayTextChanged = function(displayText, whileTyping) {
  var event = {
    displayText: displayText,
    whileTyping: !!whileTyping
  };
  this.trigger('displayTextChanged', event);
};

scout.ValueField.prototype.setDisplayText = function(displayText) {
  this.setProperty('displayText', displayText);
};

// FIXME [awe] 6.1 - check fields like DateField where setTimestamp is used instead of setValue
scout.ValueField.prototype.setValue = function(value) {
  this.setProperty('value', value);
};

scout.ValueField.prototype._syncValue = function(value) {
  var oldValue = this.value;
  this.value = this._validateValue(value);
  this._updateTouched();
  this._updateEmpty();
  this.triggerPropertyChange('value', oldValue, value);
  this._updateDisplayText();
};

scout.ValueField.prototype._updateDisplayText = function() {
  var returned = this._formatValue(this.value);
  if (returned && $.isFunction(returned.promise)) {
    // Promise is returned -> set display text later
    returned
      .done(this.setDisplayText.bind(this))
      .fail(function() {
        this.setDisplayText('');
        $.log.error('Could not resolve display text.');
      }.bind(this));
  } else {
    this.setDisplayText(returned);
  }
};

/**
 * @returns the validated value
 */
scout.ValueField.prototype._validateValue = function(value) {
  return value;
};

/**
 * @returns the formatted string or a promise
 */
scout.ValueField.prototype._formatValue = function(value) {
  return scout.nvl(value, ''); // FIXME [awe] 6.1 - check impl. for fields other than StringField
};

scout.ValueField.prototype._updateTouched = function() {
  this.touched = !scout.objects.equals(this.value, this._initialValue);
};

scout.ValueField.prototype.addField = function($field) {
  scout.ValueField.parent.prototype.addField.call(this, $field);
  this.$field.data('valuefield', this);
};

scout.ValueField.prototype._onStatusMousedown = function(event) {
  if (this.menus && this.menus.length > 0) {
    var $activeElement = this.$container.activeElement();
    if ($activeElement.data('valuefield') === this ||
      $activeElement.parent().data('valuefield') === this) {
      this.acceptInput();
    }
  }

  scout.ValueField.parent.prototype._onStatusMousedown.call(this, event);
};

// ==== static helper methods ==== //

/**
 * Invokes 'ValueField.aboutToBlurByMouseDown' on the currently active value field.
 * This method has no effect if another element is the focus owner.
 */
scout.ValueField.invokeValueFieldAboutToBlurByMouseDown = function(target) {
  var activeValueField = this._getActiveValueField(target);
  if (activeValueField) {
    activeValueField.aboutToBlurByMouseDown(target);
  }
};

/**
 * Invokes 'ValueField.acceptInput' on the currently active value field.
 * This method has no effect if another element is the focus owner.
 */
scout.ValueField.invokeValueFieldAcceptInput = function(target) {
  var activeValueField = this._getActiveValueField(target);
  if (activeValueField) {
    activeValueField.acceptInput();
  }
};

/**
 * Returns the currently active value field, or null if another element is active.
 * Also, if no value field currently owns the focus, its parent is checked to be a value field and is returned accordingly.
 * That is used in DateField.js with multiple input elements.
 */
scout.ValueField._getActiveValueField = function(target) {
  var $activeElement = $(target.ownerDocument.activeElement),
    valueField = $activeElement.data('valuefield') || $activeElement.parent().data('valuefield');
  return valueField && !(valueField.$field && valueField.$field.hasClass('disabled')) ? valueField : null;
};

scout.ValueField.prototype.markAsSaved = function() {
  scout.ValueField.parent.prototype.markAsSaved.call(this);
  this._initialValue = this.value;
};

/**
 * @override
 */
scout.ValueField.prototype._updateEmpty = function() {
  this.empty = this.value === null || this.value === undefined;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ValueFieldAdapter = function() {
  scout.ValueFieldAdapter.parent.call(this);
};
scout.inherits(scout.ValueFieldAdapter, scout.FormFieldAdapter);

scout.ValueFieldAdapter.prototype._onWidgetDisplayTextChanged = function(event) {
  this._send('displayTextChanged', {
    displayText: event.displayText,
    whileTyping: event.whileTyping
  }, {
    showBusyIndicator: !event.whileTyping
  });
};

scout.ValueFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'displayTextChanged') {
    this._onWidgetDisplayTextChanged(event);
  } else {
    scout.ValueFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/**
 * @override ModelAdapter.js
 */
scout.ValueFieldAdapter.prototype.exportAdapterData = function(adapterData) {
  adapterData = scout.ValueFieldAdapter.parent.prototype.exportAdapterData.call(this, adapterData);
  delete adapterData.displayText;
  return adapterData;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Common base class for ValueFields having an HTML input field.
 */
scout.BasicField = function() {
  scout.BasicField.parent.call(this);
  this._onDisplayTextModifiedHandler = this._onDisplayTextModified.bind(this);
  this.disabledCopyOverlay = true;
  this._displayTextModifiedTimeoutId = null;
};
scout.inherits(scout.BasicField, scout.ValueField);

scout.BasicField.prototype._renderProperties = function() {
  scout.BasicField.parent.prototype._renderProperties.call(this);
  this._renderUpdateDisplayTextOnModify();
};

scout.BasicField.prototype.setUpdateDisplayTextOnModify = function(updateDisplayTextOnModify) {
  this.setProperty('updateDisplayTextOnModify', updateDisplayTextOnModify);
};

scout.BasicField.prototype._renderUpdateDisplayTextOnModify = function() {
  if (this.updateDisplayTextOnModify) {
    this.$field.on('input', this._onDisplayTextModifiedHandler);
  } else {
    clearTimeout(this._displayTextModifiedTimeoutId);
    this.$field.off('input', this._onDisplayTextModifiedHandler);
  }
};

/**
 * Called when the property 'updateDisplayTextOnModified' is TRUE and the display text (field's input
 * value) has been modified by a user action, e.g. a key or paste event. If the property is FALSE, this
 * method is _never_ called. Uses the debounce pattern.
 */
scout.BasicField.prototype._onDisplayTextModified = function() {
  clearTimeout(this._displayTextModifiedTimeoutId);
  this._displayTextModifiedTimeoutId = setTimeout(function() {
    if (!this.rendered) {
      // Field may be removed in the meantime -> accepting input is not possible anymore
      this._displayTextModifiedTimeoutId = null;
      return;
    }
    this.acceptInput(true);
  }.bind(this), 250);
};

scout.BasicField.prototype.acceptInput = function(whileTyping) {
  if (!whileTyping && this._displayTextModifiedTimeoutId !== null) {
    clearTimeout(this._displayTextModifiedTimeoutId);
    this.acceptInput(true);
  }
  this._displayTextModifiedTimeoutId = null;
  scout.BasicField.parent.prototype.acceptInput.call(this, whileTyping);
};

/**
 * @override ValueField.js
 */
scout.BasicField.prototype._checkDisplayTextChanged = function(displayText, whileTyping) {
  var displayTextChanged = scout.BasicField.parent.prototype._checkDisplayTextChanged.call(this, displayText, whileTyping);

  // OR if updateDisplayTextOnModify is true
  // 2. check is necessary to make sure the value and not only the display text gets written to the model (IBasicFieldUIFacade.parseAndSetValueFromUI vs setDisplayTextFromUI)
  if (displayTextChanged || (this.updateDisplayTextOnModify || this._displayTextChangedWhileTyping) && !whileTyping) {
    // In 'updateDisplayTextOnModify' mode, each change of text is sent to the server with whileTyping=true.
    // On field blur, the text is sent again with whileTyping=false. The following logic prevents sending
    // to many events to the server. When whileTyping is false, the text has only to be send to the server
    // when there have been any whileTyping=true events. When the field looses the focus without any
    // changes, no request should be sent.
    if (this.updateDisplayTextOnModify) {
      if (whileTyping) {
        // Remember that we sent some events to the server with "whileTyping=true".
        this._displayTextChangedWhileTyping = true;
      } else {
        if (!this._displayTextChangedWhileTyping) {
          // If there were no "whileTyping=true" events, don't send anything to the server.
          return false;
        }
        this._displayTextChangedWhileTyping = false; // Reset
      }
    }
    return true;
  }
  return false;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BasicFieldAdapter = function() {
  scout.BasicFieldAdapter.parent.call(this);
  this.enabledWhenOffline = true;
};
scout.inherits(scout.BasicFieldAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Controller with functionality to register and render views and dialogs.
 *
 * The forms are put into the list 'views' and 'dialogs' contained in 'displayParent'.
 */
scout.FormController = function(displayParent, session) {
  this.displayParent = displayParent;
  this.session = session;
};

/**
 * Adds the given view or dialog to this controller and renders it.
 * position is only used if form is a view. this position determines at which position the tab is placed.
 * if select view is set the view rendered in _renderView is also selected.
 */
scout.FormController.prototype.registerAndRender = function(form, position, selectView) {
  form._setProperty('displayParent', this.displayParent);
  if (form.isPopupWindow()) {
    this._renderPopupWindow(form);
  } else if (form.isView()) {
    this._renderView(form, true, position, selectView);
  } else {
    this._renderDialog(form, true);
  }
};

scout.FormController.prototype._renderPopupWindow = function(formAdapterId, position) {
  throw new Error('popup window only supported by DesktopFormController');
};

/**
 * Removes the given view or dialog from this controller and DOM. However, the form's adapter is not destroyed. That only happens once the Form is closed.
 */
scout.FormController.prototype.unregisterAndRemove = function(form) {
  if (!form) {
    return;
  }

  if (form.isPopupWindow()) {
    this._removePopupWindow(form);
  } else if (form.isView()) {
    this._removeView(form);
  } else {
    this._removeDialog(form);
  }
};

scout.FormController.prototype._removePopupWindow = function(form) {
  throw new Error('popup window only supported by DesktopFormController');
};

/**
 * Renders all dialogs and views registered with this controller.
 */
scout.FormController.prototype.render = function() {
  this.displayParent.dialogs.forEach(function(dialog) {
    dialog._setProperty('displayParent', this.displayParent);
    this._renderDialog(dialog, false);
  }.bind(this));
  this.displayParent.views.forEach(function(view, position) {
    view._setProperty('displayParent', this.displayParent);
    this._renderView(view, false, position, false);
  }.bind(this));
};

/**
 * Removes all dialogs and views registered with this controller.
 */
scout.FormController.prototype.remove = function() {
  this.displayParent.dialogs.forEach(function(dialog) {
    this._removeDialog(dialog, false);
  }.bind(this));
  this.displayParent.views.forEach(function(view, position) {
    this._removeView(view, false);
  }.bind(this));
};

/**
 * Activates the given view or dialog.
 */
scout.FormController.prototype.activateForm = function(form) {
  // if form is not rendered it can not be activated.
  if (!form.rendered) {
    return;
  }
  // FIXME awe: (2nd screen) handle popupWindow?
  if (form.displayHint === scout.Form.DisplayHint.VIEW) {
    this._activateView(form);
  } else {
    this._activateDialog(form);
  }
};

scout.FormController.prototype.acceptView = function(view, register, position, selectView) {
  // Only render view if 'displayParent' is rendered yet; if not, the view will be rendered once 'displayParent' is rendered.
  if (!this.displayParent.rendered) {
    return false;
  }

  return true;
};

scout.FormController.prototype._renderView = function(view, register, position, selectView) {
  if (register) {
    if (position !== undefined) {
      scout.arrays.insert(this.displayParent.views, view, position);
    } else {
      this.displayParent.views.push(view);
    }
  }

  // Display parent may implement acceptView, if not implemented -> use default
  if (this.displayParent.acceptView) {
    if (!this.displayParent.acceptView(view)) {
      return;
    }
  } else if (!this.acceptView(view)) {
    return;
  }

  // Prevent "Already rendered" errors / FIXME bsh, dwi: Remove this hack! Fix in on model if possible. See #162954.
  if (view.rendered) {
    return false;
  }
  if (this.session.desktop.displayStyle === scout.Desktop.DisplayStyle.COMPACT && !this.session.desktop.bench) {
    // Show bench and hide navigation if this is the first view to be shown
    this.session.desktop.sendOutlineToBack();
    this.session.desktop.switchToBench();
  }
  this.session.desktop.bench.addView(view, selectView);
};

scout.FormController.prototype.acceptDialog = function(dialog) {
  // Only render dialog if 'displayParent' is rendered yet; if not, the dialog will be rendered once 'displayParent' is rendered.
  if (!this.displayParent.rendered) {
    return false;
  }
  return true;
};

scout.FormController.prototype._renderDialog = function(dialog, register) {
  var desktop = this.session.desktop;
  if (register) {
    this.displayParent.dialogs.push(dialog);
  }

  // Display parent may implement acceptDialog, if not implemented -> use default
  if (this.displayParent.acceptDialog) {
    if (!this.displayParent.acceptDialog(dialog)) {
      return;
    }
  } else if (!this.acceptDialog(dialog)) {
    return;
  }

  // Prevent "Already rendered" errors / FIXME bsh, dwi: Remove this hack! Fix in on model if possible. See #162954.
  if (dialog.rendered) {
    return false;
  }

  dialog.on('remove', function() {
    if (this.displayParent.dialogs.length > 0) {
      desktop._setFormActivated(this.displayParent.dialogs[this.displayParent.dialogs.length - 1]);
    } else if (this.displayParent instanceof scout.Form && !this.displayParent.detailForm) {
      // activate display parent, but not if it is the detail form
      desktop._setFormActivated(this.displayParent);
    } else {
      desktop._setOutlineActivated();
    }
  }.bind(this));

  if (dialog.isPopupWindow()) {
    this._renderPopupWindow(dialog);
  } else {
    dialog.render(desktop.$container);
    this._layoutDialog(dialog);
    desktop._setFormActivated(dialog);

    // Only display the dialog if its 'displayParent' is visible to the user.
    if (!this.displayParent.inFront()) {
      dialog.detach();
    }
  }
};

scout.FormController.prototype._removeView = function(view, unregister) {
  unregister = scout.nvl(unregister, true);
  if (unregister) {
    scout.arrays.remove(this.displayParent.views, view);
  }
  // in COMPACT case views are already removed.
  if (this.session.desktop.bench) {
    this.session.desktop.bench.removeView(view);
  }
};

scout.FormController.prototype._removeDialog = function(dialog, unregister) {
  unregister = scout.nvl(unregister, true);
  if (unregister) {
    scout.arrays.remove(this.displayParent.dialogs, dialog);
  }
  if (dialog.rendered) {
    dialog.remove();
  }
};

scout.FormController.prototype._activateView = function(view) {
  this.session.desktop.bench.activateView(view);
};

scout.FormController.prototype._activateDialog = function(dialog) {
  if (this.displayParent.inFront() && !dialog.attached) {
    dialog.attach();
  }
};

/**
 * Attaches all dialogs to their original DOM parents.
 * In contrast to 'render', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.
 *
 * This method has no effect if already attached.
 */
scout.FormController.prototype.attachDialogs = function() {
  this.displayParent.dialogs.forEach(function(dialog) {
    dialog.attach();
  }, this);
};

/**
 * Detaches all dialogs from their DOM parents. Thereby, modality glassPanes are not detached.
 * In contrast to 'remove', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.
 *
 * This method has no effect if already detached.
 */
scout.FormController.prototype.detachDialogs = function() {
  this.displayParent.dialogs.forEach(function(dialog) {
    dialog.detach();
  }, this);
};

scout.FormController.prototype._layoutDialog = function(dialog) {
  var left, top, opticalMiddleOffset, dialogSize,
    $window = dialog.$container.window(),
    windowSize = new scout.Dimension($window.width(), $window.height());

  dialog.htmlComp.pixelBasedSizing = true;
  dialog.htmlComp.validateLayout();

  dialogSize = dialog.htmlComp.getSize(true);
  left = (windowSize.width - dialogSize.width) / 2;
  top = (windowSize.height - dialogSize.height) / 2;

  // optical middle
  opticalMiddleOffset = Math.min(top / 5, 10);
  top -= opticalMiddleOffset;

  dialog.$container
    .cssLeft(left)
    .cssTop(top);

  dialog.trigger('move', {
    top: top,
    left: left
  });

  // FIXME dwi: If not validated anew, focus on single-button forms is not gained.
  //                 Maybe, this is the same problem as in BusyIndicator.js
  this.session.focusManager.validateFocus();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MessageBox = function() {
  scout.MessageBox.parent.call(this);
  this.$container;
  this.$content;
  this.$header;
  this.$body;
  this.$buttons;
  this.$yesButton;
  this.$noButton;
  this.$cancelButton;
  this._$closeButton;
  this.focusListener;
};
scout.inherits(scout.MessageBox, scout.Widget);

// represents severity codes from IStatus // FIXME [awe] 6.1 - same as scout.Status.Severity!? merge
scout.MessageBox.SEVERITY = {
  OK: 1,
  INFO: 256,
  WARNING: 65536,
  ERROR: 16777216
};

/**
 * @override
 */
scout.MessageBox.prototype._createKeyStrokeContext = function() {
  return new scout.KeyStrokeContext();
};

/**
 * @override
 */
scout.MessageBox.prototype._initKeyStrokeContext = function() {
  scout.MessageBox.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([
    new scout.FocusAdjacentElementKeyStroke(this.session, this),
    new scout.ClickActiveElementKeyStroke(this, [
      scout.keys.SPACE, scout.keys.ENTER
    ]),
    new scout.CloseKeyStroke(this, function() {
      return this._$closeButton;
    }.bind(this))
  ]);
};

scout.MessageBox.prototype._render = function($parent) {
  if (!$parent) {
    throw new Error('Missing argument $parent');
  }
  // Render modality glasspanes (must precede adding the message box to the DOM)
  this._glassPaneRenderer = new scout.GlassPaneRenderer(this.session, this, true);
  this._glassPaneRenderer.renderGlassPanes();

  this.$container = $parent.appendDiv('messagebox');

  var $handle = this.$container.appendDiv('drag-handle');
  this.$container.makeDraggable($handle);

  this.$content = this.$container.appendDiv('messagebox-content');
  this.$header = this.$content.appendDiv('messagebox-label messagebox-header');
  this.$body = this.$content.appendDiv('messagebox-label messagebox-body');
  this.$html = this.$content.appendDiv('messagebox-label messagebox-html prevent-initial-focus');
  this.$buttons = this.$container.appendDiv('messagebox-buttons');

  var boxButtons = new scout.BoxButtons(this.$buttons, this._onButtonClick.bind(this));
  this._$closeButton = null; // button to be executed when close() is called, e.g. when ESCAPE is pressed
  if (this.yesButtonText) {
    this.$yesButton = boxButtons.addButton({
      text: this.yesButtonText,
      option: 'yes'
    });
    this._$closeButton = this.$yesButton;
  }
  if (this.noButtonText) {
    this.$noButton = boxButtons.addButton({
      text: this.noButtonText,
      option: 'no'
    });
    this._$closeButton = this.$noButton;
  }
  if (this.cancelButtonText) {
    this.$cancelButton = boxButtons.addButton({
      text: this.cancelButtonText,
      option: 'cancel'
    });
    this._$closeButton = this.$cancelButton;
  }

  // Render properties
  this._renderIconId(this.iconId);
  this._renderSeverity(this.severity);
  this._renderHeader(this.header);
  this._renderBody(this.body);
  this._renderHtml(this.html);
  this._renderHiddenText(this.hiddenText);

  // FIXME bsh: Somehow let the user copy the 'copyPasteText' - but how?

  // Prevent resizing when message-box is dragged off the viewport
  this.$container.addClass('calc-helper');
  var naturalWidth = this.$container.width();
  this.$container.removeClass('calc-helper');
  this.$container.css('min-width', Math.max(naturalWidth, boxButtons.buttonCount() * 100));
  boxButtons.updateButtonWidths(this.$container.width());
  // Now that all texts, paddings, widths etc. are set, we can calculate the position
  this._position();
  this.$container.addClassForAnimation('animate-open');
};

scout.MessageBox.prototype._postRender = function() {
  scout.MessageBox.parent.prototype._postRender.call(this);
  this.session.focusManager.installFocusContext(this.$container, scout.focusRule.AUTO);
};

scout.MessageBox.prototype._remove = function() {
  this._glassPaneRenderer.removeGlassPanes();
  this.session.focusManager.uninstallFocusContext(this.$container);
  scout.MessageBox.parent.prototype._remove.call(this);
};

scout.MessageBox.prototype._position = function() {
  this.$container.cssMarginLeft(-this.$container.outerWidth() / 2);
};

scout.MessageBox.prototype._renderIconId = function(iconId) {
  // FIXME bsh: implement
};

scout.MessageBox.prototype._renderSeverity = function(severity) {
  this.$container.removeClass('severity-error');
  if (severity === scout.MessageBox.SEVERITY.ERROR) {
    this.$container.addClass('severity-error');
  }
};

scout.MessageBox.prototype._renderHeader = function(text) {
  this.$header.html(scout.strings.nl2br(text));
  this.$header.setVisible(text);
};

scout.MessageBox.prototype._renderBody = function(text) {
  this.$body.html(scout.strings.nl2br(text));
  this.$body.setVisible(text);
};

scout.MessageBox.prototype._renderHtml = function(text) {
  this.$html.html(text);
  this.$html.setVisible(text);
  // Don't change focus when a link is clicked by mouse
  this.$html.find('a, .app-link')
    .attr('tabindex', '0')
    .unfocusable();
};

scout.MessageBox.prototype._renderHiddenText = function(text) {
  if (this.$hiddenText) {
    this.$hiddenText.remove();
  }
  if (text) {
    this.$hiddenText = this.$content.appendElement('<!-- \n' + text.replace(/<!--|-->/g, '') + '\n -->');
  }
};

scout.MessageBox.prototype._onButtonClick = function(event, option) {
  this.trigger('action', {
    option: option
  });
};

/**
 * Used by CloseKeyStroke.js
 */
scout.MessageBox.prototype.close = function() {
  if (this._$closeButton && this.session.focusManager.requestFocus(this._$closeButton)) {
    this._$closeButton.click();
  }
};

/**
 * @override Widget.js
 */
scout.MessageBox.prototype._attach = function() {
  this.$parent.append(this.$container);
  this.session.detachHelper.afterAttach(this.$container);
  scout.MessageBox.parent.prototype._attach.call(this);
};

/**
 * @override Widget.js
 */
scout.MessageBox.prototype._detach = function() {
  this.session.detachHelper.beforeDetach(this.$container);
  this.$container.detach();
  scout.MessageBox.parent.prototype._detach.call(this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.MessageBoxAdapter = function() {
  scout.MessageBoxAdapter.parent.call(this);
};
scout.inherits(scout.MessageBoxAdapter, scout.ModelAdapter);

scout.MessageBoxAdapter.prototype._onWidgetAction = function(event) {
  this._send('action', {
    option: event.option
  });
};

scout.MessageBoxAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'action') {
    this._onWidgetAction(event);
  } else {
    scout.MessageBoxAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Controller with functionality to register and render message boxes.
 *
 * The message boxes are put into the list 'messageBoxes' contained in 'displayParent'.
 */
scout.MessageBoxController = function(displayParent, session) {
  this.displayParent = displayParent;
  this.session = session;
};

/**
 * Adds the given message box to this controller and renders it.
 */
scout.MessageBoxController.prototype.registerAndRender = function(messageBox) {
  messageBox._setProperty('displayParent', this.displayParent);
  this.displayParent.messageBoxes.push(messageBox);
  this._render(messageBox);
};

/**
 * Removes the given message box from this controller and DOM. However, the message box's adapter is not destroyed. That only happens once the message box is closed.
 */
scout.MessageBoxController.prototype.unregisterAndRemove = function(messageBox) {
  if (messageBox) {
    scout.arrays.remove(this.displayParent.messageBoxes, messageBox);
    this._remove(messageBox);
  }
};

/**
 * Removes all message boxes registered with this controller from DOM.
 */
scout.MessageBoxController.prototype.remove = function() {
  this.displayParent.messageBoxes.forEach(this._remove.bind(this));
};

/**
 * Renders all message boxes registered with this controller.
 */
scout.MessageBoxController.prototype.render = function() {
  this.displayParent.messageBoxes.forEach(this._render.bind(this));
};

scout.MessageBoxController.prototype._render = function(messageBox) {
  // Only render message box if 'displayParent' is rendered yet; if not, the message box will be rendered once 'displayParent' is rendered.
  if (!this.displayParent.rendered) {
    return;
  }
  // Prevent "Already rendered" errors / FIXME bsh, dwi: Remove this hack! Fix in on model if possible. See #162954.
  if (messageBox.rendered) {
    return;
  }
  // Open all message boxes in the center of the desktop, except message-boxes that belong to a popup-window
  // Since the message box doesn't have a DOM element as parent when render is called, we must find the
  // entryPoint by using the model.
  var $mbParent;
  if (this.displayParent instanceof scout.Form && this.displayParent.isPopupWindow()) {
    $mbParent = this.displayParent.popupWindow.$container;
  } else {
    $mbParent = this.session.desktop.$container;
  }
  messageBox.render($mbParent);

  // Only display the message box if its 'displayParent' is visible to the user.
  if (!this.displayParent.inFront()) {
    messageBox.detach();
  }
};

scout.MessageBoxController.prototype._remove = function(messageBox) {
  messageBox.remove();
};

/**
 * Attaches all message boxes to their original DOM parents.
 * In contrast to 'render', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.
 *
 * This method has no effect if already attached.
 */
scout.MessageBoxController.prototype.attach = function() {
  this.displayParent.messageBoxes.forEach(function(messageBox) {
    messageBox.attach();
  }, this);
};

/**
 * Detaches all message boxes from their DOM parents. Thereby, modality glassPanes are not detached.
 * In contrast to 'remove', this method uses 'JQuery detach mechanism' to retain CSS properties, so that the model must not be interpreted anew.
 *
 * This method has no effect if already detached.
 */
scout.MessageBoxController.prototype.detach = function() {
  this.displayParent.messageBoxes.forEach(function(messageBox) {
    messageBox.detach();
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Base class for fields where the value should be visualized.
 */
scout.BeanField = function() {
  scout.BeanField.parent.call(this);

  this.preventInitialFocus = true;
};
scout.inherits(scout.BeanField, scout.ValueField);

scout.BeanField.prototype._render = function($parent) {
  this.addContainer($parent, 'bean-field');
  this.addLabel();
  this.addField($parent.makeDiv());
  this.addStatus();
};

scout.BeanField.prototype._renderProperties = function() {
  scout.BeanField.parent.prototype._renderProperties.call(this);
  this._renderValue();
};

/**
 * @override FormField.js
 */
scout.BeanField.prototype._initKeyStrokeContext = function() {
  scout.BeanField.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke(new scout.AppLinkKeyStroke(this, this._onAppLinkAction));
};

/**
 * @override
 */
scout.BeanField.prototype._renderDisplayText = function() {
  // nop
};

scout.BeanField.prototype._renderValue = function() {
  // to be implemented by the subclass
};

scout.BeanField.prototype.triggerAppLinkAction = function(ref) {
  this.trigger('appLinkAction', {
    ref: ref
  });
};

scout.BeanField.prototype._onAppLinkAction = function(event) {
  var $target = $(event.target);
  var ref = $target.data('ref');
  this.triggerAppLinkAction(ref);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BeanFieldAdapter = function() {
  scout.BeanFieldAdapter.parent.call(this);
};
scout.inherits(scout.BeanFieldAdapter, scout.ValueFieldAdapter);

scout.BeanFieldAdapter.prototype._onWidgetAppLinkAction = function(event) {
  this._send('appLinkAction', {
    ref: event.ref
  });
};

scout.BeanFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'appLinkAction') {
    this._onWidgetAppLinkAction(event);
  } else {
    scout.BeanFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BrowserField = function() {
  scout.BrowserField.parent.call(this);

  this._messageListener;
  this._popupWindow;
  this._externalWindowTextField;
  this._externalWindowButton;
};
scout.inherits(scout.BrowserField, scout.ValueField);

scout.BrowserField.windowStates = {
  WINDOW_OPEN: "true",
  WINDOW_CLOSED: "false"
};

scout.BrowserField.prototype._render = function($parent) {
  this.addContainer($parent, 'browser-field');
  this.addLabel();
  this.addStatus();

  if (!this.showInExternalWindow) {
    // mode 1: <iframe>
    this.addField($parent.makeElement('<iframe>'));
  } else {
    // mode 2: separate window
    this.addField($parent.makeDiv());
    this._externalWindowTextField = this.$field.appendDiv()
      .addClass('alt');
    this._externalWindowButton = this.$field.appendDiv()
      .addClass('button')
      .on('click', this._openPopupWindow.bind(this));
  }

  this.myWindow = $parent.window(true);

  this._messageListener = this._onMessage.bind(this);
  this.myWindow.addEventListener('message', this._messageListener);

  if (this.enabledComputed) {
    // use setTimeout to call method, because _openPopupWindow must be called after layouting
    setTimeout(this._openPopupWindow.bind(this, true), 20);
  }
};

/**
 * @override ValueField.js
 */
scout.BrowserField.prototype._renderProperties = function() {
  scout.BrowserField.parent.prototype._renderProperties.call(this);
  this._renderIframeProperties();
  // external window properties
  this._renderExternalWindowButtonText();
  this._renderExternalWindowFieldText();
};

scout.BrowserField.prototype._renderIframeProperties = function() {
  this._renderLocation();
  this._renderScrollBarEnabled();
  this._renderSandboxEnabled(); // includes _renderSandboxPermissions()
};

scout.BrowserField.prototype._renderLocation = function() {
  // Convert empty locations to 'about:blank', because in Firefox (maybe others, too?),
  // empty locations simply remove the src attribute but don't remove the old content.
  var location = this.location || 'about:blank';
  if (!this.showInExternalWindow) {
    // <iframe>
    this.$field.attr('src', location);
  } else {
    // fallback: separate window
    if (this._popupWindow && !this._popupWindow.closed) {
      this._popupWindow.location = location;
    }
  }
};

scout.BrowserField.prototype._renderScrollBarEnabled = function() {
  if (!this.showInExternalWindow) {
    this.$field.toggleClass('no-scrolling', !this.scrollBarEnabled);
    // According to http://stackoverflow.com/a/18470016, setting 'overflow: hidden' via
    // CSS should be enough. However, if the inner page sets 'overflow' to another value,
    // scroll bars are shown again. Therefore, we add the legacy 'scrolling=no' attribute,
    // which is deprecated in HTML5, but seems to do the trick.
    if (this.scrollBarEnabled) {
      this.$field.removeAttr('scrolling');
    } else {
      this.$field.attr('scrolling', 'no');
    }
  }
};

scout.BrowserField.prototype._renderSandboxEnabled = function() {
  if (!this.showInExternalWindow) {
    if (this.sandboxEnabled) {
      this._renderSandboxPermissions();
    } else {
      this.$field.removeAttr('sandbox');
      this.$field.removeAttr('security');
    }
  }
};

scout.BrowserField.prototype._renderSandboxPermissions = function() {
  if (!this.showInExternalWindow && this.sandboxEnabled) {
    this.$field.attr('sandbox', scout.nvl(this.sandboxPermissions, ''));
    if (scout.device.requiresIframeSecurityAttribute()) {
      this.$field.attr('security', 'restricted');
    }
  }
};

scout.BrowserField.prototype._renderExternalWindowButtonText = function() {
  if (this.showInExternalWindow) {
    this._externalWindowButton.text(this.externalWindowButtonText);
  }
};

scout.BrowserField.prototype._renderExternalWindowFieldText = function() {
  if (this.showInExternalWindow) {
    this._externalWindowTextField.text(this.externalWindowFieldText);
  }
};

scout.BrowserField.prototype._openPopupWindow = function(reopenIfClosed) {
  reopenIfClosed = scout.nvl(reopenIfClosed, true);
  if (!this.showInExternalWindow) {
    return;
  }

  if (!this._popupWindow || (reopenIfClosed && this._popupWindow.closed)) {
    var popupBlockerHandler = new scout.PopupBlockerHandler(this.session);
    // (a) positioning and sizing
    // screenLeft, screenTop might reveal the actual document screen position; screenX, screenY is just the browser window screen position
    // window should not be positioned outside of the available screen (probably not even possible), subtract 400 pixel of lower right corner of screen
    var windowLeft = Math.min(scout.nvl(window.screenLeft, window.screenX) + this.$field.offset().left, window.screen.availWidth - 400);
    // add 50 px (guessing there is a toolbar of 50 px)
    var windowTop = Math.min(scout.nvl(window.screenTop, window.screenY + 50) + this.$field.offset().top, window.screen.availHeight - 400);
    // do not taskbar hide window, leave a safety margin of 40 pixel to lower screen bound (suppose a taskbar is shown there)
    var windowWidth = ((this.$field.width() + windowLeft) > window.screen.availWidth) ? (window.screen.availWidth - windowLeft) : this.$field.width();
    var windowHeight = ((this.$field.height() + windowTop) > window.screen.availHeight) ? (window.screen.availHeight - windowTop) : this.$field.height();
    // (b) window specifications
    var windowSpecs = scout.strings.join(',',
      'directories=no',
      'location=no',
      'menubar=no',
      'resizable=yes,',
      'status=no',
      'scrollbars=' + (this.scrollBarEnabled ? 'yes' : 'no'),
      'toolbar=no',
      'dependent=yes',
      'left=' + windowLeft,
      'top=' + windowTop,
      'width=' + windowWidth,
      'height=' + windowHeight
    );
    var location = this.location || 'about:blank';
    this._popupWindow = popupBlockerHandler.openWindow(location,
      undefined,
      windowSpecs);
    if (this._popupWindow) {
      this._popupWindowOpen();
    } else {
      $.log.warn('Popup-blocker detected! Show link to open window manually');
      popupBlockerHandler.showNotification(function() {
        this._popupWindow = window.open(location,
          undefined,
          windowSpecs);
        this._popupWindowOpen();
      }.bind(this));
    }
  } else if (reopenIfClosed) {
    this._popupWindow.focus();
  }
};

scout.BrowserField.prototype._popupWindowOpen = function() {
  if (this._popupWindow && !this._popupWindow.closed) {
    this.trigger('externalWindowStateChange', {
      windowState: scout.BrowserField.windowStates.WINDOW_OPEN
    });
    var popupInterval = window.setInterval(function() {
      if (this._popupWindow === null || this._popupWindow.closed) {
        window.clearInterval(popupInterval);
        this.trigger('externalWindowStateChange', {
          windowState: scout.BrowserField.windowStates.WINDOW_CLOSED
        });
      }
    }.bind(this), 500);
  }
};

scout.BrowserField.prototype._onMessage = function(event) {
  $.log.debug('received post-message data=' + event.data + ' origin=' + event.origin);
  this.trigger('message', {
    data: event.data,
    origin: event.origin
  });
};

/**
 * @override FormField.js
 */
scout.BrowserField.prototype._remove = function() {
  scout.BrowserField.parent.prototype._remove.call(this);
  this.myWindow.removeEventListener('message', this._messageListener);
  this._messageListener = null;

  // if content is shown in an external window and auto close is set to true
  if (this.showInExternalWindow && this.autoCloseExternalWindow) {
    // try to close popup window (if it is not already closed)
    if (this._popupWindow && !this._popupWindow.closed) {
      this._popupWindow.close();
    }
  }
};

/**
 * @override Widget.js
 */
scout.BrowserField.prototype._afterAttach = function(parent) {
  // the security=restricted attribute prevents browsers (IE 9 and below) from
  // sending any cookies a second time
  // as a workaround for IFRAMEs to work, we have to recreate the whole field in that case
  if (!this.showInExternalWindow && scout.device.requiresIframeSecurityAttribute()) {
    this.$field.remove();
    this._removeField();
    this.addField(parent.$container.makeElement('<iframe>'));
    this._renderIframeProperties();
    this.htmlComp.revalidateLayout();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.BrowserFieldAdapter = function() {
  scout.BrowserFieldAdapter.parent.call(this);
};
scout.inherits(scout.BrowserFieldAdapter, scout.ValueFieldAdapter);

scout.BrowserFieldAdapter.prototype._onWidgetMessage = function(event) {
  this._send('postMessage', {
    data: event.data,
    origin: event.origin
  });
};

scout.BrowserFieldAdapter.prototype._onWidgetExternalWindowStateChange = function(event) {
  this._send('externalWindowStateChange', {
    windowState: event.windowState
  });
};

scout.BrowserFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'message') {
    this._onWidgetMessage(event);
  } else if (event.type === 'externalWindowStateChange') {
    this._onWidgetExternalWindowStateChange(event);
  } else {
    scout.BrowserFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.Button = function() {
  scout.Button.parent.call(this);
  this._addAdapterProperties(['menus']);

  this.systemType = scout.Button.SystemType.NONE;
  this.defaultButton = false;
  this.processButton = true;
  this.selected = false;
  this.displayStyle = scout.Button.DisplayStyle.DEFAULT;
  this.keyStroke;
  this.statusVisible = false;

  this.$buttonLabel;
  this.buttonKeyStroke = new scout.ButtonKeyStroke(this, null);
};
scout.inherits(scout.Button, scout.FormField);

scout.Button.SystemType = {
  NONE: 0,
  CANCEL: 1,
  CLOSE: 2,
  OK: 3,
  RESET: 4,
  SAVE: 5,
  SAVE_WITHOUT_MARKER_CHANGE: 6
};

scout.Button.DisplayStyle = {
  DEFAULT: 0,
  TOGGLE: 1,
  RADIO: 2,
  LINK: 3
};

scout.Button.prototype._init = function(model) {
  scout.Button.parent.prototype._init.call(this, model);
  this._syncKeyStroke(this.keyStroke);
};

/**
 * @override
 */
scout.Button.prototype._initKeyStrokeContext = function() {
  scout.Button.parent.prototype._initKeyStrokeContext.call(this);

  this._initDefaultKeyStrokes();

  this.formKeyStrokeContext = new scout.KeyStrokeContext();
  this.formKeyStrokeContext.invokeAcceptInputOnActiveValueField = true;
  this.formKeyStrokeContext.registerKeyStroke(this.buttonKeyStroke);
  this.formKeyStrokeContext.$bindTarget = function() {
    if (this.keyStrokeScope) {
      return this.keyStrokeScope.$container;
    }
    // use form as default scope
    return this.getForm().$container;
  }.bind(this);
};

/**
 * @override FormField.js
 */
scout.Button.prototype.recomputeEnabled = function(parentEnabled) {
  if (this._isIgnoreAccessibilityFlags()) {
    parentEnabled = true;
  }
  scout.Button.parent.prototype.recomputeEnabled.call(this, parentEnabled);
};

scout.Button.prototype._isIgnoreAccessibilityFlags = function() {
  return this.systemType === scout.Button.SystemType.CANCEL || this.systemType === scout.Button.SystemType.CLOSE;
};

scout.Button.prototype._initDefaultKeyStrokes = function() {
  this.keyStrokeContext.registerKeyStroke([
    new scout.ButtonKeyStroke(this, 'ENTER'),
    new scout.ButtonKeyStroke(this, 'SPACE')
  ]);
};

/**
 * @override
 */
scout.Button.prototype._createLoadingSupport = function() {
  return new scout.LoadingSupport({
    widget: this,
    $container: function() {
      return this.$field;
    }.bind(this)
  });
};

/**
 * The button form-field has no label and no status. Additionally it also has no container.
 * Container and field are the same thing.
 */
scout.Button.prototype._render = function($parent) {
  var $button;
  if (this.displayStyle === scout.Button.DisplayStyle.LINK) {
    // Render as link-button/ menu-item.
    // This is a bit weird: the model defines a button, but in the UI it behaves like a menu-item.
    // Probably it would be more reasonable to change the configuration (which would lead to additional
    // effort required to change an existing application).
    $button = $parent.makeDiv('link-button');
    // Separate $link element to have a smaller focus border
    this.$link = $button.appendDiv('menu-item link');
    this.$buttonLabel = this.$link.appendSpan('button-label text');
  } else {
    // render as button
    $button = $parent.makeElement('<button>')
      .addClass('button');
    this.$buttonLabel = $button.appendSpan('button-label');

    if (scout.device.supportsTouch()) {
      $button.setTabbable(false);
    }
  }
  this.addContainer($parent, 'button-field', new scout.ButtonLayout(this));
  this.addField($button);
  // FIXME cgu: should we add a label? -> would make it possible to control the space left of the button using labelVisible, like it is possible with checkboxes
  this.addStatus();

  $button.on('click', this._onClick.bind(this))
    .unfocusable();

  if (this.menus && this.menus.length > 0) {
    this.menus.forEach(function(menu) {
      this.keyStrokeContext.registerKeyStroke(menu);
    }, this);
    if (this.label || !this.iconId) { // no indicator when _only_ the icon is visible
      this.$submenuIcon = (this.$link || $button).appendSpan('submenu-icon');
    }
  }
  this.session.keyStrokeManager.installKeyStrokeContext(this.formKeyStrokeContext);
};

scout.Button.prototype._remove = function() {
  scout.Button.parent.prototype._remove.call(this);
  this.session.keyStrokeManager.uninstallKeyStrokeContext(this.formKeyStrokeContext);
  this.$submenuIcon = null;
};

/**
 * @override
 */
scout.Button.prototype._renderProperties = function() {
  scout.Button.parent.prototype._renderProperties.call(this);
  this._renderIconId();
  this._renderSelected();
  this._renderDefaultButton();
};

scout.Button.prototype._renderForegroundColor = function() {
  scout.Button.parent.prototype._renderForegroundColor.call(this);
  // Color button label as well, otherwise the color would not be visible because button label has already a color set using css
  this.$buttonLabel.css('color', scout.styles.modelToCssColor(this.foregroundColor));
};

/**
 * @returns {Boolean}
 *          <code>true</code> if the action has been performed or <code>false</code> if it
 *          has not been performed (e.g. when the button is not enabled).
 */
scout.Button.prototype.doAction = function() {
  if (!this.enabledComputed || !this.visible) {
    return false;
  }

  if (this.displayStyle === scout.Button.DisplayStyle.TOGGLE) {
    this.setSelected(!this.selected);
  } else if (this.menus.length > 0) {
    this.togglePopup();
  } else {
    this.trigger('click');
  }
  return true;
};

scout.Button.prototype.togglePopup = function() {
  if (this.popup) {
    this.popup.close();
  } else {
    this.popup = this._openPopup();
    this.popup.one('destroy', function(event) {
      this.popup = null;
    }.bind(this));
  }
};

scout.Button.prototype._openPopup = function() {
  var popup = scout.create('ContextMenuPopup', {
    parent: this,
    menuItems: this.menus,
    cloneMenuItems: false,
    closeOnAnchorMousedown: false,
    $anchor: this.$field
  });
  popup.open();
  return popup;
};

scout.Button.prototype._doActionTogglesSubMenu = function() {
  return false;
};

scout.Button.prototype.setDefaultButton = function(defaultButton) {
  this.setProperty('defaultButton', defaultButton);
};

scout.Button.prototype._renderDefaultButton = function() {
  this.$field.toggleClass('default', this.defaultButton);
};

/**
 * @override
 */
scout.Button.prototype._renderEnabled = function() {
  scout.Button.parent.prototype._renderEnabled.call(this);
  if (this.displayStyle === scout.Button.DisplayStyle.LINK) {
    this.$link.setEnabled(this.enabledComputed);
    this.$field.setTabbable(this.enabledComputed && !scout.device.supportsTouch());
  }
};

scout.Button.prototype.setSelected = function(selected) {
  this.setProperty('selected', selected);
};

scout.Button.prototype._renderSelected = function() {
  if (this.displayStyle === scout.Button.DisplayStyle.TOGGLE) {
    this.$field.toggleClass('selected', this.selected);
  }
};

/**
 * @override
 */
scout.Button.prototype._renderLabel = function() {
  if (this.iconId) {
    // If there is an icon, we don't need to ensure &nbsp; for empty strings
    this.$buttonLabel.text(this.label);
  } else {
    this.$buttonLabel.textOrNbsp(this.label);
  }
  // Invalidate layout because button may now be longer or shorter
  this.htmlComp.invalidateLayoutTree();
};

scout.Button.prototype.setIconId = function(iconId) {
  this.setProperty('iconId', iconId);
};

/**
 * Adds an image or font-based icon to the button by adding either an IMG or SPAN element to the button.
 */
scout.Button.prototype._renderIconId = function() {
  var $iconTarget = this.$link || this.$field;
  $iconTarget.icon(this.iconId);
  var $icon = $iconTarget.data('$icon');
  if ($icon) {
    $icon.toggleClass('with-label', !!this.label);
    // <img>s are loaded asynchronously. The real image size is not known until the image is loaded.
    // We add a listener to revalidate the button layout after this has happened. The 'loading' and
    // 'broken' classes ensure the incomplete icon is not taking any space.
    $icon.removeClass('loading broken');
    if ($icon.is('img')) {
      $icon.addClass('loading');
      $icon
        .off('load error')
        .on('load', updateButtonLayoutAfterImageLoaded.bind(this, true))
        .on('error', updateButtonLayoutAfterImageLoaded.bind(this, false));
    }
  }
  // Invalidate layout because button may now be longer or shorter
  this.htmlComp.invalidateLayoutTree();

  // ----- Helper functions -----

  function updateButtonLayoutAfterImageLoaded(success) {
    $icon.removeClass('loading');
    $icon.toggleClass('broken', !success);
    this.htmlComp.invalidateLayoutTree();
  }
};

scout.Button.prototype._syncKeyStroke = function(keyStroke) {
  this._setProperty('keyStroke', keyStroke);
  this.buttonKeyStroke.parseAndSetKeyStroke(this.keyStroke);
};

scout.Button.prototype._onClick = function(event) {
  if (this.enabledComputed) {
    this.doAction();
  }
};

/**
 * @override FormField.js
 */
scout.Button.prototype.getFocusableElement = function() {
  if (this.adaptedBy) {
    return this.adaptedBy.getFocusableElement(this);
  } else {
    return scout.Button.parent.prototype.focus.getFocusableElement(this);
  }
};

/**
 * @override FormField.js
 */
scout.Button.prototype.getFocusableElement = function() {
  if (this.adaptedBy) {
    return this.adaptedBy.getFocusableElement(this);
  } else {
    return scout.Button.parent.prototype.focus.getFocusableElement(this);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ButtonAdapter = function() {
  scout.ButtonAdapter.parent.call(this);
  this._addRemoteProperties(['selected']);
};
scout.inherits(scout.ButtonAdapter, scout.FormFieldAdapter);

scout.ButtonAdapter.prototype._postCreateWidget = function() {
  if (!this.widget.keyStrokeScope) {
    return;
  }

  var formAdapter = this.widget.getForm().modelAdapter;
  if (formAdapter.attached) {
    this._resolveKeyStrokeScope();
    return;
  }
  // KeyStrokeScope is another widget (form or formfield) which may not be initialized and attached to the adapter yet.
  // The widget must be on the same form as the button, so once that form is attached the keyStrokeScope has to be available
  formAdapter.events.one('attach', this._resolveKeyStrokeScope.bind(this));
};

scout.ButtonAdapter.prototype._resolveKeyStrokeScope = function() {
  this.widget.keyStrokeScope = this.session.getWidget(this.widget.keyStrokeScope);
  if (!this.widget.keyStrokeScope) {
    throw new Error('Could not resolve keyStrokeScope: ' + this.widget.keyStrokeScope);
  }
};

scout.ButtonAdapter.prototype._onWidgetClick = function(event) {
  this._send('clicked');
};

scout.ButtonAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'click') {
    this._onWidgetClick(event);
  } else {
    scout.ButtonAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/**
 * @override ModelAdapter.js
 */
scout.ButtonAdapter.prototype.exportAdapterData = function(adapterData) {
  adapterData = scout.ButtonAdapter.parent.prototype.exportAdapterData.call(this, adapterData);
  delete adapterData.keyStrokeScope; // FIXME [awe] 6.1 - add log messages about deleted properties to exported json
  return adapterData;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Button Layout, for fields with a button.
 */
scout.ButtonLayout = function(button) {
  scout.ButtonLayout.parent.call(this, button);
  this.button = button;
};
scout.inherits(scout.ButtonLayout, scout.FormFieldLayout);

scout.ButtonLayout.prototype.naturalSize = function() {
  return scout.graphics.prefSize(this.button.$field, {
    includeMargin: true
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ButtonKeyStroke = function(button, keyStroke) {
  scout.ButtonKeyStroke.parent.call(this);
  this.field = button;
  this.parseAndSetKeyStroke(keyStroke);
  this.stopPropagation = true;

  this.renderingHints.offset = 4;
  this.renderingHints.hAlign = scout.hAlign.RIGHT;
  this.renderingHints.$drawingArea = function($drawingArea, event) {
    return this.field.$container;
  }.bind(this);
};
scout.inherits(scout.ButtonKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.ButtonKeyStroke.prototype._accept = function(event) {
  var accepted = scout.ButtonKeyStroke.parent.prototype._accept.call(this, event);
  return accepted && this.field.$field.isAttached();
};

/**
 * @override KeyStroke.js
 */
scout.ButtonKeyStroke.prototype.handle = function(event) {
  this.field.doAction();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CalendarField = function() {
  scout.CalendarField.parent.call(this);
  this._addAdapterProperties(['calendar']);
};
scout.inherits(scout.CalendarField, scout.FormField);

scout.CalendarField.prototype._render = function($parent) {
  this.addContainer($parent, 'calendar-field');
  this.addLabel();
  this.addStatus();
  if (this.calendar) {
    this.calendar.render(this.$container);
    this.addField(this.calendar.$container);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CalendarFieldAdapter = function() {
  scout.CalendarFieldAdapter.parent.call(this);
  this._addAdapterProperties(['calendar']);
};
scout.inherits(scout.CalendarFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CheckBoxField = function() {
  scout.CheckBoxField.parent.call(this);
  this.triStateEnabled = false;
  this.$checkBox;
  this.$checkBoxLabel;
};
scout.inherits(scout.CheckBoxField, scout.ValueField);

/**
 * The value of the CheckBoxField widget is: false, true (and null in tri-state mode)
 * @override
 */
scout.CheckBoxField.prototype._initKeyStrokeContext = function() {
  scout.CheckBoxField.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke(new scout.CheckBoxToggleKeyStroke(this));
};

scout.CheckBoxField.prototype._render = function($parent) {
  this.addContainer($parent, 'check-box-field');
  this.addLabel();
  this.addMandatoryIndicator();
  this.addFieldContainer($parent.makeDiv());

  this.$checkBox = this.$fieldContainer
    .appendDiv('check-box')
    .on('mousedown', this._onMouseDown.bind(this))
    .data('valuefield', this);
  this.addField(this.$checkBox);

  this.$checkBoxLabel = this.$fieldContainer
    .appendDiv('label')
    .on('mousedown', this._onMouseDown.bind(this));

  scout.tooltips.installForEllipsis(this.$checkBoxLabel, {
    parent: this
  });

  this.addStatus();
};

scout.CheckBoxField.prototype._remove = function() {
  scout.tooltips.uninstall(this.$checkBoxLabel);
  scout.CheckBoxField.parent.prototype._remove.call(this);
};

scout.CheckBoxField.prototype.acceptInput = function(whileTyping, forceSend) {
  //nop
};

scout.CheckBoxField.prototype._renderDisplayText = function() {
  //nop
};

scout.CheckBoxField.prototype._onMouseDown = function(event) {
  this.toggleChecked();
  if (event.currentTarget === this.$checkBoxLabel[0]) {
    this.session.focusManager.requestFocus(this.$checkBox);
  }
};

scout.CheckBoxField.prototype.toggleChecked = function() {
  if (!this.enabledComputed) {
    return;
  }
  if (this.triStateEnabled) {
    if (this.value === false) {
      this.setValue(true);
    } else if (this.value === true) {
      this.setValue(null);
    } else {
      this.setValue(false);
    }
  } else {
    this.setValue(!this.value);
  }
};

scout.CheckBoxField.prototype.setValue = function(value) {
  this.setProperty('value', value);
};

/**
 * @override
 */
scout.CheckBoxField.prototype._renderEnabled = function() {
  scout.CheckBoxField.parent.prototype._renderEnabled.call(this);
  this.$checkBox
    .setTabbable(this.enabledComputed && !scout.device.supportsTouch())
    .setEnabled(this.enabledComputed);
};

scout.CheckBoxField.prototype._renderProperties = function() {
  scout.CheckBoxField.parent.prototype._renderProperties.call(this);
  this._renderValue();
};

scout.CheckBoxField.prototype._renderValue = function() {
  this.$checkBox.toggleClass('checked', this.value === true);
  this.$checkBox.toggleClass('undefined', this.triStateEnabled && this.value !== true && this.value !== false);
};

/**
 * @override
 */
scout.CheckBoxField.prototype._renderLabel = function() {
  this.$checkBoxLabel.textOrNbsp(this.label, 'empty');
  // Make sure the empty label is as height as the other labels, especially important for top labels
  this.$label.html('&nbsp;');
};

/**
 * @override
 */
scout.CheckBoxField.prototype._renderFont = function() {
  scout.styles.legacyStyle(this, this.$fieldContainer);
};

/**
 * @override
 */
scout.CheckBoxField.prototype._renderForegroundColor = function() {
  scout.styles.legacyStyle(this, this.$fieldContainer);
};

/**
 * @override
 */
scout.CheckBoxField.prototype._renderBackgroundColor = function() {
  scout.styles.legacyStyle(this, this.$fieldContainer);
};

scout.CheckBoxField.prototype._renderGridData = function() {
  scout.CheckBoxField.parent.prototype._renderGridData.call(this);
  this.updateInnerAlignment({
    useHorizontalAlignment: true
  });
};

scout.CheckBoxField.prototype.prepareForCellEdit = function(opts) {
  scout.CheckBoxField.parent.prototype.prepareForCellEdit.call(this, opts);
  this.$checkBoxLabel.hide();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CheckBoxFieldAdapter = function() {
  scout.CheckBoxFieldAdapter.parent.call(this);
  this._addRemoteProperties(['value']);
};
scout.inherits(scout.CheckBoxFieldAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.CheckBoxToggleKeyStroke = function(checkbox) {
  scout.CheckBoxToggleKeyStroke.parent.call(this);
  this.field = checkbox;
  this.which = [scout.keys.SPACE];
  if (!(this.field.owner instanceof scout.Table)) {
    this.which.push(scout.keys.ENTER);
  }
  this.renderingHints.render = false;
  this.stopPropagation = true;
};
scout.inherits(scout.CheckBoxToggleKeyStroke, scout.KeyStroke);

/**
 * @override KeyStroke.js
 */
scout.CheckBoxToggleKeyStroke.prototype.handle = function(event) {
  this.field.toggleChecked();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ClipboardField = function() {
  scout.ClipboardField.parent.call(this);

  this._fileUploadWaitRetryCountTimeout = 99;
  this._fullSelectionLength = 0;
};
scout.inherits(scout.ClipboardField, scout.ValueField);

/**
 * @override Widget.js
 */
scout.ClipboardField.prototype._createKeyStrokeContext = function() {
  return new scout.InputFieldKeyStrokeContext();
};

scout.ClipboardField.prototype._render = function($parent) {
  // We don't use makeDiv() here intentionally because the DIV created must
  // not have the 'unselectable' attribute. Otherwise clipboard-field will
  // not work in IE9.
  this.addContainer($parent, 'clipboard-field');
  this.addLabel();
  this.addField($parent.makeElement('<div>'));
  this.addStatus();

  this.$field
    .disableSpellcheck()
    .attr('contenteditable', true)
    .attr('tabindex', '0')
    .on('keydown', this._onInput.bind(this))
    .on('input', this._onInput.bind(this))
    .on('paste', this._onPaste.bind(this))
    .on('copy', this._onCopy.bind(this))
    .on('cut', this._onCopy.bind(this));

  $parent.on('click', function(event) {
    this.session.focusManager.requestFocus(this.$field);
  }.bind(this));

  if (this.rendered) {
    this.session.focusManager.requestFocus(this.$field);
  }
};

scout.ClipboardField.prototype._renderProperties = function() {
  scout.ClipboardField.parent.prototype._renderProperties.call(this);
  this._renderDropType();
};

scout.ClipboardField.prototype._createDragAndDropHandler = function() {
  return scout.dragAndDrop.handler(this, {
    supportedScoutTypes: scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER,
    dropType: function() {
      return this.dropType;
    }.bind(this),
    dropMaximumSize: function() {
      return this.maximumSize;
    }.bind(this),
    allowedTypes: function() {
      return this.allowedMimeTypes;
    }.bind(this)
  });
};

scout.ClipboardField.prototype._renderDisplayText = function() {
  var displayText = this.displayText;
  var img;
  this.$field.children().each(function(idx, elem) {
    if (!img && elem.nodeName === 'IMG') {
      img = elem;
    }
  });
  if (scout.strings.hasText(displayText)) {
    this.$field.html(scout.strings.nl2br(displayText, true));
    scout.scrollbars.install(this.$field, {
      parent: this
    });

    this.$field.selectAllText();
    // store length of full selection, in order to determine if the whole text is selected in "onCopy"
    var selection = this._getSelection();
    this._fullSelectionLength = (selection) ? selection.toString().length : 0;
  } else {
    this.$field.empty();
  }
  // restore old img for firefox upload mechanism.
  if (img) {
    this.$field.prepend(img);
  }
};

// Because a <div> is used as field, jQuery's val() used in ValueField.js is not working here, so
// the content of displayText variable is used instead.
// (For reading the displayText innerHmtl() _could_ be used on the div-field, but some browsers
// would collapse whitespaces which would also collapse multiple tabs when coping some table rows.
// So instead of reading the effective displayText from the field, the internal displayText value
// will be reused without actual reading. Parsing of pasted content is handled onPaste() and stored
// in this.displayText.)
scout.ClipboardField.prototype._readDisplayText = function() {
  return this.displayText;
};

scout.ClipboardField.prototype._getSelection = function() {
  var selection, myWindow = this.$container.window(true);
  if (myWindow.getSelection) {
    selection = myWindow.getSelection();
  } else if (document.getSelection) {
    selection = document.getSelection();
  }
  if (!selection || selection.toString().length === 0) {
    return null;
  }
  return selection;
};

// do not allow enter something manually some browsers such as IE do not send input events.
// The 'keydown' event is used in this cases.
scout.ClipboardField.prototype._onInput = function(event) {
  if (event.type === 'input') {
    this._renderDisplayText();
    return false;
  } else if (!event['char'] || event['char'] === '') {
    return;
  } else if (event.ctrlKey && (event.key === 'c' || event.key === 'x')) {
    return;
  } else if (!this.readOnly && event.ctrlKey && event.key === 'v') {
    return;
  } else if (event.keyCode === scout.keys.ESC || event.keyCode === scout.keys.ENTER) {
    return;
  } else {
    this._renderDisplayText();
    return false;
  }
};

scout.ClipboardField.prototype._onCopy = function(event) {
  var selection, text, dataTransfer, myWindow = this.$container.window(true);
  if (event.originalEvent.clipboardData) {
    dataTransfer = event.originalEvent.clipboardData;
  } else if (myWindow.clipboardData) {
    dataTransfer = myWindow.clipboardData;
  } else {
    // unable to obtain data transfer object
    throw new Error('Unable to access clipboard data.');
  }

  // scroll bar must not be in field when copying
  scout.scrollbars.uninstall(this.$field, this.session);

  selection = this._getSelection();
  if (!selection) {
    return;
  }

  // if the length of the selection is equals to the length of the (initial) full selection
  // use the internal 'displayText' value because some browsers are collapsing white spaces
  // which lead to problems when coping data form tables with empty cells ("\t\t").
  if (selection.toString().length === this._fullSelectionLength) {
    text = this.displayText;
  } else {
    text = scout.strings.plainText(selection.toString());
  }

  try {
    // Chrome, Firefox - causes an exception in IE
    dataTransfer.setData('text/plain', text);
  } catch (e) {
    // IE, see https://www.lucidchart.com/techblog/2014/12/02/definitive-guide-copying-pasting-javascript/
    dataTransfer.setData('Text', text);
  }

  // (re)install scroll bars
  scout.scrollbars.install(this.$field, {
    parent: this
  });

  return false;
};

scout.ClipboardField.prototype._onPaste = function(event) {
  if (this.readOnly) {
    this._renderDisplayText();
    return;
  }
  var dataTransfer, myWindow = this.$container.window(true);
  this.$field.selectAllText();
  if (event.originalEvent.clipboardData) {
    dataTransfer = event.originalEvent.clipboardData;
  } else if (myWindow.clipboardData) {
    dataTransfer = myWindow.clipboardData;
  } else {
    // unable to obtain data transfer object
    throw new Error('Unable to access clipboard data.');
  }

  var filesArgument = [], // options to be uploaded, arguments for this.session.uploadFiles
    additionalOptions = {},
    additionalOptionsCompatibilityIndex = 0, // counter for additional options
    contentCount = 0;

  // some browsers (e.g. IE) specify text content simply as data of type 'Text', it is not listed in list of types
  var textContent = dataTransfer.getData('Text');
  if (textContent) {
    if (window.Blob) {
      filesArgument.push(new Blob([textContent], {
        type: scout.mimeTypes.TEXT_PLAIN
      }));
      contentCount++;
    } else {
      // compatibility workaround
      additionalOptions['textTransferObject' + additionalOptionsCompatibilityIndex++] = textContent;
      contentCount++;
    }
  }

  if (dataTransfer.items) {
    Array.prototype.forEach.call(dataTransfer.items, function(item) {
      if (item.type === scout.mimeTypes.TEXT_PLAIN) {
        item.getAsString(function(str) {
          filesArgument.push(new Blob([str], {
            type: scout.mimeTypes.TEXT_PLAIN
          }));
          contentCount++;
        });
      } else if (scout.isOneOf(item.type, [scout.mimeTypes.IMAGE_PNG, scout.mimeTypes.IMAGE_JPG, scout.mimeTypes.IMAGE_JPEG, scout.mimeTypes.IMAGE_GIF])) {
        filesArgument.push(item.getAsFile());
        contentCount++;
      }
    });
  }

  var waitForFileReaderEvents = 0;
  if (dataTransfer.files) {
    Array.prototype.forEach.call(dataTransfer.files, function(item) {
      var reader = new FileReader();
      // register functions for file reader
      reader.onload = function(event) {
        var f = new Blob([event.target.result], {
          type: item.type
        });
        f.name = item.name;
        filesArgument.push(f);
        waitForFileReaderEvents--;
      };
      reader.onerror = function(event) {
        waitForFileReaderEvents--;
        $.log.error('Error during file upload ' + item.name + ' / ' + event.target.error.code);
      };
      // start file reader
      waitForFileReaderEvents++;
      contentCount++;
      reader.readAsArrayBuffer(item);
    });
  }

  // upload function needs to be called asynchronously to support real files
  var uploadFunctionTimeoutCount = 0;
  var uploadFunction = function() {
    if (waitForFileReaderEvents !== 0 && uploadFunctionTimeoutCount++ !== this._fileUploadWaitRetryCountTimeout) {
      setTimeout(uploadFunction, 150);
      return;
    }

    if (uploadFunctionTimeoutCount >= this._fileUploadWaitRetryCountTimeout) {
      var boxOptions = {
        entryPoint: this.$container.entryPoint(),
        header: this.session.text('ui.ClipboardTimeoutTitle'),
        body: this.session.text('ui.ClipboardTimeout'),
        yesButtonText: this.session.text('Ok')
      };

      this.session.showFatalMessage(boxOptions);
      return;
    }

    // upload paste event as files
    if (filesArgument.length > 0 || Object.keys(additionalOptions).length > 0) {
      this.session.uploadFiles(this, filesArgument, additionalOptions, this.maximumSize, this.allowedMimeTypes);
    }
  }.bind(this);

  // upload content function, if content can not be read from event
  // (e.g. "Allow programmatic clipboard access" is disabled in IE)
  var uploadContentFunction = function() {
    // store old inner html (will be replaced)
    scout.scrollbars.uninstall(this.$field, this.session);
    var oldHtmlContent = this.$field.html();
    this.$field.html('');
    var restoreOldHtmlContent = function() {
      this.$field.html(oldHtmlContent);
      scout.scrollbars.install(this.$field, {
        parent: this
      });
    }.bind(this);
    setTimeout(function() {
      var imgElementsFound = false;
      this.$field.children().each(function(idx, elem) {
        if (elem.nodeName === 'IMG') {
          var srcAttr = $(elem).attr('src');
          var srcDataMatch = /^data:(.*);base64,(.*)/.exec(srcAttr);
          var mimeType = srcDataMatch && srcDataMatch[1];
          if (scout.isOneOf(mimeType, scout.mimeTypes.IMAGE_PNG, scout.mimeTypes.IMAGE_JPG, scout.mimeTypes.IMAGE_JPEG, scout.mimeTypes.IMAGE_GIF)) {
            var encData = window.atob(srcDataMatch[2]); // base64 decode
            var byteNumbers = [];
            for (var i = 0; i < encData.length; i++) {
              byteNumbers[i] = encData.charCodeAt(i);
            }
            var byteArray = new Uint8Array(byteNumbers);
            var f = new Blob([byteArray], {
              type: mimeType
            });
            f.name = '';
            filesArgument.push(f);
            imgElementsFound = true;
          }
        }
      });
      if (imgElementsFound) {
        restoreOldHtmlContent();
      } else {
        // try to read nativly pasted text from field
        var nativePasteContent = this.$field.text();
        if (scout.strings.hasText(nativePasteContent)) {
          this.setDisplayText(nativePasteContent);
          filesArgument.push(new Blob([nativePasteContent], {
            type: scout.mimeTypes.TEXT_PLAIN
          }));
        } else {
          restoreOldHtmlContent();
        }
      }
      uploadFunction();
    }.bind(this), 0);
  }.bind(this);

  if (contentCount > 0) {
    uploadFunction();

    // do not trigger any other actions
    return false;
  } else {
    uploadContentFunction();

    // trigger other actions to catch content
    return true;
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ClipboardFieldAdapter = function() {
  scout.ClipboardFieldAdapter.parent.call(this);
};
scout.inherits(scout.ClipboardFieldAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ColorField = function() {
  scout.ColorField.parent.call(this);
};
scout.inherits(scout.ColorField, scout.ValueField);

scout.ColorField.prototype._render = function($parent) {
  this.addContainer($parent, 'color-field');
  this.addLabel();
  this.addField($parent.makeDiv('not-implemented').text('not implemented yet'));
  this.addMandatoryIndicator();
  this.addStatus();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ColorFieldAdapter = function() {
  scout.ColorFieldAdapter.parent.call(this);
};
scout.inherits(scout.ColorFieldAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DateField = function() {
  scout.DateField.parent.call(this);

  this.hasDate = true;
  this.hasTime = false;
  this.disabledCopyOverlay = true;

  this.$dateField;
  this.$timeField;
  this.$dateFieldIcon;
  this.$timeFieldIcon;
  this._$predictDateField;
  this._$predictTimeField;

  // This is the storage for the time (as date) while the focus in the field (e.g. when
  // pressing up/down). In date fields, the date picker is used for that purposes.
  this._tempTimeDate;

  // The UI does some parsing validations that may set error status to "this.errorStatus"
  // (see _setDateValid() and _setTimeValid()). When the UI finds no errors, the UI error
  // status is removed. In this case, the original error status of the server model
  // has to be set again. Therefore, we have to store it in a private variable.
  this._modelErrorStatus = null;

  this.popup;
  this.oldDisplayText = '';
  this.timestamp = null;
  this._addCloneProperties(['timestamp', 'timestampAsDate', 'hasDate', 'hasTime', 'dateFormatPattern', 'timeFormatPattern']);
};
scout.inherits(scout.DateField, scout.ValueField);

/**
 * @override Widget.js
 */
scout.DateField.prototype._createKeyStrokeContext = function() {
  return new scout.InputFieldKeyStrokeContext();
};

scout.DateField.prototype._init = function(model) {
  scout.DateField.parent.prototype._init.call(this, model);
  scout.fields.initTouch(this, model);
  this.popup = model.popup;
  this._syncDateFormatPattern(this.dateFormatPattern);
  this._syncTimeFormatPattern(this.timeFormatPattern);
  this._syncTimestamp(this.timestamp);
  this._syncAutoTimestamp(this.autoTimestamp);
  this._syncDisplayText(this.displayText);
  this._syncAllowedDates(this.allowedDates);
};

scout.DateField.prototype.createPopup = function() {
  var popupType = this.touch ? 'DatePickerTouchPopup' : 'DatePickerPopup';
  return scout.create(popupType, {
    parent: this,
    $anchor: this.$field,
    boundToAnchor: !this.touch,
    closeOnAnchorMousedown: false,
    field: this,
    allowedDates: this.allowedDates,
    dateFormat: this.isolatedDateFormat
  });
};

scout.DateField.prototype._render = function($parent) {
  this.addContainer($parent, 'date-field');
  this.addLabel();
  this.addField($parent.makeDiv('date-time-composite'));
  this.addStatus(this.$field);
  if (!this.embedded) {
    this.addMandatoryIndicator();
  }

  this.htmlDateTimeComposite = scout.HtmlComponent.install(this.$field, this.session);
  this.htmlDateTimeComposite.setLayout(new scout.DateTimeCompositeLayout(this));
};

scout.DateField.prototype._renderProperties = function() {
  this._renderHasDate();
  this._renderHasTime();
  this._renderDateFormatPattern();

  // Has to be the last call, otherwise _renderErrorStatus() would operate on the wrong state.
  scout.DateField.parent.prototype._renderProperties.call(this);
};

scout.DateField.prototype._remove = function() {
  scout.DateField.parent.prototype._remove.call(this);
  this.$dateField = null;
  this.$timeField = null;
  this.$dateFieldIcon = null;
  this.$timeFieldIcon = null;
  this._$predictDateField = null;
  this._$predictTimeField = null;
  this.popup = null;
};

scout.DateField.prototype._renderHasDate = function() {
  if (this.hasDate && !this.$dateField) {
    // Add $dateField
    this.$dateField = scout.fields.makeInputOrDiv(this, 'date')
      .on('mousedown', this._onDateFieldClick.bind(this))
      .appendTo(this.$field);
    if (!this.touch) {
      this.$dateField
        .on('keydown', this._onDateFieldKeydown.bind(this))
        .on('input', this._onDateFieldInput.bind(this))
        .on('blur', this._onDateFieldBlur.bind(this));
    }

    scout.HtmlComponent.install(this.$dateField, this.session);

    this.$dateFieldIcon = scout.fields.appendIcon(this.$field, 'date')
      .on('mousedown', this._onDateIconClick.bind(this));

    this.invalidateLayout();

  } else if (!this.hasDate && this.$dateField) {
    // Remove $dateField
    this.$dateField.remove();
    this.$dateField = null;
    this.$dateFieldIcon.remove();
    this.$dateFieldIcon = null;

    this.invalidateLayout();
  }
};

scout.DateField.prototype._renderHasTime = function() {
  if (this.hasTime && !this.$timeField) {
    // Add $timeField
    this.$timeField = scout.fields.makeInputOrDiv(this, 'time')
      .on('mousedown', this._onTimeFieldClick.bind(this))
      .appendTo(this.$field);
    if (!this.touch) {
      this.$timeField
        .on('keydown', this._onTimeFieldKeydown.bind(this))
        .on('input', this._onTimeFieldInput.bind(this))
        .on('blur', this._onTimeFieldBlur.bind(this));
    }
    this.$timeFieldIcon = scout.fields.appendIcon(this.$field, 'time')
      .on('mousedown', this._onTimeIconClick.bind(this));
    scout.HtmlComponent.install(this.$timeField, this.session);

    this.invalidateLayout();

  } else if (!this.hasTime && this.$timeField) {
    // Remove $timeField
    this.$timeField.remove();
    this.$timeField = null;
    this.$timeFieldIcon.remove();
    this.$timeFieldIcon = null;

    this.invalidateLayout();
  }
};

/**
 * @override FormField.js
 */
scout.DateField.prototype._renderPlaceholder = function() {
  scout.DateField.parent.prototype._renderPlaceholder.call(this,
    this._fieldForPlaceholder());
};

/**
 * @override FormField.js
 */
scout.DateField.prototype._removePlaceholder = function() {
  scout.DateField.parent.prototype._removePlaceholder.call(this,
    this._fieldForPlaceholder());
};

scout.DateField.prototype._fieldForPlaceholder = function() {
  if (this.hasDate) {
    return this.$dateField;
  } else if (this.hasTime) {
    return this.$timeField;
  }
  return null;
};

scout.DateField.prototype._syncDateFormatPattern = function(dateFormatPattern) {
  this._setProperty('dateFormatPattern', dateFormatPattern);
  this.isolatedDateFormat = new scout.DateFormat(this.session.locale, this.dateFormatPattern);
};

scout.DateField.prototype._renderDateFormatPattern = function() {
  if (!this.popup) {
    return;
  }
  this.getDatePicker().dateFormat = this.isolatedDateFormat;
};

scout.DateField.prototype._syncTimeFormatPattern = function(timeFormatPattern) {
  this._setProperty('timeFormatPattern', timeFormatPattern);
  this.isolatedTimeFormat = new scout.DateFormat(this.session.locale, this.timeFormatPattern);
};

/**
 * @override FormField.js
 */
scout.DateField.prototype._renderEnabled = function() {
  scout.DateField.parent.prototype._renderEnabled.call(this);
  this.$container.setEnabled(this.enabledComputed);
  if (this.$dateField) {
    this.$dateField.setEnabled(this.enabledComputed);
  }
  if (this.$timeField) {
    this.$timeField.setEnabled(this.enabledComputed);
  }
};

/**
 * @override ValueField.js
 */
scout.DateField.prototype._renderDisplayText = function() {
  if (this.hasDate) {
    this._renderDateDisplayText();
  }
  if (this.hasTime) {
    this._renderTimeDisplayText();
  }
  this._removePredictionFields();
};

scout.DateField.prototype._renderDateDisplayText = function() {
  scout.fields.valOrText(this, this.$dateField, this.dateDisplayText);
};

scout.DateField.prototype._renderTimeDisplayText = function() {
  scout.fields.valOrText(this, this.$timeField, this.timeDisplayText);
};

scout.DateField.prototype._syncDisplayText = function(displayText) {
  var dateText = '',
    timeText = '',
    parts;

  this.oldDisplayText = this.displayText;
  this._setProperty('displayText', displayText);

  if (scout.strings.hasText(this.displayText)) {
    parts = this.displayText.split('\n');
    dateText = parts[0];
    timeText = parts[1];
  }
  this.dateDisplayText = dateText;
  this.timeDisplayText = timeText;
};

scout.DateField.prototype._syncTimestamp = function(timestamp) {
  // TODO CGU [6.1] no need to keep two timestamp properties, only hold date based type. Convert to back to string when sending. Also rename to value instead of timestamp
  timestamp = scout.dates.ensure(timestamp);
  this.timestampAsDate = timestamp;
};

scout.DateField.prototype._syncAutoTimestamp = function(autoTimestamp) {
  autoTimestamp = scout.dates.ensure(autoTimestamp);
  this.autoTimestampAsDate = autoTimestamp;
};

scout.DateField.prototype._syncAllowedDates = function(allowedDates) {
  if (Array.isArray(allowedDates)) {
    var convAllowedDates = [];
    allowedDates.forEach(function(dateString) {
      convAllowedDates.push(scout.dates.parseJsonDate(dateString));
    });
    this._setProperty('allowedDates', convAllowedDates);
  } else {
    this._setProperty('allowedDates', null);
  }
};

scout.DateField.prototype._renderAllowedDates = function() {
  if (!this.popup) {
    return;
  }
  this.getDatePicker().allowedDates = this.allowedDates;
};

/**
 * @override FormField.js
 */
scout.DateField.prototype._renderErrorStatus = function() {
  scout.DateField.parent.prototype._renderErrorStatus.call(this);
  var hasStatus = !!this.errorStatus,
    statusClass = hasStatus ? this.errorStatus.cssClass() : '';

  if (this.$dateField) {
    this.$dateField.removeClass(scout.Status.cssClasses);
    this.$dateField.toggleClass(statusClass, hasStatus);

    // Because the error color of field icons depends on the error status of sibling <input> elements.
    // The prediction fields are clones of the input fields, so the 'has-error' class has to be
    // removed from them as well to make the icon "valid".
    if (this._$predictDateField) {
      this._$predictDateField.removeClass(scout.Status.cssClasses);
      this._$predictDateField.toggleClass(statusClass, hasStatus);
    }
  }

  // Do the same for the time field
  if (this.$timeField) {
    this.$timeField.removeClass(scout.Status.cssClasses);
    this.$timeField.toggleClass(statusClass, hasStatus);
    if (this._$predictTimeField) {
      this._$predictTimeField.removeClass(scout.Status.cssClasses);
      this._$predictTimeField.toggleClass(statusClass, hasStatus);
    }
  }

  if (this.hasDate && this.popup) {
    this.popup.$container.removeClass(scout.Status.cssClasses);
    this.popup.$container.toggleClass(statusClass, hasStatus);
  }
};

/**
 * @Override FormField.js
 */
scout.DateField.prototype._renderFont = function() {
  this.$dateField && scout.styles.legacyStyle(this, this.$dateField);
  this.$timeField && scout.styles.legacyStyle(this, this.$timeField);
};

/**
 * @Override FormField.js
 */
scout.DateField.prototype._renderForegroundColor = function() {
  this.$dateField && scout.styles.legacyStyle(this, this.$dateField);
  this.$timeField && scout.styles.legacyStyle(this, this.$timeField);
};

/**
 * @Override FormField.js
 */
scout.DateField.prototype._renderBackgroundColor = function() {
  this.$dateField && scout.styles.legacyStyle(this, this.$dateField);
  this.$timeField && scout.styles.legacyStyle(this, this.$timeField);
};

scout.DateField.prototype._onDateFieldClick = function() {
  if (scout.fields.handleOnClick(this)) {
    this.openPopupAndSelect(this.timestampAsDate);
  }
};

scout.DateField.prototype._onDateIconClick = function(event) {
  if (scout.fields.handleOnClick(this)) {
    this.$dateField.focus();
    this.openPopupAndSelect(this.timestampAsDate);
  }
};

scout.DateField.prototype._onTimeFieldClick = function(event) {
  if (scout.fields.handleOnClick(this) && this.touch) {
    this.openPopupAndSelect(this.timestampAsDate);
  }
};

scout.DateField.prototype._onTimeIconClick = function(event) {
  if (scout.fields.handleOnClick(this)) {
    this.$timeField.focus();
    if (this.touch) {
      this.openPopupAndSelect(this.timestampAsDate);
    }
  }
};

scout.DateField.prototype._onDateFieldBlur = function() {
  // Close picker and update model
  if (!this.embedded) {
    // in embedded mode we must update the date prediction but not close the popup
    this.closePopup();
  }
  this._acceptDateTimePrediction(true, false);
};

scout.DateField.prototype._onTimeFieldBlur = function() {
  this._tempTimeDate = null;
  this._acceptDateTimePrediction(false, true);
};

/**
 * Handle "navigation" keys, i.e. keys that don't emit visible characters. Character input is handled
 * in _onDateFieldInput(), which is fired after 'keydown'.
 */
scout.DateField.prototype._onDateFieldKeydown = function(event) {
  var delta = 0,
    diffYears = 0,
    diffMonths = 0,
    diffDays = 0,
    cursorPos = this.$dateField[0].selectionStart,
    displayText = this.$dateField.val(),
    prediction = this._$predictDateField && this._$predictDateField.val(),
    modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),
    pickerStartDate = this.timestampAsDate || this._referenceDate(),
    shiftDate = true;

  // Don't propagate tab to cell editor -> tab should focus time field
  if (this.hasTime &&
    this.mode === scout.FormField.MODE_CELLEDITOR &&
    event.which === scout.keys.TAB &&
    modifierCount === 0) {
    event.stopPropagation();
    return;
  }

  if (event.which === scout.keys.TAB ||
    event.which === scout.keys.SHIFT ||
    event.which === scout.keys.HOME ||
    event.which === scout.keys.END ||
    event.which === scout.keys.CTRL ||
    event.which === scout.keys.ALT) {
    // Default handling
    return;
  }

  if (event.which === scout.keys.ENTER) {
    if (this.popup || this._$predictDateField) {
      // Close the picker and accept the current prediction (if available)
      this._acceptDateTimePrediction(true, false); // accept date part
      this.closePopup();
      $.suppressEvent(event);
    }
    return;
  }

  if (event.which === scout.keys.ESC) {
    if (this.popup) {
      // Close the picker, but don't do anything else
      this.closePopup();
      $.suppressEvent(event);
    }
    return;
  }

  if (event.which === scout.keys.RIGHT && cursorPos === displayText.length) {
    // Move cursor one right and apply next char of the prediction
    if (prediction) {
      this._setDateDisplayText(prediction.substring(0, displayText.length + 1));
    }
    return;
  }

  if (event.which === scout.keys.PAGE_UP || event.which === scout.keys.PAGE_DOWN) {
    if (!displayText || !this._isDateValid()) {
      // If input is empty or invalid, set picker to reference date
      pickerStartDate = this._referenceDate();
      if (this.hasTime) { // keep time part
        pickerStartDate = scout.dates.combineDateTime(pickerStartDate, this.timestampAsDate);
      }
      this.openPopupAndSelect(pickerStartDate);
      this.renderDate(pickerStartDate);
      shiftDate = false; // don't shift if field has no value yet and popup was not open
    } else if (!this.popup) {
      // Otherwise, ensure picker is open
      this.openPopupAndSelect(pickerStartDate);
    }
    if (shiftDate) {
      diffMonths = (event.which === scout.keys.PAGE_UP ? -1 : 1);
      this.shiftSelectedDate(0, diffMonths, 0);
    }
    $.suppressEvent(event);
    return;
  }

  if (event.which === scout.keys.UP || event.which === scout.keys.DOWN) {
    delta = (event.which === scout.keys.UP ? -1 : 1);
    //event.ctrlKey||event.metaKey  --> some keystrokes with ctrl modifier are captured and suppressed by osx use in this cases command key
    if ((event.ctrlKey || event.metaKey) && modifierCount === 1) { // only ctrl
      diffYears = delta;
    } else if (event.shiftKey && modifierCount === 1) { // only shift
      diffMonths = delta;
    } else if (modifierCount === 0) { // no modifier
      diffDays = delta;
    } else {
      // Unsupported modifier or too many modifiers
      $.suppressEvent(event);
      return;
    }

    if (!displayText || !this._isDateValid()) {
      // If input is empty or invalid, set picker to reference date
      pickerStartDate = this._referenceDate();
      if (this.hasTime) { // keep time part
        pickerStartDate = scout.dates.combineDateTime(pickerStartDate, this.timestampAsDate);
      }
      this.openPopupAndSelect(pickerStartDate);
      this.renderDate(pickerStartDate);
      shiftDate = false; // don't shift if field has no value yet and popup was not open
    } else if (!this.popup) {
      // Otherwise, ensure picker is open
      this.openPopupAndSelect(pickerStartDate);
    }
    if (shiftDate) {
      this.shiftSelectedDate(diffYears, diffMonths, diffDays);
    }
    $.suppressEvent(event);
    return;
  }
};

/**
 * Handle changed input. This method is fired when the field's content has been altered by a user
 * action (not by JS) such as pressing a character key, deleting a character using DELETE or
 * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.
 * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled
 * in _onDateFieldKeydown().
 */
scout.DateField.prototype._onDateFieldInput = function(event) {
  var displayText = this.$dateField.val();

  // If the focus has changed to another field in the meantime, don't predict anything and
  // don't show the picker. Just validate the input.
  if (this.$dateField[0] !== this.$dateField.activeElement(true)) {
    return;
  }

  // Create $predictDateField if necessary
  if (!this._$predictDateField) {
    this._$predictDateField = this._createPredictionField(this.$dateField);
  }

  // Predict date
  var datePrediction = this._predictDate(displayText); // this also updates the errorStatus
  if (datePrediction) {
    this._$predictDateField.val(datePrediction.text);
    this.openPopupAndSelect(datePrediction.date);
  } else {
    // No valid prediction!
    this._removePredictionFields();
  }
};

/**
 * Handle "navigation" keys, i.e. keys that don't emit visible characters. Character input is handled
 * in _onTimeFieldInput(), which is fired after 'keydown'.
 */
scout.DateField.prototype._onTimeFieldKeydown = function(event) {
  var delta = 0,
    diffHours = 0,
    diffMinutes = 0,
    diffSeconds = 0,
    cursorPos = this.$timeField[0].selectionStart,
    displayText = this.$timeField.val(),
    prediction = this._$predictTimeField && this._$predictTimeField.val(),
    modifierCount = (event.ctrlKey ? 1 : 0) + (event.shiftKey ? 1 : 0) + (event.altKey ? 1 : 0) + (event.metaKey ? 1 : 0),
    shiftDate = true;

  // Don't propagate shift-tab to cell editor -> shift tab should focus date field
  if (this.hasDate &&
    this.mode === scout.FormField.MODE_CELLEDITOR &&
    event.which === scout.keys.TAB &&
    event.shiftKey &&
    modifierCount === 1) {
    event.stopPropagation();
    return;
  }

  if (event.which === scout.keys.TAB ||
    event.which === scout.keys.SHIFT ||
    event.which === scout.keys.HOME ||
    event.which === scout.keys.END ||
    event.which === scout.keys.CTRL ||
    event.which === scout.keys.ALT ||
    event.which === scout.keys.ESC) {
    // Default handling
    return;
  }

  if (event.which === scout.keys.ENTER) {
    // Timefield is shown in touch popup, so we need to make sure time gets accepted and popup closed, even if the regular time field itself has no popup
    if (this.popup || this._$predictDateField) {
      // Accept the current prediction (if available)
      this._tempTimeDate = null;
      this._acceptDateTimePrediction(false, true); // accept time part
      this.closePopup();
      $.suppressEvent(event);
    }
    return;
  }

  if (event.which === scout.keys.RIGHT && cursorPos === displayText.length) {
    // Move cursor one right and apply next char of the prediction
    if (prediction) {
      this._setTimeDisplayText(prediction.substring(0, displayText.length + 1));
    }
    return;
  }

  if (event.which === scout.keys.UP || event.which === scout.keys.DOWN) {
    delta = (event.which === scout.keys.UP ? -1 : 1);
    if (event.ctrlKey && modifierCount === 1) { // only ctrl
      diffSeconds = delta;
    } else if (event.shiftKey && modifierCount === 1) { // only shift
      diffHours = delta;
    } else if (modifierCount === 0) { // no modifier
      diffMinutes = delta;
    } else {
      // Unsupported modifier or too many modifiers
      $.suppressEvent(event);
      return;
    }

    if (!this._tempTimeDate) {
      var timePrediction = this._predictTime(displayText); // this also updates the errorStatus
      if (timePrediction && timePrediction.date) {
        this._tempTimeDate = timePrediction.date;
      } else {
        this._tempTimeDate = this._referenceDate();
        shiftDate = false;
      }
    }
    if (shiftDate) {
      this._tempTimeDate = scout.dates.shiftTime(this._tempTimeDate, diffHours, diffMinutes, diffSeconds);
    }
    if (this.hasDate) {
      // Combine _tempTimeDate with existing date part
      this._tempTimeDate = scout.dates.combineDateTime(this.timestampAsDate || this._referenceDate(), this._tempTimeDate);
    }
    this.renderDate(this._tempTimeDate);
    $.suppressEvent(event);
    return;
  }
};

/**
 * Handle changed input. This method is fired when the field's content has been altered by a user
 * action (not by JS) such as pressing a character key, deleting a character using DELETE or
 * BACKSPACE, cutting or pasting text with ctrl-x / ctrl-v or mouse drag'n'drop.
 * Keys that don't alter the content (e.g. modifier keys, arrow keys, home, end etc.) are handled
 * in _onTimeFieldKeydown().
 */
scout.DateField.prototype._onTimeFieldInput = function(event) {
  var displayText = this.$timeField.val();

  // If the focus has changed to another field in the meantime, don't predict anything and
  // don't show the picker. Just validate the input.
  if (this.$timeField[0] !== this.$timeField.activeElement(true)) {
    return;
  }

  // Create $predictTimeField if necessary
  if (!this._$predictTimeField) {
    this._$predictTimeField = this._createPredictionField(this.$timeField);
  }

  // Predict time
  var timePrediction = this._predictTime(displayText); // this also updates the errorStatus
  if (timePrediction) {
    this._$predictTimeField.val(timePrediction.text);
  } else {
    // No valid prediction!
    this._tempTimeDate = null;
    this._removePredictionFields();
  }
};

scout.DateField.prototype._onDatePickerDateSelect = function(event) {
  this._setDateValid(true);
  this._setTimeValid(true);
  this.renderDate(event.date);
  if (!event.shifting) {
    this._triggerDisplayTextIfChanged();
    this.updateTimestamp(this._newTimestampAsDate(event.date, this.timestampAsDate));
    // closeDatePicker is set to false when date-field is in touch-mode
    // since popup will be closed by the embedded date-field
    if (scout.nvl(event.closeDatePicker, true)) {
      this.closePopup();
    }
  }
};

scout.DateField.prototype._createPredictionField = function($inputField) {
  var $predictionField = $inputField.clone()
    .addClass('predict')
    .attr('tabIndex', '-1')
    .insertBefore($inputField);
  if ($inputField.hasClass('has-error')) {
    $predictionField.addClass('has-error');
  }
  return $predictionField;
};

scout.DateField.prototype._removePredictionFields = function() {
  if (this._$predictDateField) {
    this._$predictDateField.remove();
    this._$predictDateField = null;
  }
  if (this._$predictTimeField) {
    this._$predictTimeField.remove();
    this._$predictTimeField = null;
  }
};

/**
 * Formats the given date (or this.timestampAsDate) using the specified formats and writes
 * the resulting string to the $dateField and $timeField, respectively. Prediction fields
 * are removed.
 */
scout.DateField.prototype.renderDate = function(date) {
  date = date || this.timestampAsDate;

  // Only update displayTexts when value is invalid. Otherwise, we would
  // override the invalid display text from the model. Also note that we
  // have to backup and restore the selection, otherwise, the cursor would
  // move to the end after every key press.
  var selection;
  if (this.hasDate && this._isDateValid()) {
    selection = this.$dateField.backupSelection();
    this._setDateDisplayText(this.isolatedDateFormat.format(date));
    this.$dateField.restoreSelection(selection);
  }
  if (this.hasTime && this._isTimeValid()) {
    selection = this.$timeField.backupSelection();
    this._setTimeDisplayText(this.isolatedTimeFormat.format(date));
    this.$timeField.restoreSelection(selection);
  }
  // Make sure there is no invisible and wrong prediction
  this._removePredictionFields();
};

scout.DateField.prototype._setDateDisplayText = function(displayText) {
  this.dateDisplayText = displayText;
  this._updateDisplayTextProperty();
  if (this.rendered) {
    this._renderDateDisplayText();
  }
};

scout.DateField.prototype._setTimeDisplayText = function(displayText) {
  this.timeDisplayText = displayText;
  this._updateDisplayTextProperty();
  if (this.rendered) {
    this._renderTimeDisplayText();
  }
};

scout.DateField.prototype._updateDisplayTextProperty = function() {
  var dateText = this.dateDisplayText || '',
    timeText = this.timeDisplayText || '';

  this.displayText = scout.strings.join('\n', dateText, timeText);
};

/**
 * @override ValueField.js
 */
scout.DateField.prototype.acceptInput = function(whileTyping) {
  this._acceptDateTimePrediction(this.hasDate, this.hasTime);
};

/**
 * @override ValueField.js
 */
scout.DateField.prototype.aboutToBlurByMouseDown = function(target) {
  var dateFieldActive, timeFieldActive, eventOnDatePicker,
    eventOnDateField = this.$dateField ? this.$dateField.isOrHas(target) : false,
    eventOnTimeField = this.$timeField ? this.$timeField.isOrHas(target) : false,
    eventOnPopup = this.popup && this.popup.$container.isOrHas(target);

  if (!eventOnDateField && !eventOnTimeField && !eventOnPopup) {
    // event outside this field.
    dateFieldActive = scout.focusUtils.isActiveElement(this.$dateField);
    timeFieldActive = scout.focusUtils.isActiveElement(this.$timeField);
    // Accept only the currently focused part (the other one cannot have a pending change)
    this._acceptDateTimePrediction(dateFieldActive, timeFieldActive);
    return;
  }

  // when date-field is embedded, time-prediction must be accepted before
  // the date-picker triggers the 'dateSelect' event.
  if (this.embedded) {
    eventOnDatePicker = this.getDatePicker().$container.isOrHas(target);
    timeFieldActive = scout.focusUtils.isActiveElement(this.$timeField);
    if (eventOnDatePicker && timeFieldActive) {
      this._acceptDateTimePrediction(false, true);
    }
  }
};

/**
 * Returns null if both arguments are not set. Otherwise, this.timestampAsDate or the current date
 * is used as basis and the given arguments are applied to that date. The result is returned.
 */
scout.DateField.prototype._newTimestampAsDate = function(date, time) {
  var result = null;
  if (date || time) {
    result = this._referenceDate();
    if (date) {
      result = scout.dates.combineDateTime(date, result);
    }
    if (time) {
      result = scout.dates.combineDateTime(result, time);
    }
  }
  return result;
};

/**
 * Returns the reference date for this date field, which is used in various places (i.e. opening the date picker, analyzing user inputs).
 *
 * The reference date is either (in that order):
 * - the model's "auto timestamp" (as date), or
 * - the current date/time
 */
scout.DateField.prototype._referenceDate = function() {
  var referenceDate = this.autoTimestampAsDate || scout.dates.trunc(new Date());
  if (this.allowedDates) {
    referenceDate = this._findAllowedReferenceDate(referenceDate);
  }
  return referenceDate;
};

/**
 * Find nearest allowed date which is equals or greater than the current referenceDate.
 */
scout.DateField.prototype._findAllowedReferenceDate = function(referenceDate) {
  var i, allowedDate;
  // 1st: try to find a date which is equals or greater than the referenceDate (today)
  for (i = 0; i < this.allowedDates.length; i++) {
    allowedDate = this.allowedDates[i];
    if (scout.dates.compare(allowedDate, referenceDate) >= 0) {
      return allowedDate;
    }
  }
  // 2nd: try to find an allowed date in the past
  for (i = this.allowedDates.length - 1; i >= 0; i--) {
    allowedDate = this.allowedDates[i];
    if (scout.dates.compare(allowedDate, referenceDate) <= 0) {
      return allowedDate;
    }
  }
  return referenceDate;
};

scout.DateField.prototype.updateTimestamp = function(timestampAsDate, syncToServer) {
  var timestamp = scout.dates.toJsonDate(timestampAsDate, false, this.hasDate, this.hasTime);
  if (timestamp !== this.timestamp || this.errorStatus) {
    this.timestamp = timestamp;
    this.timestampAsDate = timestampAsDate;

    if (!this._hasUiErrorStatus()) {
      this.trigger('timestampChanged', {
        timestamp: this.timestamp
      });
      if (scout.nvl(syncToServer, true)) {
        this._send('timestampChanged', {
          timestamp: this.timestamp
        });
      }
    }
  }
};

scout.DateField.prototype._sendParsingError = function() {
  this._send('parsingError');
};

scout.DateField.prototype._triggerDisplayTextIfChanged = function() {
  if (this.oldDisplayText !== this.displayText) {
    this._triggerDisplayTextChanged(this.displayText);
    this.oldDisplayText = this.displayText;
  }
};

scout.DateField.prototype.openPopup = function(date) {
  if (this.popup) {
    // already open
    return;
  }

  this.popup = this.createPopup();
  this.popup.open();
  this.popup.on('remove', function() {
    this.popup = null;
  }.bind(this));
  this.getDatePicker().on('dateSelect', this._onDatePickerDateSelect.bind(this));
};

scout.DateField.prototype.closePopup = function() {
  if (this.popup) {
    this.popup.close();
  }
};

scout.DateField.prototype._acceptDateTimePrediction = function(acceptDate, acceptTime) {
  var datePrediction, timePrediction,
    dateText = '',
    timeText = '';

  var success = true;
  if (acceptDate) {
    dateText = (this._$predictDateField ? this._$predictDateField.val() : this.$dateField.val());
    datePrediction = this._predictDate(dateText); // this also updates the errorStatus
    if (!datePrediction) {
      success = false;
    }
    this._setDateDisplayText(dateText);
  }
  if (acceptTime) {
    timeText = (this._$predictTimeField ? this._$predictTimeField.val() : this.$timeField.val());
    timePrediction = this._predictTime(timeText); // this also updates the errorStatus
    if (!timePrediction) {
      success = false;
    }
    this._setTimeDisplayText(timeText);
  }
  this._removePredictionFields();

  // Send display text before timestamp, otherwise server would create a display text by its own and send it back
  this._triggerDisplayTextIfChanged();

  if (success) {
    // parse success -> send new timestamp to server
    var newTimestamp = null;
    if ((acceptDate && datePrediction.date) || (acceptTime && timePrediction.date)) {
      newTimestamp = this._newTimestampAsDate(
        (acceptDate ? datePrediction.date : this.timestampAsDate), (acceptTime ? timePrediction.date : this.timestampAsDate));
    }
    this.updateTimestamp(newTimestamp);
    this.renderDate(this.timestampAsDate);
  } else {
    // parse error -> send error to server
    this._sendParsingError();
  }
};

/**
 * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'
 */
scout.DateField.prototype._predictDate = function(inputText) {
  inputText = inputText || '';

  // "Date calculations"
  var m = inputText.match(/^([+-])(\d*)$/);
  if (m) {
    var now = new Date();
    var daysToAdd = Number(m[1] + (m[2] || '0'));
    now.setDate(now.getDate() + daysToAdd);
    this._setDateValid(true);
    return {
      date: now,
      text: inputText
    };
  }

  var analyzeInfo = this.isolatedDateFormat.analyze(inputText, this._referenceDate());
  if (analyzeInfo.error) {
    this._setDateValid(false);
    return null;
  }

  // No predicted date? -> return empty string (may happen if inputText is empty)
  if (!analyzeInfo.predictedDate) {
    this._setDateValid(true);
    return {
      date: null,
      text: ''
    };
  }

  var predictedDate = analyzeInfo.predictedDate;
  var predictionFormat = new scout.DateFormat(this.isolatedDateFormat.locale, analyzeInfo.parsedPattern);
  var predictedDateFormatted = predictionFormat.format(predictedDate, true);

  // If predicted date format starts with validatedText, ensure that the capitalization matches.
  // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')
  m = predictedDateFormatted.match(new RegExp('^' + scout.strings.quote(inputText) + '(.*)$', 'i'));
  if (m) {
    predictedDateFormatted = inputText + m[1];
  }

  this._setDateValid(true);
  return {
    date: predictedDate,
    text: predictedDateFormatted
  };
};

/**
 * @returns null if input is invalid, otherwise an object with properties 'date' and 'text'
 */
scout.DateField.prototype._predictTime = function(inputText) {
  inputText = inputText || '';

  var analyzeInfo = this.isolatedTimeFormat.analyze(inputText, this._referenceDate());
  if (analyzeInfo.error) {
    this._setTimeValid(false);
    return null;
  }

  // No predicted date? -> return empty string (may happen if inputText is empty)
  if (!analyzeInfo.predictedDate) {
    this._setTimeValid(true);
    return {
      date: null,
      text: ''
    };
  }

  var predictedDate = analyzeInfo.predictedDate;
  var predictionFormat = new scout.DateFormat(this.isolatedTimeFormat.locale, analyzeInfo.parsedPattern);
  var predictedTimeFormatted = predictionFormat.format(predictedDate, true);

  // If predicted date format starts with validatedText, ensure that the capitalization matches.
  // Example: input = 'frid', predicted = 'Friday, 1.10.2014' --> return 'friday, 1.10.2014')
  var m = predictedTimeFormatted.match(new RegExp('^' + scout.strings.quote(inputText) + '(.*)$', 'i'));
  if (m) {
    predictedTimeFormatted = inputText + m[1];
  }

  this._setTimeValid(true);
  return {
    date: predictedDate,
    text: predictedTimeFormatted
  };
};

/**
 * @returns {scout.Status} error status from UI or error status set by model.
 */
scout.DateField.prototype._errorStatus = function(valid) {
  var errorStatus = this.errorStatus;
  if (valid) {
    // Set to valid
    if (errorStatus) {
      // If no other UI error remains, revert to errorStatus from model
      if (!this._hasUiErrorStatus()) {
        errorStatus = this._modelErrorStatus;
      }
    }
  } else {
    // Set to invalid (this is always a UI error)
    if (!this._hasUiErrorStatus()) {
      errorStatus = new scout.Status({
        message: this.session.text('ui.InvalidDateFormat'),
        severity: scout.Status.Severity.ERROR
      });
    }
  }
  return errorStatus;
};

/**
 * This method updates the UI parts (date, time) of the error status. When both UI parts are valid,
 * we use the error status from the model, which can be null (= no errors).
 */
scout.DateField.prototype._setErrorStatusPart = function(property, valid) {
  var errorStatus = this._errorStatus(valid);
  if (errorStatus) {
    errorStatus[property] = !valid;
    if (!errorStatus.invalidDate && !errorStatus.invalidTime) {
      errorStatus = this._modelErrorStatus;
    }
  }
  // clone error status, to prevent errorStatus and _modelErrorStatus pointing to the same instance
  this.setErrorStatus(scout.Status.clone(errorStatus));
};

scout.DateField.prototype._setDateValid = function(valid) {
  this._setErrorStatusPart('invalidDate', valid);
};

scout.DateField.prototype._setTimeValid = function(valid) {
  this._setErrorStatusPart('invalidTime', valid);
};

scout.DateField.prototype._isErrorStatusPartValid = function(property) {
  if (this.errorStatus && this.errorStatus[property]) {
    return false;
  }
  return true;
};

scout.DateField.prototype._isDateValid = function() {
  return this._isErrorStatusPartValid('invalidDate');
};

scout.DateField.prototype._isTimeValid = function() {
  return this._isErrorStatusPartValid('invalidTime');
};

scout.DateField.prototype._hasUiErrorStatus = function() {
  return !!(this.errorStatus && (this.errorStatus.invalidDate || this.errorStatus.invalidTime));
};

/**
 * Method invoked if being rendered within a cell-editor (mode='scout.FormField.MODE_CELLEDITOR'), and once the editor finished its rendering.
 */
scout.DateField.prototype.onCellEditorRendered = function(options) {
  if (options.openFieldPopup && this.hasDate) {
    this.openPopupAndSelect(this.timestampAsDate);
  }
};

/**
 * @override FormField.js
 */
scout.DateField.prototype.prepareForCellEdit = function(opts) {
  opts = opts || {};
  scout.DateField.parent.prototype.prepareForCellEdit.call(this, opts);

  this.$field.removeClass('cell-editor-field first');
  if (this.$dateField) {
    this.$dateField.addClass('cell-editor-field');
    if (opts.firstCell) {
      this.$dateField.addClass('first');
    }
  }
  if (this.$timeField) {
    this.$timeField.addClass('cell-editor-field');
    if (opts.firstCell && !this.$dateField) {
      this.$timeField.addClass('first');
    }
  }
};

/**
 * @returns DatePicker instance from popup, because the property name is different
 *    for DatePickerPopup and DatePickerTouchPopup.
 */
scout.DateField.prototype.getDatePicker = function() {
  return this.popup.getDatePicker();
};

/**
 * Opens picker and selects date
 *
 * @param date
 *          optional, Date to pass to the date picker. If no date is specified, the reference date
 *          is preselected (not selected!).
 */
scout.DateField.prototype.openPopupAndSelect = function(date) {
  if (!date) {
    this.preselectDate(this._referenceDate());
  } else {
    this.selectDate(date);
  }
};

scout.DateField.prototype.preselectDate = function(date, animated) {
  this.openPopup();
  this.getDatePicker().preselectDate(date, animated);
};

scout.DateField.prototype.selectDate = function(date, animated) {
  this.openPopup();
  this.getDatePicker().selectDate(date, animated);
};

scout.DateField.prototype.shiftSelectedDate = function(years, months, days) {
  this.openPopup();
  this.getDatePicker().shiftSelectedDate(years, months, days);
};

// TODO awe, cgu: (value-field): we should refactor this setTimestamp / formatTimestamp
// as soon as we have implemented parse/format/validation logic on ValueField.js. This
// should work like the Java client (AbstractValueField) does. Also rename timestamp to value
scout.DateField.prototype.setTimestamp = function(timestamp) {
  if (this.timestamp === timestamp) {
    return;
  }
  this._setProperty('timestamp', timestamp);
  this.timestampAsDate = scout.dates.parseJsonDate(timestamp);
  this.formatTimestamp(this.timestampAsDate);
  if (this.rendered) {
    this._renderDisplayText();
  }
};

scout.DateField.prototype.formatTimestamp = function(timestamp) {
  var
    dateText = '',
    timeText = '';

  if (timestamp) {
    if (this.hasDate) {
      dateText = this.isolatedDateFormat.format(timestamp);
    }
    if (this.hasTime) {
      timeText = this.isolatedTimeFormat.format(timestamp);
    }
  }

  this.dateDisplayText = dateText;
  this.timeDisplayText = timeText;
  this._updateDisplayTextProperty();
};

scout.DateField.prototype._renderDisabledStyle = function() {
  this._renderDisabledStyleInternal(this.$dateField);
  this._renderDisabledStyleInternal(this.$timeField);
  this._renderDisabledStyleInternal(this.$mandatory);
};

/**
 * @override
 */
scout.DateField.prototype._updateEmpty = function() {
  // TODO [6.1] CGU remove this method as soon as timestamp is renamed to value. Then the default implementation of value field may be used
  this.empty = this.timestamp === null || this.timestamp === undefined;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DateFieldAdapter = function() {
  scout.DateFieldAdapter.parent.call(this);
  this.enabledWhenOffline = true;
};
scout.inherits(scout.DateFieldAdapter, scout.ValueFieldAdapter);

scout.DateFieldAdapter.prototype._initProperties = function(model) {
  if (model.errorStatus) {
    model._modelErrorStatus = new scout.Status(model.errorStatus);
  } else {
    model._modelErrorStatus = null;
  }
};

scout.DateFieldAdapter.prototype._syncErrorStatus = function(errorStatus) {
  // always store the error status from the server in a separate property
  if (errorStatus) {
    this.widget._modelErrorStatus = new scout.Status(errorStatus);
  } else {
    this.widget._modelErrorStatus = null;
  }
  // if UI has already an error, don't overwrite it with the error status from the server
  if (!this.widget._hasUiErrorStatus()) {
    // info: this setter ensures that errorStatus object is converted to scout.Status
    this.widget.setErrorStatus(errorStatus);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DateTimeCompositeLayout = function(dateField) {
  scout.DateTimeCompositeLayout.parent.call(this);
  this._dateField = dateField;

  // Minimum field with to normal state, for smaller widths the "compact" style is applied.
  this.MIN_DATE_FIELD_WIDTH = 90;
  this.MIN_TIME_FIELD_WIDTH = 60;
};
scout.inherits(scout.DateTimeCompositeLayout, scout.AbstractLayout);

scout.DateTimeCompositeLayout.prototype.layout = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    $dateField = this._dateField.$dateField,
    $timeField = this._dateField.$timeField,
    $dateFieldIcon = this._dateField.$dateFieldIcon,
    $timeFieldIcon = this._dateField.$timeFieldIcon,
    $predictDateField = this._dateField._$predictDateField,
    $predictTimeField = this._dateField._$predictTimeField,
    htmlDateField = ($dateField ? scout.HtmlComponent.get($dateField) : null),
    htmlTimeField = ($timeField ? scout.HtmlComponent.get($timeField) : null);

  var availableSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  var dateFieldSize, timeFieldSize;
  // --- Date and time ---
  if (htmlDateField && htmlTimeField) {
    // Field size
    var dateFieldMargins = htmlDateField.getMargins();
    var timeFieldMargins = htmlTimeField.getMargins();
    var compositeMargins = new scout.Insets(
      Math.max(dateFieldMargins.top, timeFieldMargins.top),
      Math.max(dateFieldMargins.right, timeFieldMargins.right),
      Math.max(dateFieldMargins.bottom, timeFieldMargins.bottom),
      Math.max(dateFieldMargins.left, timeFieldMargins.left)
    );
    var compositeSize = availableSize.subtract(compositeMargins);
    var hgap = this._hgap();
    var totalWidth = compositeSize.width - hgap;
    // Date field 60%, time field 40%
    var dateFieldWidth = (totalWidth * 0.6);
    var timeFieldWidth = (totalWidth - dateFieldWidth);

    dateFieldSize = new scout.Dimension(dateFieldWidth, compositeSize.height);
    timeFieldSize = new scout.Dimension(timeFieldWidth, compositeSize.height);
    htmlDateField.setSize(dateFieldSize);
    htmlTimeField.setSize(timeFieldSize);
    $timeField.cssRight(0);

    // Icons
    $dateFieldIcon.cssRight(timeFieldWidth + hgap)
      .cssHeight(dateFieldSize.height)
      .cssLineHeight(dateFieldSize.height);
    $timeFieldIcon.cssRight(0)
      .cssHeight(timeFieldSize.height)
      .cssLineHeight(timeFieldSize.height);

    // Compact style
    $dateField.toggleClass('compact', dateFieldSize.width < this.MIN_DATE_FIELD_WIDTH);
    $timeField.toggleClass('compact', timeFieldSize.width < this.MIN_TIME_FIELD_WIDTH);

    // Prediction
    if ($predictDateField) {
      scout.graphics.setSize($predictDateField, dateFieldSize);
    }
    if ($predictTimeField) {
      scout.graphics.setSize($predictTimeField, timeFieldSize);
      $predictTimeField.cssRight(0);
    }
  }
  // --- Date only ---
  else if (htmlDateField) {
    // Field size
    dateFieldSize = availableSize.subtract(htmlDateField.getMargins());
    htmlDateField.setSize(dateFieldSize);

    // Icons
    $dateFieldIcon.cssRight(0)
      .cssHeight(dateFieldSize.height)
      .cssLineHeight(dateFieldSize.height);

    // Compact style
    $dateField.toggleClass('compact', dateFieldSize.width < this.MIN_DATE_FIELD_WIDTH);

    // Prediction
    if ($predictDateField) {
      scout.graphics.setSize($predictDateField, dateFieldSize);
    }
  }
  // --- Time only ---
  else if (htmlTimeField) {
    // Field size
    timeFieldSize = availableSize.subtract(htmlTimeField.getMargins());
    htmlTimeField.setSize(timeFieldSize);

    // Icons
    $timeFieldIcon.cssRight(0)
      .cssHeight(timeFieldSize.height)
      .cssLineHeight(timeFieldSize.height);

    // Compact style
    $timeField.toggleClass('compact', timeFieldSize.width < this.MIN_TIME_FIELD_WIDTH);

    // Prediction
    if ($predictTimeField) {
      scout.graphics.setSize($predictTimeField, timeFieldSize);
    }
  }
  var popup = this._dateField.popup;
  if (popup && popup.rendered) {
    // Make sure the popup is correctly positioned (especially necessary for cell editor)
    popup.position();
  }
};

scout.DateTimeCompositeLayout.prototype._hgap = function() {
  if (this._dateField.cellEditor) {
    return 0;
  }
  return scout.HtmlEnvironment.smallColumnGap;
};

scout.DateTimeCompositeLayout.prototype.preferredLayoutSize = function($container) {
  var prefSize = scout.graphics.prefSize($container);
  // --- Date and time ---
  if (this._dateField.hasDate && this._dateField.hasTime) {
    prefSize.width = this.MIN_DATE_FIELD_WIDTH + this._hgap() + this.MIN_TIME_FIELD_WIDTH;
  }
  // --- Date only ---
  else if (this._dateField.hasDate) {
    prefSize.width = this.MIN_DATE_FIELD_WIDTH;
  }
  // --- Time only ---
  else if (this._dateField.hasTime) {
    prefSize.width = this.MIN_TIME_FIELD_WIDTH;
  }
  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FileChooserField = function() {
  scout.FileChooserField.parent.call(this);
};
scout.inherits(scout.FileChooserField, scout.ValueField);

/**
 * @override Widget.js
 */
scout.FileChooserField.prototype._createKeyStrokeContext = function() {
  return new scout.InputFieldKeyStrokeContext();
};

scout.FileChooserField.prototype._render = function($parent) {
  this.addContainer($parent, 'file-chooser-field');
  this.addLabel();
  this.addMandatoryIndicator();

  this.addField(scout.fields.makeTextField($parent)
    .on('blur', this._onFieldBlur.bind(this))
    .on('dragenter', this._onDragEnterOrOver.bind(this))
    .on('dragover', this._onDragEnterOrOver.bind(this))
    .on('drop', this._onDrop.bind(this))
    .on('keydown', this._onKeydown.bind(this))
  );

  this.addIcon();
  this.addStatus();
};

scout.FileChooserField.prototype._remove = function() {
  scout.FileChooserField.parent.prototype._remove.call(this);
  if (this.$fileInputField) {
    this.$fileInputField.remove();
    this.$fileInputField = null;
  }
};

scout.FileChooserField.prototype._onDragEnterOrOver = function(event) {
  scout.dragAndDrop.verifyDataTransferTypesScoutTypes(event, scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER);
};

scout.FileChooserField.prototype._onDrop = function(event) {
  if (scout.dragAndDrop.dataTransferTypesContainsScoutTypes(event.originalEvent.dataTransfer, scout.dragAndDrop.SCOUT_TYPES.FILE_TRANSFER)) {
    event.stopPropagation();
    event.preventDefault();

    var files = event.originalEvent.dataTransfer.files;
    if (files.length >= 1) {
      this.session.uploadFiles(this, [files[0]], undefined, this.maximumUploadSize);
    }
  }
};

scout.FileChooserField.prototype._onKeydown = function(event) {
  if (event.which === scout.keys.DOWN) {
    this.openFileChooser();
    return false;
  }
  return true;
};

scout.FileChooserField.prototype._onClick = function(event) {};

scout.FileChooserField.prototype._onIconClick = function(event) {
  scout.FileChooserField.parent.prototype._onIconClick.call(this, event);
  this.openFileChooser();
};

scout.FileChooserField.prototype.openFileChooser = function() {
  // FIXME CGU [6.1] offline case?
  this.trigger('chooseFile');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.FileChooserFieldAdapter = function() {
  scout.FileChooserFieldAdapter.parent.call(this);
};
scout.inherits(scout.FileChooserFieldAdapter, scout.ValueFieldAdapter);

scout.FileChooserFieldAdapter.prototype._onWidgetChooseFile = function(event) {
  this._send('chooseFile');
};

scout.FileChooserFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'chooseFile') {
    this._onWidgetChooseFile(event);
  } else {
    scout.FileChooserFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.GroupBox = function() {
  scout.GroupBox.parent.call(this);
  this._addAdapterProperties(['fields', 'menus']);

  this.fields = [];
  this.menus = [];
  this.menuBarVisible = true;
  this.borderDecoration = 'auto';
  this.borderVisible = true;
  this.mainBox = false;
  this.scrollable = false;
  this.expandable = false;
  this.expanded = true;
  this.gridColumnCount = 2;
  this.controls = [];
  this.systemButtons = [];
  this.customButtons = [];
  this.processButtons = [];
  this.processMenus = [];
  this.staticMenus = [];

  this.$body;
  this.$title;
};
scout.inherits(scout.GroupBox, scout.CompositeField);

scout.GroupBox.prototype._init = function(model) {
  scout.GroupBox.parent.prototype._init.call(this, model);
  this._syncFields(this.fields);
  this.menuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.GroupBoxMenuItemsOrder()
  });
  if (this.mainBox) {
    this.menuBar.large();
  }
  this._updateMenuBar();
};

scout.GroupBox.prototype._syncFields = function(fields) {
  this._setProperty('fields', fields);
  this._prepareFields();
};

/**
 * @override
 */
scout.GroupBox.prototype._initKeyStrokeContext = function() {
  scout.GroupBox.parent.prototype._initKeyStrokeContext.call(this);
  this.keyStrokeContext.invokeAcceptInputOnActiveValueField = true;
  this.keyStrokeContext.$bindTarget = this._keyStrokeBindTarget.bind(this);
};

/**
 * @override FormField.js
 */
scout.GroupBox.prototype._syncKeyStrokes = function(keyStrokes) {
  keyStrokes = scout.arrays.ensure(keyStrokes);

  var groupBoxRenderingHints = {
    render: function() {
      return true;
    },
    offset: 0,
    hAlign: scout.hAlign.RIGHT,
    $drawingArea: function($drawingArea, event) {
      if (this.labelVisible) {
        return this.$title;
      } else {
        return this.$body;
      }
    }.bind(this)
  };

  keyStrokes
    .forEach(function(keyStroke) {
      keyStroke.actionKeyStroke.renderingHints = $.extend({}, keyStroke.actionKeyStroke.renderingHints, groupBoxRenderingHints);
    }, this);

  scout.GroupBox.parent.prototype._syncKeyStrokes.call(this, keyStrokes);
};

/**
 * Returns a $container used as a bind target for the key-stroke context of the group-box.
 * By default this function returns the container of the form, or when group-box is has no
 * form as a parent the container of the group-box.
 */
scout.GroupBox.prototype._keyStrokeBindTarget = function() {
  var form = this.getForm();
  if (form) {
    // keystrokes on a group-box have form scope
    return form.$container;
  }
  return this.$container;
};

scout.GroupBox.prototype._render = function($parent) {
  var htmlBody,
    env = scout.HtmlEnvironment;

  this.addContainer($parent, this.mainBox ? 'root-group-box' : 'group-box', this._createLayout());

  this.$title = this.$container.appendDiv('group-box-title');
  this.addLabel();
  this.addStatus();
  this.$body = this.$container.appendDiv('group-box-body');
  htmlBody = scout.HtmlComponent.install(this.$body, this.session);
  htmlBody.setLayout(new scout.LogicalGridLayout(env.formColumnGap, env.formRowGap));
  if (this.scrollable) {
    scout.scrollbars.install(this.$body, {
      parent: this,
      axis: 'y'
    });
  }

  this.controls.forEach(function(control) {
    control.render(this.$body);

    // set each children layout data to logical grid data
    control.setLayoutData(new scout.LogicalGridData(control));
  }, this);
};

scout.GroupBox.prototype._remove = function() {
  scout.GroupBox.parent.prototype._remove.call(this);
  if (this.scrollable) {
    scout.scrollbars.uninstall(this.$body);
  }
};

scout.GroupBox.prototype._renderProperties = function() {
  scout.GroupBox.parent.prototype._renderProperties.call(this);

  this._renderBorderVisible();
  this._renderExpandable();
  this._renderExpanded();
  this._renderMenuBarVisible();
};

scout.GroupBox.prototype._createLayout = function() {
  return new scout.GroupBoxLayout(this);
};

scout.GroupBox.prototype.addLabel = function() {
  if (this.$label) {
    return;
  }
  this.$label = this.$title.appendSpan('label');
};

scout.GroupBox.prototype._renderLabel = function() {
  this.$label.textOrNbsp(this.label);
};

scout.GroupBox.prototype._renderStatusPosition = function() {
  if (this.statusPosition === scout.FormField.STATUS_POSITION_TOP) {
    // move into title
    this.$status.appendTo(this.$title);
  } else {
    this.$status.appendTo(this.$container);
  }
  this.invalidateLayoutTree();
};

scout.GroupBox.prototype._prepareFields = function() {
  this.unregisterKeyStrokes(this.processButtons);

  this.controls = [];
  this.systemButtons = [];
  this.customButtons = [];
  this.processButtons = [];
  this.processMenus = [];

  var i, field;
  for (i = 0; i < this.fields.length; i++) {
    field = this.fields[i];
    if (field instanceof scout.Button) {
      if (field.processButton) {
        this.processButtons.push(field);
        if (field.systemType !== scout.Button.SystemType.NONE) {
          this.systemButtons.push(field);
        } else {
          this.customButtons.push(field);
        }
      } else {
        this.controls.push(field);
        this._registerButtonKeyStrokes(field);
      }
    } else if (field instanceof scout.TabBox) {
      this.controls.push(field);
      for (var k = 0; k < field.tabItems.length; k++) {
        if (field.tabItems[k].selectionKeystroke) {
          this.keyStrokeContext.registerKeyStroke(new scout.TabItemKeyStroke(field.tabItems[k].selectionKeystroke, field.tabItems[k]));
        }
      }
    } else {
      this.controls.push(field);
    }
  }

  // Create menu for each process button
  this.processButtons.forEach(function(button) {
    var menu = scout.create('ButtonAdapterMenu',
      scout.ButtonAdapterMenu.adaptButtonProperties(button, {
        parent: this,
        button: button
      }));
    this.processMenus.push(menu);
  }, this);
  this.registerKeyStrokes(this.processMenus);
};

scout.GroupBox.prototype._registerButtonKeyStrokes = function(button) {
  if (button.keyStrokes) {
    button.keyStrokes.forEach(function(keyStroke) {
      this.keyStrokeContext.registerKeyStroke(keyStroke);
    }, this);
  }
};

/**
 * @override
 */
scout.GroupBox.prototype.getFields = function() {
  return this.fields;
};

scout.GroupBox.prototype._renderBorderVisible = function() {
  var borderVisible = this.borderVisible;
  if (this.borderDecoration === 'auto') {
    borderVisible = this._computeBorderVisible(borderVisible);
  }

  if (!borderVisible) {
    this.$body.addClass('y-padding-invisible');
  }
};

// Don't include in renderProperties, it is not necessary to execute it initially because renderBorderVisible is executed already
scout.GroupBox.prototype._renderBorderDecoration = function() {
  this._renderBorderVisible();
};

scout.GroupBox.prototype.setMenuBarVisible = function(visible) {
  this.setProperty('menuBarVisible', visible);
};

scout.GroupBox.prototype._renderMenuBarVisible = function() {
  if (this.menuBarVisible) {
    this._renderMenuBar();
  } else {
    this.menuBar.remove();
  }
  this.invalidateLayoutTree();
};

scout.GroupBox.prototype._renderMenuBar = function() {
  this.menuBar.render(this.$container);
  if (this.menuBar.position === 'top') {
    // move after title
    this.menuBar.$container.insertAfter(this.$title);
  }
};

/**
 *
 * @returns false if it is the mainbox. Or if the groupbox contains exactly one tablefield which has an invisible label
 */
scout.GroupBox.prototype._computeBorderVisible = function(borderVisible) {
  if (this.mainBox) {
    borderVisible = false;
  } else if (this.parent instanceof scout.GroupBox &&
    this.parent.parent instanceof scout.Form &&
    this.parent.parent.parent instanceof scout.WrappedFormField &&
    this.parent.parent.parent.parent instanceof scout.SplitBox &&
    this.parent.getFields().length === 1) {
    // Special case for wizard: wrapped form in split box with a single group box
    borderVisible = false;
  }
  return borderVisible;
};

scout.GroupBox.prototype._renderExpandable = function() {
  var expandable = this.expandable;
  var $control = this.$title.children('.group-box-control');

  if (expandable) {
    if ($control.length === 0) {
      // Create control if necessary
      $control = this.$container.makeDiv('group-box-control')
        .on('click', this._onControlClick.bind(this))
        .prependTo(this.$title);
    }
    this.$title
      .addClass('expandable')
      .on('click.group-box-control', this._onControlClick.bind(this));
  } else {
    $control.remove();
    this.$title
      .removeClass('expandable')
      .off('.group-box-control');
  }
};

scout.GroupBox.prototype._renderExpanded = function() {
  var expanded = this.expanded;
  this.$container.toggleClass('collapsed', !expanded);
  if (this.borderDecoration === 'line') {
    this.$container.toggleClass('with-line', !expanded);
  }

  // Group boxes have set "useUiHeight=true" by default. When a group box is collapsed, it should not
  // stretched vertically (no "weight Y"). However, because "weightY" is -1 by default, a calculated value
  // is assigned (LogicalGridData._inheritWeightY()) that is based on the group boxes height. In collapsed
  // state, this height would be wrong. Therefore, we manually assign "weightY=0" to collapsed group boxes
  // to prevent them from beeing stretched.
  if (this.expanded) {
    // If group box was previously collapsed, restore original "weightY" griaData value
    if (this._collapsedWeightY !== undefined) {
      this.gridData.weightY = this._collapsedWeightY;
      delete this._collapsedWeightY;
    }
    // Update inner layout (e.g. menubar)
    this.invalidateLayout();
  } else {
    // If group box has a weight different than 0, we set it to zero and back up the old value
    if (this.gridData.weightY !== 0) {
      this._collapsedWeightY = this.gridData.weightY;
      this.gridData.weightY = 0;
    }
  }

  this.invalidateLayoutTree();
};

/**
 * @override FormField.js
 */
scout.GroupBox.prototype._renderLabelVisible = function(labelVisible) {
  this.$title.setVisible(this._computeTitleVisible(labelVisible));
  this._updateStatusVisible();
};

scout.GroupBox.prototype._computeTitleVisible = function(labelVisible) {
  labelVisible = scout.nvl(labelVisible, this.labelVisible);
  return !!(labelVisible && this.label && !this.mainBox);
};

/**
 * @override FormField.js
 */
scout.GroupBox.prototype._updateStatusVisible = function() {
  this._renderStatusVisible();
};

/**
 * @override FormField.js
 *
 * Only show the group box status if title is visible.
 */
scout.GroupBox.prototype._computeStatusVisible = function() {
  return scout.GroupBox.parent.prototype._computeStatusVisible.call(this) && this._computeTitleVisible();
};

scout.GroupBox.prototype._syncMenus = function(menus) {
  scout.GroupBox.parent.prototype._syncMenus.call(this, menus);

  if (this.menuBar) {
    // updateMenuBar is required because menuBar is not created yet when synMenus is called initially
    this._updateMenuBar();
  }
};

scout.GroupBox.prototype._updateMenuBar = function() {
  var menus = this.staticMenus
    .concat(this.processMenus)
    .concat(this.menus);

  this.menuBar.setMenuItems(menus);
};

scout.GroupBox.prototype._removeMenus = function() {
  // menubar takes care about removal
};

scout.GroupBox.prototype.setStaticMenus = function(staticMenus) {
  this._setProperty('staticMenus', staticMenus);
  this._updateMenuBar();
};

scout.GroupBox.prototype._onControlClick = function(event) {
  if (this.expandable) {
    this.setExpanded(!this.expanded);
  }
  $.suppressEvent(event); // otherwise, the event would be triggered twice sometimes (by group-box-control and group-box-title)
};

scout.GroupBox.prototype.setExpanded = function(expanded) {
  this.setProperty('expanded', expanded);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.GroupBoxAdapter = function() {
  scout.GroupBoxAdapter.parent.call(this);
  this._addAdapterProperties(['fields', 'menus']);
  this._addRemoteProperties(['expanded']);
};
scout.inherits(scout.GroupBoxAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.GroupBoxLayout = function(groupBox) {
  scout.GroupBoxLayout.parent.call(this);
  this._groupBox = groupBox;
  this._statusWidth = scout.HtmlEnvironment.fieldStatusWidth;

  // The maximum width for the group box body (null = no max. width)
  this.maxContentWidth = null;
};
scout.inherits(scout.GroupBoxLayout, scout.AbstractLayout);

scout.GroupBoxLayout.prototype.layout = function($container) {
  var titleMarginX, menuBarSize, gbBodySize,
    statusWidth = 0,
    statusPosition = this._groupBox.statusPosition,
    labelMarginX = 0,
    htmlContainer = this._groupBox.htmlComp,
    htmlGbBody = this._htmlGbBody(),
    htmlMenuBar = this._htmlMenuBar(),
    $groupBoxTitle = this._groupBox.$title,
    $label = this._groupBox.$label,
    $status = this._groupBox.$status,
    containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  if ($status && $status.isVisible()) {
    this._layoutStatus();
    statusWidth = $status.outerWidth(true);
  }

  if (htmlMenuBar) {
    menuBarSize = this._menuBarSize(htmlMenuBar, containerSize, statusWidth);
    htmlMenuBar.setSize(menuBarSize);
  } else {
    menuBarSize = new scout.Dimension(0, 0);
  }

  gbBodySize = containerSize.subtract(htmlGbBody.getMargins());
  gbBodySize.height -= this._titleHeight();
  gbBodySize.height -= menuBarSize.height;

  if (statusWidth > 0) {
    if (statusPosition === scout.FormField.STATUS_POSITION_TOP) {
      labelMarginX = $label.cssMarginX() + statusWidth;
      $label.css('width', 'calc(100% - ' + labelMarginX + 'px');
    } else {
      titleMarginX = $groupBoxTitle.cssMarginX() + statusWidth;
      $groupBoxTitle.css('width', 'calc(100% - ' + titleMarginX + 'px');
    }
  }

  // When max. content width should be enforced, add a padding to the group box body
  // if necessary (to make sure, scrollbar position is not changed)
  if (this.maxContentWidth > 0) {
    // Reset padding-right manually set by layout
    htmlGbBody.$comp.css('padding-right', '');
    // Measure current padding-right (by CSS)
    var cssPaddingRight = htmlGbBody.$comp.cssPxValue('padding-right');
    // Calculate difference between current body with and max. width
    var oldWidth = gbBodySize.width;
    var newWidth = Math.min(gbBodySize.width, this.maxContentWidth);
    var diff = oldWidth - newWidth;
    if (diff > cssPaddingRight) {
      htmlGbBody.$comp.css('padding-right', diff);
    }
  }

  $.log.trace('(GroupBoxLayout#layout) gbBodySize=' + gbBodySize);
  htmlGbBody.setSize(gbBodySize);

  if (htmlGbBody.scrollable) {
    scout.scrollbars.update(htmlGbBody.$comp);
  }
};

scout.GroupBoxLayout.prototype._layoutStatus = function() {
  var htmlContainer = this._groupBox.htmlComp,
    containerPadding = htmlContainer.getInsets({
      includeBorder: false
    }),
    top = containerPadding.top,
    right = containerPadding.right,
    $groupBoxTitle = this._groupBox.$title,
    titleInnerHeight = $groupBoxTitle.innerHeight(),
    $status = this._groupBox.$status,
    statusMargins = scout.graphics.getMargins($status),
    statusPosition = this._groupBox.statusPosition;

  $status.cssWidth(this._statusWidth);
  if (statusPosition === scout.FormField.STATUS_POSITION_DEFAULT) {
    $status
      .cssTop(top + $groupBoxTitle.cssMarginTop())
      .cssRight(right)
      .cssHeight(titleInnerHeight - statusMargins.vertical())
      .cssLineHeight(titleInnerHeight - statusMargins.vertical());
  }
};

scout.GroupBoxLayout.prototype.preferredLayoutSize = function($container) {
  var htmlContainer = this._groupBox.htmlComp,
    htmlGbBody = this._htmlGbBody(),
    htmlMenuBar,
    prefSize;

  if (this._groupBox.expanded) {
    prefSize = htmlGbBody.getPreferredSize()
      .add(htmlGbBody.getMargins());

    htmlMenuBar = this._htmlMenuBar();
    if (htmlMenuBar) {
      prefSize.height += htmlMenuBar.getPreferredSize().height;
    }
  } else {
    prefSize = new scout.Dimension(0, 0);
  }
  prefSize = prefSize.add(htmlContainer.getInsets());
  prefSize.height += this._titleHeight();

  // predefined height or width in pixel override other values
  if (this._groupBox.gridData && this._groupBox.gridData.widthInPixel) {
    prefSize.width = this._groupBox.gridData.widthInPixel;
  }
  if (this._groupBox.gridData && this._groupBox.gridData.heightInPixel) {
    prefSize.height = this._groupBox.gridData.heightInPixel;
  }

  return prefSize;
};

scout.GroupBoxLayout.prototype._titleHeight = function() {
  return scout.graphics.prefSize(this._groupBox.$title, {
    includeMargin: true
  }).height;
};

scout.GroupBoxLayout.prototype._menuBarSize = function(htmlMenuBar, containerSize, statusWidth) {
  var menuBarSize = scout.MenuBarLayout.size(htmlMenuBar, containerSize);
  if (!this._groupBox.mainBox) {
    // adjust size of menubar as well if it is in a regular group box
    menuBarSize.width -= statusWidth;
  }
  return menuBarSize;
};

/**
 * Return menu-bar when it exists and it is visible.
 */
scout.GroupBoxLayout.prototype._htmlMenuBar = function() {
  if (this._groupBox.menuBar && this._groupBox.menuBarVisible) {
    var htmlMenuBar = scout.HtmlComponent.get(this._groupBox.menuBar.$container);
    if (htmlMenuBar.isVisible()) {
      return htmlMenuBar;
    }
  }
  return null;
};

scout.GroupBoxLayout.prototype._htmlGbBody = function() {
  return scout.HtmlComponent.get(this._groupBox.$body);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.GroupBoxMenuItemsOrder = function() {};

scout.GroupBoxMenuItemsOrder.prototype.order = function(items) {
  var leftButtons = [],
    leftMenus = [],
    rightButtons = [],
    rightMenus = [];

  items.forEach(function(item) {
    if (item.isButton()) {
      var horizontalAlignment = item.horizontalAlignment;
      if (horizontalAlignment === undefined) {
        // Real buttons have no property 'horizontalAlignment' but a corresponding field on the gridData
        horizontalAlignment = (item.gridData && item.gridData.horizontalAlignment);
      }
      if (horizontalAlignment === 1) {
        rightButtons.push(item);
      } else { // also 0
        leftButtons.push(item);
      }
    } else {
      if (item.horizontalAlignment === 1) {
        rightMenus.push(item);
      } else { // also 0
        leftMenus.push(item);
      }
    }
  });

  return {
    left: leftButtons.concat(leftMenus),
    right: rightButtons.concat(rightMenus)
  };
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AbstractGroupBoxBodyGrid = function() {
  this.gridRows = 0;
  this.gridColumns = 0;
};

scout.AbstractGroupBoxBodyGrid.prototype.init = function() {};

scout.AbstractGroupBoxBodyGrid.prototype.validate = function(groupBox, recursive) {
  // reset old state
  this.gridRows = 0;
  // step 0: column count
  this.gridColumns = this._computeGridColumnCount(groupBox);
  var containingGridXYCount = 0;
  var notContainingGridXYCount = 0;
  // build
  var fieldsExceptProcessButtons = [];
  groupBox.fields.forEach(function(field) {
    if (field.visible) {
      if (!field.processButton) {
        fieldsExceptProcessButtons.push(field);
        var hints = field.gridDataHints;
        if (hints && hints.x >= 0 && hints.y >= 0) {
          containingGridXYCount++;
        } else {
          notContainingGridXYCount++;
        }
      }
    } else {
      var gd = scout.GridData.createFromHints(field, 1);
      field.gridData = gd;
    }
  }.bind(this));
  if (containingGridXYCount > 0 && notContainingGridXYCount === 0) {
    this.layoutAllStatic(fieldsExceptProcessButtons);
  } else {
    this.layoutAllDynamic(fieldsExceptProcessButtons);
  }

  if (recursive && recursive === true) {
    groupBox.fields.filter(function(e) {
      return e.objectType === 'GroupBox';
    }).forEach(function(e) {
      this.validate(e, true);
    }.bind(this));
  }
};

scout.AbstractGroupBoxBodyGrid.prototype.layoutAllStatic = function(fields) {
  var hints = [];
  fields.forEach(function(v) {
    hints.push(scout.GridData.createFromHints(v, 1));
  });
  var totalGridW = hints.reduce(function(x, y) {
    var y1 = y.x + y.w;
    return y1 > x ? y1 : x;
  }, 1);
  var totalGridH = hints.reduce(function(x, y) {
    var y1 = y.y + y.h;
    return y1 > x ? y1 : x;
  }, 0);
  fields.forEach(function(v) {
    v.gridData = scout.GridData.createFromHints(v, totalGridW);
  });
  this.gridRows = totalGridH;
  this.gridColumns = totalGridW;
};

scout.AbstractGroupBoxBodyGrid.prototype.layoutAllDynamic = function(fields) {
  // abstract, must be implemented by sub classes
};

scout.AbstractGroupBoxBodyGrid.prototype.getGridColumnCount = function() {
  return this.gridColumns;
};

scout.AbstractGroupBoxBodyGrid.prototype.getGridRowCount = function() {
  return this.gridRows;
};

scout.AbstractGroupBoxBodyGrid.prototype._computeGridColumnCount = function(groupBox) {
  var gridColumns = -1,
    tmp = groupBox;
  do {
    gridColumns = scout.nvl(tmp.gridColumnCount, gridColumns);
  } while (gridColumns < 0 && tmp.getParentGroupBox && (tmp = tmp.getParentGroupBox()));
  return gridColumns < 0 ? 2 : gridColumns;
};

/**
 * if grid w greater than group box column count. Grid w will be set to group box column count.
 */
scout.AbstractGroupBoxBodyGrid.getGridDataFromHints = function(field, groupBoxColumnCount) {
  var data = scout.GridData.createFromHints(field, groupBoxColumnCount);
  data.w = Math.min(groupBoxColumnCount, data.w);
  return data;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.HorizontalGroupBoxBodyGrid = function() {
  scout.HorizontalGroupBoxBodyGrid.parent.call(this);
};
scout.inherits(scout.HorizontalGroupBoxBodyGrid, scout.AbstractGroupBoxBodyGrid);

scout.AbstractGroupBoxBodyGrid.prototype.layoutAllDynamic = function(fields) {
  var matrix = new scout.HorizontalGridMatrixGroupBox(this.getGridColumnCount());
  matrix.computeGridData(fields);
  this.gridRows = matrix.getRowCount();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.VerticalSmartGroupBoxBodyGrid = function() {
  scout.VerticalSmartGroupBoxBodyGrid.parent.call(this);
};
scout.inherits(scout.VerticalSmartGroupBoxBodyGrid, scout.AbstractGroupBoxBodyGrid);

scout.VerticalSmartGroupBoxBodyGrid.prototype.layoutAllDynamic = function(fields) {
  var cellCount = 0;
  fields.forEach(function(f) {
    var hints = scout.AbstractGroupBoxBodyGrid.getGridDataFromHints(f, this.getGridColumnCount());
    cellCount += hints.w * hints.h;
  }.bind(this));

  // do the calc
  var rowCount = Math.floor((cellCount + this.getGridColumnCount() - 1) / this.getGridColumnCount());
  var matrix = new scout.VerticalGridMatrixGroupBox(this.getGridColumnCount(), rowCount);
  while (!matrix.computeGridData(fields)) {
    matrix.resetAll(this.getGridColumnCount(), ++rowCount);
  }

  // set gridData
  fields.forEach(function(f) {
    f.gridData = matrix.getGridData(f);
  });
  this.gridRows = matrix.getRowCount();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.AbstractGridMatrixGroupBox = function(cursor) {
  this._cursor = cursor;
  this._assignedCells = [];
};

scout.AbstractGridMatrixGroupBox.prototype.getColumnCount = function() {
  return this._cursor.columnCount;
};

scout.AbstractGridMatrixGroupBox.prototype.getRowCount = function() {
  return this._cursor.rowCount;
};

scout.AbstractGridMatrixGroupBox.prototype._setAssignedCell = function(index, val) {
  if (!this._assignedCells[index.x]) {
    this._assignedCells[index.x] = [];
  }
  this._assignedCells[index.x][index.y] = val;
};

scout.AbstractGridMatrixGroupBox.prototype._getAssignedCell = function(index) {
  if (!this._assignedCells[index.x]) {
    return null;
  }
  return this._assignedCells[index.x][index.y];
};

scout.AbstractGridMatrixGroupBox.prototype._nextFree = function(w, h) {
  if (!this._cursor.increment()) {
    return false;
  }
  var currentIndex = this._cursor.currentIndex();
  if (!this._isAllCellFree(currentIndex.x, currentIndex.y, w, h)) {
    if (!this._getAssignedCell(currentIndex)) {
      this._setAssignedCell(currentIndex, new scout.GroupBoxGridCell());
    }
    return this._nextFree(w, h);
  }
  return true;
};

scout.AbstractGridMatrixGroupBox.prototype._isAllCellFree = function(x, y, w, h) {
  if (x + w > this._cursor.startX + this._cursor.columnCount || y + h > this._cursor.startY + this._cursor.rowCount) {
    return false;
  }
  return this._assignedCells.slice(x, x + w).every(function(valX) {
    return (valX || []).slice(y, y + h).every(function(valY) {
      return !valY;
    }.bind(this));
  }.bind(this));
};

scout.AbstractGridMatrixGroupBox.prototype.toString = function() {
  var ret = "----Group Box Grid Matrix [orientation="+this._cursor.orientation+", columnCount=" + this.getColumnCount() + ", rowCount=" + this.getRowCount() + "]--------------\n";
  var tempCursor = new scout.GroupBoxGridMatrixCursor(0, 0, this.getColumnCount(), this.getRowCount(), this._cursor.orientation);
  while (tempCursor.increment()) {
    var cell = this._getAssignedCell(tempCursor.currentIndex());
    ret += "cell[" + tempCursor.currentIndex().x + ", " + tempCursor.currentIndex().y + "] ";
    if (!cell) {
      ret += "NULL";
    } else if (!cell.field) {
      ret += "Placeholder";
    } else {
      ret += cell.field + (cell.field ? ", [" + cell.field.label + "]" : "");
    }
    ret += "\n";
  }
  return ret;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.GroupBoxGridCell = function(field, data) {
  this.field = field;
  this.data = data;
};

scout.GroupBoxGridCell.prototype.isEmpty = function() {
  return !this.field;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.GroupBoxGridMatrixCursor = function(x, y, columnCount, rowCount, orientation) {
  this.startX = x;
  this.startY = y;
  this.columnCount = columnCount;
  this.rowCount = rowCount;
  this.orientation = orientation;

  this.reset();
};

scout.GroupBoxGridMatrixCursor.HORIZONTAL = 0;
scout.GroupBoxGridMatrixCursor.VERTICAL = 1;

scout.GroupBoxGridMatrixCursor.prototype.reset = function() {
  this._currentIndex = {
    x: -1,
    y: -1
  };
};

scout.GroupBoxGridMatrixCursor.prototype.currentIndex = function() {
  return {
    x: this._currentIndex.x,
    y: this._currentIndex.y
  };
};

scout.GroupBoxGridMatrixCursor.prototype.increment = function() {
  if (this._currentIndex.x < 0 || this._currentIndex.y < 0) {
    // initial
    this._currentIndex.x = this.startX;
    this._currentIndex.y = this.startY;
  } else if (this.orientation === scout.GroupBoxGridMatrixCursor.HORIZONTAL) {
    this._currentIndex.x++;
    if (this._currentIndex.x >= this.startX + this.columnCount) {
      this._currentIndex.x = this.startX;
      this._currentIndex.y++;
    }
  } else {
    // vertical
    this._currentIndex.y++;
    if (this._currentIndex.y >= this.startY + this.rowCount) {
      this._currentIndex.y = this.startY;
      this._currentIndex.x++;
    }
  }
  if (this._currentIndex.x >= this.startX + this.columnCount || this._currentIndex.y >= this.startY + this.rowCount) {
    return false;
  }
  return true;
};

scout.GroupBoxGridMatrixCursor.prototype.decrement = function() {
  if (this._currentIndex.x < 0 || this._currentIndex.y < 0) {
    return false;
  } else if (this._currentIndex.x >= this.startX + this.columnCount || this._currentIndex.y >= this.startY + this.rowCount) {
    this._currentIndex.x = this.startX + this.columnCount - 1;
    this._currentIndex.y = this.startY + this.rowCount - 1;
  } else if (this.orientation === scout.GroupBoxGridMatrixCursor.HORIZONTAL) {
    this._currentIndex.x--;
    if (this._currentIndex.x < this.startX) {
      this._currentIndex.x = this.startX + this.columnCount - 1;
      this._currentIndex.y--;
    }
  } else {
    // vertical
    this._currentIndex.y--;
    if (this._currentIndex.y < this.startY) {
      this._currentIndex.y = this.startY + this.rowCount - 1;
      this._currentIndex.x--;
    }
  }
  if (this._currentIndex.x < this.startX || this._currentIndex.y < this.startY) {
    return false;
  }
  return true;
};

scout.GroupBoxGridMatrixCursor.prototype.toString = function() {
  var builder = [];
  builder.push("MatrixCursor [");
  builder.push("orientation=" + this.orientation);
  builder.push(", startX=" + this.startX);
  builder.push(", startY=" + this.startY);
  builder.push(", columnCount=" + this.columnCount);
  builder.push(", currentIndex=" + this._currentIndex.x + ", " + this._currentIndex.y);
  builder.push("]");
  return builder.join("");
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.HorizontalGridMatrixGroupBox = function(columnCount) {
  scout.HorizontalGridMatrixGroupBox.parent.call(this, new scout.GroupBoxGridMatrixCursor(0, 0, columnCount, Number.MAX_SAFE_INTEGER, scout.GroupBoxGridMatrixCursor.HORIZONTAL));

  this.rowCount = 0;
};
scout.inherits(scout.HorizontalGridMatrixGroupBox, scout.AbstractGridMatrixGroupBox);

scout.HorizontalGridMatrixGroupBox.prototype.computeGridData = function(fields) {
  fields.forEach(function(field) {
    var hints = scout.GridData.createFromHints(field, this.getColumnCount());
    var gridData = new scout.GridData(hints);
    gridData.w = Math.min(hints.w, this.getColumnCount());
    this._add(field, hints, gridData);
    field.gridData = gridData;
  }.bind(this));
  this._cursor.rowCount = this.rowCount;
  return true;
};

scout.HorizontalGridMatrixGroupBox.prototype._add = function(field, hints, data) {
  this._nextFree(data.w, data.h);
  var currentIndex = this._cursor.currentIndex();
  if (data.w <= (this.getColumnCount() - currentIndex.x)) {
    data.x = currentIndex.x;
    data.y = currentIndex.y;
    // add field
    for (var xx = currentIndex.x; xx < currentIndex.x + data.w; xx++) {
      for (var yy = currentIndex.y; yy < currentIndex.y + data.h; yy++) {
        this._setAssignedCell({
          x: xx,
          y: yy
        }, new scout.GroupBoxGridCell(field, data));
      }
    }
    this.rowCount = currentIndex.y + data.h;
  } else {
    // add dummy cell
    this._setAssignedCell(this._cursor.currentIndex(), new scout.GroupBoxGridCell());
    this._add(field, hints, data);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.VerticalGridMatrixGroupBox = function(columnCount, rowCount, x, y) {
  scout.VerticalGridMatrixGroupBox.parent.call(this, new scout.GroupBoxGridMatrixCursor(x || 0, y || 0, columnCount, rowCount, scout.GroupBoxGridMatrixCursor.VERTICAL));

  this._fields = [];
  this._fieldGridDatas = [];
};
scout.inherits(scout.VerticalGridMatrixGroupBox, scout.AbstractGridMatrixGroupBox);

scout.VerticalGridMatrixGroupBox.prototype.resetAll = function(columnCount, rowCount) {
  this._fieldGridDatas = [];
  this._assignedCells = [];
  this._fieldIndexes = [];
  this._cursor = new scout.GroupBoxGridMatrixCursor(this._cursor.startX, this._cursor.startY, columnCount, rowCount, scout.GroupBoxGridMatrixCursor.VERTICAL);
};

scout.VerticalGridMatrixGroupBox.prototype.computeGridData = function(fields) {
  this._fields = fields;
  return fields.every(function(f, i) {
    this._fieldGridDatas[i] = scout.AbstractGroupBoxBodyGrid.getGridDataFromHints(f, this._cursor.columnCount);
    return this._add(f, this._fieldGridDatas[i]);
  }.bind(this));
};

scout.VerticalGridMatrixGroupBox.prototype.getGridData = function(f) {
  return this._fieldGridDatas[this._fields.indexOf(f)];
};

scout.VerticalGridMatrixGroupBox.prototype._addAssignedCells = function(cells) {
  cells.forEach(function(v, i) {
    if (v) {
      v.forEach(function(w, j) {
        if (w) {
          this._setAssignedCell({
            x: i,
            y: j
          }, w);
        }
      }.bind(this));
    }
  }.bind(this));
};

scout.VerticalGridMatrixGroupBox.prototype._getAssignedCells = function() {
  return this._assignedCells;
};

scout.VerticalGridMatrixGroupBox.prototype._add = function(f, gd) {
  var idx = this._cursor.currentIndex();
  if (gd.w > 1) {
    // try to reorganize fields above
    var x = idx.x,
      y = idx.y;
    // try to move left if the right border of the field is outside the column range
    while (x + gd.w > this._cursor.startX + this._cursor.columnCount) {
      // shift left and bottom
      x--;
      y = this._cursor.rowCount - 1;
    }
    this._reorganizeGridAbove(x, y, gd.w);
  }
  if (!this._nextFree(gd.w, gd.h)) {
    return false;
  }
  idx = this._cursor.currentIndex();
  gd.x = idx.x;
  gd.y = idx.y;
  // add field
  for (var xx = idx.x; xx < idx.x + gd.w; xx++) {
    for (var yy = idx.y; yy < idx.y + gd.h; yy++) {
      this._setAssignedCell({
        x: xx,
        y: yy
      }, new scout.GroupBoxGridCell(f, gd));
    }
  }
  return true;
};

scout.VerticalGridMatrixGroupBox.prototype._reorganizeGridAbove = function(x, y, w) {
  var fieldsToReorganize = [];
  var addFieldToReorganize = function(f) {
    if (fieldsToReorganize.indexOf(f) === -1) {
      fieldsToReorganize.push(f);
    }
  };
  var occupiedCells = [];
  var setOccupiedCell = function(x, y, val) {
    if (!occupiedCells[x]) {
      occupiedCells[x] = [];
    }
    occupiedCells[x][y] = val;
  };
  var reorgBounds = {
    x: x,
    y: 0,
    w: w,
    h: y + 1
  }; // x, y, w, h

  var minY = y;
  var usedCells = 0;
  var continueLoop = true;
  for (var yi = y; yi >= 0 && continueLoop; yi--) {
    for (var xi = x; xi < x + w && continueLoop; xi++) {
      var idx = {
        x: xi,
        y: yi
      };
      var cell = this._getAssignedCell(idx);
      if (cell && !cell.isEmpty()) {
        var gd = cell.data;
        if (this._horizontalMatchesOrOverlaps(reorgBounds, gd)) {
          continueLoop = false;
        } else if (this._horizontalOverlapsOnSide(reorgBounds, gd)) {
          // freeze the cells for reorganization
          setOccupiedCell(idx.x, idx.y, cell);
          usedCells++;
          minY = Math.min(idx.y, minY);
        }
        // includes
        else {
          // add field to reorganization
          this._setAssignedCell(idx, null);
          addFieldToReorganize(cell.field);
          usedCells++;
          minY = Math.min(idx.y, minY);
        }
      }
    }
  }
  if (fieldsToReorganize.length === 0) {
    return;
  }
  fieldsToReorganize.sort(function(a, b) {
    return this._fields.indexOf(a) < this._fields.indexOf(b) ? -1 : 1;
  }.bind(this));
  reorgBounds.y = minY;

  var reorgMatrix = new scout.VerticalGridMatrixGroupBox(reorgBounds.w, Math.floor((usedCells + reorgBounds.w - 1) / reorgBounds.w), reorgBounds.x, reorgBounds.y);
  reorgMatrix._addAssignedCells(occupiedCells);
  while (!reorgMatrix.computeGridData(fieldsToReorganize)) {
    reorgMatrix.resetAll(reorgMatrix.getColumnCount(), reorgMatrix.getRowCount() + 1);
  }
  this._cursor.reset();
  this._addAssignedCells(reorgMatrix._getAssignedCells());
  reorgMatrix._fieldGridDatas.forEach(function(v, i) {
    this._fieldGridDatas[this._fields.indexOf(reorgMatrix._fields[i])] = v;
  }.bind(this));
};

scout.VerticalGridMatrixGroupBox.prototype._horizontalMatchesOrOverlaps = function(bounds, gd) {
  return bounds.x >= gd.x && bounds.x + bounds.w <= gd.x + gd.w;
};

scout.VerticalGridMatrixGroupBox.prototype._horizontalOverlapsOnSide = function(bounds, gd) {
  return bounds.x > gd.x || bounds.x + bounds.w < gd.x + gd.w;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.HtmlField = function() {
  scout.HtmlField.parent.call(this);
  this.scrollBarEnabled = false;
  this.preventInitialFocus = true;
};
scout.inherits(scout.HtmlField, scout.ValueField);

/**
 * @override FormField.js
 */
scout.HtmlField.prototype._initKeyStrokeContext = function() {
  scout.HtmlField.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke(new scout.AppLinkKeyStroke(this, this._onAppLinkAction));
};

scout.HtmlField.prototype._render = function($parent) {
  this.addContainer($parent, 'html-field');
  this.addLabel();

  this.addField($parent.makeDiv());
  this.addStatus();
};

scout.HtmlField.prototype._renderProperties = function() {
  scout.HtmlField.parent.prototype._renderProperties.call(this);

  this._renderScrollBarEnabled();
  this._renderScrollToAnchor(this.scrollToAnchor);
};

/**
 * @override
 */
scout.HtmlField.prototype._renderDisplayText = function() {
  if (!this.displayText) {
    this.$field.empty();
    return;
  }
  this.$field.html(this.displayText);

  // Add action to app-links
  this.$field.find('.app-link')
    .on('click', this._onAppLinkAction.bind(this));

  // Don't change focus when a link is clicked by mouse
  this.$field.find('a, .app-link')
    .attr('tabindex', '0')
    .unfocusable();

  // Add listener to images to update the layout when the images are loaded
  this.$field.find('img')
    .on('load', this._onImageLoad.bind(this))
    .on('error', this._onImageError.bind(this));

  // Because this method replaces the content, the scroll bars might have to be added or removed
  if (this.rendered) { // (only necessary if already rendered, otherwise it is done by renderProperties)
    this._renderScrollBarEnabled();
  }

  this.invalidateLayoutTree();
};

scout.HtmlField.prototype._remove = function() {
  scout.scrollbars.uninstall(this.$field, this.session);
  scout.HtmlField.parent.prototype._remove.call(this);
};

scout.HtmlField.prototype._renderScrollBarEnabled = function() {
  if (this.scrollBarEnabled) {
    scout.scrollbars.install(this.$field, {
      parent: this
    });
  } else {
    scout.scrollbars.uninstall(this.$field, this.session);
  }
};

// Not called in _renderProperties() because this is not really a property (more like an event)
scout.HtmlField.prototype._renderScrollToEnd = function() {
  if (this.scrollBarEnabled) {
    scout.scrollbars.scrollToBottom(this.$fieldContainer);
  }
};

scout.HtmlField.prototype._renderScrollToAnchor = function(anchor) {
  if (this.scrollBarEnabled && anchor && this.$field.find(anchor)) {
    var anchorElem = this.$field.find('#'.concat(anchor));
    if (anchorElem && anchorElem.length > 0) {
      scout.scrollbars.scrollTo(this.$fieldContainer, anchorElem);
    }
  }
};

scout.HtmlField.prototype._onAppLinkAction = function(event) {
  var $target = $(event.target);
  var ref = $target.data('ref');
  this.triggerAppLinkAction(ref);
};

scout.HtmlField.prototype.triggerAppLinkAction = function(ref) {
  this.trigger('appLinkAction', {
    ref: ref
  });
};

scout.HtmlField.prototype._onImageLoad = function(event) {
  this.invalidateLayoutTree();
};

scout.HtmlField.prototype._onImageError = function(event) {
  this.invalidateLayoutTree();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.HtmlFieldAdapter = function() {
  scout.HtmlFieldAdapter.parent.call(this);
};
scout.inherits(scout.HtmlFieldAdapter, scout.ValueFieldAdapter);

scout.HtmlFieldAdapter.prototype._onWidgetAppLinkAction = function(event) {
  this._send('appLinkAction', {
    ref: event.ref
  });
};

scout.HtmlFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'appLinkAction') {
    this._onWidgetAppLinkAction(event);
  } else {
    scout.HtmlFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ImageField = function() {
  scout.ImageField.parent.call(this);
  this.scrollBarEnabled = false;
};
scout.inherits(scout.ImageField, scout.FormField);

scout.ImageField.prototype._render = function($parent) {
  this.addContainer($parent, 'image-field', new scout.ImageFieldLayout(this));
  this.addFieldContainer($parent.makeDiv());

  var $field = this.$fieldContainer.appendElement('<img>', 'image')
    .on('load', this._onImageLoad.bind(this))
    .on('error', this._onImageError.bind(this));

  this.addLabel();
  this.addField($field);
  this.addStatus();
};

scout.ImageField.prototype._renderProperties = function() {
  scout.ImageField.parent.prototype._renderProperties.call(this);
  this._renderImageUrl();
  this._renderAutoFit();
  this._renderScrollBarEnabled();
  this._renderDropType();
};

scout.ImageField.prototype._remove = function() {
  scout.scrollbars.uninstall(this.$fieldContainer, this.session);
  scout.ImageField.parent.prototype._remove.call(this);
};

scout.ImageField.prototype._installDragAndDropHandler = function(event) {
  if (this.dragAndDropHandler) {
    return;
  }
  // add drag and drop event listeners to field container, img field might be hidden (e.g. if no image has been set)
  this.dragAndDropHandler = this._createDragAndDropHandler();
  this.dragAndDropHandler.install(this.$fieldContainer);
};

scout.ImageField.prototype._renderImageUrl = function() {
  this.$field.attr('src', this.imageUrl);
  // Hide <img> when it has no content to suppress the browser's 'broken image' icon
  this.$field.toggleClass('empty', !this.imageUrl);
};

scout.ImageField.prototype._renderAutoFit = function() {
  this.$field.toggleClass('autofit', this.autoFit);
  scout.scrollbars.update(this.$fieldContainer);
};

scout.ImageField.prototype._renderScrollBarEnabled = function() {
  // Note: Inner alignment has to be updated _before_ installing the scrollbar, because the inner
  // alignment uses absolute positioning, which confuses the scrollbar calculations.
  this._updateInnerAlignment();

  if (this.scrollBarEnabled) {
    scout.scrollbars.install(this.$fieldContainer, {
      parent: this
    });
  } else {
    scout.scrollbars.uninstall(this.$fieldContainer, this.session);
  }
};

scout.ImageField.prototype._renderGridData = function() {
  scout.ImageField.parent.prototype._renderGridData.call(this);
  this._updateInnerAlignment();
};

scout.ImageField.prototype._updateInnerAlignment = function() {
  // Enable inner alignment only when scrollbars are disabled
  this.updateInnerAlignment({
    useHorizontalAlignment: (!this.scrollBarEnabled),
    useVerticalAlignment: (!this.scrollBarEnabled)
  });
};

scout.ImageField.prototype._onImageLoad = function(event) {
  this.$field.removeClass('broken');
  scout.scrollbars.update(this.$fieldContainer);
  this.invalidateLayoutTree();
};

scout.ImageField.prototype._onImageError = function(event) {
  this.$field.addClass('empty broken');
  scout.scrollbars.update(this.$fieldContainer);
  this.invalidateLayoutTree();
};

scout.ImageField.prototype.setImageUrl = function(imageUrl) {
  this.setProperty('imageUrl', imageUrl);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ImageFieldAdapter = function() {
  scout.ImageFieldAdapter.parent.call(this);
};
scout.inherits(scout.ImageFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ImageFieldLayout = function(imageField) {
  scout.ImageFieldLayout.parent.call(this, imageField);
};
scout.inherits(scout.ImageFieldLayout, scout.FormFieldLayout);

scout.ImageFieldLayout.prototype.layout = function($container) {
  scout.ImageFieldLayout.parent.prototype.layout.call(this, $container);
  scout.scrollbars.update(this.formField.$fieldContainer);
};

scout.ImageFieldLayout.prototype.naturalSize = function(formField) {
  var img = formField.$field[0];
  if (img && img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
    return new scout.Dimension(img.naturalWidth, img.naturalHeight);
  }
  return scout.ImageFieldLayout.parent.prototype.naturalSize.call(this, formField);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.LabelField = function() {
  scout.LabelField.parent.call(this);
};
scout.inherits(scout.LabelField, scout.ValueField);

scout.LabelField.prototype._render = function($parent) {
  this.addContainer($parent, 'label-field');
  this.addLabel();
  this.addField($parent.makeDiv());
  this.addStatus();
};

scout.LabelField.prototype._renderProperties = function() {
  scout.LabelField.parent.prototype._renderProperties.call(this);
  this._renderWrapText(this.wrapText);
  // FIXME cgu: render selectable
};

/**
 * @override
 */
scout.LabelField.prototype._renderDisplayText = function() {
  var displayText = this.displayText || '';
  if (this.htmlEnabled) {
    this.$field.html(displayText);
  } else {
    this.$field.html(scout.strings.nl2br(displayText));
  }
};

scout.LabelField.prototype._renderWrapText = function() {
  this.$field.toggleClass('white-space-nowrap', !this.wrapText);
};

scout.LabelField.prototype._renderGridData = function() {
  scout.LabelField.parent.prototype._renderGridData.call(this);
  this.updateInnerAlignment({
    useHorizontalAlignment: true
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.LabelFieldAdapter = function() {
  scout.LabelFieldAdapter.parent.call(this);
};
scout.inherits(scout.LabelFieldAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ListBox = function() {
  scout.ListBox.parent.call(this);
  this._addAdapterProperties(['table', 'filterBox']);
};
scout.inherits(scout.ListBox, scout.ValueField);

scout.ListBox.prototype._init = function(model) {
  scout.ListBox.parent.prototype._init.call(this, model);
  if (this.filterBox) {
    this.filterBox.enabledComputed = true; // filter is always enabled
    this.filterBox.recomputeEnabled(true);
  }
};

scout.ListBox.prototype._render = function($parent) {
  this.addContainer($parent, 'list-box');
  this.addLabel();
  this.addMandatoryIndicator();
  this.addStatus();

  this.addFieldContainer($parent.makeDiv());
  var htmlComp = scout.HtmlComponent.install(this.$fieldContainer, this.session);
  htmlComp.setLayout(new scout.ListBoxLayout(this, this.table, this.filterBox));

  if (this.table) {
    this._renderTable();
  }
  if (this.filterBox) {
    this._renderFilterBox();
    this.table.htmlComp.pixelBasedSizing = true;
  }
};

scout.ListBox.prototype._renderTable = function() {
  this.table.render(this.$fieldContainer);
  this.addField(this.table.$container);
};

scout.ListBox.prototype._renderFilterBox = function() {
  this.filterBox.render(this.$fieldContainer);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ListBoxAdapter = function() {
  scout.ListBoxAdapter.parent.call(this);
  this._addAdapterProperties(['table', 'filterBox']);
};
scout.inherits(scout.ListBoxAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ListBoxLayout = function(listBox, table, filterBox) {
  scout.ListBoxLayout.parent.call(this);
  this.table = table;
  this.filterBox = filterBox;
  this.listBox = listBox;
};
scout.inherits(scout.ListBoxLayout, scout.AbstractLayout);

scout.ListBoxLayout.prototype.layout = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    size = htmlContainer.getSize(),
    height = size.height,
    filterBoxHeight;

  if (this.filterBox && this.filterBox.rendered && this.filterBox.$container.isVisible()) {
    filterBoxHeight = scout.HtmlComponent.get(this.filterBox.$container).getPreferredSize().height;
    height -= filterBoxHeight;
  }

  height = Math.max(height, 20);
  var htmlTable = scout.HtmlComponent.get(this.table.$container);
  htmlTable.setSize(new scout.Dimension(size.width, height));

  if (this.filterBox && this.filterBox.rendered && this.filterBox.$container.isVisible()) {
    var htmlFilterBox = scout.HtmlComponent.get(this.filterBox.$container);
    htmlFilterBox.setSize(new scout.Dimension(size.width, filterBoxHeight));
  }
};

scout.ListBoxLayout.prototype.preferredLayoutSize = function($container) {
  var prefSizeTable, prefSizeFilterBox, tableContainer, filterContainer,
    width = 0,
    htmlContainer = scout.HtmlComponent.get($container),
    height = scout.HtmlEnvironment.formRowHeight,
    listBox = this.listBox;
  if (listBox.$label && listBox.labelVisible) {
    width += scout.HtmlEnvironment.fieldLabelWidth;
  }
  if (listBox.$mandatory) {
    width += listBox.$mandatory.outerWidth(true);
  }
  if (listBox.$status && listBox.statusVisible) {
    width += listBox.$status.outerWidth(true);
  }

  // getSize of table and size of filterBox
  tableContainer = scout.HtmlComponent.optGet(this.table.$container);
  if (tableContainer) {
    prefSizeTable = tableContainer.getPreferredSize()
      .add(htmlContainer.getInsets())
      .add(tableContainer.getMargins());
  } else {
    prefSizeTable = this.naturalSize(listBox);
  }

  filterContainer = scout.HtmlComponent.optGet(this.filterBox.$container);
  if (filterContainer) {
    prefSizeFilterBox = filterContainer.getPreferredSize()
      .add(htmlContainer.getInsets())
      .add(filterContainer.getMargins());
  } else {
    prefSizeTable = this.naturalSize(listBox);
  }

  width += Math.max(prefSizeTable.width, prefSizeFilterBox.width);
  height = Math.max(height, prefSizeTable.height + prefSizeFilterBox.height);

  return new scout.Dimension(width, height);

};

scout.ListBoxLayout.prototype.naturalSize = function(formField) {
  return new scout.Dimension(formField.$fieldContainer.width(), formField.$fieldContainer.height());
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.NumberField = function() {
  scout.NumberField.parent.call(this);
};
scout.inherits(scout.NumberField, scout.BasicField);

scout.NumberField.prototype._init = function(model) {
  scout.NumberField.parent.prototype._init.call(this, model);
  if (!(this.decimalFormat instanceof scout.DecimalFormat)) {
    this.decimalFormat = new scout.DecimalFormat(this.session.locale, this.decimalFormat);
  }
  this.calc = new scout.Calculator();
};

/**
 * @override Widget.js
 */
scout.NumberField.prototype._createKeyStrokeContext = function() {
  return new scout.InputFieldKeyStrokeContext();
};

scout.NumberField.prototype._render = function($parent) {
  this.addContainer($parent, 'number-field');
  this.addLabel();
  this.addMandatoryIndicator();
  var $field = scout.fields.makeTextField($parent)
    .on('blur', this._onFieldBlur.bind(this));
  this.addField($field);
  this.addStatus();
};

scout.NumberField.prototype._renderGridData = function() {
  scout.NumberField.parent.prototype._renderGridData.call(this);
  this.updateInnerAlignment({
    useHorizontalAlignment: true
  });
};

scout.NumberField.prototype._syncDecimalFormat = function(decimalFormat) {
  decimalFormat = scout.DecimalFormat.ensure(this.session.locale, decimalFormat);
  this._setProperty('decimalFormat', decimalFormat);
};

scout.NumberField.prototype._renderDecimalFormat = function() {
  this._parse();
};

scout.NumberField.prototype.acceptInput = function(whileTyping) {
  if (!whileTyping) {
    this._parse();
  }
  scout.NumberField.parent.prototype.acceptInput.call(this, whileTyping);
};

scout.NumberField.prototype.parse = function() {
  var number = null;
  try {
    number = this.decimalFormat.parse(this.displayText);
  } catch(e) {
    // catch Error thrown when number isNaN
  }
  return number;
};

scout.NumberField.prototype._parse = function() {
  var input = this.$field.val();
  if (input) {
    // Convert to JS number format (remove groupingChar, replace decimalSeparatorChar with '.')
    input = input
      .replace(new RegExp('[' + this.decimalFormat.groupingChar + ']', 'g'), '')
      .replace(new RegExp('[' + this.decimalFormat.decimalSeparatorChar + ']', 'g'), '.')
      .replace(/\s/g, '');

    // if only math symbols are in the input string...
    if (this.calc.isFormula(input)) {
      // ...evaluate, reformat the result and set is to the field. If the display text
      // changed, ValueField.js will make sure, the new value is sent to the model.
      try {
        input = this.calc.evalFormula(input);
        input = this.decimalFormat.format(input, false);
        this.$field.val(input);
      } catch (err) {
        // ignore errors, let the input be handled by scout model
      }
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.NumberFieldAdapter = function() {
  scout.NumberFieldAdapter.parent.call(this);
};
scout.inherits(scout.NumberFieldAdapter, scout.BasicFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/*
 * A simple calculator similar to eval but safe in use.
 * Supports the following format:
 * group character ( )
 * digits 0-9
 * operators + - * /
 * decimal separator .
 * no grouping character
 * no whitespace
 */
scout.Calculator = function() {};

scout.Calculator.prototype.isFormula = function(input) {
  return input.match(/^[\d\(\)\+\-\*\/\.]+$/);
};

scout.Calculator.prototype.evalFormula = function(input) {
  this._tokens = input
    .split(/([\d.]+|\(|\)|[\+\-\*\/])/)
    .filter(function(e) {
      return e.length !== 0;
    });
  return this._expr();
};

scout.Calculator.prototype._next = function() {
  if (this._tokens.length === 0) {
    return undefined;
  }
  return this._tokens[0];
};

scout.Calculator.prototype._consumeNext = function() {
  var cur = this._tokens[0];
  this._tokens = this._tokens.slice(1, this._tokens.length);
  return cur;
};

scout.Calculator.prototype._expr = function() {
  return this._sum();
};

//a+b+...
scout.Calculator.prototype._sum = function() {
  var v = this._prod();
  while (this._next() === '+' || this._next() === '-') {
    switch (this._consumeNext()) { // NOSONAR
      case '+':
        v = v + this._prod();
        break;
      case '-':
        v = v - this._prod();
        break;
    }
  }
  return v;
};

//a*b*...
scout.Calculator.prototype._prod = function() {
  var v = this._unary();
  while (this._next() === '*' || this._next() === '/') {
    switch (this._consumeNext()) { // NOSONAR
      case '*':
        v = v * this._unary();
        break;
      case '/':
        v = v / this._unary();
        break;
    }
  }
  return v;
};

//[+-]123, [+-](a)
scout.Calculator.prototype._unary = function() {
  var qualifier = 1;
  if (this._next() === '+') {
    this._consumeNext();
  } else if (this._next() === '-') {
    this._consumeNext();
    qualifier = -1;
  }
  var v;
  if ((v = this._group()) !== undefined) {
    return qualifier * v;
  }
  //must be num
  v = this._consumeNext();
  return qualifier * v;
};

//(a)
scout.Calculator.prototype._group = function() {
  if (this._next() === '(') {
    this._consumeNext();
    var v = this._expr();
    if (this._next() !== ')') {
      throw 'missing closing bracket';
    }
    this._consumeNext();
    return v;
  }
  return undefined;
};


/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlaceholderField = function() {
  scout.PlaceholderField.parent.call(this);
};
scout.inherits(scout.PlaceholderField, scout.FormField);

scout.PlaceholderField.prototype._render = function($parent) {
  this.addContainer($parent, 'placeholder-field');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlaceholderFieldAdapter = function() {
  scout.PlaceholderFieldAdapter.parent.call(this);
};
scout.inherits(scout.PlaceholderFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlannerField = function() {
  scout.PlannerField.parent.call(this);
  this._addAdapterProperties(['planner']);

  this.splitterPosition = 168;
};
scout.inherits(scout.PlannerField, scout.FormField);

scout.PlannerField.prototype._render = function($parent) {
  this.addContainer($parent, 'planner-field');
  this.addLabel();
  this.addStatus();
  if (this.planner) {
    this._renderPlanner();
  }
};

/**
 * Will also be called by model adapter on property change event
 */
scout.PlannerField.prototype._renderPlanner = function() {
  this.planner.render(this.$container);
  this.addField(this.planner.$container);
};

scout.PlannerField.prototype._removePlanner = function() {
  this.planner.remove();
  this._removeField();
};

scout.PlannerField.prototype._renderSplitterPosition = function() {};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.PlannerFieldAdapter = function() {
  scout.PlannerFieldAdapter.parent.call(this);
  this._addAdapterProperties(['planner']);
};
scout.inherits(scout.PlannerFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RadioButton = function() {
  scout.RadioButton.parent.call(this);

  this.focusWhenSelected;
};
scout.inherits(scout.RadioButton, scout.Button);

/**
 * @override Button.js
 */
scout.RadioButton.prototype._initDefaultKeyStrokes = function() {
  this.keyStrokeContext.registerKeyStroke([
    new scout.RadioButtonKeyStroke(this, 'ENTER'),
    new scout.RadioButtonKeyStroke(this, 'SPACE')
  ]);
};

scout.RadioButton.prototype._init = function(model) {
  scout.RadioButton.parent.prototype._init.call(this, model);
  this.focusWhenSelected = scout.nvl(model.focusWhenSelected, !scout.device.supportsFocusEmptyBeforeDiv());
};

scout.RadioButton.prototype._render = function($parent) {
  this.addContainer($parent, 'radio-button', new scout.ButtonLayout(this));
  this.addField($parent.makeDiv()
    .on('mousedown', this._mouseDown.bind(this)));
  this.$field.data('radiobutton', this);
  this.addStatus();

  scout.tooltips.installForEllipsis(this.$field, {
    parent: this
  });
};

scout.RadioButton.prototype._remove = function() {
  scout.tooltips.uninstall(this.$field);
  scout.RadioButton.parent.prototype._remove.call(this);
};

scout.RadioButton.prototype._mouseDown = function(event) {
  this.select();
  if (this.focusWhenSelected) {
    this.session.focusManager.requestFocus(this.$field);
    event.preventDefault();
  }
};

scout.RadioButton.prototype.select = function() {
  if (!this.enabledComputed) {
    return;
  }
  if (this.parent instanceof scout.RadioButtonGroup) {
    this.parent.selectButton(this);
  } else {
    this.setSelected(true);
  }
};

scout.RadioButton.prototype.setSelected = function(selected) {
  this.setProperty('selected', selected);
};

/**
 * @override Button.js
 */
scout.RadioButton.prototype.doAction = function(event) {
  // Since RadioButton extends Button, doAction should do something useful because it may be called (and actually is by ButtonKeyStroke)
  this.select();
  return true;
};

scout.RadioButton.prototype.setTabbable = function(tabbable) {
  this.$field.setTabbable(tabbable && !scout.device.supportsTouch());
};

/**
 * @override
 */
scout.RadioButton.prototype._renderProperties = function() {
  scout.RadioButton.parent.prototype._renderProperties.call(this);
  this._renderSelected();
};

/**
 * @override
 */
scout.RadioButton.prototype._renderLabel = function() {
  this.$field.textOrNbsp(this.label);
};

scout.RadioButton.prototype._renderSelected = function() {
  this.$field.toggleClass('checked', this.selected);
};

scout.RadioButton.prototype._renderForegroundColor = function() {
  // Don't call renderForeground of Button.js, $butonLabel does not exist for radio buttons
  scout.FormField.prototype._renderForegroundColor.call(this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RadioButtonAdapter = function() {
  scout.RadioButtonAdapter.parent.call(this);
  this._addRemoteProperties(['selected']);
};
scout.inherits(scout.RadioButtonAdapter, scout.ButtonAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RadioButtonGroup = function() {
  scout.RadioButtonGroup.parent.call(this);
  this._addAdapterProperties('formFields');
  this.formFields = [];
  this.radioButtons = [];
  this.selectedButton = null;
  this.$body;
};

scout.inherits(scout.RadioButtonGroup, scout.ValueField);

/**
 * @override ModelAdapter.js
 */
scout.RadioButtonGroup.prototype._initKeyStrokeContext = function() {
  scout.RadioButtonGroup.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([
    new scout.RadioButtonGroupLeftKeyStroke(this),
    new scout.RadioButtonGroupRightKeyStroke(this)
  ]);
};

scout.RadioButtonGroup.prototype.getFields = function() {
  return this.formFields;
};

/**
 * @override FormField.js
 */
scout.RadioButtonGroup.prototype.visit = function(visitor) {
  scout.RadioButtonGroup.parent.prototype.visit.call(this, visitor);
  this.formFields.forEach(function(field) {
    field.visit(visitor);
  });
};

scout.RadioButtonGroup.prototype._init = function(model) {
  scout.RadioButtonGroup.parent.prototype._init.call(this, model);

  this.formFields.forEach(function(formField) {
    if (formField instanceof scout.RadioButton) {
      this.radioButtons.push(formField);
      if (formField.selected) {
        this.selectedButton = formField;
      }
    }
  }, this);
};

scout.RadioButtonGroup.prototype._render = function($parent) {
  var env = scout.HtmlEnvironment,
    htmlBodyContainer;

  this.addContainer($parent, 'radiobutton-group');

  this.$body = this.$container.appendDiv('radiobutton-group-body');
  htmlBodyContainer = scout.HtmlComponent.install(this.$body, this.session);
  htmlBodyContainer.setLayout(new scout.LogicalGridLayout(env.smallColumnGap, env.formRowGap));

  this.formFields.forEach(function(formField) {
    formField.render(this.$body);

    // set each children layout data to logical grid data
    formField.setLayoutData(new scout.LogicalGridData(formField));
  }, this);

  this.addLabel();
  this.addMandatoryIndicator();
  this.addField(this.$body);
  this.addStatus();
};

/**
 * @override
 */
scout.RadioButtonGroup.prototype._renderEnabled = function() {
  scout.RadioButtonGroup.parent.prototype._renderEnabled.call(this);
  this._provideTabIndex();
};

/**
 * @override FormField.js
 */
scout.RadioButtonGroup.prototype.recomputeEnabled = function(parentEnabled) {
  scout.RadioButtonGroup.parent.prototype.recomputeEnabled.call(this, parentEnabled);
  this.getFields().forEach(function(field) {
    field.recomputeEnabled(this.enabledComputed);
  }, this);
};

scout.RadioButtonGroup.prototype._provideTabIndex = function() {
  var tabSet;
  this.radioButtons.forEach(function(radioButton) {
    if (radioButton.enabledComputed && this.enabledComputed && !tabSet) {
      radioButton.setTabbable(true);
      tabSet = radioButton;
    } else if (tabSet && this.enabledComputed && radioButton.enabledComputed && radioButton.selected) {
      tabSet.setTabbable(false);
      radioButton.setTabbable(true);
      tabSet = radioButton;
    } else {
      radioButton.setTabbable(false);
    }
  }, this);
};

scout.RadioButtonGroup.prototype.selectButton = function(radioButtonToSelect) {
  this.selectedButton = null;
  this.radioButtons.forEach(function(radioButton) {
    if (radioButton === radioButtonToSelect) {
      if (!radioButton.enabledComputed) {
        return;
      }
      radioButton.setSelected(true);
      radioButton.setTabbable(true);
      this.selectedButton = radioButton;
    } else {
      radioButton.setSelected(false);
      radioButton.setTabbable(false);
    }
  }, this);
};

scout.RadioButtonGroup.prototype.addButton = function(radioButton) {
  this.formFields.push(radioButton);
  this.radioButtons.push(radioButton);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RadioButtonGroupAdapter = function() {
  scout.RadioButtonGroupAdapter.parent.call(this);
  this._addAdapterProperties('formFields');
};
scout.inherits(scout.RadioButtonGroupAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RadioButtonGroupLeftKeyStroke = function(radioButtonGroup) {
  scout.RadioButtonGroupLeftKeyStroke.parent.call(this);
  this.field = radioButtonGroup;
  this.which = [scout.keys.LEFT];
  this.renderingHints.render = false;
};
scout.inherits(scout.RadioButtonGroupLeftKeyStroke, scout.KeyStroke);

scout.RadioButtonGroupLeftKeyStroke.prototype.handle = function(event) {
  var fieldBefore,
    focusedButton = $(event.target).data('radiobutton');
  this.field.radioButtons.some(function(radioButton) {
    if (fieldBefore && radioButton === focusedButton) {
      fieldBefore.select();
      this.field.session.focusManager.requestFocus(fieldBefore.$field);
      return true;
    }
    if (radioButton.enabledComputed && radioButton.visible) {
      fieldBefore = radioButton;
    }
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RadioButtonGroupRightKeyStroke = function(radioButtonGroup) {
  scout.RadioButtonGroupRightKeyStroke.parent.call(this);
  this.field = radioButtonGroup;
  this.which = [scout.keys.RIGHT];
  this.renderingHints.render = false;
};
scout.inherits(scout.RadioButtonGroupRightKeyStroke, scout.KeyStroke);

scout.RadioButtonGroupRightKeyStroke.prototype.handle = function(event) {
  var fieldBefore,
    focusedButton = $(event.target).data('radiobutton');
  this.field.radioButtons.some(function(radioButton) {
    if (fieldBefore && radioButton.enabledComputed && radioButton.visible) {
      radioButton.select();
      this.field.session.focusManager.requestFocus(radioButton.$field);
      return true;
    }
    if (radioButton === focusedButton && radioButton.enabledComputed && radioButton.visible) {
      fieldBefore = radioButton;
    }
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.RadioButtonKeyStroke = function(button, keyStroke) {
  scout.RadioButtonKeyStroke.parent.call(this, button, keyStroke);
};
scout.inherits(scout.RadioButtonKeyStroke, scout.ButtonKeyStroke);

/**
 * @override ButtonKeyStroke.js
 *
 * To not prevent a parent key stroke context from execution of the event, the key stroke event is only accepted if the radio button is not selected.
 */
scout.RadioButtonKeyStroke.prototype._accept = function(event) {
  var accepted = scout.RadioButtonKeyStroke.parent.prototype._accept.call(this, event);
  return accepted && !this.field.selected;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SequenceBox = function() {
  scout.SequenceBox.parent.call(this);
  this._addAdapterProperties('fields');

  this.fields = [];
};
scout.inherits(scout.SequenceBox, scout.CompositeField);

scout.SequenceBox.prototype._render = function($parent) {
  var field, i;
  this.addContainer($parent, 'sequence-box');
  this.addLabel();
  this.addField($parent.makeDiv());
  this.addStatus();
  this._handleStatus();
  var htmlComp = scout.HtmlComponent.install(this.$field, this.session);
  htmlComp.setLayout(new scout.LogicalGridLayout(scout.HtmlEnvironment.smallColumnGap, 0));
  for (i = 0; i < this.fields.length; i++) {
    field = this.fields[i];
    field.labelUseUiWidth = true;
    field.on('propertyChange', this._onFieldPropertyChange.bind(this));
    field.render(this.$field);
    this._modifyLabel(field);

    // set each children layout data to logical grid data
    field.setLayoutData(new scout.LogicalGridData(field));
  }
};

scout.SequenceBox.prototype._onFieldPropertyChange = function(event) {
  var visibiltyChanged = (event.changedProperties.indexOf('visible') !== -1);
  if (scout.arrays.containsAny(event.changedProperties, ['errorStatus', 'tooltipText', 'visible', 'menus', 'menusVisible'])) {
    this._handleStatus(visibiltyChanged);
  }
};

/**
 * Moves the status relevant properties from the last visible field to the sequencebox. This makes sure that the fields inside the sequencebox have the same size.
 */
scout.SequenceBox.prototype._handleStatus = function(visibilityChanged) {
  //FIXME cgu: what if sequencebox itself has a tooltip or errorstatus? probably field has higher prio -> override status of seq box
  if (visibilityChanged && this._lastVisibleField) {
    // if there is a new last visible field, make sure the status is shown on the previously last one
    this._lastVisibleField.suppressStatus = false;
    this._lastVisibleField._renderErrorStatus();
    this._lastVisibleField._renderTooltipText();
    this._lastVisibleField._renderMenus();
  }
  this._lastVisibleField = this._getLastVisibleField();
  if (!this._lastVisibleField) {
    return;
  }

  // Update the sequencebox with the status relevant flags
  this.setErrorStatus(this._lastVisibleField.errorStatus);
  this.setTooltipText(this._lastVisibleField.tooltipText);
  this.setMenus(this._lastVisibleField.menus);
  this.setMenusVisible(this._lastVisibleField.menusVisible);

  // Make sure the last field won't display a status
  this._lastVisibleField.suppressStatus = true;
  if (visibilityChanged) {
    // If the last field got invisible, make sure the new last field does not display a status anymore (now done by the seq box)
    this._lastVisibleField._renderErrorStatus();
    this._lastVisibleField._renderTooltipText();
    this._lastVisibleField._renderMenus();
  }
};

scout.SequenceBox.prototype._getLastVisibleField = function() {
  var visibleFields = this.fields.filter(function(field) {
    return field.visible;
  });
  if (visibleFields.length === 0) {
    return;
  }

  return visibleFields[visibleFields.length - 1];
};

/**
 * override
 */
scout.SequenceBox.prototype._updateStatusVisible = function() {
  this._renderStatusVisible();
};

// TODO [5.2] awe: (scout, sequence-box) remove _modifyLabel when CheckboxForm uses SequenceBox5
// The new sequence-box sets the label to invisible on the model.
scout.SequenceBox.prototype._modifyLabel = function(field) {
  if (field instanceof scout.CheckBoxField) {
    field.labelVisible = false;
  }
};

/**
 * @override CompositeField.js
 */
scout.SequenceBox.prototype.getFields = function() {
  return this.fields;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SequenceBoxAdapter = function() {
  scout.SequenceBoxAdapter.parent.call(this);
  this._addAdapterProperties('fields');
};
scout.inherits(scout.SequenceBoxAdapter, scout.CompositeFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SliderField = function() {
  scout.SliderField.parent.call(this);
  this.slider;
};
scout.inherits(scout.SliderField, scout.ValueField);

scout.SliderField.prototype._init = function(model) {
  scout.SliderField.parent.prototype._init.call(this, model);
  var sliderOptions = $.extend({parent: this}, model);
  this.slider = scout.create('Slider', sliderOptions);
};

scout.SliderField.prototype._render = function($parent) {
  this.addContainer($parent, 'slider-field');
  this.addLabel();
  this.addMandatoryIndicator();
  this._renderSlider();
};

scout.SliderField.prototype._renderSlider = function() {
  this.slider.render(this.$container);
  this.addField(this.slider.$container);
};

scout.SliderField.prototype.setValue = function(value) {
  this.slider.setValue(value);
};

scout.SliderField.prototype.getValue = function() {
  return this.slider.value;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
// FIXME awe: (smart-field) Do not open popup when Ctrl or Alt key is pressed (e.g. Ctrl + 1)

/**
 * Three smart-field modes:
 *
 * [default] when no flag is set, used for Desktop applications
 *     smart-field opens a popup for proposal-chooser when user
 *     clicks into input-field
 * [touch] smart-field is only a DIV that shows the display-text
 *     when user clicks on the DIV it opens a popup that has an
 *     embedded smart-field and a proposal-chooser.
 * [embedded] used in the popup opened by the touch smart-field.
 *     this type of smart-field does not react on focus / blur
 *     events.
 */
scout.SmartField = function() {
  scout.SmartField.parent.call(this);

  this.DEBOUNCE_DELAY = 200;

  this._addAdapterProperties(['proposalChooser']);
  this.options;
  /**
   * This property is used to prevent unnecessary requests to the server.
   */
  this._oldDisplayText;
  this.popup;
  this._requestedProposal = false;
  /**
   * This property is used to prevent multiple acceptProposal request to the server (blur, aboutToBlur, acceptInput from Action).
   */
  this._tabPrevented = null;
  this._pendingProposalTyped = null;
  this._navigating = false;
  this.lookupCall;
  this.codeType;
};
scout.inherits(scout.SmartField, scout.ValueField);

/**
 * @override Widget.js
 */
scout.SmartField.prototype._createKeyStrokeContext = function() {
  return new scout.InputFieldKeyStrokeContext();
};

/**
 * @override FormField.js
 */
scout.SmartField.prototype._init = function(model) {
  scout.SmartField.parent.prototype._init.call(this, model);
  scout.fields.initTouch(this, model);
  this.popup = model.popup;
  this._syncLookupCall(this.lookupCall);
  this._syncCodeType(this.codeType);
};

scout.SmartField.prototype.createPopup = function() {
  var popupType = this.touch ? 'SmartFieldTouchPopup' : 'SmartFieldPopup';
  return scout.create(popupType, {
    parent: this,
    $anchor: this.$field,
    boundToAnchor: !this.touch,
    closeOnAnchorMousedown: false,
    field: this
  });
};

scout.SmartField.prototype._render = function($parent) {
  var cssClass = this.proposal ? 'proposal-field' : 'smart-field';
  this.addContainer($parent, cssClass, new scout.SmartFieldLayout(this));
  this.addLabel();

  var $field = scout.fields.makeInputOrDiv(this)
    .click(this._onClick.bind(this));
  if (!this.touch) {
    $field
      .blur(this._onFieldBlur.bind(this))
      .focus(this._onFocus.bind(this))
      .keyup(this._onKeyUp.bind(this))
      .keydown(this._onKeyDown.bind(this));
  }
  this.addField($field);

  if (!this.embedded) {
    this.addMandatoryIndicator();
  }
  this.addIcon();
  this.addStatus();
};

scout.SmartField.prototype._remove = function() {
  scout.SmartField.parent.prototype._remove.call(this);
  this.popup = null;
};

scout.SmartField.prototype._renderProperties = function() {
  scout.SmartField.parent.prototype._renderProperties.call(this);
  this._renderProposalChooser();
};

scout.SmartField.prototype._syncLookupCall = function(lookupCall) {
  if (typeof lookupCall === 'string') {
    lookupCall = scout.create(lookupCall);
  }
  this._setProperty('lookupCall', lookupCall);
};

scout.SmartField.prototype._syncCodeType = function(codeType) {
  this._setProperty('codeType', codeType);
  if (!codeType) {
    return;
  }
  var lookupCall = scout.create('CodeLookupCall', {
    session: this.session,
    codeType: codeType
  });
  this.setProperty('lookupCall', lookupCall);
};

scout.SmartField.prototype._formatValue = function(value) {
  if (!this.lookupCall) {
    return '';
  }
  if (value === null || value === undefined) {
    return '';
  }
  return this.lookupCall.textById(value);
};

scout.SmartField.prototype._syncDisplayText = function(displayText) {
  this._oldDisplayText = displayText;
  this._setProperty('displayText', displayText);
};

/**
 * @override ValueField.js
 */
scout.SmartField.prototype._renderDisplayText = function() {
  scout.fields.valOrText(this, this.$field, this.displayText);
};

scout.SmartField.prototype._readDisplayText = function() {
  // in case of touch mode a 'div' is rendered and not an 'input' -> use text not val
  return scout.fields.valOrText(this, this.$field);
};

scout.SmartField.prototype._readSearchText = function() {
  return this._readDisplayText();
};

/**
 * Sync method is required because when proposal-chooser has never been rendered and the search-string
 * does not return any proposals in a proposal field, neither _renderProposalChooser nor _removeProposalChooser
 * is called and thus the _requestedProposal flag would never be resetted.
 */
scout.SmartField.prototype._syncProposalChooser = function(proposalChooser) {
  if (this.embedded) {
    // Never hold the proposal chooser in embedded mode, original smart field takes care of it
    // This makes sure proposal chooser does not get rendered twice.
    // Prevent rendering as well, original smart field will render it into the popup
    return false;
  }
  this._setProperty('proposalChooser', proposalChooser);
};

/**
 * When popup is not rendered at this point, we render the popup.
 */
scout.SmartField.prototype._renderProposalChooser = function() {
  $.log.debug('(SmartField#_renderProposalChooser) proposalChooser=' + this.proposalChooser + ' touch=' + this.touch);
  if (!this.proposalChooser) {
    return;
  }
  this.openPopup();
  this.popup.setProposalChooser(this.proposalChooser);
};

/**
 * This method is called after a valid option has been selected in the proposal chooser.
 */
scout.SmartField.prototype._removeProposalChooser = function() {
  $.log.trace('(SmartField#_removeProposalChooser) proposalChooser=' + this.proposalChooser);
  this._closeProposal(false);
};

scout.SmartField.prototype._isNavigationKey = function(e) {
  return e.which === scout.keys.PAGE_UP ||
    e.which === scout.keys.PAGE_DOWN ||
    e.which === scout.keys.UP ||
    e.which === scout.keys.DOWN;
};

scout.SmartField.prototype._isFunctionKey = function(e) {
  return e.which >= scout.keys.F1 && e.which < scout.keys.F12;
};

scout.SmartField.prototype._onClick = function(event) {
  if (scout.fields.handleOnClick(this)) {
    this._openProposal(true);
  }
};

scout.SmartField.prototype._onIconClick = function(event) {
  if (scout.fields.handleOnClick(this)) {
    scout.SmartField.parent.prototype._onIconClick.call(this, event);
    this._openProposal(true);
  }
};

scout.SmartField.prototype._isPreventDefaultTabHandling = function() {
  var doPrevent = !!this.proposalChooser;
  $.log.trace('(SmartField#_isPreventDefaultTabHandling) must prevent default when TAB was pressed = ' + doPrevent);
  return doPrevent;
};

// navigate in options
scout.SmartField.prototype._onKeyDown = function(e) {
  if (e.which === scout.keys.ESCAPE) {
    if (this.popup) {
      e.stopPropagation();
    }
    this._closeProposal();
    this._navigating = false;
    return;
  }

  // We must prevent default focus handling
  if (e.which === scout.keys.TAB && this.mode !== scout.FormField.MODE_CELLEDITOR) {
    if (this._isPreventDefaultTabHandling()) {
      e.preventDefault();
      this._tabPrevented = {
        directionBack: e.shiftKey
      };
      this._acceptProposal();
      this._navigating = false;
      return;
    }
  }

  if (e.which === scout.keys.ENTER) {
    if (this.popup) {
      e.stopPropagation();
    }
    this._acceptProposal();
    this._navigating = false;
    return;
  }

  if (this._isNavigationKey(e)) {
    this._navigating = true;
    if (this.proposalChooser) {
      this._delegateToProposalChooser(e);
    } else {
      // Since this is the keyDown handler we cannot access the typed text here
      // But when the user presses the down arrow, we can open the proposal
      // chooser immediately. Also we can start a search with text that was already
      // in the text field.
      this._openProposal(true);
    }
  } else {
    this._navigating = false;
  }
};

/**
 * Before we delegate to the proposal chooser, we must make sure that no proposal-typed
 * events are pending (debounce). Otherwise the proposal chooser event is executed _before_
 * the proposal-typed event, which would destroy the selection in the proposal chooser,
 * since the proposal chooser is reloaded, when the search-text changes.
 */
scout.SmartField.prototype._delegateToProposalChooser = function(event) {
  if (this._pendingProposalTyped) {
    // execute pending proposal typed event immediately
    this._pendingProposalTyped.func();
    this._clearPendingProposalTyped();
  }
  if (this.proposalChooser) {
    // in some rare cases proposal chooser has been disposed in the meantime --> do nothing
    this.proposalChooser.delegateEvent(event);
  }
};

scout.SmartField.prototype._onKeyUp = function(e) {

  // Escape
  if (e.which === scout.keys.ESCAPE) {
    e.stopPropagation();
    return;
  }

  // Enter
  if (e.which === scout.keys.ENTER) {
    e.stopPropagation();
    return;
  }

  // Pop-ups shouldn't open when one of the following keys is pressed
  if (e.which === scout.keys.TAB ||
    e.which === scout.keys.SHIFT ||
    e.which === scout.keys.HOME ||
    e.which === scout.keys.END ||
    e.which === scout.keys.LEFT ||
    e.which === scout.keys.RIGHT ||
    this._isNavigationKey(e) ||
    this._isFunctionKey(e)) {
    return;
  }

  // The typed character is not available until the keyUp event happens
  // That's why we must deal with that event here (and not in keyDown)
  // We don't use _displayText() here because we always want the text the
  // user has typed.
  if (this.popup) {
    this._proposalTyped();
  } else {
    this._openProposal(false);
  }
};

scout.SmartField.prototype._onFocus = function(e) {
  this._oldDisplayText = this._readDisplayText();
};

scout.SmartField.prototype._proposalTyped = function() {
  var displayText = this._readSearchText();
  $.log.trace('(SmartField#_proposalTyped) displayText=' + displayText + ' currentDisplayText=' + this.displayText);
  if (displayText === this.displayText) {
    return;
  }
  this.displayText = displayText;

  // debounce send
  var id, func;
  this._clearPendingProposalTyped();

  func = function() {
    $.log.debug('(SmartField#_proposalTyped) send displayText=' + displayText);
    this.trigger('proposalTyped', {
      displayText: displayText
    });
  }.bind(this);
  id = setTimeout(func, this.DEBOUNCE_DELAY);
  this._pendingProposalTyped = {
    func: func,
    id: id
  };
};

/**
 * Returns the bounds of the text-input element. Subclasses may override this method when their
 * text-field is not === this.$field.
 */
scout.SmartField.prototype._fieldBounds = function() {
  return scout.graphics.offsetBounds(this.$field);
};

scout.SmartField.prototype._onFieldBlur = function() {
  // omit super call
  $.log.debug('(SmartField#_onFieldBlur) tabPrevented=' + this._tabPrevented ? 'true' : 'false');
  this._requestedProposal = false;

  if (this.embedded) {
    // Do not accept input while popup is open
    // Done button of ios virtual keyboard triggers blur -> don't close the popup when pressing done, popup is closed when pressing enter.
    return;
  }

  // When we have prevented TAB handling in keyDown handler, we have already sent an acceptProposal event.
  // At this time the proposalChooser was open, and thus the proposalChooserOpen flag was set to true
  // which means the Java-client uses the selected row from the proposalChooser and _not_ the display text.
  // After the request, when we set the focus with _focusNextTabbable(), we must _not_ send acceptProposal
  // again. It is not only unnecessary but would even cause errors, because at this time the proposalChooser
  // is closed and for the Java-client the request would look like, it should perform a lookup after the
  // user has typed something into the SmartField.
  if (this._tabPrevented) {
    this._tabPrevented = null;
  } else {
    this.acceptInput();
  }
};

scout.SmartField.prototype._clearPendingProposalTyped = function() {
  if (this._pendingProposalTyped) {
    clearTimeout(this._pendingProposalTyped.id);
  }
  this._pendingProposalTyped = null;
};

scout.SmartField.prototype.proposalSelected = function() {
  this.proposalSelectedInProgress = true;
  this._oldDisplayText = this._readDisplayText();
};

// See comment in ProposalChooserAdapter.js
scout.SmartField.prototype._abortAcceptProposal = function(displayText) {
  var abort = this.proposalSelectedInProgress && displayText === this._oldDisplayText;
  if (abort) {
    $.log.debug('(SmartField#_abortAcceptProposal) aborted _acceptProposal because displayText has not changed since proposal has been selected');
    this.proposalSelectedInProgress = false;
  }
  return abort;
};

/**
 * This method is called when the user presses the TAB or ENTER key in the UI, or when _onFieldBlur()
 * or acceptInput(). In case the field is a proposal-field we must send the current displayText
 * to the server, even when the popup is not opened (this happens when the user types something which
 * is not in the list of proposals). We must accept the user defined text in that case.
 */
scout.SmartField.prototype._acceptProposal = function(forceClose) {

  // must clear pending "proposalTyped" events because nothing good happens
  // when proposalTyped arrives _after_ an "acceptProposal" event.
  this._clearPendingProposalTyped();

  forceClose = scout.nvl(forceClose, false);
  // embedded smartfield does not hold a reference to the chooser, but if it is shown touch popup is open and therefore the chooser as well
  var proposalChooserOpen = !!this.proposalChooser || this.embedded,
    displayText = this._readSearchText();

  $.log.debug('(SmartField#_acceptProposal) displayText=' + displayText + ' proposalChooserOpen=' + proposalChooserOpen + ' forceClose=' + forceClose);

  if (this._abortAcceptProposal(displayText)) {
    return;
  }

  if (proposalChooserOpen) {
    // Always send accept proposal, when proposal chooser is opened,
    // Because user wants to choose the selected proposal from the
    // proposal chooser by pressing TAB or ENTER.
    // The Java client will use the selected row as value when it
    // receives the acceptProposal event in that case.
    //
    // We must also handle the case that the user deletes the search
    // text immediately followed by a TAB key press. In that case the
    // UI Server has not enough information to find out what happened
    // and would accept a proposal, since on the model there's still
    // a selected proposal (ticket #168652).
    var textDeleted = scout.strings.empty(displayText) && scout.strings.hasText(this._oldDisplayText);
    if (textDeleted && !this._navigating) {
      this._sendDeleteProposal(displayText);
      this._triggerDeleteProposal(displayText);
    } else {
      this._sendAcceptProposal(displayText, true, forceClose);
      this._triggerAcceptProposal(displayText);
    }

    if (this.embedded) {
      // Always close popup when user presses 'Enter' on virtual keyboard if touch popup is open
      this._closeProposal();
    }
  } else {
    // When proposal chooser is closed, only send accept proposal
    // when search text has changed. Prevents unnecessary requests
    // to the server when the user tabs over the smart-field.
    if (displayText === this._oldDisplayText) {
      return;
    }
    this._sendAcceptProposal(displayText, false, forceClose);
    this._triggerAcceptProposal(displayText);
  }

  this.session.listen().done(this._onSessionDone.bind(this));
};

scout.SmartField.prototype._onSessionDone = function(event) {
  $.log.debug('(SmartField#_onSessionDone) request done proposalChooser=' + this.proposalChooser);
  this.proposalSelectedInProgress = false;
  if (this._tabPrevented && !this.proposalChooser) {
    this._focusNextTabbable();
  }
};

scout.SmartField.prototype._triggerDeleteProposal = function(displayText) {
  this.trigger('deleteProposal', {
    displayText: displayText
  });
};

scout.SmartField.prototype._sendDeleteProposal = function(displayText) {
  this._syncDisplayText(displayText);
  this._send('deleteProposal'); // FIXME [6.1] cgu move to adapter
};

scout.SmartField.prototype._triggerAcceptProposal = function(displayText) {
  this.trigger('acceptProposal', {
    displayText: displayText
  });
};

/**
 * Note: we set showBusyIndicator=false in this request, because without it it could cause two calls
 * to send/acceptProposal when the user presses Enter. The first one because of the keyDown event
 * and the second one because of the blur event caused by the busy indicator.
 */
scout.SmartField.prototype._sendAcceptProposal = function(displayText, chooser, forceClose) {
  this._syncDisplayText(displayText);
  this._send('acceptProposal', { // FIXME [6.1] cgu move to adapter
    displayText: displayText,
    chooser: chooser,
    forceClose: forceClose,
    showBusyIndicator: false,
    coalesce: function(previous) {
      return this.type === previous.type;
    }
  });
};

// FIXME awe, dwi: (focus) check if we can find next tabbable in the current focus-context (FocusManager)
scout.SmartField.prototype._focusNextTabbable = function() {
  var $tabElements = this.entryPoint().find(':tabbable');
  var direction = this._tabPrevented.directionBack ? -1 : 1;
  var fieldIndex = $tabElements.index(this.$field);
  var nextIndex = fieldIndex + direction;
  if (nextIndex < 0) {
    nextIndex = $tabElements.length - 1;
  } else if (nextIndex >= $tabElements.length) {
    nextIndex = 0;
  }
  $.log.debug('SmartField tab-index=' + fieldIndex + ' next tab-index=' + nextIndex);
  $tabElements.eq(nextIndex).focus();
};

scout.SmartField.prototype._closeProposal = function(notifyServer) {
  if (!this.popup) {
    return;
  }

  if (scout.nvl(notifyServer, true)) {
    this._sendCancelProposal();
  }
  this.popup.close();
};

scout.SmartField.prototype._sendCancelProposal = function() {
  this._send('cancelProposal');
};

/**
 * This method opens a popup before we contact the server to load proposals. This means
 * at this point we cannot know what size the popup should have. We have to set a fixed
 * size and resize the popup later when proposals are available.
 *
 * When the smartfield is valid, we want to perform a "browse all" search (=empty string),
 * when the field is invalid, we want to perform a search with the current display-text.
 *
 * Other as in _proposalTyped we always open the proposal, even when the display text
 * has not changed.
 */
scout.SmartField.prototype._openProposal = function(browseAll) {
  var displayText = this._readSearchText(),
    selectCurrentValue = browseAll;
  this.displayText = displayText;
  if (this.errorStatus) {
    selectCurrentValue = false;
  }

  if (this._requestedProposal) {
    $.log.trace('(SmartField#_openProposal) already requested proposal -> do nothing');
  } else {
    this._requestedProposal = true;
    $.log.debug('(SmartField#_openProposal) send openProposal. displayText=' + displayText + ' selectCurrentValue=' + selectCurrentValue);
    this._send('openProposal', {
      displayText: displayText,
      selectCurrentValue: selectCurrentValue,
      browseAll: browseAll
    });
  }
};

scout.SmartField.prototype.openPopup = function() {
  if (this.popup) {
    // already open
    return;
  }

  this.popup = this.createPopup();
  this.popup.open();
  this.popup.on('remove', function() {
    this.popup = null;
  }.bind(this));
  if (this.touch) {
    // Error message is shown on touch popup as well, don't show twice
    this._hideStatusMessage();
  }
};

/**
 * Returns true if the smart-field lookup returns a lot of rows. In that case
 * the proposal chooser must create a table with virtual scrolling, which means
 * only the rows visible in the UI are rendered in the DOM. By default we render
 * all rows, since this avoids problems with layout-invalidation with rows
 * that have a bitmap-image (PNG) which is loaded asynchronously.
 */
scout.SmartField.prototype.virtual = function() {
  return this.browseMaxRowCount > 100;
};

/**
 * @override ValueField.js
 */
scout.SmartField.prototype.acceptInput = function(whileTyping) {
  this._acceptProposal(true);
};

/**
 * @override ValueField.js
 */
scout.SmartField.prototype.aboutToBlurByMouseDown = function(target) {
  var eventOnField = this.$field.isOrHas(target);
  var eventOnPopup = this.popup && this.popup.$container.isOrHas(target);

  if (!eventOnField && !eventOnPopup) {
    this.acceptInput(); // event outside this field.
  }
};

/**
 * Method invoked if being rendered within a cell-editor (mode='scout.FormField.MODE_CELLEDITOR'), and once the editor finished its rendering.
 */
scout.SmartField.prototype.onCellEditorRendered = function(options) {
  if (options.openFieldPopup) {
    this._onClick();
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SmartFieldAdapter = function() {
  scout.SmartFieldAdapter.parent.call(this);
  this._addAdapterProperties(['proposalChooser']);
};
scout.inherits(scout.SmartFieldAdapter, scout.ValueFieldAdapter);

scout.SmartFieldAdapter.prototype._onWidgetProposalTyped = function(event) {
  this._send('proposalTyped', {
    displayText: event.displayText
  }, {
    showBusyIndicator: false
  });
};

scout.SmartFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'proposalTyped') {
    this._onWidgetProposalTyped(event);
  } else {
    scout.SmartFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/**
 * We must reset the flag _requestedProposal in the _sync function of the adapter
 * Because the _sync function of the widget is only called, when the value has
 * changed. However, we must always set the flag to false.
 *
 * Note: we should try to move this flag to the adapter completely. It does not
 * belong to the widget.
 */
scout.SmartFieldAdapter.prototype._syncProposalChooser = function(proposalChooser) {
  $.log.debug('(SmartFieldAdapter#_syncProposalChooser) set _requestedProposal to false');
  this.widget._requestedProposal = false;
  this.widget.callSetter('proposalChooser', proposalChooser);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SmartFieldTouchPopup = function() {
  scout.SmartFieldTouchPopup.parent.call(this);
  this._addAdapterProperties('proposalChooser');
};
scout.inherits(scout.SmartFieldTouchPopup, scout.TouchPopup);

scout.SmartFieldTouchPopup.prototype._init = function(options) {
  scout.SmartFieldTouchPopup.parent.prototype._init.call(this, options);
  this._delegateEvents(['acceptProposal', 'proposalTyped', 'cancelProposal']);
  this._delegateDisplayTextChanges(['acceptProposal', 'proposalTyped', 'deleteProposal']);
};

scout.SmartFieldTouchPopup.prototype._fieldOverrides = function() {
  var obj = scout.SmartFieldTouchPopup.parent.prototype._fieldOverrides.call(this);
  // Make sure proposal chooser does not get cloned, because it would not work (e.g. because selectedRows may not be cloned)
  // It would also generate a loop because field would try to render the chooser and the popup
  // -> The original smart field has to control the chooser
  obj.proposalChooser = null;
  return obj;
};

scout.SmartFieldTouchPopup.prototype.setProposalChooser = function(proposalChooser) {
  this.setProperty('proposalChooser', proposalChooser);
};

scout.SmartFieldTouchPopup.prototype._renderProposalChooser = function() {
  this.proposalChooser.render(this._$widgetContainer);
  this.proposalChooser.$container.addClass('touch');
  this._widgetContainerHtmlComp.invalidateLayoutTree();
};

/**
 * @override Popup.js
 */
scout.SmartFieldTouchPopup.prototype._onMouseDownOutside = function(event) {
  // Sync display text first because accept input needs the correct display text
  this._delegateDisplayText();
  this._touchField.acceptInput();
  this.close();
};

// Info: cannot name this method _syncDisplayText because of naming-conflict with our _sync* functions from the Scout framework
scout.SmartFieldTouchPopup.prototype._delegateDisplayText = function() {
  this._touchField.setDisplayText(this._field.displayText);
};

scout.SmartFieldTouchPopup.prototype._delegateEvents = function(eventTypes) {
  var that = this;
  eventTypes.forEach(function(eventType) {
    that._field.on(eventType, function(event) {
      that._touchField.events.trigger(event.type, event);
    });
  });
};

scout.SmartFieldTouchPopup.prototype._delegateDisplayTextChanges = function(eventTypes) {
  eventTypes.forEach(function(eventType) {
    this._field.on(eventType, this._delegateDisplayText.bind(this));
  }, this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * SmartFieldLayout works like FormLayout but additionally layouts its proposal-chooser popup.
 */
scout.SmartFieldLayout = function(smartField) {
  scout.SmartFieldLayout.parent.call(this, smartField);
  this._smartField = smartField;
};
scout.inherits(scout.SmartFieldLayout, scout.FormFieldLayout);

scout.SmartFieldLayout.prototype.layout = function($container) {
  scout.SmartFieldLayout.parent.prototype.layout.call(this, $container);

  // when embedded smart-field layout must not validate the popup
  // since this would lead to an endless recursion because the smart-field
  // is a child of the popup.
  if (this._smartField.embedded) {
    return;
  }

  var popup = this._smartField.popup;
  if (popup && popup.rendered) {
    // Make sure the popup is correctly layouted and positioned
    popup.position();
    popup.validateLayout();
  }
};

/**
 * Layout for icon in multiline smart-field works a bit different because the icon here is _inside_
 * an additional field container, which contains the INPUT field and the icon.
 *
 * @override FormFieldLayout.js
 */
scout.SmartFieldLayout.prototype._layoutIcon = function(formField, fieldBounds, right, top) {
  var multiline = formField instanceof scout.SmartFieldMultiline;
  // Cannot use field bounds because icon should be as height as input field
  var height = this._smartField.$field.outerHeight();
  formField.$icon
    .cssRight(formField.$field.cssBorderRightWidth() + (multiline ? 0 : right))
    .cssTop(top)
    .cssHeight(height)
    .cssLineHeight(height);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SmartFieldPopup = function() {
  scout.SmartFieldPopup.parent.call(this);
  this._addAdapterProperties('proposalChooser');
};
scout.inherits(scout.SmartFieldPopup, scout.Popup);

scout.SmartFieldPopup.prototype._init = function(options) {
  options.scrollType = options.scrollType || 'layoutAndPosition';
  options.installFocusContext = false;
  scout.SmartFieldPopup.parent.prototype._init.call(this, options);
  this._field = options.field;
};

scout.SmartFieldPopup.prototype._createLayout = function() {
  return new scout.SmartFieldPopupLayout(this);
};

scout.SmartFieldPopup.prototype._render = function($parent) {
  this.$container = $parent
    .appendDiv('smart-field-popup')
    .on('mousedown', this._onContainerMouseDown.bind(this));

  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(this._createLayout());
  this.htmlComp.validateRoot = true;
};

scout.SmartFieldPopup.prototype.setProposalChooser = function(proposalChooser) {
  this.setProperty('proposalChooser', proposalChooser);
};

scout.SmartFieldPopup.prototype._renderProposalChooser = function() {
  this.proposalChooser.setVirtual(this._field.virtual());
  this.proposalChooser.render(this.$container);
  this.revalidateLayout();
};

/**
 * This event handler is called before the mousedown handler on the _document_ is triggered
 * This allows us to prevent the default, which is important for the CellEditorPopup which
 * should stay open when the SmartField popup is closed. It also prevents the focus blur
 * event on the SmartField input-field.
 */
//TODO [5.2] cgu, awe: this is not required by the cell editor anymore, but we cannot remove it either because mouse down on a row would immediately close the popup, why?
scout.SmartFieldPopup.prototype._onContainerMouseDown = function(event) {
  // when user clicks on proposal popup with table or tree (prevent default,
  // so input-field does not lose the focus, popup will be closed by the
  // proposal chooser impl.
  return false;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * The popup layout is different from other layouts, since it can determine its own size
 * when the autoSize flag is set to true. Otherwise it uses the given size, like a regular
 * layout. The autoSize feature is used, when a child of the SmartFieldPopupLayout invalidates the
 * tree up to the popup. Since the popup is a validate root it must re-layout itself.
 * However: the size of the popup dependes on the field it belongs to.
 *
 *  The proposal-chooser DIV is not always present.
 */
scout.SmartFieldPopupLayout = function(popup) {
  scout.SmartFieldPopupLayout.parent.call(this, popup);
};
scout.inherits(scout.SmartFieldPopupLayout, scout.PopupLayout);

scout.SmartFieldPopupLayout.prototype.layout = function($container) {
  var size, popupSize,
    htmlProposalChooser = this._htmlProposalChooser($container);

  scout.SmartFieldPopupLayout.parent.prototype.layout.call(this, $container);

  popupSize = this.popup.htmlComp.getSize();
  if (htmlProposalChooser) {
    size = popupSize.subtract(this.popup.htmlComp.getInsets());
    htmlProposalChooser.setSize(size);
  }
  // Reposition because opening direction may have to be switched if popup gets bigger
  // Don't do it the first time (will be done by popup.open), only if the popup is already open and gets layouted again
  if (this.popup.htmlComp.layouted) {
    this.popup.position();
  }
};

/**
 * @override AbstractLayout.js
 */
scout.SmartFieldPopupLayout.prototype.preferredLayoutSize = function($container) {
  var prefSize,
    htmlProposalChooser = this._htmlProposalChooser($container),
    fieldBounds = this.popup._field._fieldBounds();

  if (htmlProposalChooser) {
    prefSize = htmlProposalChooser.getPreferredSize();
    prefSize = prefSize.add(this.popup.htmlComp.getInsets());
  } else {
    prefSize = new scout.Dimension(
      scout.HtmlEnvironment.formColumnWidth,
      scout.HtmlEnvironment.formRowHeight * 2);
  }

  prefSize.width = Math.max(fieldBounds.width, prefSize.width);
  prefSize.height = Math.max(15, Math.min(350, prefSize.height)); // at least some pixels height in case there is no data, no status, no active filter

  if (prefSize.width > this._maxWindowSize()) {
    prefSize.width = this._maxWindowSize();
  }

  return prefSize;
};

scout.SmartFieldPopupLayout.prototype._htmlProposalChooser = function($container) {
  return scout.HtmlComponent.optGet($container.children('.proposal-chooser'));
};

scout.SmartFieldPopupLayout.prototype._maxWindowSize = function() {
  return this.popup.$container.window().width() - (2 * this.popup.windowPaddingX);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ProposalChooser = function() {
  scout.ProposalChooser.parent.call(this);
  this._addAdapterProperties(['model']);
  this.$container;
  this.$status;
  this.activeFilter;
  this.htmlComp;

  this._updateStatusTimeout;
};
scout.inherits(scout.ProposalChooser, scout.Widget);

/**
 * @see IContentAssistField#getActiveFilterLabels() - should have the same order.
 */
scout.ProposalChooser.ACTIVE_FILTER_VALUES = ['UNDEFINED', 'FALSE', 'TRUE'];

scout.ProposalChooser.prototype._render = function($parent) {
  this.$container = $parent.appendDiv('proposal-chooser');
  this.htmlComp = scout.HtmlComponent.install(this.$container, this.session);
  this.htmlComp.setLayout(new scout.ProposalChooserLayout(this));
  this.model.render(this.$container);
  if (this.model instanceof scout.Tree) {
    // disable focus on field container
    this.model._onNodeControlMouseDownDoFocus = function() {};
  }

  // status
  this.$status = this.$container
    .appendDiv('status')
    .setVisible(false);

  // active filter
  if (this.activeFilter) {
    this.activeFilterGroup = scout.create('RadioButtonGroup', {
      parent: this,
      labelVisible: false,
      statusVisible: false
    });

    // add radio buttons
    scout.ProposalChooser.ACTIVE_FILTER_VALUES.forEach(function(value, index) {
      this._renderButton(value, index);
    }, this);

    this.activeFilterGroup.render(this.$container);
    this.activeFilterGroup.$container.addClass('active-filter');
    this.activeFilterGroup.removeMandatoryIndicator();
  }
};

scout.ProposalChooser.prototype._renderProperties = function() {
  scout.ProposalChooser.parent.prototype._renderProperties.call(this);
  this._updateStatus();
  this.htmlComp.revalidateLayout();
};

/**
 * Delegates an event (e.g. keyup, keydown) to the model.$container of this instance,
 * calling the JQuery trigger method.
 */
scout.ProposalChooser.prototype.delegateEvent = function(event) {
  event.originalEvent.smartFieldEvent = true;
  this.model.$container.trigger(event);
};

scout.ProposalChooser.prototype._renderStatus = function() {
  this._updateStatus();
};

scout.ProposalChooser.prototype._renderStatusVisible = function() {
  this._updateStatus();
};

scout.ProposalChooser.prototype._computeStatusVisible = function() {
  return !!(this.statusVisible && this.status);
};

scout.ProposalChooser.prototype._updateStatus = function() {
  // Note: the UI has a special way to deal with the status. When the UI is rendered
  // we do NOT render an OK status, even when it is set on the model. The status
  // "Search proposals..." is set to severity OK. That status is only displayed, when
  // it is still there after 250 ms. Usually a smart-field lookup is fast, so the user
  // never sees the status message. However: it would be better if the status on the
  // (Java-)model would implement the behavior described above, but
  // this would require a timer thread, so it is easier to implement that in the UI.
  // Status with other severities than OK are displayed immediately.
  clearTimeout(this._updateStatusTimeout);
  if (scout.objects.optProperty(this.status, 'severity') === scout.Status.Severity.OK) {
    // compute statusVisible 250 ms later (status can change in the meantime)
    this._updateStatusTimeout = setTimeout(
        this._updateStatusImpl.bind(this), 250);
  } else {
    this._updateStatusImpl();
  }
};

scout.ProposalChooser.prototype._updateStatusImpl = function() {
  var
    oldVisible = this.$status.isVisible(),
    oldMessage = this.$status.text(),
    visible = this._computeStatusVisible();

  if (oldVisible === visible &&
      oldMessage === scout.objects.optProperty(this.status, 'message')) {
    return;
  }

  $.log.debug('_updateStatus statusVisible=' + visible);
  this.$status.setVisible(visible);
  if (this.status) {
    this._setStatusMessage(this.status.message);
  } else {
    this.$status.text('');
  }
  this.htmlComp.invalidateLayoutTree();
};

/**
 * Replaces an ellipsis (...) at the end of the message-text with a CSS animation.
 */
scout.ProposalChooser.prototype._setStatusMessage = function(message) {
  scout.Status.animateStatusMessage(this.$status, message);
};

scout.ProposalChooser.prototype._renderButton = function(value, index) {
  var radio = scout.create('RadioButton', {
      parent: this.activeFilterGroup,
      label: this.activeFilterLabels[index],
      radioValue: scout.ProposalChooser.ACTIVE_FILTER_VALUES[index],
      selected: this.activeFilter === value,
      focusWhenSelected: false,
      gridData: {
        x: index,
        y: 1,
        useUiWidth: true
      }
    });

  radio.on('propertyChange', function(event) {
    if (event.changedProperties.indexOf('selected') !== -1 && event.newProperties.selected === true) {
      this._onActiveFilterChanged(event.source.radioValue);
    }
  }.bind(this));

  this.activeFilterGroup.addButton(radio);
};

scout.ProposalChooser.prototype._onActiveFilterChanged = function(radioValue) {
  this._send('activeFilterChanged', {
    state: radioValue
  });
};

scout.ProposalChooser.prototype.setVirtual = function(virtual) {
  if (this.model instanceof scout.Table) {
    this.model.setVirtual(virtual);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ProposalChooserAdapter = function() {
  scout.ProposalChooserAdapter.parent.call(this);
  this._addAdapterProperties(['model']);
};
scout.inherits(scout.ProposalChooserAdapter, scout.ModelAdapter);

scout.ProposalChooserAdapter.prototype._postCreateWidget = function() {
  this._injectSendFunction();

  this.widget.model.on('rowClicked', this._onModelProposalSelected.bind(this));
};

scout.ProposalChooserAdapter.prototype._modelAdapter = function() {
  if (this.widget && this.widget.model) {
    return this.widget.model.modelAdapter;
  } else {
    return null;
  }
};

/**
 * This function is required because on slow connections issues. When a rowsSelected
 * event and an acceptProposal event is sent in the same request, the acceptProposal
 * event "wins". Which means, it sets the displayText to a wrong, old text. To
 * prevent this, we don't send the acceptProposal event at all, as long as the
 * displayText has not changed (in that case the displayText of the acceptProposal
 * event would still win).
 */
scout.ProposalChooserAdapter.prototype._onModelProposalSelected = function(event) {
  this.widget.owner.proposalSelected();
};

/**
 * We wrap the original _send method of the ModelAdapter
 */
scout.ProposalChooserAdapter.prototype._injectSendFunction = function() {
  var modelAdapter = this._modelAdapter();
  if (!modelAdapter) {
    return;
  }
  var origSendFunc = scout.objects.mandatoryFunction(modelAdapter, '_send');
  var sendFunc = function(type, data, options) {
    var extOptions = $.extend({}, options);
    extOptions.showBusyIndicator = false;
    origSendFunc.call(modelAdapter, type, data, extOptions);
  };
  modelAdapter._send = sendFunc;
};

scout.ProposalChooserAdapter.prototype._syncModel = function(model) {
  this._injectSendFunction();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.ProposalChooserLayout = function(proposalChooser) {
  scout.ProposalChooserLayout.parent.call(this);
  this._proposalChooser = proposalChooser;
  this._typeHandler = this._createTypeHandler(proposalChooser);
};
scout.inherits(scout.ProposalChooserLayout, scout.AbstractLayout);

/**
 * This factory creates type handlers for the various proposal types. By default we support Table and Tree.
 * If one must support other types, this factory must be extended.
 */
scout.ProposalChooserLayout.TYPE_HANDLER = {

  TABLE: {
    _table: null,
    _fillerWidth: null,
    cssSelector: '.table',
    prepare: function($container, layout) {
      this._table = layout._proposalChooser.model;
    },
    /**
     * Clears the given CSS property and stores the old value as data with prefix 'backup'
     * which is used to restore the CSS property later.
     */
    cssBackup: function($element, property) {
      var oldValue = $element.css(property);
      $element
        .css(property, '')
        .data('backup' + property, oldValue);
    },
    cssRestore: function($element, property) {
      var dataProperty = 'backup' + property,
        oldValue = $element.data(dataProperty);
      $element
        .css(property, oldValue)
        .removeData(dataProperty);
    },
    /**
     * Go through all rows and cells and call the given modifyFunc (backup/restore) on each element.
     */
    modifyTableData: function(modifyFunc) {
      var that = this;
      this._table.$rows().each(function() {
        var $row = $(this);
        modifyFunc($row, 'width');
        that._table.$cellsForRow($row).each(function() {
          var $cell = $(this);
          modifyFunc($cell, 'min-width');
          modifyFunc($cell, 'max-width');
        });
      });
    },
    /**
     * Modifies the table in a way that the preferred width may be read.
     * Removes explicit widths on rows, cells, fillers and sets display to inline-block.
     */
    modifyDom: function($container) {
      this._table.$container
        .css('display', 'inline-block')
        .css('width', 'auto')
        .css('height', 'auto');
      this._table.$data
        .css('display', 'inline-block');

      this.modifyFiller(this._table.$fillBefore);
      this.modifyFiller(this._table.$fillAfter);
      this.modifyTableData(this.cssBackup);
    },

    modifyFiller: function($filler) {
      if ($filler) {
        this._fillerWidth = $filler.css('width');
        $filler.css('width', '');
      }
    },

    restoreDom: function($container) {
      this._table.$container
        .css('display', 'block')
        .css('width', '100%')
        .css('height', '100%');
      this._table.$data
        .css('display', 'block');

      this.restoreFiller(this._table.$fillBefore);
      this.restoreFiller(this._table.$fillAfter);
      this.modifyTableData(this.cssRestore);
    },

    restoreFiller: function($filler) {
      if ($filler) {
        $filler.css('width', this._fillerWidth);
      }
    }
  },

  TREE: {
    _tree: null,
    cssSelector: '.tree',
    prepare: function($container, layout) {
      this._tree = layout._proposalChooser.model;
      var $nodes = this._tree.$data
        .children('.tree-node')
        .removeClass('first last');
      $nodes.first()
        .addClass('first');
      $nodes.last()
        .addClass('last');
    },
    modifyDom: function($container) {
      this._tree.$container
        .css('display', 'inline-block')
        .css('width', 'auto')
        .css('height', 'auto');
      this._tree.$data
        .css('display', 'inline-block');
    },
    restoreDom: function($container) {
      this._tree.$container
        .css('display', 'block')
        .css('width', '100%')
        .css('height', '100%');
      this._tree.$data
        .css('display', 'block');
    }
  }
};

scout.ProposalChooserLayout.prototype._createTypeHandler = function(proposalChooser) {
  var typeId = proposalChooser.model.objectType.toUpperCase(),
    typeHandler = scout.ProposalChooserLayout.TYPE_HANDLER[typeId];
  if (!typeHandler) {
    throw new Error('No type handler defined for type=' + typeId);
  }
  return typeHandler;
};

scout.ProposalChooserLayout.prototype.layout = function($container) {
  var filterPrefSize,
    htmlContainer = scout.HtmlComponent.get($container),
    htmlComp = scout.HtmlComponent.get($container.children(this._typeHandler.cssSelector)),
    size = htmlContainer.getSize().subtract(htmlContainer.getInsets()),
    $status = this._proposalChooser.$status,
    hasStatus = $status && $status.isVisible(),
    filter = this._proposalChooser.activeFilterGroup;

  if (hasStatus) {
    size.height -= scout.graphics.getSize($status).height;
  }
  if (filter) {
    filterPrefSize = filter.htmlComp.getPreferredSize();
    size.height -= filterPrefSize.height;
  }

  // when status or active-filter is available we must explicitly set the
  // height of the model (table or tree) in pixel. Otherwise we'd rely on
  // the CSS height which is set to 100%.
  if (hasStatus || filter) {
    htmlComp.pixelBasedSizing = true;
  }

  htmlComp.setSize(size);

  if (filter) {
    filter.htmlComp.setSize(new scout.Dimension(size.width, filterPrefSize.height));
  }
};

/**
 * This preferred size implementation modifies the DIV where the table/tree is rendered
 * in a way the DIV does not limit the size of the table/tree. Thus we can read the preferred
 * size of the table/tree. After that the original width and height is restored.
 */
scout.ProposalChooserLayout.prototype.preferredLayoutSize = function($container) {
  var oldDisplay, prefSize, modelSize, statusSize, filterPrefSize,
    pcWidth, pcHeight,
    htmlComp = this._proposalChooser.htmlComp,
    $status = this._proposalChooser.$status,
    filter = this._proposalChooser.activeFilterGroup,
    detachHelper = this._proposalChooser.session.detachHelper;

  this._typeHandler.prepare($container, this);
  modelSize = this._proposalChooser.model.htmlComp.getPreferredSize();
  prefSize = modelSize;
  detachHelper._storeScrollPositions($container);

  // pref size of table and tree don't return accurate values for width -> measure width
  pcWidth = $container.css('width');
  pcHeight = $container.css('height');

  this._typeHandler.modifyDom($container);
  $container
    .css('display', 'inline-block')
    .css('width', 'auto')
    .css('height', 'auto');
  modelSize.width = scout.graphics.prefSize($container, {
    restoreScrollPositions: false
  }).width;

  this._typeHandler.restoreDom($container);
  $container
    .css('display', 'block')
    .css('width', pcWidth)
    .css('height', pcHeight);

  detachHelper._restoreScrollPositions($container);

  if ($status && $status.isVisible()) {
    oldDisplay = $status.css('display');
    $status.css('display', 'inline-block');
    statusSize = scout.graphics.prefSize($status, {
      includeMargin: true,
      useCssSize: true
    });
    $status.css('display', oldDisplay);
    prefSize = new scout.Dimension(Math.max(prefSize.width, statusSize.width), prefSize.height + statusSize.height);
  }

  if (filter) {
    filterPrefSize = filter.htmlComp.getPreferredSize();
    prefSize = new scout.Dimension(Math.max(prefSize.width, filterPrefSize.width), prefSize.height + filterPrefSize.height);
  }

  $container.toggleClass('empty', modelSize.height === 0);
  return prefSize.add(htmlComp.getInsets());
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SmartFieldMultiline = function() {
  scout.SmartFieldMultiline.parent.call(this);
  this.options;
  this._$multilineField;
};
scout.inherits(scout.SmartFieldMultiline, scout.SmartField);

scout.SmartFieldMultiline.prototype._render = function($parent) {
  var $field, htmlComp;

  this.addContainer($parent, 'smart-field', new scout.SmartFieldLayout(this));
  this.addLabel();
  this.addFieldContainer($parent.makeDiv());
  htmlComp = scout.HtmlComponent.install(this.$fieldContainer, this.session);
  htmlComp.setLayout(new scout.SmartFieldMultilineLayout());

  $field = scout.fields.makeInputOrDiv(this, 'multiline')
    .click(this._onClick.bind(this))
    .appendTo(this.$fieldContainer);
  if (!this.touch) {
    $field
      .blur(this._onFieldBlur.bind(this))
      .focus(this._onFocus.bind(this))
      .keyup(this._onKeyUp.bind(this))
      .keydown(this._onKeyDown.bind(this));
  }
  this.addField($field);
  this._$multilineField = this.$fieldContainer.appendDiv('multiline-field');
  if (!this.embedded) {
    this.addMandatoryIndicator();
  }
  this.addIcon(this.$fieldContainer);
  this.addStatus();
};

/**
 * @override ValueField.js
 */
scout.SmartFieldMultiline.prototype._renderDisplayText = function() {
  var tmp = this.displayText.split('\n'),
    firstLine = tmp.shift(),
    additionalLines = scout.arrays.formatEncoded(tmp, '<br/>');
  scout.fields.valOrText(this, this.$field, firstLine);
  this._$multilineField.html(additionalLines);
};

/**
 * @override SmartField.js
 */
scout.SmartFieldMultiline.prototype._getInputBounds = function() {
  var fieldBounds = scout.graphics.offsetBounds(this.$fieldContainer),
    textFieldBounds = scout.graphics.offsetBounds(this.$field);
  fieldBounds.height = textFieldBounds.height;
  return fieldBounds;
};

/**
 * Concatenates the text in the input-field and from the other additional lines in model.displayText
 * (which are displayed in the text-box below the input-field).
 *
 * @override SmartField.js
 */
scout.SmartFieldMultiline.prototype._readDisplayText = function() {
  var i,
    firstLine = scout.fields.valOrText(this, this.$field),
    newDisplayText = [firstLine],
    oldDisplayText = this.displayText.split('\n');
  for (i = 1; i < oldDisplayText.length; i++) {
    newDisplayText.push(oldDisplayText[i]);
  }
  return newDisplayText.join('\n');
};

/**
 * @override SmartField.js
 */
scout.SmartFieldMultiline.prototype._readSearchText = function() {
  // Only read the first line
  return scout.fields.valOrText(this, this.$field);
};

  /*******************************************************************************
   * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
   * All rights reserved. This program and the accompanying materials
   * are made available under the terms of the Eclipse Public License v1.0
   * which accompanies this distribution, and is available at
   * http://www.eclipse.org/legal/epl-v10.html
   *
   * Contributors:
   *     BSI Business Systems Integration AG - initial API and implementation
   ******************************************************************************/
  scout.SmartFieldMultilineAdapter = function() {
    scout.SmartFieldMultilineAdapter.parent.call(this);
  };
  scout.inherits(scout.SmartFieldMultilineAdapter, scout.SmartFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * This layout only layout the INPUT and DIV part of the multi-line smart-field, not the entire form-field.
 */
scout.SmartFieldMultilineLayout = function() {
  scout.SmartFieldMultilineLayout.parent.call(this);
};
scout.inherits(scout.SmartFieldMultilineLayout, scout.AbstractLayout);

scout.SmartFieldMultilineLayout.prototype.layout = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    $inputField = $container.children('.multiline'),
    $multilines = $container.children('.multiline-field'),
    innerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  $inputField.cssHeight(scout.HtmlEnvironment.formRowHeight);
  $multilines.cssHeight(innerSize.height - scout.HtmlEnvironment.formRowHeight);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SplitBox = function() {
  scout.SplitBox.parent.call(this);
  this._addAdapterProperties(['firstField', 'secondField', 'collapsibleField']);

  this.fieldCollapsed = false;
  this.collapsibleField;
  this.splitHorizontal; // true = split x-axis, false = split y-axis
  this._collapseKeyStroke;

  this._$splitArea;
  this._$splitter;
};
scout.inherits(scout.SplitBox, scout.CompositeField);

scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE = 'relative';
scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_FIRST = 'absoluteFirst';
scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND = 'absoluteSecond';

scout.SplitBox.prototype._init = function(model) {
  scout.SplitBox.parent.prototype._init.call(this, model);
  this._syncCollapseKeyStroke(this.collapseKeyStroke);
  this._updateCollapseHandle();
};

scout.SplitBox.prototype._render = function($parent) {
  this.addContainer($parent, 'split-box');
  // This widget does not support label, mandatoryIndicator and status

  // Create split area
  this._$splitArea = $parent.makeDiv('split-area');
  this.addField(this._$splitArea);
  this.htmlSplitArea = scout.HtmlComponent.install(this._$splitArea, this.session);
  this.htmlSplitArea.setLayout(new scout.SplitBoxLayout(this));
  this._$window = $parent.window();
  this._$body = $parent.body();

  // Add fields and splitter
  if (this.firstField) {
    this.firstField.render(this._$splitArea);
    this.firstField.$container
      .addClass('first-field')
      .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');
    this.firstField.on('propertyChange', onInnerFieldPropertyChange.bind(this));

    if (this.secondField) {
      this._$splitter = this._$splitArea.appendDiv('splitter')
        .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis')
        .on('mousedown', resizeSplitter.bind(this));

      this.secondField.render(this._$splitArea);
      this.secondField.$container
        .addClass('second-field')
        .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');
      this.secondField.on('propertyChange', onInnerFieldPropertyChange.bind(this));
    }
  }

  // --- Helper functions ---

  function resizeSplitter(event) {
    if (event.which !== 1) {
      return; // only handle left mouse button
    }
    if (this.splitterEnabled) {
      // Update mouse position (see resizeMove() for details)
      var mousePosition = {
        x: event.clientX,
        y: event.clientY
      };

      // Add listeners (we add them to the window to make sure we get the mouseup event even when the cursor it outside the window)
      this._$window
        .on('mousemove.splitbox', resizeMove.bind(this))
        .on('mouseup.splitbox', resizeEnd.bind(this));
      // Ensure the correct cursor is always shown while moving
      this._$body.addClass(this.splitHorizontal ? 'col-resize' : 'row-resize');

      // Get initial area and splitter bounds
      var splitAreaPosition = this._$splitArea.offset();
      var splitAreaSize = scout.graphics.getSize(this._$splitArea, true);
      var splitterPosition = this._$splitter.offset();
      var splitterSize = scout.graphics.getSize(this._$splitter, true);

      // Create temporary splitter
      var $tempSplitter = this._$splitArea.appendDiv('temp-splitter')
        .addClass(this.splitHorizontal ? 'x-axis' : 'y-axis');
      if (this.splitHorizontal) { // "|"
        $tempSplitter.cssLeft(splitterPosition.left - splitAreaPosition.left);
      } else { // "--"
        $tempSplitter.cssTop(splitterPosition.top - splitAreaPosition.top);
      }
      this._$splitter.addClass('dragging');
    }

    var newSplitterPosition = this.splitterPosition;
    var SNAP_SIZE = 25;

    function resizeMove(event) {
      if (event.clientX === mousePosition.x && event.clientY === mousePosition.y) {
        // Chrome bug: https://code.google.com/p/chromium/issues/detail?id=161464
        // When holding the mouse, but not moving it, a 'mousemove' event is fired every second nevertheless.
        return;
      }
      mousePosition = {
        x: event.clientX,
        y: event.clientY
      };

      if (this.splitHorizontal) { // "|"
        // Calculate target splitter position (in area)
        var targetSplitterPositionLeft = event.pageX - splitAreaPosition.left;

        // Snap to begin and end
        var tempSplitterOffsetX = splitterSize.width / 2;
        if (targetSplitterPositionLeft < SNAP_SIZE) {
          targetSplitterPositionLeft = 0;
          tempSplitterOffsetX = 0;
        } else if (splitAreaSize.width - targetSplitterPositionLeft < SNAP_SIZE) {
          targetSplitterPositionLeft = splitAreaSize.width;
          tempSplitterOffsetX = splitterSize.width;
        }

        // Update temporary splitter
        $tempSplitter.cssLeft(targetSplitterPositionLeft - tempSplitterOffsetX);
        // Normalize target position
        newSplitterPosition = (targetSplitterPositionLeft - tempSplitterOffsetX - scout.HtmlEnvironment.fieldMandatoryIndicatorWidth);
        if (this.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE) {
          newSplitterPosition = newSplitterPosition / (splitAreaSize.width - splitterSize.width - scout.HtmlEnvironment.fieldMandatoryIndicatorWidth);
        } else if (this.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {
          newSplitterPosition = splitAreaSize.width - newSplitterPosition - splitterSize.width;
        }
      } else { // "--"
        // Calculate target splitter position (in area)
        var targetSplitterPositionTop = event.pageY - splitAreaPosition.top;

        // Snap to begin and end
        var tempSplitterOffsetY = splitterSize.height / 2;
        if (targetSplitterPositionTop < SNAP_SIZE) {
          targetSplitterPositionTop = 0;
          tempSplitterOffsetY = 0;
        } else if (splitAreaSize.height - targetSplitterPositionTop < SNAP_SIZE) {
          targetSplitterPositionTop = splitAreaSize.height;
          tempSplitterOffsetY = splitterSize.height;
        }

        // Update temporary splitter
        $tempSplitter.cssTop(targetSplitterPositionTop - tempSplitterOffsetY);
        // Normalize target position
        newSplitterPosition = targetSplitterPositionTop;
        if (this.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE) {
          newSplitterPosition = newSplitterPosition / splitAreaSize.height;
        } else if (this.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {
          newSplitterPosition = splitAreaSize.height - newSplitterPosition - splitterSize.height;
        }
      }
    }

    function resizeEnd(event) {
      if (event.which !== 1) {
        return; // only handle left mouse button
      }
      // Remove listeners and reset cursor
      this._$window
        .off('mousemove.splitbox')
        .off('mouseup.splitbox');
      if ($tempSplitter) { // instead of check for this.splitterEnabled, if splitter is currently moving it must be finished correctly
        this._$body.removeClass((this.splitHorizontal ? 'col-resize' : 'row-resize'));

        // Remove temporary splitter
        $tempSplitter.remove();
        this._$splitter.removeClass('dragging');

        // Update split box
        this.newSplitterPosition(newSplitterPosition);
        if (this.rendered) {
          // TODO CGU [6.0] remove this, should not be necessary anymore with 6.0
          this.htmlSplitArea.validateLayout(); // validate layout immediately (was invalidated by newSplitterPosition())
        }
      }
    }

    return false;
  }

  function onInnerFieldPropertyChange(event) {
    if (event.changedProperties.indexOf('visible') !== -1) {
      // Mark layout as invalid
      this.htmlSplitArea.invalidateLayoutTree(false);
    }
  }
};

scout.SplitBox.prototype._renderProperties = function() {
  scout.SplitBox.parent.prototype._renderProperties.call(this);
  this._renderSplitterPosition();
  this._renderSplitterEnabled();
  this._renderCollapsibleField(); // renders collapsibleField _and_ fieldCollapsed
  this._renderCollapseHandle(); // renders collapseHandle _and_ collapseKeyStroke
};

scout.SplitBox.prototype._syncSplitterPosition = function(splitterPosition) {
  this._setProperty('splitterPosition', splitterPosition);
  // If splitter position is explicitly set by an event, no recalculation is necessary
  this._oldSplitterPositionType = null;
};

scout.SplitBox.prototype._renderSplitterPosition = function() {
  this.newSplitterPosition(this.splitterPosition);
};

scout.SplitBox.prototype._syncSplitterPositionType = function(splitterPositionType) {
  if (this.rendered && !this._oldSplitterPositionType) {
    this._oldSplitterPositionType = this.splitterPositionType;
    // We need to recalculate the splitter position. Because this requires the proper
    // size of the split box, this can only be done in _renderSplitterPositionType().
  }
  this._setProperty('splitterPositionType', splitterPositionType);
};

scout.SplitBox.prototype._renderSplitterPositionType = function() {
  if (this._oldSplitterPositionType) {
    // splitterPositionType changed while the split box was rendered --> convert splitterPosition
    // to the target type such that the current position in screen does not change.
    var splitAreaSize = this.htmlSplitArea.getSize(),
      splitterPosition = this.splitterPosition,
      splitterSize = scout.graphics.getVisibleSize(this._$splitter, true),
      totalSize = 0;
    if (this.splitHorizontal) { // "|"
      totalSize = splitAreaSize.width - splitterSize.width;
    } else { // "--"
      totalSize = splitAreaSize.height - splitterSize.height;
    }

    // Convert value depending on the old and new type system
    var oldIsRelative = (this._oldSplitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE);
    var newIsRelative = (this.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE);
    var oldIsAbsolute = !oldIsRelative;
    var newIsAbsolute = !newIsRelative;
    if (oldIsRelative && newIsAbsolute) {
      // From relative to absolute
      if (this.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {
        splitterPosition = totalSize - (totalSize * splitterPosition);
      } else {
        splitterPosition = totalSize * splitterPosition;
      }
    } else if (oldIsAbsolute && newIsRelative) {
      // From absolute to relative
      if (this._oldSplitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {
        splitterPosition = (totalSize - splitterPosition) / totalSize;
      } else {
        splitterPosition = splitterPosition / totalSize;
      }
    } else if (oldIsAbsolute && newIsAbsolute) {
      splitterPosition = (totalSize - splitterPosition);
    }
    // Set as new splitter position
    this._oldSplitterPositionType = null;
    this.newSplitterPosition(splitterPosition);
  }
};

scout.SplitBox.prototype._renderSplitterEnabled = function() {
  if (this._$splitter) {
    this._$splitter.setEnabled(this.splitterEnabled);
  }
};

scout.SplitBox.prototype.setFieldCollapsed = function(collapsed) {
  this.setProperty('fieldCollapsed', collapsed);
  this._updateCollapseHandleButtons();
};

scout.SplitBox.prototype._renderFieldCollapsed = function() {
  this._renderCollapsibleField();
};

scout.SplitBox.prototype.setCollapsibleField = function(field) {
  this.setProperty('collapsibleField', field);
  this._updateCollapseHandle();
};

scout.SplitBox.prototype._updateCollapseHandle = function() {
  // always unregister key stroke first (although it may have been added by _syncCollapseKeyStroke before)
  if (this.collapseKeyStroke) {
    this.unregisterKeyStrokes(this.collapseKeyStroke);
  }
  if (this.collapsibleField) {
    if (!this._collapseHandle) {
      this._collapseHandle = scout.create('CollapseHandle', {
        parent: this
      });
      this._collapseHandle.on('action', this.toggleFieldCollapsed.bind(this));
      if (this.collapseKeyStroke) {
        this.registerKeyStrokes(this.collapseKeyStroke);
      }
    }
    this._updateCollapseHandleButtons();
  } else {
     if (this._collapseHandle) {
       this._collapseHandle.destroy();
       this._collapseHandle = null;
     }
  }
};

scout.SplitBox.prototype._updateCollapseHandleButtons = function() {
  var leftVisible, rightVisible,
    collapsed = this.fieldCollapsed;
  if (this.collapsibleField === this.firstField) {
    leftVisible  = !collapsed;
    rightVisible =  collapsed;
  } else {
    leftVisible  =  collapsed;
    rightVisible = !collapsed;
  }
  this._collapseHandle.setLeftVisible(leftVisible);
  this._collapseHandle.setRightVisible(rightVisible);
};

scout.SplitBox.prototype._renderCollapsibleField = function() {
  if (this.firstField) {
    this.firstField.$container.removeClass('collapsed');
  }
  if (this.secondField) {
    this.secondField.$container.removeClass('collapsed');
  }
  if (this.collapsibleField && this.fieldCollapsed) {
    this.collapsibleField.$container.addClass('collapsed');
  }
  if (this.rendered) { // don't invalidate layout on initial rendering
    this.htmlSplitArea.invalidateLayoutTree(false);
  }
};

scout.SplitBox.prototype._syncCollapseKeyStroke = function(keyStroke) {
  if (keyStroke) {
    if (this.collapseKeyStroke instanceof scout.KeyStroke) {
      this.unregisterKeyStrokes(this.collapseKeyStroke);
    }
    this.collapseKeyStroke = new scout.SplitBoxCollapseKeyStroke(this, keyStroke);
    if (this._collapseHandle) {
      this.registerKeyStrokes(this.collapseKeyStroke);
    }
  }
};

scout.SplitBox.prototype._renderCollapseHandle = function() {
  if (this._collapseHandle) {
    this._collapseHandle.render(this.$container);
  }
};

scout.SplitBox.prototype.newSplitterPosition = function(newSplitterPosition) {
  if (this.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE) {
    // Ensure range 0..1
    newSplitterPosition = Math.max(0, Math.min(1, newSplitterPosition));
  } else {
    // Ensure not negative
    newSplitterPosition = Math.max(0, newSplitterPosition);
  }

  // Set new value (send to server if changed)
  var positionChanged = (this.splitterPosition !== newSplitterPosition);
  this.splitterPosition = newSplitterPosition;
  if (positionChanged) {
    this.trigger('positionChange', {
      position: newSplitterPosition
    });
  }

  // Mark layout as invalid
  this.htmlSplitArea.invalidateLayoutTree(false);
};

scout.SplitBox.prototype.toggleFieldCollapsed = function() {
  this.setFieldCollapsed(!this.fieldCollapsed);
};

/**
 * @override CompositeField.js
 */
scout.SplitBox.prototype.getFields = function() {
  var fields = [];
  if (this.firstField) {
    fields.push(this.firstField);
  }
  if (this.secondField) {
    fields.push(this.secondField);
  }
  return fields;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SplitBoxAdapter = function() {
  scout.SplitBoxAdapter.parent.call(this);
  this._addAdapterProperties(['firstField', 'secondField', 'collapsibleField']);
  this._addRemoteProperties(['collapsibleField', 'fieldCollapsed']);
};
scout.inherits(scout.SplitBoxAdapter, scout.CompositeFieldAdapter);

scout.SplitBoxAdapter.prototype._onWidgetPositionChange = function(event) {
  this._send('setSplitterPosition', {
    splitterPosition: event.position
  });
};

scout.SplitBoxAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'positionChange') {
    this._onWidgetPositionChange(event);
  } else {
    scout.SplitBoxAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SplitBoxCollapseKeyStroke = function(splitBox, keyStroke) {
  scout.SplitBoxCollapseKeyStroke.parent.call(this);
  this.field = splitBox;
  this.parseAndSetKeyStroke(keyStroke);
};
scout.inherits(scout.SplitBoxCollapseKeyStroke, scout.KeyStroke);

scout.SplitBoxCollapseKeyStroke.prototype.handle = function(event) {
  this.field.toggleFieldCollapsed();
};

scout.SplitBoxCollapseKeyStroke.prototype._postRenderKeyBox = function($drawingArea, $keyBox) {
  var handleOffset,
    $collapseHandle = this.field._collapseHandle.$container;

  $keyBox.addClass('split-box-collapse-key-box');
  handleOffset = $collapseHandle.offsetTo(this.field.$container);
  $keyBox
    .cssLeft(handleOffset.left - $keyBox.outerWidth())
    .cssTop(handleOffset.top);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.SplitBoxLayout = function(splitBox) {
  scout.SplitBoxLayout.parent.call(this);
  this._splitBox = splitBox;
};
scout.inherits(scout.SplitBoxLayout, scout.AbstractLayout);

scout.SplitBoxLayout.prototype.layout = function($container) {
  // Extract components
  var htmlContainer = scout.HtmlComponent.get($container), // = split-area
    $splitter = $container.children('.splitter'),
    $fields = $container.children('.form-field'),
    htmlFirstField = scout.HtmlComponent.optGet($fields.eq(0)),
    htmlSecondField = scout.HtmlComponent.optGet($fields.eq(1)),
    // Calculate available size for split area
    splitXAxis = this._splitBox.splitHorizontal;

  $splitter.removeClass('hidden');

  var firstFieldSize, secondFieldSize, firstFieldBounds, secondFieldBounds,
    splitterSize = scout.graphics.getVisibleSize($splitter, true),
    availableSize = htmlContainer
      .getAvailableSize()
      .subtract(htmlContainer.getInsets()),

    hasFirstField = (htmlFirstField && htmlFirstField.isVisible()),
    hasSecondField = (htmlSecondField && htmlSecondField.isVisible()),
    hasTwoFields = hasFirstField && hasSecondField,
    hasOneField = !hasTwoFields && (hasFirstField || hasSecondField),
    splitterPosition = this._splitBox.splitterPosition;

  // remove splitter size from available with, only when both fields are visible
  // otherwise the splitter is invisible and requires no space.
  var availableSizeForFields = new scout.Dimension(availableSize);
  if (hasTwoFields) {
    if (splitXAxis) { // "|"
      availableSizeForFields.width -= splitterSize.width;
    } else { // "--"
      availableSizeForFields.height -= splitterSize.height;
    }
  }

  // Default case: two fields
  if (hasTwoFields) {
    // Distribute available size to the two fields according to the splitter position ratio
    firstFieldSize = new scout.Dimension(availableSizeForFields);
    secondFieldSize = new scout.Dimension(availableSizeForFields);
    if (splitXAxis) { // "|"
      if (this._splitBox.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE) {
        // Relative
        firstFieldSize.width *= splitterPosition;
        secondFieldSize.width *= (1 - splitterPosition);
      } else {
        // Absolute
        splitterPosition = Math.min(splitterPosition, availableSizeForFields.width);
        if (this._splitBox.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {
          firstFieldSize.width = availableSizeForFields.width - splitterPosition;
          secondFieldSize.width = splitterPosition;
        } else {
          firstFieldSize.width = splitterPosition;
          secondFieldSize.width = availableSizeForFields.width - splitterPosition;
        }
      }
    } else { // "--"
      if (this._splitBox.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_RELATIVE) {
        // Relative
        firstFieldSize.height *= splitterPosition;
        secondFieldSize.height *= (1 - splitterPosition);
      } else {
        // Absolute
        splitterPosition = Math.min(splitterPosition, availableSizeForFields.height);
        if (this._splitBox.splitterPositionType === scout.SplitBox.SPLITTER_POSITION_TYPE_ABSOLUTE_SECOND) {
          firstFieldSize.height = availableSizeForFields.height - splitterPosition;
          secondFieldSize.height = splitterPosition;
        } else {
          firstFieldSize.height = splitterPosition;
          secondFieldSize.height = availableSizeForFields.height - splitterPosition;
        }
      }
    }
    firstFieldSize = firstFieldSize.subtract(htmlFirstField.getMargins());
    secondFieldSize = secondFieldSize.subtract(htmlSecondField.getMargins());

    // Calculate and set bounds (splitter and second field have to be moved)
    firstFieldBounds = new scout.Rectangle(0, 0, firstFieldSize.width, firstFieldSize.height);
    secondFieldBounds = new scout.Rectangle(0, 0, secondFieldSize.width, secondFieldSize.height);
    if (splitXAxis) { // "|"
      $splitter.cssLeft(firstFieldBounds.width);
      secondFieldBounds.x = firstFieldBounds.width + splitterSize.width;
    } else { // "--"
      $splitter.cssTop(firstFieldBounds.height);
      secondFieldBounds.y = firstFieldBounds.height + splitterSize.height;
    }
    htmlFirstField.setBounds(firstFieldBounds);
    htmlSecondField.setBounds(secondFieldBounds);
  }
  // Special case: only one field (or none at all)
  else {
    if (hasOneField) {
      var singleField = hasFirstField ? htmlFirstField : htmlSecondField,
        singleFieldSize = availableSize.subtract(singleField.getMargins());
      singleField.setBounds(new scout.Rectangle(0, 0, singleFieldSize.width, singleFieldSize.height));
    }
    $splitter.addClass('hidden');
  }

  // Calculate collapse button position
  if (this._splitBox._collapseHandle) {

    // Horizontal layout:
    // - if 1st field is collapsible -> align button on the right side of the field
    // - if 2nd field is collapsible -> align button on the left side of the field
    var x,
      $collapseHandle = this._splitBox._collapseHandle.$container,
      collapseHandleSize = scout.graphics.getSize($collapseHandle);

    if (this._splitBox.collapsibleField === this._splitBox.firstField) {
      x = hasFirstField ? firstFieldBounds.width - collapseHandleSize.width : 0;
    } else { // secondField
      x = hasSecondField ? availableSize.width - secondFieldBounds.width : availableSize.width - collapseHandleSize.width;
    }

    var collapseHandleLocation = new scout.Point(x, availableSize.height - collapseHandleSize.height);
    scout.graphics.setLocation($collapseHandle, collapseHandleLocation);
  }
};

scout.SplitBoxLayout.prototype.preferredLayoutSize = function($container) {
  // Extract components
  var htmlContainer = scout.HtmlComponent.get($container), // = split-area
    $splitter = $container.children('.splitter'),
    $fields = $container.children('.form-field'),
    htmlFirstField = scout.HtmlComponent.optGet($fields.eq(0)),
    htmlSecondField = scout.HtmlComponent.optGet($fields.eq(1));

  var splitXAxis = this._splitBox.splitHorizontal;
  var splitterSize = scout.graphics.getVisibleSize($splitter, true);

  // Get preferred size of fields
  var firstFieldSize = new scout.Dimension(0, 0);
  if (htmlFirstField) {
    firstFieldSize = htmlFirstField.getPreferredSize()
      .add(htmlFirstField.getMargins());
  }
  var secondFieldSize = new scout.Dimension(0, 0);
  if (htmlSecondField) {
    secondFieldSize = htmlSecondField.getPreferredSize()
      .add(htmlSecondField.getMargins());
  }

  // Calculate prefSize
  var prefSize;
  if (splitXAxis) { // "|"
    prefSize = new scout.Dimension(
      firstFieldSize.width + secondFieldSize.width + splitterSize.width,
      Math.max(firstFieldSize.height, secondFieldSize.height)
    );
  } else { // "--"
    prefSize = new scout.Dimension(
      Math.max(firstFieldSize.width, secondFieldSize.width),
      firstFieldSize.height + secondFieldSize.height + splitterSize.height
    );
  }
  prefSize = prefSize.add(htmlContainer.getInsets());

  return prefSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.StringField = function() {
  scout.StringField.parent.call(this);

  this.inputMasked = false;
  this.multilineText = false;
  this.updateDisplayTextOnModify = false;
  this.maxLength = 4000;

  this._onSelectionChangingActionHandler = this._onSelectionChangingAction.bind(this);
};
scout.inherits(scout.StringField, scout.BasicField);

scout.StringField.FORMAT = {
  LOWER: 'a' /* IStringField.FORMAT_LOWER */ ,
  UPPER: 'A' /* IStringField.FORMAT_UPPER */
};

scout.StringField.TRIM_REGEXP = new RegExp('^(\\s*)(.*?)(\\s*)$');

/**
 * @override ModelAdapter.js
 */
scout.StringField.prototype._initKeyStrokeContext = function() {
  scout.StringField.parent.prototype._initKeyStrokeContext.call(this);

  this.keyStrokeContext.registerKeyStroke([
    new scout.StringFieldEnterKeyStroke(this),
    new scout.StringFieldCtrlEnterKeyStroke(this)
  ]);
};

/**
 * @override Widget.js
 */
scout.StringField.prototype._createKeyStrokeContext = function() {
  return new scout.InputFieldKeyStrokeContext();
};

scout.StringField.prototype._render = function($parent) {
  this.addContainer($parent, 'string-field');
  this.addLabel();
  this.addMandatoryIndicator();

  var $field;
  if (this.multilineText) {
    var mousedownHandler = function() {
      this.mouseClicked = true;
    }.bind(this);
    $field = $parent.makeElement('<textarea>')
      .on('DOMMouseScroll mousewheel', function(event) {
        // otherwise scout.Scrollbar.prototype would handle this event for scrollable group boxes and prevent scrolling on textarea
        event.stopPropagation();
      })
      .on('mousedown', mousedownHandler)
      .on('focus', function(event) {
        this.$field.off('mousedown', mousedownHandler);
        if (!this.mouseClicked) { // only trigger on tab focus in
          setTimeout(function() {
            if (this.rendered) {
              this._renderSelectionStart();
              this._renderSelectionEnd();
            }
          }.bind(this));
        }
        this.mouseClicked = false;
      }.bind(this))
      .on('focusout', function() {
        this.$field.on('mousedown', mousedownHandler);
      }.bind(this));
  } else {
    $field = scout.fields.makeTextField($parent);
  }
  $field.on('blur', this._onFieldBlur.bind(this));

  this.addField($field);
  this.addStatus();

};

scout.StringField.prototype._onFieldBlur = function() {
  scout.StringField.parent.prototype._onFieldBlur.call(this);
  if (this.multilineText) {
    this._updateSelection();
  }
};

scout.StringField.prototype._renderProperties = function() {
  scout.StringField.parent.prototype._renderProperties.call(this);

  this._renderInputMasked();
  this._renderWrapText();
  this._renderFormat();
  this._renderSpellCheckEnabled();
  this._renderHasAction();
  this._renderMaxLength();
  this._renderSelectionTrackingEnabled();
  // Do not render selectionStart and selectionEnd here, because that would cause the focus to
  // be set to <textarea>s in IE. Instead, the selection is rendered when the focus has entered
  // the field, see _render(). #168648
  this._renderDropType();
};

scout.StringField.prototype._renderMaxLength = function() {
  // Check if "maxLength" attribute is supported by browser
  if (this.$field[0].maxLength) {
    this.$field.attr('maxlength', this.maxLength);
  } else {
    // Fallback for IE9
    this.$field.on('keyup paste', function(e) {
      setTimeout(function() {
        var text = this.$field.val();
        if (text.length > this.maxLength) {
          this.$field.val(text.slice(0, this.maxLength));
        }
      }.bind(this), 0);
    }.bind(this));
  }
};

scout.StringField.prototype._renderSelectionStart = function() {
  if (scout.nvl(this.selectionStart, null) !== null) {
    this.$field[0].selectionStart = this.selectionStart;
  }
};

scout.StringField.prototype._renderSelectionEnd = function() {
  if (scout.nvl(this.selectionEnd, null) !== null) {
    this.$field[0].selectionEnd = this.selectionEnd;
  }
};

scout.StringField.prototype._renderSelectionTrackingEnabled = function() {
  this.$field
    .off('select', this._onSelectionChangingActionHandler)
    .off('mousedown', this._onSelectionChangingActionHandler)
    .off('keydown', this._onSelectionChangingActionHandler)
    .off('input', this._onSelectionChangingActionHandler);
  if (this.selectionTrackingEnabled) {
    this.$field.on('select', this._onSelectionChangingActionHandler)
      .on('mousedown', this._onSelectionChangingActionHandler)
      .on('keydown', this._onSelectionChangingActionHandler)
      .on('input', this._onSelectionChangingActionHandler);
  }
};

scout.StringField.prototype._renderInputMasked = function() {
  if (this.multilineText) {
    return;
  }
  this.$field.attr('type', (this.inputMasked ? 'password' : 'text'));
};

scout.StringField.prototype._renderHasAction = function() {
  if (this.hasAction) {
    this.$container.addClass("has-action");
    this.addIcon();
    this.invalidateLayoutTree(false);
  } else {
    if (this.$icon) {
      this.$icon.remove();
      this.$container.removeClass("has-action");
    }
  }
};

scout.StringField.prototype._renderFormat = function() {
  if (this.format === scout.StringField.FORMAT.LOWER) {
    this.$field.css('text-transform', 'lowercase');
  } else if (this.format === scout.StringField.FORMAT.UPPER) {
    this.$field.css('text-transform', 'uppercase');
  }
};

scout.StringField.prototype._renderSpellCheckEnabled = function() {
  if (this.spellCheckEnabled) {
    this.$field.attr('spellcheck', 'true');
  } else {
    this.$field.attr('spellcheck', 'false');
  }
};

scout.StringField.prototype._renderDisplayText = function() {
  var displayText = scout.strings.nvl(this.displayText);
  var oldDisplayText = scout.strings.nvl(this.$field.val());
  var oldSelection = this._getSelection();
  scout.StringField.parent.prototype._renderDisplayText.call(this);
  // Try to keep the current selection for cases where the old and new display
  // text only differ because of the automatic trimming.
  if (this.trimText && oldDisplayText !== displayText) {
    var matches = oldDisplayText.match(scout.StringField.TRIM_REGEXP);
    if (matches && matches[2] === displayText) {
      this._setSelection({
        start: Math.max(oldSelection.start - matches[1].length, 0),
        end: Math.min(oldSelection.end - matches[1].length, displayText.length)
      });
    }
  }
};

// Not called in _renderProperties() because this is not really a property (more like an event)
scout.StringField.prototype._renderInsertText = function() {
  if (!this.insertText) {
    return;
  }
  var text = this.$field.val();

  // Prevent insert if new length would exceed maxLength to prevent unintended deletion of characters at the end of the string
  if (this.insertText.length + text.length > this.maxLength) {
    scout.create('DesktopNotification', {
      parent: this,
      id: scout.numbers.randomId(),
      desktop: this.session.desktop,
      duration: 3000,
      status: {
        message: this.session.text('ui.CannotInsertTextTooLong'),
        severity: scout.Status.Severity.WARNING
      }
    }).show();
    return;
  }

  var selection = this._getSelection();
  text = text.slice(0, selection.start) + this.insertText + text.slice(selection.end);
  this.$field.val(text);

  this._setSelection(selection.start + this.insertText.length);

  // Make sure display text gets sent (necessary if field does not have the focus)
  if (this.updateDisplayTextOnModify) {
    // If flag is true, we need to send two events (First while typing=true, second = false)
    this.acceptInput(true);
  }
  this.acceptInput();
};

scout.StringField.prototype._renderWrapText = function() {
  this.$field.attr('wrap', this.wrapText ? 'soft' : 'off');
};

scout.StringField.prototype._renderTrimText = function() {
  // nop, property used in _validateDisplayText()
};

scout.StringField.prototype._renderGridData = function() {
  scout.StringField.parent.prototype._renderGridData.call(this);
  this.updateInnerAlignment({
    useHorizontalAlignment: (this.multilineText ? false : true)
  });
};

scout.StringField.prototype._onIconClick = function(event) {
  this.acceptInput();
  scout.StringField.parent.prototype._onIconClick.call(this, event);
  this.trigger('action');
};

scout.StringField.prototype._onSelectionChangingAction = function(event) {
  if (event.type === 'mousedown') {
    this.$field.window().one('mouseup.stringfield', function() {
      // For some reason, when clicking side an existing selection (which clears the selection), the old
      // selection is still visible. To get around this case, we use setTimeout to handle the new selection
      // after it really has been changed.
      setTimeout(this._updateSelection.bind(this));
    }.bind(this));
  } else if (event.type === 'keydown') {
    // Use set timeout to let the cursor move to the target position
    setTimeout(this._updateSelection.bind(this));
  } else {
    this._updateSelection();
  }
};

scout.StringField.prototype._getSelection = function() {
  var start = scout.nvl(this.$field[0].selectionStart, null);
  var end = scout.nvl(this.$field[0].selectionEnd, null);
  if (start === null || end === null) {
    start = 0;
    end = 0;
  }
  return {
    start: start,
    end: end
  };
};

scout.StringField.prototype._setSelection = function(selectionStart, selectionEnd) {
  if (typeof selectionStart === 'number') {
    selectionEnd = scout.nvl(selectionEnd, selectionStart);
  } else if (typeof selectionStart === 'object') {
    selectionEnd = selectionStart.end;
    selectionStart = selectionStart.start;
  }
  this.$field[0].selectionStart = selectionStart;
  this.$field[0].selectionEnd = selectionEnd;
  this._updateSelection();
};

scout.StringField.prototype._updateSelection = function() {
  var oldSelectionStart = this.selectionStart;
  var oldSelectionEnd = this.selectionEnd;
  this.selectionStart = this.$field[0].selectionStart;
  this.selectionEnd = this.$field[0].selectionEnd;
  if (this.selectionTrackingEnabled) {
    var selectionChanged = (this.selectionStart !== oldSelectionStart || this.selectionEnd !== oldSelectionEnd);
    if (selectionChanged) {
      this.triggerSelectionChange();
    }
  }
};

scout.StringField.prototype.triggerSelectionChange = function() {
  this.trigger('selectionChange', {
    selectionStart: this.selectionStart,
    selectionEnd: this.selectionEnd
  });
};

scout.StringField.prototype._validateValue = function(value) {
  if (this.trimText) {
    value = value.trim();
  }
  return scout.StringField.parent.prototype._validateValue(value);
};

/**
 * @override ValueField.js
 */
scout.StringField.prototype._updateEmpty = function() {
  this.empty = scout.strings.empty(this.value);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.StringFieldAdapter = function() {
  scout.StringFieldAdapter.parent.call(this);
};
scout.inherits(scout.StringFieldAdapter, scout.BasicFieldAdapter);

scout.StringFieldAdapter.prototype._onWidgetSelectionChange = function(event) {
  // send delayed to avoid a lot of requests while selecting
  // coalesce: only send the latest selection changed event for a field
  this._send('selectionChanged', {
    selectionStart: event.selectionStart,
    selectionEnd: event.selectionEnd
  }, {
    delay: 500,
    coalesce: function(previous) {
      return this.id === previous.id && this.type === previous.type;
    }
  });
};

scout.StringFieldAdapter.prototype._onWidgetAction = function(event) {
  this._send('callAction');
};

scout.StringFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'selectionChange') {
    this._onWidgetSelectionChange(event);
  } else if (event.type === 'action') {
    this._onWidgetAction(event);
  } else {
    scout.StringFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.StringFieldEnterKeyStroke = function(stringField) {
  scout.StringFieldEnterKeyStroke.parent.call(this);
  this.field = stringField;
  this.which = [scout.keys.ENTER];
  this.renderingHints.render = false;
  this.preventDefault = false;
};
scout.inherits(scout.StringFieldEnterKeyStroke, scout.KeyStroke);

scout.StringFieldEnterKeyStroke.prototype._applyPropagationFlags = function(event) {
  scout.StringFieldEnterKeyStroke.parent.prototype._applyPropagationFlags.call(this, event);

  var activeElement = this.field.$container.activeElement(true);
  this.preventInvokeAcceptInputOnActiveValueField = !event.isPropagationStopped() && activeElement.tagName.toLowerCase() === 'textarea';
  if (this.preventInvokeAcceptInputOnActiveValueField) {
    event.stopPropagation();
  }
};

scout.StringFieldEnterKeyStroke.prototype.handle = function(event) {
  // NOP
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.StringFieldCtrlEnterKeyStroke = function(stringField) {
  scout.StringFieldCtrlEnterKeyStroke.parent.call(this);
  this.field = stringField;
  this.which = [scout.keys.ENTER];
  this.ctrl = true;
};
scout.inherits(scout.StringFieldCtrlEnterKeyStroke, scout.KeyStroke);

scout.StringFieldCtrlEnterKeyStroke.prototype._accept = function(event) {
  var accepted = scout.StringFieldCtrlEnterKeyStroke.parent.prototype._accept.call(this, event);
  return accepted && this.field.hasAction;
};

scout.StringFieldCtrlEnterKeyStroke.prototype.handle = function(event) {
  this.field._onIconClick();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TabAreaLayout = function(tabBox) {
  scout.TabAreaLayout.parent.call(this);
  this._tabBox = tabBox;
  this._$ellipsis;
  this._overflowTabs = [];
};
scout.inherits(scout.TabAreaLayout, scout.AbstractLayout);

scout.TabAreaLayout.prototype.layout = function($container) {
  if (!this._ellipsisBounds) {
    this._createAndRenderEllipsis($container);
    this._ellipsisBounds = scout.graphics.bounds(this._$ellipsis, true, true);
  }

  this._destroyEllipsis();
  this._tabBox.rebuildTabs();

  var bounds,
    tabArea = $container[0],
    clientWidth = tabArea.clientWidth - scout.graphics.getInsets($container).horizontal(),
    scrollWidth = tabArea.scrollWidth,
    menuBar = this._tabBox.menuBar,
    $status = this._tabBox.$status,
    statusWidth = 0,
    statusPosition = this._tabBox.statusPosition;

  // If tab area contains a menubar, less space is available
  clientWidth -= scout.graphics.getSize(menuBar.$container, true).width;

  if (statusPosition === scout.FormField.STATUS_POSITION_TOP) {
    // Status on top means it is inside the tab area
    if ($status && $status.isVisible()) {
      statusWidth = $status.outerWidth(true);
    }
    if (statusWidth > 0) {
      clientWidth -= statusWidth;
      // Status is on the right of the menuBar
      menuBar.$container.cssRight(statusWidth);
    }
  }

  this._overflowTabs = [];
  if (clientWidth < scrollWidth) {

    // determine visible range (at least selected tab must be visible)
    var i, tab, numTabs,
      tabs = [], // tabs that are visible by model
      tabBounds = [], // bounds of visible tabs
      visibleTabs = [], // tabs that are visible by model and visible in the UI (= not in overflow)
      selectedTab = -1; // points to index of selected tab (in array of UI visible tabs)

    // reduce list to tab-items that are visible by model
    for (i = 0; i < this._tabBox.tabItems.length; i++) {
      tab = this._tabBox.tabItems[i];
      if (tab.visible) {
        bounds = scout.graphics.bounds(tab.$tabContainer, true, true);
        tabs.push(tab);
        tabBounds.push(bounds);
        // cannot use selectedTab property of TabBox, it points to the wrong index
        // since this layout only works with visible tabs
        if (tab._tabActive) {
          selectedTab = tabs.length - 1;
        }
      }
    }
    numTabs = tabs.length;

    if (selectedTab >= 0) {
      // if we have too few space to even display the selected tab, only render the selected tab
      visibleTabs.push(selectedTab);
      bounds = tabBounds[selectedTab];

      if (clientWidth > bounds.width) {
        // in case of overflow, place selected tab at the left-most position...
        var horizontalInsets = scout.graphics.getInsets($container).horizontal();

        var viewWidth = bounds.width,
          delta = bounds.x - horizontalInsets, // delta used to start from x=0
          overflow = false;

        // when viewWidth doesn't fit into clientWidth anymore, abort always
        // expand to the right until the last tab is reached...
        if (selectedTab < numTabs - 1) {
          for (i = selectedTab + 1; i < numTabs; i++) {
            bounds = tabBounds[i];
            viewWidth = bounds.x - delta + bounds.width + this._ellipsisBounds.width;
            if (viewWidth < clientWidth) {
              visibleTabs.push(i);
            } else {
              overflow = true;
            }
          }
        }

        // than expand to the left until the first tab is reached
        if (!overflow && selectedTab > 0) {
          for (i = selectedTab - 1; i >= 0; i--) {
            bounds = tabBounds[i];
            if (viewWidth + delta - bounds.x < clientWidth) {
              visibleTabs.push(i);
            }
          }
        }
      }

      // remove all tabs which aren't visible
      for (i = 0; i < numTabs; i++) {
        tab = tabs[i];
        if (visibleTabs.indexOf(i) === -1) {
          $.log.debug('Overflow tab=' + tab);
          this._overflowTabs.push(tab);
          tab.removeTab();
        }
      }
    }
  }

  if (this._overflowTabs.length > 0) {
    this._createAndRenderEllipsis($container);
  }
};

scout.TabAreaLayout.prototype._createAndRenderEllipsis = function($container) {
  this._$ellipsis = $container
    .appendDiv('overflow-tab-item')
    .click(this._onClickEllipsis.bind(this));
};

scout.TabAreaLayout.prototype._destroyEllipsis = function() {
  if (this._$ellipsis) {
    this._$ellipsis.remove();
    this._$ellipsis = null;
  }
};

scout.TabAreaLayout.prototype._onClickEllipsis = function(event) {
  var menu, popup,
    overflowMenus = [],
    tabBox = this._tabBox;
  this._overflowTabs.forEach(function(tabItem) {
    menu = scout.create('Menu', {
      parent: tabBox,
      text: tabItem.label,
      tabItem: tabItem,
      visible: tabItem.visible
    });
    menu.on('doAction', function(event) {
      $.log.debug('(TabAreaLayout#_onClickEllipsis) tabItem=' + tabItem);
      tabBox._syncSelectedTab(tabItem);
        popup.one('remove', function(event) {
          tabItem.session.focusManager.requestFocus(tabItem.$tabContainer);
      });
    });
    overflowMenus.push(menu);
  });

  popup = scout.create('ContextMenuPopup', {
    parent: tabBox,
    menuItems: overflowMenus,
    cloneMenuItems: false,
    location: {
      x: event.pageX,
      y: event.pageY
    }
  });
  popup.open();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
/**
 * Tab-area = where the 1-n tabs are placed (may have multiple runs = lines).
 * Tab-content = where the content of a single tab is displayed.
 */
scout.TabBox = function() {
  scout.TabBox.parent.call(this);
  this._addAdapterProperties(['tabItems', 'selectedTab']);
  this._addPreserveOnPropertyChangeProperties(['selectedTab']); // FIXME [awe] 6.1 - do this in Calendar too, for selectedComponent
  this.selectedTab;
  this._$tabArea;
  this._$tabContent;

  this._tabItemPropertyChangeHandler = function(event) {
    var numProperties = event.changedProperties.length;
    if (numProperties === 1 && event.changedProperties[0] === 'enabled') {
      // Optimization: don't invalidate layout when only the enabled state has changed (this should not affect the layout).
      return;
    }
    if (numProperties > 0) {
      scout.HtmlComponent.get(this._$tabArea).invalidateLayoutTree();
    }
  }.bind(this);
};
scout.inherits(scout.TabBox, scout.CompositeField);

/**
 * @override FormField.js
 */
scout.TabBox.prototype._init = function(model) {
  scout.TabBox.parent.prototype._init.call(this, model);
  if (this.selectedTab) {
    this.selectedTab.setTabActive(true);
  }
  this.menuBar = scout.create('MenuBar', {
    parent: this,
    menuOrder: new scout.GroupBoxMenuItemsOrder()
  });
  this._updateMenuBar(this.menus);
};

scout.TabBox.prototype._render = function($parent) {
  this.addContainer($parent, 'tab-box', new scout.TabBoxLayout(this));

  this._$tabArea = this.$container
    .appendDiv('tab-area')
    .on('keydown', this._onKeyDown.bind(this));
  this.addStatus();
  var htmlAreaComp = scout.HtmlComponent.install(this._$tabArea, this.session);
  htmlAreaComp.setLayout(new scout.TabAreaLayout(this));

  this.menuBar.render(this._$tabArea);

  this._$tabContent = this.$container.appendDiv('tab-content');
  var htmlCompContent = scout.HtmlComponent.install(this._$tabContent, this.session);
  htmlCompContent.setLayout(new scout.SingleLayout());
};

/**
 * @override FormField.js
 */
scout.TabBox.prototype._renderProperties = function() {
  scout.TabBox.parent.prototype._renderProperties.call(this);
  this._renderTabs();
  this._renderTabContent();
};

/**
 * @override FormField.js
 */
scout.TabBox.prototype._remove = function() {
  scout.TabBox.parent.prototype._remove.call(this);
  this._removeTabs();
  this._removeTabContent();
};

scout.TabBox.prototype._renderTabs = function() {
  this.tabItems.forEach(function(tabItem) {
    tabItem.renderTab(this._$tabArea);
    tabItem.on('propertyChange', this._tabItemPropertyChangeHandler);
  }, this);
};

scout.TabBox.prototype._removeTabs = function() {
  this.tabItems.forEach(function(tabItem) {
    tabItem.removeTab();
    tabItem.off('propertyChange', this._tabItemPropertyChangeHandler);
  }, this);
};

scout.TabBox.prototype._removeTabContent = function() {
  this.tabItems.forEach(function(tabItem) {
    tabItem.remove();
  }, this);
};

scout.TabBox.prototype.rebuildTabs = function() {
  // FIXME awe: (tab-box) refactor this and work with a clone in the TabBoxLayout - when we remove an existing
  // DOM element which currently has the focus - the focus is lost. An other solution would be, to render the
  // tab at the correct position but probably that's not so easy because the render impl. does always append.
  // Temporary focus fix
  var $focusedElement = $(document.activeElement),
    focusedElement = null;
  if ($focusedElement.is('.tab-item')) {
    focusedElement = $focusedElement.data('tabItem');
  }
  this.tabItems.forEach(function(tabItem) {
    if (tabItem._tabRendered) {
      tabItem.removeTab();
    }
  }, this);
  this._renderTabs();
  if (focusedElement) {
    this.session.focusManager.requestFocus(focusedElement.$tabContainer);
  }
};

scout.TabBox.prototype.selectTabById = function(tabId) {
  var tab = this.getTabItem(tabId);
  if (!tab) {
    throw new Error('Tab with ID \'' + tabId + '\' does not exist');
  }
  this.setSelectedTab(tab);
};

scout.TabBox.prototype.setSelectedTab = function(selectedTab) {
  this.setProperty('selectedTab', selectedTab);
};

scout.TabBox.prototype._syncSelectedTab = function(tab, notifyServer) {
  if (this.selectedTab === tab) {
    return;
  }
  $.log.debug('(TabBox#_selectTab) tab=' + tab);
  var oldSelectedTab = this.selectedTab;
  var selectedTab = tab;
  if (oldSelectedTab) {
    oldSelectedTab.setTabActive(false);
  }
  if (selectedTab) {
    selectedTab.setTabActive(true);
  }
  this._setProperty('selectedTab', selectedTab);

  if (this.rendered) {
    // revalidateLayoutTree layout when tab-area has changed, because overflow tabs must be re-arranged
    if (!this.selectedTab || !this.selectedTab._tabRendered) {
      scout.HtmlComponent.get(this._$tabArea).revalidateLayoutTree();
    }
    if (this.selectedTab) {
      this.selectedTab.focusTab();
    }
    if (oldSelectedTab) {
      oldSelectedTab.detach();
    }
    this._renderTabContent();
  }
};

// keyboard navigation in tab-box button area
// TODO awe: (tab-box) overflow menu should be accessible by keyboard navigation
scout.TabBox.prototype._onKeyDown = function(event) {
  var navigationKey =
    event.which === scout.keys.LEFT ||
    event.which === scout.keys.RIGHT;
  if (!navigationKey) {
    return true;
  }

  event.preventDefault();
  event.stopPropagation();

  var nextTab = this._getNextVisibleTabForKeyStroke(event.which);
  if (nextTab && nextTab._tabRendered) {
    this.setSelectedTab(nextTab);
  }
};

scout.TabBox.prototype._getNextVisibleTabForKeyStroke = function(keyStroke) {
  var nextTab,
    dir = (keyStroke === scout.keys.LEFT) ? -1 : 1,
    i = this.tabItems.indexOf(this.selectedTab) + dir;

  while (i >= 0 && i < this.tabItems.length) {
    nextTab = this.tabItems[i];
    if (nextTab.visible) {
      return nextTab;
    }
    i += dir;
  }
  return null;
};

scout.TabBox.prototype._renderTabContent = function() {
  // add new tab-content (use from cache or render)
  var selectedTab = this.selectedTab;
  if (selectedTab) {
    if (selectedTab.rendered && !selectedTab.attached) {
      selectedTab.attach();
    } else {
      // in Swing there's some complicated logic dealing with borders and labels
      // that determines whether the first group-box in a tab-box has a title or not.
      // I decided to simplify this and always set the title of the first group-box
      // to invisible.
      selectedTab.render(this._$tabContent);
    }
  }
  if (this.rendered) {
    scout.HtmlComponent.get(this._$tabContent).revalidateLayoutTree();
  }
};

scout.TabBox.prototype._syncMenus = function(menus) {
  scout.TabBox.parent.prototype._syncMenus.call(this, menus);
  if (this.menuBar) {
    // updateMenuBar is required because menuBar is not created yet when synMenus is called initially
    this._updateMenuBar(menus);
  }
};

scout.TabBox.prototype._removeMenus = function() {
  // menubar takes care about removal
};

scout.TabBox.prototype._updateMenuBar = function(menus) {
  var menuItems = scout.menus.filter(this.menus, ['TabBox.Header']);
  this.menuBar.setMenuItems(menuItems);
};

scout.TabBox.prototype._renderStatusPosition = function() {
  if (this.statusPosition === scout.FormField.STATUS_POSITION_TOP) {
    // move into title
    this.$status.appendTo(this._$tabArea);
  } else {
    this.$status.appendTo(this.$container);
  }
  this.invalidateLayoutTree();
};

/**
 * @override CompositeField.js
 */
scout.TabBox.prototype.getFields = function() {
  return this.tabItems;
};

scout.TabBox.prototype.getTabItem = function(tabId) {
  return scout.arrays.find(this.tabItems, function(tabItem) {
    return tabItem.id === tabId;
  });
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TabBoxAdapter = function() {
  scout.TabBoxAdapter.parent.call(this);
  this._addAdapterProperties(['tabItems', 'selectedTab']);
  this._addRemoteProperties(['selectedTab']);
};
scout.inherits(scout.TabBoxAdapter, scout.CompositeFieldAdapter);

/**
 * @override ModelAdapter.js
 */
scout.TabBoxAdapter.prototype.exportAdapterData = function(adapterData) {
  adapterData = scout.TabBoxAdapter.parent.prototype.exportAdapterData.call(this, adapterData);
  delete adapterData.selectedTab;
  return adapterData;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TabBoxLayout = function(tabBox) {
  scout.TabBoxLayout.parent.call(this);
  this._tabBox = tabBox;
  this._statusWidth = scout.HtmlEnvironment.fieldStatusWidth;
};
scout.inherits(scout.TabBoxLayout, scout.AbstractLayout);

scout.TabBoxLayout.prototype.layout = function($container) {
  var containerSize, tabContentSize, tabAreaMargins, innerTabAreaSize,
    htmlContainer = scout.HtmlComponent.get($container),
    htmlTabContent = scout.HtmlComponent.get(this._tabBox._$tabContent),
    htmlTabArea = scout.HtmlComponent.get(this._tabBox._$tabArea),
    tabAreaWidth = 0,
    tabAreaHeight = 0,
    tabAreaSize = new scout.Dimension(),
    $status = this._tabBox.$status,
    statusPosition = this._tabBox.statusPosition;

  containerSize = htmlContainer.getAvailableSize()
    .subtract(htmlContainer.getInsets());

  if (htmlTabArea.isVisible()) {
    tabAreaMargins = htmlTabArea.getMargins();
    tabAreaHeight = htmlTabArea.getPreferredSize().height;
    tabAreaWidth = containerSize.subtract(tabAreaMargins).width;
    if ($status && $status.isVisible()) {
      this._layoutStatus();
      if (statusPosition === scout.FormField.STATUS_POSITION_DEFAULT) {
        tabAreaWidth -= $status.outerWidth(true);
      }
    }
    innerTabAreaSize = new scout.Dimension(tabAreaWidth, tabAreaHeight);
    htmlTabArea.setSize(innerTabAreaSize);
    tabAreaSize = innerTabAreaSize.add(tabAreaMargins);
  }

  tabContentSize = containerSize.subtract(htmlTabContent.getMargins());
  tabContentSize.height -= tabAreaSize.height;
  htmlTabContent.setSize(tabContentSize);
};

scout.TabBoxLayout.prototype._layoutStatus = function() {
  var htmlContainer = this._tabBox.htmlComp,
    containerPadding = htmlContainer.getInsets({
      includeBorder: false
    }),
    top = containerPadding.top,
    right = containerPadding.right,
    $tabArea = this._tabBox._$tabArea,
    tabAreaInnerHeight = $tabArea.innerHeight(),
    $status = this._tabBox.$status,
    statusMargins = scout.graphics.getMargins($status),
    statusTop = top,
    statusPosition = this._tabBox.statusPosition,
    statusHeight = tabAreaInnerHeight - statusMargins.vertical();

  if (statusPosition === scout.FormField.STATUS_POSITION_DEFAULT) {
    statusTop += $tabArea.cssMarginTop();
  } else {
    statusHeight -= $status.cssBorderWidthY(); // status has a transparent border to align icon with text
  }

  $status.cssWidth(this._statusWidth)
    .cssTop(statusTop)
    .cssRight(right)
    .cssHeight(statusHeight)
    .cssLineHeight(statusHeight);
};

/**
 * Preferred size of the tab-box aligns every tab-item in a single line, so that each item is visible.
 */
scout.TabBoxLayout.prototype.preferredLayoutSize = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    htmlTabContent = scout.HtmlComponent.get(this._tabBox._$tabContent),
    htmlTabArea = scout.HtmlComponent.get(this._tabBox._$tabArea),
    tabAreaSize = new scout.Dimension(),
    tabContentSize = new scout.Dimension();

  if (htmlTabArea.isVisible()) {
    tabAreaSize = htmlTabArea.getPreferredSize()
      .add(htmlTabArea.getMargins());
  }

  tabContentSize = htmlTabContent.getPreferredSize()
    .add(htmlContainer.getInsets())
    .add(htmlTabContent.getMargins());

  return new scout.Dimension(
    Math.max(tabAreaSize.width, tabContentSize.width),
    tabContentSize.height + tabAreaSize.height);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TabItem = function() {
  scout.TabItem.parent.call(this);
  this.$tabContainer;
  this._tabRendered = false;
  this._tabActive = false;
  this.selectionKeystroke;
};
scout.inherits(scout.TabItem, scout.GroupBox);

scout.TabItem.prototype._init = function(model) {
  scout.TabItem.parent.prototype._init.call(this, model);
  this._syncStatusVisible(this.statusVisible);
  this._syncMenusVisible(this.menusVisible);
};

scout.TabItem.prototype._removeCssClass = function() {
  // Call super only if the group-box is rendered or is rendering
  if (this.$container) {
    scout.TabItem.parent.prototype._removeCssClass.call(this);
  }

  this.$tabContainer.removeClass(this.cssClass);
};

scout.TabItem.prototype._renderCssClass = function() {
  // Call super only if the group-box is rendered or is rendering
  if (this.$container) {
    scout.TabItem.parent.prototype._renderCssClass.call(this);
  }

  this.$tabContainer.addClass(this.cssClass);
};

scout.TabItem.prototype._createLayout = function() {
  return new scout.TabItemLayout(this);
};

/**
 * This method has nothing to do with the regular rendering of the GroupBox. It is an additional method
 * to render a single tab for this tab-item. Since tab and tab-item share the same model.
 */
scout.TabItem.prototype.renderTab = function($parent) {
  if (this._tabRendered) {
    throw new Error('Tab already rendered');
  }
  this.$tabContainer = $parent.appendDiv('tab-item')
    .data('tabItem', this)
    .on('mousedown', this._onTabMouseDown.bind(this));
  this.tabHtmlComp = scout.HtmlComponent.install(this.$tabContainer, this.session);

  this.addLabel();
  this.addStatus();
  this._renderTabActive();
  this._renderLabel();
  this._renderMarked();
  this._renderVisible();
  this._renderCssClass();
  this._renderTooltipText();
  this._renderErrorStatus();
  this._tabRendered = true;
};

scout.TabItem.prototype._onTabMouseDown = function(event) {
  if (this._preventTabActivation) {
    this._preventTabActivation = false;
    return;
  }
  this.parent.setSelectedTab(this);
  // Focus tab on mouse down, normally done when the tab get selected, but not if focus manger is deactivated.
  // -> If user explicitly clicks a tab it needs to get the focus otherwise keystrokes to switch tabs would not work.
  if (!this.session.focusManager.active) {
    this.$tabContainer.focus();
  }
};

scout.TabItem.prototype._onStatusMousedown = function(event) {
  scout.TabItem.parent.prototype._onStatusMousedown.call(this, event);
  // Prevent switching tabs when status gets clicked
  // Don't use event.preventDefault, otherwise other mouse listener (like tooltip mouse down) will not be executed as well
  this._preventTabActivation = true;
  // Prevent focusing the tab
  event.preventDefault();
};

scout.TabItem.prototype.focusTab = function() {
  if (this._tabRendered) {
    this.session.focusManager.requestFocus(this.$tabContainer);
  }
};

scout.TabItem.prototype.setTabActive = function(active) {
  var oldTabActive = this._tabActive;
  this._tabActive = active;
  if (this._tabRendered && oldTabActive !== active) {
    this._renderTabActive();
  }
};

scout.TabItem.prototype._renderTabActive = function() {
  this.$tabContainer.select(this._tabActive);
  this.$tabContainer.setTabbable(this._tabActive && !scout.device.supportsTouch());
};

/**
 * It's allowed to call removeTab() even when the tab is _not_ rendered.
 * This may be the case, when a tab is placed in the overflow-menu of the tab-area.
 * Thus it happens that some tabs are rendered and some are not.
 */
scout.TabItem.prototype.removeTab = function() {
  if (this._tabRendered) {
    this.$tabContainer.remove();
    this.$tabContainer = null;
    this._removeStatus();
    this._removeLabel();
    this._tabRendered = false;
  }
};

scout.TabItem.prototype.setMarked = function(marked) {
  if (this.marked === marked) {
    return;
  }
  this._setProperty('marked', marked);
  // Marked affects the tab item -> it needs to be rendered even if groupox is not
  if (this._tabRendered) {
    this._renderMarked();
  }
  return false;
};

scout.TabItem.prototype._renderMarked = function(marked) {
  this.$tabContainer.toggleClass('marked', this.marked);
};

/**
 * @override
 */
scout.TabItem.prototype.setVisible = function(visible) {
  if (this.visible === visible) {
    return;
  }
  this._setProperty('visible', visible);
  // Visible affects the tab item -> it needs to be rendered even if groupox is not
  if (this._tabRendered) {
    this._renderVisible();
  }
  return false;
};

/**
 * @override
 */
scout.TabItem.prototype._renderVisible = function() {
  // Call super only if the group-box is rendered or is rendering
  if (this.$container) {
    scout.TabItem.parent.prototype._renderVisible.call(this);
  }
  this.$tabContainer.setVisible(this.visible);
};

scout.TabItem.prototype.setLabel = function(label) {
  if (this.label === label) {
    return;
  }
  this._setProperty('label', label);
  // Label affects the tab item -> it needs to be rendered even if groupox is not
  if (this._tabRendered) {
    this._renderLabel();
  }
};

scout.TabItem.prototype._renderLabel = function() {
  this.$label.textOrNbsp(this.label);
};

scout.TabItem.prototype._renderLabelVisible = function() {
  // Never make the title of the group box visible -> label is rendered into tabContainer
  scout.TabItem.parent.prototype._renderLabelVisible.call(this, false);
};

scout.TabItem.prototype.addLabel = function() {
  if (this.$label) {
    return;
  }
  this.$label = this.$tabContainer.appendSpan('label');
};

scout.TabItem.prototype.addStatus = function() {
  if (this.$status) {
    return;
  }
  this.$status = this.$tabContainer
    .appendSpan('status')
    .on('mousedown', this._onStatusMousedown.bind(this))
    .cssWidth(scout.HtmlEnvironment.fieldStatusWidth);
};

scout.TabItem.prototype._syncStatusVisible = function() {
  // Always invisible to not waste space, icon will be visible if status needs to be shown
  this._setProperty('statusVisible', false);
};

/**
 * @Override
 */
scout.TabItem.prototype._renderStatusPosition = function() {
  // Skip implementation of GroupBox.js, because that would move the status to a different place in DOM!
  scout.TabItem.parent.parent.prototype._renderStatusPosition.call(this);
};

scout.TabItem.prototype._renderTooltipText = function() {
  if (this.$container) {
    scout.TabItem.parent.prototype._renderTooltipText.call(this);
  } else {
    // Normally done by renderTooltipText, but since it is not called -> call explicitly
    this._updateStatusVisible();
  }
  var hasTooltipText = scout.strings.hasText(this.tooltipText);
  this.$tabContainer.toggleClass('has-tooltip', hasTooltipText);
};

scout.TabItem.prototype._renderErrorStatus = function() {
  var hasStatus = !!this.errorStatus,
    statusClass = hasStatus ? this.errorStatus.cssClass() : '';

  if (this.$container) {
    this.$container.removeClass(scout.Status.cssClasses);
    this.$container.addClass(statusClass, hasStatus);
  }
  this.$tabContainer.removeClass(scout.Status.cssClasses);
  this.$tabContainer.addClass(statusClass, hasStatus);

  this._updateStatusVisible();
  if (hasStatus) {
    this._showStatusMessage();
  } else {
    this._hideStatusMessage();
  }
};

scout.TabItem.prototype._renderStatusVisible = function() {
  var wasVisible = this.$status.isVisible();
  scout.TabItem.parent.prototype._renderStatusVisible.call(this);
  if (this.rendered && wasVisible !== this._computeStatusVisible()) {
    // Make sure tab area gets re layouted on status visibility changes, it may necessary to show ellipsis now if status got visible
    this.tabHtmlComp.invalidateLayoutTree();
  }
};

scout.TabItem.prototype._syncMenusVisible = function() {
  // Always invisible because menus are displayed in menu bar and not with status icon
  // Actually not needed at the moment because only value fields have menus (at least at the java model).
  // But actually we should change this so that menus are possible for every form field
  // TODO CGU [6.0] remove this comment if java model supports form field menus
  this._setProperty('menusVisible', false);
};

/**
 * @override Widgets.js
 */
scout.TabItem.prototype._attach = function() {
  this.$parent.append(this.$container);
  this.session.detachHelper.afterAttach(this.$container);
  scout.TabItem.parent.prototype._attach.call(this);
};

/**
 * @override Widgets.js
 */
scout.TabItem.prototype._detach = function() {
  this.session.detachHelper.beforeDetach(this.$container, {
    storeFocus: false
  });
  this.$container.detach();
  scout.TabItem.parent.prototype._detach.call(this);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TabItemAdapter = function() {
  scout.TabItemAdapter.parent.call(this);
};
scout.inherits(scout.TabItemAdapter, scout.GroupBoxAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TabItemLayout = function(tabItem) {
  scout.TabItemLayout.parent.call(this, tabItem);
};
scout.inherits(scout.TabItemLayout, scout.GroupBoxLayout);

scout.TabItemLayout.prototype._layoutStatus = function() {
  // NOP: $status width is set in TabItem.addStatus()
};

scout.TabItemLayout.prototype._menuBarSize = function(htmlMenuBar, containerSize, statusWidth) {
  var menuBarSize = scout.MenuBarLayout.size(htmlMenuBar, containerSize);
  var tabBox = this._groupBox.parent;
  menuBarSize.width = tabBox._$tabArea.outerWidth();
  return menuBarSize;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableField = function() {
  scout.TableField.parent.call(this);
  this._addAdapterProperties(['table']);

  this._tableChangedHandler;
  this._deletedRows = [];
  this._insertedRows = [];
  this._updatedRows = [];
  this._checkedRows = [];
};
scout.inherits(scout.TableField, scout.FormField);

scout.TableField.TABLE_CHANGE_EVENTS = 'rowsInserted rowsDeleted allRowsDeleted rowsUpdated rowsChecked';

scout.TableField.prototype._init = function(model) {
  scout.TableField.parent.prototype._init.call(this, model);

  this._delegatePropertyChange('enabled');
  this._delegatePropertyChange('disabledStyle');

  this._tableChangedHandler = this._onTableChanged.bind(this);

  if (this.table) {
    this.table.on(scout.TableField.TABLE_CHANGE_EVENTS, this._tableChangedHandler);
  }
};

scout.TableField.prototype._delegatePropertyChange = function(propertyName) {
  this.on('propertyChange', function(event) {
    if (event.newProperties.hasOwnProperty(propertyName)) {
      this.table.setProperty(propertyName, event.newProperties[propertyName]);
    }
  }.bind(this));
};

scout.TableField.prototype._render = function($parent) {
  this.addContainer($parent, 'table-field');
  this.addLabel();
  this.addMandatoryIndicator();
  this.addStatus();
  this._renderTable();
};

scout.TableField.prototype._syncTable = function(table) {
  if (this.table) {
    this.table.off(scout.TableField.TABLE_CHANGE_EVENTS, this._tableChangedHandler);
  }
  this._setProperty('table', table);
  if (table) {
    table.on(scout.TableField.TABLE_CHANGE_EVENTS, this._tableChangedHandler);
  }
};

scout.TableField.prototype.setTable = function(table) {
  this.setProperty('table', table);
};

scout.TableField.prototype._renderTable = function() {
  if (this.table) {
    this.table.render(this.$container);
    this.addField(this.table.$container);
  }
};

scout.TableField.prototype._removeTable = function() {
  if (this.table) {
    this.table.remove();
  }
  this._removeField();
};

scout.TableField.prototype.computeRequiresSave = function() {
  return this._deletedRows.length > 0 ||
      this._insertedRows.length > 0 ||
      this._updatedRows.length > 0 ||
      this._checkedRows.length > 0;
};

scout.TableField.prototype._onTableChanged = function(event) {
  if (scout.isOneOf(event.type, 'rowsDeleted', 'allRowsDeleted')) {
    scout.arrays.pushAll(this._deletedRows, event.rows);
    this._updateInsertedRows();
    return;
  }
  if (event.type === 'rowsInserted') {
    scout.arrays.pushAll(this._insertedRows, event.rows);
    return;
  }
  if (event.type === 'rowsUpdated') {
    scout.arrays.pushAll(this._updatedRows, event.rows);
    return;
  }
  if (event.type === 'rowsChecked') {
    this._toggleCheckedRows(event.rows);
  }
};

/**
 * If a row is contained in both arrays (_deletedRows, _insertedRows) an inserted row has been
 * deleted again. In that case we can remove that row from both arrays.
 */
scout.TableField.prototype._updateInsertedRows = function () {
  var insertedAndDeletedRows = [];
  this._deletedRows.forEach(function(deletedRow) {
    if (this._insertedRows.indexOf(deletedRow) !== -1) {
      insertedAndDeletedRows.push(deletedRow);
    }
  }, this);

  insertedAndDeletedRows.forEach(function(row) {
    scout.arrays.remove(this._deletedRows, row);
    scout.arrays.remove(this._insertedRows, row);
  }, this);
};

/**
 * If a row already exists in the _checkedRows array, remove it (row was checked/unchecked again, which
 * means it is no longer changed). Add it to the array otherwise.
 */
scout.TableField.prototype._toggleCheckedRows = function (rows) {
  rows.forEach(function(row) {
    var removed = scout.arrays.remove(this._checkedRows, row);
    if (!removed) {
      this._checkedRows.push(row);
    }
  }, this);
};

scout.TableField.prototype.markAsSaved = function() {
  scout.TableField.parent.prototype.markAsSaved.call(this);
  this._deletedRows = [];
  this._insertedRows = [];
  this._updatedRows = [];
  this._checkedRows = [];
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TableFieldAdapter = function() {
  scout.TableFieldAdapter.parent.call(this);
  this._addAdapterProperties(['table']);
};
scout.inherits(scout.TableFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeBox = function() {
  scout.TreeBox.parent.call(this);
  this._addAdapterProperties(['tree', 'filterBox']);
};
scout.inherits(scout.TreeBox, scout.ValueField);

scout.TreeBox.prototype._init = function(model) {
  scout.TreeBox.parent.prototype._init.call(this, model);
  if (this.filterBox) {
    this.filterBox.enabledComputed = true; // filter is always enabled
    this.filterBox.recomputeEnabled(true);
  }
};

scout.TreeBox.prototype._render = function($parent) {
  this.addContainer($parent, 'tree-box');
  this.addLabel();
  this.addMandatoryIndicator();
  this.addStatus();

  this.addFieldContainer($parent.makeDiv());
  var htmlComp = scout.HtmlComponent.install(this.$fieldContainer, this.session);
  htmlComp.setLayout(new scout.TreeBoxLayout(this, this.tree, this.filterBox));

  if (this.tree) {
    this._renderTree();
  }
  if (this.filterBox) {
    // TODO [5.2] bsh: Tree | Only render when filter active
    this._renderFilterBox();
    this.tree.htmlComp.pixelBasedSizing = true;
  }
};

scout.TreeBox.prototype._renderTree = function($fieldContainer) {
  this.tree.render(this.$fieldContainer);
  this.addField(this.tree.$container);
};

scout.TreeBox.prototype._renderFilterBox = function($fieldContainer) {
  this.filterBox.render(this.$fieldContainer);
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeBoxAdapter = function() {
  scout.TreeBoxAdapter.parent.call(this);
  this._addAdapterProperties(['tree', 'filterBox']);
};
scout.inherits(scout.TreeBoxAdapter, scout.ValueFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeBoxLayout = function(treeBox, tree, filterBox) {
  scout.TreeBoxLayout.parent.call(this);
  this.tree = tree;
  this.filterBox = filterBox;
  this.treeBox = treeBox;
};
scout.inherits(scout.TreeBoxLayout, scout.AbstractLayout);

scout.TreeBoxLayout.prototype.layout = function($container) {
  var htmlContainer = scout.HtmlComponent.get($container),
    size = htmlContainer.getSize(),
    height = size.height,
    filterBoxHeight;

  if (this.filterBox && this.filterBox.rendered && this.filterBox.$container.isVisible()) {
    filterBoxHeight = scout.HtmlComponent.get(this.filterBox.$container).getPreferredSize().height;
    height -= filterBoxHeight;
  }

  height = Math.max(height, 20);
  var htmlTree = scout.HtmlComponent.get(this.tree.$container);
  htmlTree.setSize(new scout.Dimension(size.width, height));

  if (this.filterBox && this.filterBox.rendered && this.filterBox.$container.isVisible()) {
    var htmlFilterBox = scout.HtmlComponent.get(this.filterBox.$container);
    htmlFilterBox.setSize(new scout.Dimension(size.width, filterBoxHeight));
  }
};

scout.TreeBoxLayout.prototype.preferredLayoutSize = function($container) {
  var prefSizeTree, prefSizeFilterBox, treeContainer, filterContainer,
    width = 0,
    htmlContainer = scout.HtmlComponent.get($container),
    height = scout.HtmlEnvironment.formRowHeight,
    treeBox = this.treeBox;
  if (treeBox.$label && treeBox.labelVisible) {
    width += scout.HtmlEnvironment.fieldLabelWidth;
  }
  if (treeBox.$mandatory) {
    width += treeBox.$mandatory.outerWidth(true);
  }
  if (treeBox.$status && treeBox.statusVisible) {
    width += treeBox.$status.outerWidth(true);
  }

  // getSize of tree and size of filterBox
  treeContainer = scout.HtmlComponent.optGet(this.tree.$container);
  if (treeContainer) {
    prefSizeTree = treeContainer.getPreferredSize()
      .add(htmlContainer.getInsets())
      .add(treeContainer.getMargins());
  } else {
    prefSizeTree = this.naturalSize(treeBox);
  }

  filterContainer = scout.HtmlComponent.optGet(this.filterBox.$container);
  if (filterContainer) {
    prefSizeFilterBox = filterContainer.getPreferredSize()
      .add(htmlContainer.getInsets())
      .add(filterContainer.getMargins());
  } else {
    prefSizeTree = this.naturalSize(treeBox);
  }

  width += Math.max(prefSizeTree.width, prefSizeFilterBox.width);
  height = Math.max(height, prefSizeTree.height + prefSizeFilterBox.height);

  return new scout.Dimension(width, height);

};

scout.TreeBoxLayout.prototype.naturalSize = function(formField) {
  return new scout.Dimension(formField.$fieldContainer.width(), formField.$fieldContainer.height());
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeField = function() {
  scout.TreeField.parent.call(this);
  this._addAdapterProperties(['tree']);
};
scout.inherits(scout.TreeField, scout.FormField);

scout.TreeField.prototype._render = function($parent) {
  this.addContainer($parent, 'tree-field');
  this.addLabel();
  this.addMandatoryIndicator();
  this.addStatus();
  if (this.tree) {
    this._renderTree();
  }
};

/**
 * Will also be called by model adapter on property change event
 */
scout.TreeField.prototype._renderTree = function() {
  this.tree.render(this.$container);
  this.addField(this.tree.$container);
};

scout.TreeField.prototype._removeTree = function() {
  this.tree.remove();
  this._removeField();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.TreeFieldAdapter = function() {
  scout.TreeFieldAdapter.parent.call(this);
  this._addAdapterProperties(['tree']);
};
scout.inherits(scout.TreeFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.WizardProgressField = function() {
  scout.WizardProgressField.parent.call(this);

  this.steps = [];

  // Used to determine direction of transition ("going backward" or "going forward")
  this.previousActiveStepIndex;

  // Helper map to find a step by step index. The step index does not necessarily correspond to the
  // array index, because invisible model steps can produce "holes" in the sequence of indices.
  this.stepsMap = {};
};
scout.inherits(scout.WizardProgressField, scout.FormField);

scout.WizardProgressField.prototype._init = function(model) {
  scout.WizardProgressField.parent.prototype._init.call(this, model);
  this._updateStepsMap();
};

scout.WizardProgressField.prototype._render = function($parent) {
  this.addContainer($parent, 'wizard-progress-field', new scout.WizardProgressFieldLayout(this));
  this.addField($parent.makeDiv('wizard-steps'));
  this.addStatus();
  this.addLabel();

  this.$wizardStepsBody = this.$field.appendDiv('wizard-steps-body');

  scout.scrollbars.install(this.$field, {
    parent: this,
    axis: 'x'
  });

  // If this field is the first field in a form's main box, mark the form as "wizard-container-form"
  if (this.parent instanceof scout.GroupBox && this.parent.controls[0] === this && this.parent.parent instanceof scout.Form) {
    var form = this.parent.parent;
    form.$container.addClass('wizard-container-form');
  }
};

scout.WizardProgressField.prototype._renderProperties = function() {
  scout.WizardProgressField.parent.prototype._renderProperties.call(this);
  this._renderSteps();
  this._renderActiveStepIndex();
};

scout.WizardProgressField.prototype._syncSteps = function(steps) {
  this._setProperty('steps', steps);
  this._updateStepsMap();
};

scout.WizardProgressField.prototype._renderSteps = function() {
  this.$wizardStepsBody.empty();

  this.steps.forEach(function(step, index) {
    // Step
    var $step = this.$wizardStepsBody
      .appendDiv('wizard-step')
      .addClass(step.cssClass)
      .data('wizard-step', step);
    step.$step = $step;
    if (this.enabledComputed && step.enabled && step.actionEnabled) {
      $step.addClass('action-enabled');
      $step.on('click', this._onStepClick.bind(this));
    } else if (!this.enabledComputed || !step.enabled) {
      $step.addClass('disabled');
    }
    if (scout.strings.hasText(step.tooltipText)) {
      scout.tooltips.install($step, {
        parent: this,
        text: step.tooltipText,
        tooltipPosition: 'bottom'
      });
    }
    this._updateStepClasses(step);

    // Inspector info
    if (this.session.inspector) {
      scout.inspector.applyInfo(step, $step);
      $step.attr('data-step-index', step.index);
    }

    // Content
    var $content = $step.appendDiv('wizard-step-content');
    // Icon
    if (step.iconId) {
      var $icon = $content.appendDiv('wizard-step-content-icon');
      $icon.icon(step.iconId);
    }
    // Text
    var $text = $content.appendDiv('wizard-step-content-text');
    $text.appendDiv('wizard-step-title').textOrNbsp(step.title);
    if (step.subTitle) {
      $text.appendDiv('wizard-step-sub-title').textOrNbsp(step.subTitle);
    }

    // Separator
    if (index < this.steps.length - 1) {
      $step.appendDiv('wizard-step-separator');
    }
  }.bind(this));

  this.invalidateLayoutTree(false);
};

scout.WizardProgressField.prototype._syncActiveStepIndex = function(activeStepIndex) {
  this.previousActiveStepIndex = this.activeStepIndex;
  // Ensure this.activeStepIndex always has a value. If the server has no active step set (may
  // happen during transition between steps), we use -1 as dummy value
  this._setProperty('activeStepIndex', scout.nvl(activeStepIndex, -1));
};

scout.WizardProgressField.prototype._renderActiveStepIndex = function() {
  this.steps.forEach(function(step) {
    this._updateStepClasses(step);
  }.bind(this));

  // update background color for this.$wizardStepsBody, use same as for last step (otherwise there might be white space after last step)
  if (this.steps.length > 0) {
    this.$wizardStepsBody.css('background-color', this.steps[this.steps.length - 1].$step.css('background-color'));
  }

  this.invalidateLayoutTree(false);
};

scout.WizardProgressField.prototype._updateStepClasses = function(step) {
  var $step = step.$step;
  $step.removeClass('active before-active after-active left-of-active right-of-active first last');

  // Important: those indices correspond to the UI's data structures (this.steps) and are not necessarily
  // consistent with the server indices (because the server does not send invisible steps).
  var stepIndex = this.steps.indexOf(step);
  var activeStepIndex = this.steps.indexOf(this.stepsMap[this.activeStepIndex]);

  if (stepIndex >= 0 && activeStepIndex >= 0) {
    // Active
    if (stepIndex < activeStepIndex) {
      $step.addClass('before-active');
      if (stepIndex === activeStepIndex - 1) {
        $step.addClass('left-of-active');
      }
    } else if (stepIndex > activeStepIndex) {
      $step.addClass('after-active');
      if (stepIndex === activeStepIndex + 1) {
        $step.addClass('right-of-active');
      }
    } else {
      $step.addClass('active');
    }
    // First / last
    if (stepIndex === 0) {
      $step.addClass('first');
    }
    if (stepIndex === this.steps.length - 1) {
      $step.addClass('last');
    }
  }
};

scout.WizardProgressField.prototype._stepIndex = function($step) {
  if ($step) {
    var step = $step.data('wizard-step');
    if (step) {
      return step.index;
    }
  }
  return -1;
};

scout.WizardProgressField.prototype._updateStepsMap = function() {
  this.stepsMap = {};
  this.steps.forEach(function(step) {
    this.stepsMap[step.index] = step;
  }.bind(this));
};

scout.WizardProgressField.prototype._resolveStep = function(stepIndex) {
  // Because "step index" does not necessarily correspond to the array indices
  // (invisible model steps produce "holes"), we have to loop over the array.
  for (var i = 0; i < this.steps.length; i++) {
    var step = this.steps[i];
    if (step.index === stepIndex) {
      return step;
    }
  }
  return null;
};

scout.WizardProgressField.prototype._onStepClick = function(event) {
  var $step = $(event.currentTarget); // currentTarget instead of target to support event bubbling from inner divs
  var targetStepIndex = this._stepIndex($step);
  if (targetStepIndex >= 0 && targetStepIndex !== this.activeStepIndex) {
    this.trigger('stepAction', {
      stepIndex: targetStepIndex
    });
  }
};

scout.WizardProgressField.prototype.scrollToActiveStep = function() {
  var currentStep = this.stepsMap[this.activeStepIndex];
  if (currentStep) {
    var $currentStep = currentStep.$step;
    var scrollLeft = this.$field.scrollLeft();
    var currentStepLeft = $currentStep.position().left;
    var currentStepWidth = $currentStep.width();
    var fieldWidth = this.$field.width();

    // If going forward, try to scroll the steps such that the center of active step is not after 75% of the available space.
    // If going backward, try to scroll the steps such that the center of the active step is not before 25% of the available space.
    var goingBack = (this.previousActiveStepIndex > this.activeStepIndex);
    var p1 = scrollLeft + Math.floor(fieldWidth * (goingBack ? 0.25 : 0.75));
    var p2 = currentStepLeft + Math.floor(currentStepWidth / 2);
    if ((goingBack && p2 < p1) || (!goingBack && p2 > p1)) {
      scout.scrollbars.scrollLeft(this.$field, scrollLeft + (p2 - p1));
    }
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.WizardProgressFieldAdapter = function() {
  scout.WizardProgressFieldAdapter.parent.call(this);
};
scout.inherits(scout.WizardProgressFieldAdapter, scout.FormFieldAdapter);

scout.WizardProgressFieldAdapter.prototype._onWidgetStepAction = function(event) {
  this._send('doStepAction', {
    stepIndex: event.stepIndex
  });
};

scout.WizardProgressFieldAdapter.prototype._onWidgetEvent = function(event) {
  if (event.type === 'stepAction') {
    this._onWidgetStepAction(event);
  } else {
    scout.WizardProgressFieldAdapter.parent.prototype._onWidgetEvent.call(this, event);
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.WizardProgressFieldLayout = function(formField) {
  scout.WizardProgressFieldLayout.parent.call(this, formField);
};
scout.inherits(scout.WizardProgressFieldLayout, scout.FormFieldLayout);

scout.WizardProgressFieldLayout.prototype.layout = function($container) {
  scout.WizardProgressFieldLayout.parent.prototype.layout.call(this, $container);

  // Remember old scroll position, because setting the body width might change it
  var oldScrollLeft = this.formField.$field.scrollLeft();

  // Explicitly set width of body to scrollWidth because container is scrollable. Otherwise,
  // the body would have the wrong size because it has "overflow: hidden" set.
  var $body = this.formField.$wizardStepsBody;
  $body.width('auto'); // reset previously set width to ensure 'scrollWidth' returns the preferred size
  var bodyWidth = $body[0].scrollWidth;
  $body.width(bodyWidth);

  // Ensure scrolling position did not change because of the width change (prevents flickering effect)
  this.formField.$field.scrollLeft(oldScrollLeft);
  // But also ensure the current step is visible
  this.formField.scrollToActiveStep();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.WrappedFormField = function() {
  scout.WrappedFormField.parent.call(this);
  this._addAdapterProperties(['innerForm']);

  this.initialFocusEnabled = false;
};
scout.inherits(scout.WrappedFormField, scout.FormField);

scout.WrappedFormField.prototype._render = function($parent) {
  this.addContainer($parent, 'wrapped-form-field');
  this.addLabel();
  this.addStatus();
};

scout.WrappedFormField.prototype._renderProperties = function() {
  scout.WrappedFormField.parent.prototype._renderProperties.call(this);
  this._renderInnerForm();
};

/**
 * Will also be called by model adapter on property change event
 */
scout.WrappedFormField.prototype._renderInnerForm = function() {
  if (!this.innerForm) {
    return;
  }

  this.innerForm.displayHint = scout.Form.DisplayHint.VIEW; // by definition, an inner form is a view.
  this.innerForm.modal = false; // by definition, an inner form is not modal.
  this.innerForm.renderInitialFocusEnabled = this.initialFocusEnabled; // do not render initial focus of form if disabled.

  this.innerForm.render(this.$container);

  this.addField(this.innerForm.$container);
  this.innerForm.invalidateLayoutTree();

  // required because active element is lost when 'addField' is called.
  this._renderInitialFocusEnabled();
};

scout.WrappedFormField.prototype._renderInitialFocusEnabled = function() {
  if (this.innerForm && this.initialFocusEnabled) {
    this.innerForm.renderInitialFocus();
  }
};

scout.WrappedFormField.prototype._removeInnerForm = function() {
  if (this.innerForm) {
    this.innerForm.remove();
  }
  this._removeField();
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.WrappedFormFieldAdapter = function() {
  scout.WrappedFormFieldAdapter.parent.call(this);
  this._addAdapterProperties(['innerForm']);
};
scout.inherits(scout.WrappedFormFieldAdapter, scout.FormFieldAdapter);

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.login = {

  /**
   * opts:
   * - authUrl: URL to be used for the authentication. Default is 'auth'
   * - userDataKey: name of the user parameter in the data object sent with the authentication request. Default is 'user'.
   * - passwordDataKey: name of the password parameter in the data object sent with the authentication request. Default is 'password'.
   * - redirectUrl: URL to redirect to after a successful login. If not specified the prepareRedirectUrl function is used to compute the redirectUrl.
   * - prepareRedirectUrl: function that is called on the redirectUrl before opening it. Default is scout.LoginBox.prepareRedirectUrl.
   * - logoUrl: default points to 'res/logo.png',
   * - messageKey: if set a message is displayed above the user field. Default is undefined.
   * - texts: texts to be used in the login box. Default texts are in English.
   */
  init: function(opts) {
    var deferreds = this._bootstrap();
    $.when.apply($, deferreds)
      .done(this._init.bind(this, opts));
  },

  /**
   * Executes the default bootstrap functions and returns an array of deferred objects.<p>
   * The actual startup begins only when every of these deferred objects are completed.
   * This gives the possibility to dynamically load additional scripts or files which are mandatory for a successful startup.
   * The individual bootstrap functions may return null or undefined, a single deferred or multiple deferreds as an array.
   */
  _bootstrap : function() {
    var deferredValues = [
      scout.logging.bootstrap()
    ];

    var deferreds = [];
    deferredValues.forEach(function(value) {
      if (Array.isArray(value)) {
        deferreds.concat(value);
      } else if (value) {
        deferreds.push(value);
      }
    });
    return deferreds;
  },

  /**
   * Initializes login box
   */
  _init : function(options) {
    options = options || {};
    options.texts = $.extend({}, scout.texts.readFromDOM(), options.texts);

    scout.prepareDOM();
    scout.objectFactory.init();

    var loginBox = scout.create('LoginBox', options);
    loginBox.render($('body'));
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.LoginBox = function() {
  scout.LoginBox.parent.call(this);

  this.ajaxOptions = {
    type: 'POST'
  };
  this.authUrl = 'auth';
  this.onPostDoneFunc = this.redirect.bind(this);
  this.redirectUrl;
  this.logoUrl = 'res/logo.png';
  this.userDataKey = 'user';
  this.passwordDataKey = 'password';
  this.additionalData = {};
  this.prepareRedirectUrlFunc = scout.LoginBox.prepareRedirectUrl;
  this.messageKey;
  this.texts = {
    'ui.Login': 'Login',
    'ui.LoginFailed': 'Login failed',
    'ui.User': 'Username',
    'ui.Password': 'Password'
  };
};
scout.inherits(scout.LoginBox, scout.Box);

scout.LoginBox.prototype.init = function(options) {
  options = options || {};
  options.texts = new scout.TextMap($.extend(this.texts, options.texts));
  options.ajaxOptions = $.extend(this.ajaxOptions, options.ajaxOptions);
  $.extend(this, options);
};

scout.LoginBox.prototype.render = function($parent) {
  scout.LoginBox.parent.prototype.render.call(this, $parent);

  this.$container.addClass('login-box');
  this.$content.addClass('login-box-content ');
  this.$form = $('<form>')
    .attr('action', this.authUrl)
    .attr('method', 'post')
    .submit(this._onLoginFormSubmit.bind(this))
    .appendTo(this.$content);
  if (this.messageKey) {
    this.$message = $('<div>')
      .attr('id', 'message-box')
      .text(this.texts.get(this.messageKey))
      .appendTo(this.$form);
  }
  this.$user = $('<input>')
    .attr('type', 'text')
    .attr('autocapitalize', 'off')
    .attr('autocorrect', 'off')
    .placeholder(this.texts.get('ui.User'))
    .appendTo(this.$form);
  this.$password = $('<input>')
    .attr('type', 'password')
    .placeholder(this.texts.get('ui.Password'))
    .appendTo(this.$form);
  this.$button = $('<button>')
    .attr('type', 'submit')
    .addClass('login-button button default')
    .text(this.texts.get('ui.Login'))
    .appendTo(this.$form);

  this.$user.focus();
};

scout.LoginBox.prototype._resetButtonText = function() {
  this.$button
    .text(this.texts.get('ui.Login'))
    .removeClass('login-error');
};

scout.LoginBox.prototype.data = function() {
  var data = {};
  data[this.userDataKey] = this.$user.val();
  data[this.passwordDataKey] = this.$password.val();
  $.extend(data, this.additionalData);
  return data;
};

scout.LoginBox.prototype._onLoginFormSubmit = function(event) {
  // Prevent default submit action
  event.preventDefault();

  var url = this.$form.attr('action');
  var data = this.data();

  this.$button
    .removeClass('login-error')
    .setEnabled(false);
  this.$user.off('input.resetLoginError');
  this.$password.off('input.resetLoginError');
  if (scout.device.supportsCssAnimation()) {
    this.$button
      .html('')
      .append($('<div>').addClass('login-button-loading'));
  }

  var options = $.extend({}, this.ajaxOptions, {
    url: url,
    data: data
  });
  $.ajax(options)
    .done(this._onPostDone.bind(this))
    .fail(this._onPostFail.bind(this));
};

scout.LoginBox.prototype.redirect = function(data) {
  // Calculate target URL
  var url = this.redirectUrl;
  if (!url) {
    url = (window.location.href || '').trim();
    // Remove login and everything after it from the URL
    url = this.prepareRedirectUrlFunc(url);
  }

  // Go to target URL
  if (url) {
    window.location.href = url;
  } else {
    window.location.reload();
  }
};

scout.LoginBox.prototype._onPostDone = function(data) {
  this.remove();
  this.onPostDoneFunc.call(this, data);
};

scout.LoginBox.prototype._onPostFail = function(jqXHR, textStatus, errorThrown) {
  // execute delayed to make sure loading animation is visible, otherwise (if it is very fast), it flickers
  setTimeout(this._onPostFailImpl.bind(this, jqXHR, textStatus, errorThrown), 300);
};

scout.LoginBox.prototype._onPostFailImpl = function(jqXHR, textStatus, errorThrown) {
  this.$button
    .setEnabled(true)
    .html('')
    .text(this.texts.get('ui.LoginFailed'))
    .addClass('login-error');
  this.$user
    .val('')
    .focus()
    .one('input.resetLoginError', this._resetButtonText.bind(this));
  this.$password
    .val('')
    .one('input.resetLoginError', this._resetButtonText.bind(this));
};

// ----- Helper functions -----

scout.LoginBox.prepareRedirectUrl = function(url) {
  var urlParts = /^([^?#]*)(\?[^#]*)?(#.*)?$/.exec(url || ''); // $1 = baseUrl, $2 = queryPart, $3 = hashPart
  var filteredBaseUrl = urlParts[1]
    .replace(/login.html$/, '')
    .replace(/login$/, '')
    .replace(/logout$/, '');
  return filteredBaseUrl + (urlParts[2] ? urlParts[2] : '') + (urlParts[3] ? urlParts[3] : '');
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.logout = {

  /**
   * opts:
   * - loginUrl: URL to redirect after login again button click
   * - logoUrl: default points to 'res/logo.png'
   */
  init: function(opts) {
    var deferreds = this._bootstrap();
    $.when.apply($, deferreds)
      .done(this._init.bind(this, opts));
  },

  /**
   * Executes the default bootstrap functions and returns an array of deferred objects.<p>
   * The actual startup begins only when every of these deferred objects are completed.
   * This gives the possibility to dynamically load additional scripts or files which are mandatory for a successful startup.
   * The individual bootstrap functions may return null or undefined, a single deferred or multiple deferreds as an array.
   */
  _bootstrap : function() {
    var deferredValues = [
      scout.logging.bootstrap()
    ];

    var deferreds = [];
    deferredValues.forEach(function(value) {
      if (Array.isArray(value)) {
        deferreds.concat(value);
      } else if (value) {
        deferreds.push(value);
      }
    });
    return deferreds;
  },

  /**
   * Initializes login box
   */
  _init : function(options) {
    options = options || {};
    options.texts = $.extend({}, scout.texts.readFromDOM(), options.texts);

    scout.prepareDOM();
    scout.objectFactory.init();

    var logoutBox = scout.create('LogoutBox', options);
    logoutBox.render($('body'));
  }
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.LogoutBox = function() {
  scout.LogoutBox.parent.call(this);
};
scout.inherits(scout.LogoutBox, scout.Box);

scout.LogoutBox.prototype.init = function(opts) {
  var defaultOpts = {
    loginUrl: sessionStorage.getItem('scout:loginUrl') || './',
    logoUrl: 'res/logo.png'
  };
  this.options = $.extend({}, defaultOpts, opts);
  var defaultTexts = {
    'ui.LogoutSuccessful': 'Good bye!',
    'ui.LoginAgain': 'Login again'
  };
  this.options.texts = $.extend({}, defaultTexts, opts.texts);

  this.texts = new scout.TextMap(this.options.texts);
  this.loginUrl = this.options.loginUrl;
  this.logoUrl = this.options.logoUrl;
};

scout.LogoutBox.prototype.render = function($parent) {
  scout.LogoutBox.parent.prototype.render.call(this, $parent);

  this.$content.addClass('small centered')
    .appendDiv().html(scout.strings.nl2br(this.texts.get('ui.LogoutSuccessful')));

  this.$buttonBar = $('<div>')
    .addClass('button-bar')
    .appendTo(this.$content);
  $('<button>')
    .addClass('button')
    .text(this.texts.get('ui.LoginAgain'))
    .on('click', this._loginAgain.bind(this))
    .appendTo(this.$buttonBar);
};

scout.LogoutBox.prototype._loginAgain = function() {
  window.location = this.loginUrl;
};

/*******************************************************************************
 * Copyright (c) 2014-2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
scout.DesktopFormController = function(displayParent, session) {
  scout.DesktopFormController.parent.call(this, displayParent, session);
  this.desktop = displayParent;
  this._popupWindows = [];
  this._documentPopupWindowReadyHandler = this._onDocumentPopupWindowReady.bind(this);

  // must use a document-event, since when popup-window is reloading it does
  // only know the opener of its own window (and nothing about Scout).
  $(document).on('popupWindowReady', this._documentPopupWindowReadyHandler);
};
scout.inherits(scout.DesktopFormController, scout.FormController);

scout.DesktopFormController.instanceCounter = 0;

scout.DesktopFormController.prototype.render = function() {
  scout.DesktopFormController.parent.prototype.render.call(this);
  // find active form and set selected.
  var selectable;
  if (this.desktop.activeForm) {
    var form = this.desktop.activeForm;
    if (form.isDialog()) {
      // find ui selectable part
      selectable = this._findActiveSelectablePart(form);
    } else if (form.isView()) {
      selectable = form;
    }
  }
  if (!selectable) {
    this.desktop.bringOutlineToFront();
  } else {
    this.desktop.bench.activateView(selectable);
  }
  // ensure in all view stacks the last view is activated
  if (this.desktop.bench) {
    this.desktop.bench.postRender();
  }
};

/**
 * Goes up in display hierarchy to find the form to select on desktop. null if outline is selected.
 */
scout.DesktopFormController.prototype._findActiveSelectablePart = function(form) {
  if (form.parent.isView && form.parent.isDialog) {
    if (form.parent.isView()) {
      return form.parent;
    } else if (form.parent.isDialog()) {
      return this._findActiveSelectablePart(form.parent);
    }
  }
  return null;
};

/**
 * @override FormController.js
 */
scout.DesktopFormController.prototype._renderPopupWindow = function(form) {
  var windowSpecs,
    resizeToPrefSize; // flag used to resize browser-window later (see PopupWindow.js)

  var bounds = (form.cacheBounds ? scout.PopupWindow.readWindowBounds(form) : null);
  if (bounds) {
    windowSpecs = 'left=' + bounds.x + ',top=' + bounds.y + ',width=' + bounds.width + ',height=' + bounds.height;
    resizeToPrefSize = false;
  } else {
    var $mainDocument = $(document),
      documentSize = new scout.Dimension($mainDocument.width(), $mainDocument.height());
    windowSpecs = 'left=0,top=0,width=' + documentSize.width + ',height=' + documentSize.height;
    resizeToPrefSize = true;
  }

  // Note: Chrome does not allow to position a popup outside of the primary monitor (Firefox does)
  // So the popup will always appear on the primary monitor even if we have stored the correct
  // bounds to position the popup on the secondary monitor!
  // See: https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Position_and_size_features
  windowSpecs += ',location=no,toolbar=no,menubar=no,resizable=yes';

  var popupBlockerHandler = new scout.PopupBlockerHandler(this.session),
    // form ID in URL is required for 'reload window' support
    url = 'popup-window.html?formId=' + form.id,
    // we must use '_blank' as window-name so browser-windows are never reused
    newWindow = popupBlockerHandler.openWindow(url, '_blank', windowSpecs);

  if (newWindow) {
    this._addPopupWindow(newWindow, form, resizeToPrefSize);
  } else {
    $.log.warn('Popup-blocker detected! Show link to open window manually');
    popupBlockerHandler.showNotification(function() {
      newWindow = window.open(url, '_blank', windowSpecs);
      this._addPopupWindow(newWindow, form, resizeToPrefSize);
    }.bind(this));
  }
};

scout.DesktopFormController.prototype._addPopupWindow = function(newWindow, form, resizeToPrefSize) {
  var popupWindow = new scout.PopupWindow(newWindow, form);
  popupWindow.resizeToPrefSize = resizeToPrefSize;
  popupWindow.events.on('popupWindowUnload', this._onPopupWindowUnload.bind(this));
  this._popupWindows.push(popupWindow);
  $.log.debug('Opened new popup window for form ID ' + form.id);
};

scout.DesktopFormController.prototype._onDocumentPopupWindowReady = function(event, data) {
  $.log.debug('(FormController#_onDocumentPopupWindowReady) data=' + data);
  var popupWindow;
  if (data.formId) {
    // reload (existing popup window)
    var i, formId = data.formId;
    $.log.debug('Popup window for form ID ' + formId + ' has been reloaded');
    for (i = 0; i < this._popupWindows.length; i++) {
      popupWindow = this._popupWindows[i];
      if (popupWindow.form.id === formId) {
        break;
      }
    }
    if (!popupWindow) {
      throw new Error('Couldn\'t find popupWindow reference while popup window was reloaded');
    }
  } else if (data.popupWindow) {
    // open new child window
    popupWindow = data.popupWindow;
  } else {
    // error assertion
    throw new Error('Neither property \'formId\' nor \'popupWindow\' exists on data parameter');
  }
  popupWindow._onReady();
};

scout.DesktopFormController.prototype._onPopupWindowUnload = function(popupWindow) {
  var form = popupWindow.form;
  $.log.debug('Popup window for form ID ' + form.id + ' is unloaded - don\'t know if its closed or reloaded yet');

  // this remove() is important: when a popup-window in IEis closed all references to a HTMLDivElement become
  // invalid. Every call or read on such invalid objects will cause an Error. Even though the DOM element
  // is invalid, the JQuery object which references the DOM element is still alive and occupies memory. That's
  // why we must remove JQuery objects _before_ the popup-window is closed finally.
  form.remove();

  // must do this with setTimeout because at this point window is always still open
  // Note: timeout with 0 milliseconds will not work
  setTimeout(function() {
    if (popupWindow.isClosed()) {
      $.log.debug('Popup window for form ID ' + form.id + ' has been closed');
      // TODO awe: discuss if close is Ok or do we need the now unsupported "killed from UI" event?
      // was passiert im model wenn noch fenster / message boxen offen sind?
      form.close();
    }
  }.bind(this), 250);
};

/**
 * We only close browser windows here, since during an unload event, we cannot send
 * anything with a HTTP request anyway. So we cannot inform the server that it
 * should "kill" the forms - instead we simply render the popupWindows and forms
 * again when the page has been reloaded.
 */
scout.DesktopFormController.prototype.closePopupWindows = function() {
  this._popupWindows.forEach(function(popupWindow) {
    this._removePopupWindow(popupWindow.form);
  }, this);
  this._popupWindows = [];
};

/**
 * @override FormController.js
 */
scout.DesktopFormController.prototype._removePopupWindow = function(form) {
  var popupWindow = form.popupWindow;
  if (!popupWindow) {
    throw new Error('Form has no popupWindow reference');
  }
  delete form.popupWindow;
  scout.arrays.remove(this._popupWindows, popupWindow);
  if (form.rendered) {
    form.remove();
    popupWindow.close();
  }
};

scout.DesktopFormController.prototype.dispose = function() {
  $(document).off('popupWindowReady', this._documentPopupWindowReadyHandler);
};

scout.FilterFieldsGroupBox = function() {
  scout.FilterFieldsGroupBox.parent.call(this);
};
scout.inherits(scout.FilterFieldsGroupBox, scout.GroupBox);

scout.FilterFieldsGroupBox.prototype._init = function(model) {
  scout.FilterFieldsGroupBox.parent.prototype._init.call(this, model);
  this.filter = model.filter;
  this.filter.addFilterFields(this);
  this.cssClass = 'filter-fields';
};

/**
 * @override GroupBox.js
 */
scout.FilterFieldsGroupBox.prototype._render = function($parent) {
  scout.FilterFieldsGroupBox.parent.prototype._render.call(this, $parent);
  this.filter.modifyFilterFields();
};

// TODO awe: (filter) es braucht wahrscheinlich auch eine range-validierung? z.B. from muss kleiner sein als to
// Prfen ob wir eine sequence-box dafr verwenden wollen und dafr eine client-seitige validierung impl., diese
// geschieht heute auf dem UI server. Evtl. wre auch ein from/to validator fr beliebige felder sinnvoll (auch
// ausserhalb einer sequence-box)
scout.FilterFieldsGroupBox.prototype.addFilterField = function(objectType, text, gridY) {
  var field = scout.create(objectType, {
    parent: this,
    label: this.session.text(text),
    statusVisible: false,
    labelWidthInPixel: 50,
    maxLength: 100,
    gridData: {
      y: gridY
    },
    updateDisplayTextOnModify: true
  });
  this.addField0(field);
  return field;
};

// TODO awe, cgu: (addField): see to-do in TileContainerBox.js
// Added '0' to the name to avoid temporarily to avoid naming conflict with FormField#addField
scout.FilterFieldsGroupBox.prototype.addField0 = function(field) {
  this.fields.push(field);
  this._prepareFields();
};

}(window.scout = window.scout || {}, jQuery));